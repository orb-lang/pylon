return {
  project = {
    repo = "git@gitlab.com:special-circumstance/core.git\n",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/core.git\n\n",
    home = "",
    website = "",
    name = "qor",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/cluster/mold",
hash = "bc509c41590807b8fb366915ae5ecde7ed2d9f5d109c5bc7bb86eb2deccacf8b",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal _Message_fields = {\n   method  = true,\n   message = true,\n   sendto  = true,\n   call    = true,\n}\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/cluster/actor",
hash = "f58508da224a283c9334e3a54d24409330ee56b4d2f1f39092e09dfec99734f4",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:_base\"\nlocal iscallable = assert(_base.iscallable)\n\n\n\n\n\n\nlocal act = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __act_mth_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.borrowmethod(actor, method)\n   assert(iscallable(method) or type(method) == \'string\',\n          \"#2 for borrowmethod must be string or callable\")\n   local uid = {}\n   __act_mth_attr[uid] = actor\n   actor = nil\n   if type(method) == \'string\' then\n      -- return a lookup function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return _actor[method](_actor, ...)\n      end\n   else\n      -- return a direct-call function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return method(_actor, ...)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal __act_getter_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.getter(actor, slot)\n   local uid = {}\n   __act_getter_attr[uid] = actor\n   actor = nil\n   return function()\n             local _actor = __act_getter_attr[uid]\n             if not _actor then\n                error \"actor has gone out of scope\"\n             end\n             return _actor[slot]\n          end\nend\n\n\n\n\n\n\n\n\n\nlocal gmatch = assert(string.gmatch)\nlocal function dispatchmessage(actor, msg)\n   local result\n   while msg do\n      -- #todo replace this with construction-time translation to nested message?\n      if msg.sendto then\n         for prop in gmatch(msg.sendto, \"([^.]+)[.]?\") do\n            actor = actor[prop]\n         end\n      end\n      if msg.property then\n         result = pack(actor[msg.property])\n      elseif msg.call == true then\n         result = pack(actor(unpack(msg)))\n      elseif msg.call then\n         local fn = actor[msg.call]\n         if not fn then\n            -- #todo this leaves out useful information in the case of a\n            -- nested message, and also doesn\'t know how to represent the\n            -- starting/root actor. We really want to stringify the whole\n            -- chain in a meaningful way\n            error(\"attempt to call a nil function \" .. msg.call\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(unpack(msg)))\n      elseif msg.method then\n         local fn = actor[msg.method]\n         if not fn then\n            -- Similar concern as with .call, also this is annoyingly similar\n            error(\"attempt to call a nil method \" .. msg.method\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(actor, unpack(msg)))\n      else\n         error(\"Message must have one of property, call, or method: \" .. (require \"repr:repr\".ts(msg)))\n      end\n      actor = result[1]\n      msg = msg.message\n   end\n   return unpack(result)\nend\nact.dispatchmessage = dispatchmessage\n\n\n\n\n\nreturn act\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/cluster/roshambo",
hash = "6a3854d3a1d0f3ed3488c615d9bea90623c6f6ac3ae4e8cb6734a9274f724766",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal s   = require \"status:status\"\ns.verbose = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function beats(roshambo, champ, loser)\n   --needs check for opposite condition,\n   --which is nilled out.\n   if roshambo._beats[loser] and\n      roshambo._beats[loser][champ] then\n      roshambo:pr \"reversal of fortune\"\n      roshambo._beats[loser] = roshambo._beats[loser] - champ\n      roshambo:pr(roshambo._beats[loser])\n   end\n   champion = roshambo._beats[champ]\n   if champion then\n      champion = champion + Set{loser}\n   else\n      champion = Set{loser}\n   end\n   roshambo._beats[champ] = champion\n   roshambo:pr(champ..\" beats \"..tostring(roshambo._beats[champ]))\nend\n\n\n\n\n\n\nlocal function duel(roshambo,champ,challenge)\n   if roshambo._duel_with then\n      roshambo:pr \"it\'s a duel!\"\n      local winner, loser = roshambo:_duel_with(champ,challenge)\n      roshambo:beats(winner,loser)\n      return winner, loser\n   else\n      roshambo:pr \"victory by fiat\"\n      roshambo:beats(champ,challenge)\n      return champ, challenge\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function duel_with(roshambo, fn)\n   roshambo._duel_with = fn\nend\n\n\n\n\n\n\n\n\nlocal function fight(roshambo, champ, challenge)\n   if roshambo._beats[champ] then\n      if roshambo._beats[champ](challenge) then\n          roshambo:pr(tostring(champ)..\" wins\")\n          return champ, challenge\n      elseif roshambo._beats[challenge] then\n         if roshambo._beats[challenge](champ) then\n            roshambo:pr(tostring(challenge)..\" wins\")\n            return challenge, champ\n         end\n      else --duel here\n         s:verb(tostring(challenge) .. \" not found\")\n         return duel(roshambo,champ,challenge)\n      end\n   else --duel here as well\n      s:verb(tostring(champ)..\" not found\")\n      return duel(roshambo, champ, challenge)\n   end\nend\n\n\n\n\n\n\n\n\nfunction roshambo_sort(roshambo, champ, challenge)\n   local victor = fight(roshambo, champ, challenge)\n   return victor == champ and true or false\nend\n\nlocal R = {}\nR.fight = fight\nR.beats = beats\nR.duel_with = duel_with\nR.sort  = roshambo_sort\n--- an alias for fight\n-- @function __call\n-- @param champ\n-- @param challenge\n-- @within metamethods\nR[\"__call\"] = fight\nR[\"__index\"] = R\nsetmetatable(R,{}) -- clu.Meta\n\n--- instantiates a roshambo\n-- @function Roshambo\n-- @param init a optional table of champ/loser key/value pairs.\n-- @return an instance of roshambo\nlocal function Roshambo(init)\n   local rosh = {}\n   rosh._beats = {}\n   if init then\n      if type(init) == \"table\" then\n         for i,v in pairs(init) do\n            rosh._beats[i] = Set{v}\n         end\n      else\n         error(\"Roshambo must be initialized with a table\")\n      end\n   end\n   setmetatable(rosh,R)\n   rosh.foo = \"bar\"\n   return rosh\nend\n\n\n\nreturn Roshambo\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/string/escape",
hash = "d19df2dcc1031aebb22e2ee17b675a51c1e7f2d2cf9620379c4e21ac88e81b4e",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal elpatt = require \"espalier:elpatt\"\nlocal C, P, R, S = assert(L.C), assert(L.P), assert(L.R), assert(L.S)\nlocal gsub, M = assert(elpatt.gsub), assert(elpatt.M)\n\n\n\n\nlocal escape_module = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_map = {\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nlocal function _generic_escape(ch)\n   return (\"\\\\x%02x\"):format(ch:byte())\nend\n\nlocal needs_escape = M(escape_map) + (R\"\\x00\\x1f\" + P\"\\x7f\") / _generic_escape\n\nfunction escape_module.escape(str, quotes)\n   local patt = needs_escape\n   if quotes then\n      patt = S(quotes) / \"\\\\%0\" + patt\n   end\n   return gsub(str, patt)\nend\n\nfunction escape_module.escape_char(ch, quotes)\n   local escaped = escape_map[ch]\n   if escaped then\n      return escaped\n   elseif quotes and quotes:find(ch) then\n      return \"\\\\\" .. ch\n   elseif ch:find(\"%c\") then\n      return _generic_escape(ch)\n   else\n      return ch\n   end\nend\n\n\n\n\n\n\n\n\nlocal char = assert(string.char)\n\nlocal unescape_map = {}\nfor k, v in pairs(escape_map) do\n   unescape_map[v] = k\nend\n\nlocal higit = R\"09\" + R\"af\"\n\nlocal escaped_char = M(unescape_map) +\n                     (P\"\\\\\" * C(S\"\'\\\"[]\")) / 1 +\n                     (P\"\\\\x\" * C(higit * higit)) / function(hex)\n                        return char(tonumber(\"0x\" .. hex))\n                     end\n\nfunction escape_module.unescape(str)\n   return gsub(str, escaped_char)\nend\n\n\n\nreturn escape_module\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/string/print",
hash = "7e64796a80b79f1e3f3924a93fa562a66218b47a73a056c2d4516062dc375b5d",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\nPrint = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\nlocal floor, max = assert(math.floor), assert(math.max)\nlocal inbounds = assert(require \"core:math\" . inbounds)\n\nlocal split_at = {}\nfor _, v in ipairs{\" \", \"-\", \"(\", \"{\", \"[\"} do\n   split_at[v] = v == \" \" and -1 or 0\nend\n\nfunction Print.breakascii(str, width)\n   if #str <= width then\n      return str, 1, #str\n   end\n   local lines = {}\n   local actual_width = 0\n   local left = 1\n   local min_width = floor(width / 2)\n   while left <= #str do\n      local min_right = left + min_width - 1\n      local max_right = left + width - 1\n      local line\n      if max_right >= #str then\n         line = str:sub(left)\n         lines[#lines + 1] = line\n         actual_width = max(actual_width, #line)\n         break\n      end\n      local split_index, offset\n      -- Check one past the max width because we might be able to\n      -- remove a trailing space\n      for i = max_right + 1, min_right, -1 do\n         offset = split_at[str:sub(i, i)]\n         -- But now we do need to check if we\'ll actually be in bounds\n         if offset and inbounds(i + offset, min_right, max_right) then\n            split_index = i\n            break\n         end\n      end\n      if not split_index then\n         -- Didn\'t find a natural breakpoint, just chop at the max width\n         split_index = max_right\n         offset = 0\n      end\n      line = str:sub(left, split_index + offset)\n      lines[#lines + 1] = line\n      actual_width = max(actual_width, #line)\n      left = split_index + 1\n   end\n   return concat(lines, \"\\n\"), #lines, actual_width\nend\n\n\n\n\nfunction Print.center(str, width)\n   local diff = width - #str\n   local lmargin, rmargin\n   if diff % 2 ~= 0 then\n      lmargin, rmargin = math.floor(diff / 2), math.floor(diff / 2) + 1\n   else\n      lmargin, rmargin = diff / 2, diff / 2\n   end\n   return  (\" \"):rep(lmargin) .. str .. (\" \"):rep(rmargin)\nend\n\n\n\n\nreturn Print\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/coro",
hash = "9238fa5e52f7f63e0ee8a1ac4e36c78484461ad151a51c4c940294feaede60d0",
branch = "the-big-refactor",
binary = "\n\n\nlocal coro = {}\n\n\n\n\nlocal _base = require \"core:core/_base\"\nlocal thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\nlocal coro = {}\nfor k,v in next, coroutine do\n   coro[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction coro.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction coro.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction coro.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coro.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal running = assert(coroutine.running)\n\nfunction coro.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\n\nreturn coro\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/debug",
hash = "89b137bd96939d355e731786a4fbf19d1202ea42d04f4b75cfbf29d4a7d09592",
branch = "the-big-refactor",
binary = "\n\n\n\n\nlocal Debug = {}\n\nfor k,v in pairs(assert(debug)) do\n   Debug[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal getupvalue, getinfo = assert(debug.getupvalue), assert(debug.getinfo)\n\nlocal function _findrefs(copies, val, dupes, subject)\n   if dupes[subject] then return end\n   dupes[subject] = true\n   local function test_one(test, container)\n      -- check key first\n      if rawequal(test, val) then\n         copies[#copies + 1] = container\n         copies.n = copies.n + 1\n      end\n      if type(test) == \'table\' then\n         if not dupes[test] then\n            _findrefs(copies, val, dupes, test)\n         end\n      elseif type(test) == \'function\' then\n         -- look in the upvalues\n         if not copies[test] then\n            dupes[test] = true\n            local name, ups, idx = \"\", true, 1\n            while ups ~= nil do\n               name, ups = getupvalue(test, idx)\n               if name == nil then\n                  ups = nil\n               else\n                  if ups == val then\n                     copies[#copies + 1] = debug.getinfo(test)\n                     copies.n = copies.n + 1\n                  end\n                  if type(ups) == \'table\' or type(ups) == \'function\'\n                     and (not dupes[ups]) then\n                     _findrefs(copies, val, dupes, ups)\n                  end\n                  idx = idx + 1\n               end\n            end\n         end\n         dupes[test] = true\n      end\n   end\n   if type(subject) == \'function\' then\n      test_one(subject)\n   elseif type(subject) == \'table\' then\n      for k, v in next, subject do\n         test_one(k, subject)\n         test_one(v, subject)\n      end\n      local _M = getmetatable(subject)\n      if _M then\n         _findrefs(copies, val, dupes, _M)\n      end\n   end\n   return copies\nend\n\nfunction Debug.findrefs(val)\n   local dupes = {}\n   return unpack(_findrefs({n = 0}, val, dupes, getfenv(1)))\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _tracer(tab)\n   return tab[1]\nend\n\nlocal lines;\nlocal function _repr(tab, window, c)\n   lines = lines or require \"core:core/string\" . lines\n   return lines(tab[1])\nend\n\nlocal __trace_M = { __repr = _repr,\n                    __tostring = _tracer}\n\nlocal traceback = assert(debug.traceback)\n\nfunction Debug.reprtrace(msg)\n   local trace;\n   if not msg then\n      trace = traceback(\"\", 2):sub(2)\n   else\n      trace = traceback(msg, 2)\n   end\n   return setmetatable({trace}, __trace_M)\nend\n\n\n\n\nreturn Debug\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/_base",
hash = "0281e50fc66e0d40f6b1cdccef7bb15895e1469d49aae6644f60c88beb59ef09",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\nlocal _base = {}\n\n\n\n\n\n\n\n\n\n\nfunction _base.no_op()\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction _base.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction _base.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...), 2)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction _base.iscallable(val)\n   if type(val) == \'function\' then return true end\n   if type(val) == \'table\' then\n      local M = getmetatable(val)\n      if M and rawget(M, \"__call\") then\n         return true\n      end\n   end\n   return false\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function lazy_load_gen(requires)\n   return function(tab, key)\n      if requires[key] then\n         -- put the return on the core table\n         tab[key] = require(requires[key])\n         return tab[key]\n      else\n         error(\"core doesn\'t have a module \" .. tostring(key))\n      end\n   end\nend\n\n\n\n\n\nlocal function call_gen(requires)\n   return function(tab, env)\n      local _;\n      for k in pairs(requires) do\n         _ = tab[k]\n         if env then\n            -- assign the now cached value as a global or at least slot\n            env[k] = tab[k]\n         end\n      end\n      return tab\n   end\nend\n\n\n\n\n\nfunction _base.lazyloader(lazy_table)\n   return setmetatable({}, { __index = lazy_load_gen(lazy_table),\n                             __call  = call_gen(lazy_table) })\nend\n\n\n\nreturn _base\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/env",
hash = "70febee49581cca907e3f422d832a6bf4d007caf11c751c94ba8849eff6be395",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\nlocal next = assert(next) -- !\n\nlocal Env = {}\nfunction Env.fenv(...)\n   local _env = {}\n   local f = unpack(...)\n   if not f then return _env end\n   if f then\n      for k,v in next, f, nil do\n         _env[k] = v\n      end\n      return _env\n   end\nend\n\n\n\nreturn Env\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/math",
hash = "5d2b2c4f1552dc0c7405f5320db001b80c6c7a236d444b184f0a251df09b70fb",
branch = "the-big-refactor",
binary = "\n\n\nlocal Math = {}\n\n\n\n\n\n\n\n\nfunction Math.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\n\n\nlocal assertfmt = assert(require \"core:_base\" . assertfmt)\nfunction Math.clamp(value, lower, upper)\n   if lower and upper then\n      assertfmt(lower <= upper, \"Clamp range must be nonempty (lower <= upper), got (%d, %d)\", lower, upper)\n   end\n   if lower and value < lower then\n      value = lower\n   end\n   if upper and value > upper then\n      value = upper\n   end\n   return value\nend\n\n\n\n\nreturn Math\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/cluster",
hash = "f868d34e44d34823548425f0089b11ac8612f5f5b238cca9298c3173d54c0b59",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal act = require \"core:core/cluster/actor\"\n\n\n\n\n\n\nlocal cluster = {}\n\nfor k, v in pairs(act) do\n   cluster[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal isempty = table.isempty\n                or\n                function(tab)\n                   local empty = true\n                   for _, __ in next, tab, nil do\n                      empty = false\n                      break\n                   end\n                   return empty\n                end\n\nfunction cluster.meta(Meta)\n   Meta = Meta or {}\n\n   -- decoration\n   if Meta\n      and type(Meta) == \'table\'\n      and isempty(Meta) then\n\n      Meta.__index = Meta\n      return Meta\n   end\n\n   -- inheritance\n   if Meta and Meta.__index then\n      local tab = {}\n      for field, value in next, Meta, nil do\n         if sub(field, 1, 2) == \"__\" then\n            tab[field] = value\n         end\n      end\n      if Meta.__meta then\n         tab.__meta = tab.__meta or {}\n         for _, __ in next, Meta.__meta, nil do\n            tab.__meta[_] = __\n         end\n      end\n      tab.__index = tab\n      return setmetatable(tab, Meta)\n   end\n\n   error (\"cannot make metatable from type\" .. type(Meta))\nend\n\n\n\n\n\n\n\n\nlocal s;\n\nfunction cluster.Meta(Meta)\n   s = s or require \"status:status\" ()\n   local trace = debug.traceback(\"\", 2):sub(2)\n   -- clip the relevant line\n   local nl_idx = trace:find(\"\\n\")\n   trace = trace:sub(nl_idx + 1)\n   nl_idx = trace:find(\"\\n\")\n   s:warn(\"use of Meta is deprecated, use meta: %s\", trace:sub(1, nl_idx - 1))\n   return cluster.meta(Meta)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.constructor(mt, new, instance)\n   instance = instance or {}\n   if new then\n      mt.__call = new\n   elseif not mt.__call then\n      error \"nil metatable passed to constructor without __call metamethod\"\n   end\n\n   local constructor = setmetatable(instance, mt)\n   mt.idEst = constructor\n   return constructor\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\n\n\nfunction cluster.methodchain(method, key_method)\n\n   -- per-method cache of the value-caller\n   local _cache = {}\n\n   local function value__call(value_catch, value, ...)\n      method(value_catch[1], value_catch[2], value, ...)\n      value_catch[2] = nil\n      return remove(value_catch)\n   end\n\n   return function (obj, first)\n      local launch;\n\n      if key_method then\n         obj, first = key_method(obj, first)\n      end\n      if #_cache == 0 then\n         _cache[1], _cache[2] = obj, first\n         launch = _cache\n      else\n         launch = {obj, first}\n         -- we do this optimistically, figuring most method chains complete\n         -- and ones which don\'t, might not\n         _cache = launch\n      end\n      return setmetatable(launch, { __call = value__call })\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.indexafter(idx_fn, idx_super)\n   if type(idx_super) == \'table\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super[key]\n         end\n      end\n   elseif type(idx_super) == \'function\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super(tab,key)\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _instances = setmetatable({}, { __mode = \'k\'})\n\nfunction cluster.instancememo(instance, message)\n   local memos = { [message] = {} }\n   -- grab the method, we\'re going to need it later\n   local method = instance[message]\n   _instances[instance] = memos\n   local function memo_method(inst, p, ...)\n      local param_set = assert(_instances[inst][message],\n                             \"missing instance or message\")\n      local results = param_set[p]\n      if results then return unpack(results) end\n\n      results = pack(method(inst, p, ...))\n      param_set[p] = results\n      return unpack(results)\n   end\n   instance[message] = memo_method\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--| if =fn= exists, bind fn(obj, ...)\nlocal function _maybe_bind(obj, fn)\n  if not fn then return nil end\n  return function(...)\n     return fn(obj, ...)\n  end\nend\n\nlocal function _get_idx(obj)\n   local M = getmetatable(obj)\n   return M and M.__index\nend\n\nfunction cluster.super(obj, field)\n   local super_idx\n   -- If the object has such a field directly, consider the implementation\n   -- from the metatable to be the \"super\" implementation\n   if rawget(obj, field) then\n      super_idx = _get_idx(obj)\n   -- Otherwise, look one step further up the inheritance chain\n   else\n      local M_idx = _get_idx(obj)\n      super_idx = type(M_idx) == \'table\' and _get_idx(M_idx) or nil\n   end\n   if super_idx then\n      return type(super_idx) == \'table\'\n         and _maybe_bind(obj, super_idx[field])\n         or  _maybe_bind(obj, super_idx(obj, field))\n   end\n   -- No superclass, or our class uses an __index function so we can\'t\n   -- meaningfully figure out what to do\n   return nil\nend\n\n\n\n\nreturn cluster\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/meta",
hash = "464f9248847a57c1d881f512821753d26349d30bf04fdfa61709c795635fafbd",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal meta = {}\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   if sub(mmethod,1,2) == \"__\" then\n      return rawget(M, mmethod)\n   else\n      return rawget(M, \"__\" .. mmethod)\n   end\nend\n\nmeta.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\nfunction meta.instanceof(obj, Class)\n   if type(Class) == \'string\' then\n      return type(obj) == Class\n   else\n      return type(obj) == \'table\' and obj.idEst == Class\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.weak(mode)\n   mode = mode or \'kv\'\n   return setmetatable({}, { __mode = mode })\nend\n\n\n\nreturn meta\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/fn",
hash = "5b9861bb7ee3c0ab2394732349cf2916c7a5390c6532020c38159446d8c842fb",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal fn = {}\n\n\n\n\n\n\n\n\n\nfn.no_op = _base.no_op\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _curried = setmetatable({}, { __mode = \'k\' })\n\nlocal currier = {\n   false, -- this shouldn\'t happen\n   function(fn, a, b) -- [2]\n      return function(...)\n         return fn(a, b, ...)\n      end\n   end,\n   function(fn, a, b, c) -- [3]\n      return function(...)\n         return fn(a, b, c, ...)\n      end\n   end,\n   function(fn, a, b, c, d) -- [4]\n      return function(...)\n         return fn(a, b, c, d, ...)\n      end\n   end,\n   function(fn, a, b, c, d, e) -- [5]\n      return function(...)\n         return fn(a, b, c, d, e, ...)\n      end\n   end,\n}\n\nlocal function curry(fn, param)\n   assert(type(fn) == \'function\' or\n          type(fn) == \'table\' and getmetatable(fn).__call,\n          \'#1 of curry must be a function or callable table\')\n   local curried;\n   local pre = _curried[fn]\n   if not pre then\n      curried = function(...) return fn(param, ...) end\n      _curried[curried] = { param, n = 1 , fn = fn }\n   else\n      if pre.n <= 4 then\n         local post = {}\n         for i = 1, pre.n do\n            post[i] = pre[i]\n         end\n         post.n = pre.n + 1\n         post.fn = pre.fn\n         post[post.n] = param\n         curried = currier[post.n](post.fn, unpack(post, 1, post.n))\n         _curried[curried] = post\n      else\n         curried = function(...) return fn(param, ...) end\n      end\n   end\n\n   return curried\nend\n\nfn.curry = curry\n\n\n\n\n\n\n\n\n\nfn.thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.deferSend(obj, msg, ...)\n   assert(type(obj) == \'table\', \"#1 to deferSend must be a table\")\n   assert(type(msg) == \'string\', \"#2 to deferSend must be a string\")\n   local packed = pack(...)\n   return function()\n      return obj[msg](obj, unpack(packed))\n   end\nend\n\n\n\n\n\n\n\n\nfn.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.partial(fn, ...)\n   for i = 1, select(\'#\', ...) do\n      fn = curry(fn, select(i, ...))\n   end\n   return fn\nend\n\n\n\n\n\n\n\n\nfunction fn.compose(f, g)\n   return function(...)\n      return g(f(...))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.itermap(fn, iter)\n   local ret, res = {}\n   while true do\n      res = pack(fn(iter()))\n      if #res == 0 then\n         return ret\n      else\n         ret[#ret + 1] = res\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _dynamics_call = setmetatable({}, {__mode = \'k\'})\nlocal _dynamics_registry  = setmetatable({}, {__mode = \'kv\'})\n\nlocal function dynamic(fn)\n   -- make a unique table as key\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local function dyn_fn(...)\n      return _dynamics_call[uid](...)\n   end\n   _dynamics_registry[dyn_fn] = uid\n   return dyn_fn\nend\n\nfn.dynamic = dynamic\n\n\n\n\n\n\n\n\n\nfunction fn.patch_dynamic(dyn_fn, fn)\n   assert(_dynamics_registry[dyn_fn], \"cannot patch a non-dynamic function\")\n   local uid = _dynamics_registry[dyn_fn]\n   _dynamics_call[uid] = fn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _pre_hook, _post_hook = setmetatable({}, {__mode = \'k\'}),\n                              setmetatable({}, {__mode = \'k\'})\n\nlocal function _call_with_hooks(uid, ...)\n   local fn = _dynamics_call[uid]\n   assert(fn, \"_dynamics_call is missing a hookable function\")\n   local pre, post = _pre_hook[uid], _post_hook[uid]\n\n   if pre and post then\n      local new_arg = pack(pre(...))\n      local rets = pack(fn(unpack(new_arg)))\n      -- make into one pack, because you can only apply multiple arguments at\n      -- the end of a function call\n      for i = 1, new_arg.n do\n         rets[#rets + 1] = new_arg[i]\n      end\n      rets.n = new_arg.n + rets.n\n      return post(unpack(rets))\n   elseif pre then\n      return fn(pre(...))\n   elseif post then\n      local args, rets = pack(...), pack(fn(...))\n      -- same trick here...\n      for i = 1, rets.n do\n         args[#args + 1] = rets[i]\n      end\n      args.n = rets.n + args.n\n      return post(unpack(args))\n   else\n      return fn(...)\n   end\nend\n\nlocal function prehook(hooked, pre_hook)\n   _pre_hook[_dynamics_registry[hooked]] = pre_hook\nend\n\nlocal function posthook(hooked, post_hook)\n   _post_hook[_dynamics_registry[hooked]] = post_hook\nend\n\nfn.prehook, fn.posthook = prehook, posthook\n\nfunction fn.hookable(fn, pre, post)\n   -- make a uid, add to _dynamics_call\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local hookable = function(...)\n                       return _call_with_hooks(uid, ...)\n                    end\n   -- register the hookable in the dynamics registry\n   _dynamics_registry[hookable] = uid\n   if pre then\n      prehook(hookable, pre)\n   end\n   if post then\n      posthook(hookable, post)\n   end\n   return hookable\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfn.assertfmt = _base.assertfmt\n\n\n\nreturn fn\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/string",
hash = "2205c7fda0bb2d18f902dfbd0d15ca37773cafa6dcc5875d1bc700e67d89ed78",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\nlocal String = {}\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/_base\".assertfmt\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nfor k, v in next, string do\n  String[k] = v\nend\n\n\n\n\n\n\n\n\n\nString.assertfmt = assertfmt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction String.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.findall(str, patt)\n   local find = type(str) == \'string\' and find or str.find\n   local matches = {}\n   local index = 1\n   local left, right\n   repeat\n     left, right = find(str, patt, index)\n     if left then\n        matches[#matches + 1] = {left, right}\n        index = right + 1\n     end\n   until left == nil\n   if #matches > 0 then\n      return matches\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction String.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction String.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\nString.cleave = cleave\n\n\n\n\n\n\n\n\n\n\nlocal find = assert(string.find)\nfunction String.isidentifier(str)\n   return find(str, \"^[a-zA-Z_][a-zA-Z0-9_]+$\") == 1\nend\n\n\n\n\n\n\n\nfunction String.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction String.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, _str_M)\nend\n\n\n\n\n\n\n\n\n\n\nfunction String.slurp(filename)\n  local f = io.open(tostring(filename), \"rb\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.spit(filename, file)\n  local f = io.open(tostring(filename), \"w+\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local ok = f:write(file)\n  f:close()\nend\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction String.splice(to_split, to_splice, index)\n   assert(type(to_split) == \"string\", \"bad argument #1 to splice: \"\n           .. \"string expected, got %s\", type(to_split))\n   assert(type(to_splice) == \"string\", \"bad argument #2 to splice: \"\n           .. \"string expected, got %s\", type(to_splice))\n   assert(type(index) == \"number\", \"bad argument #2 to splice: \"\n          .. \" number expected, got %s\", type(index))\n   assert(index >= 0 and index <= #to_split, \"splice index out of bounds\")\n   local head, tail = sub(to_split, 1, index), sub(to_split, index + 1)\n   return head .. to_splice .. tail\nend\n\n\n\nreturn String\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/module",
hash = "0affcf165fed76240b295da57899f4247ed30e9f532022621f3428cb16d17ba0",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\nlocal Mod = {}\n\n\n\n\nlocal _base = require \"qor:core/_base\"\nlocal assertfmt = assert(_base.assertfmt)\nlocal require, pack, unpack = assert(require), assert(pack), assert(unpack)\n\n\n\n\n\n\n\n\nMod.lazyloader = assert(_base.lazyloader)\n\n\n\n\n\n\n\n\n\n\n\nfunction Mod.import(req_str, ...)\n   local mod = require(req_str)\n   local fields, exports = pack(...), {}\n   for i = 1, fields.n do\n       exports[i] = assert(mod[fields[i]], \"can\'t require %s\", fields[i])\n   end\n   exports.n = fields.n\n   return unpack(exports)\nend\n\n\n\n\n\n\n\n\nlocal pcall = assert(pcall)\n\nfunction Mod.request(module)\n   local ok, mod = pcall(require, module)\n   if ok then\n      return mod\n   else\n      return nil\n   end\nend\n\n\n\nreturn Mod\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/set",
hash = "55da39748402aa83ba1d93242f6b80a54da6898fc2d620dddffd8eb578f92575",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal Set, Set_Build, Set_M = {}, {}, {}\nsetmetatable(Set, Set_Build)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_Build.__call(_new, tab)\n   assert(type(tab) == \'table\' or not tab, \"#1 to Set must be a table or nil\")\n   tab = tab or {}\n   local top = #tab\n   local shunt;  -- we need this for number keys\n   for i = 1, top do\n      local v = tab[i]\n      if type(v) == \'number\' then\n         shunt = shunt or {}\n         shunt[v] = true\n      else\n         tab[v] = true\n      end\n      tab[i] = nil\n   end\n   if shunt then\n      for v in pairs(shunt) do\n         tab[v] = true\n      end\n   end\n   return setmetatable(tab, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__call(set, ...)\n   for i = 1, select(\'#\', ...) do\n      set[select(i, ...)] = true\n   end\nend\n\nSet.insert = Set_M.__call\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__newindex(set, key, value)\n   assert(value == true or value == nil, \"value must be true or nil\")\n   rawset(set, key, value)\nend\n\n\n\n\n\n\n\n\n\n\ninsert = assert(table.insert)\nfunction Set.remove(set, ...)\n   local removed;\n   for i = 1, select(\'#\', ...) do\n      local elem = select(i, ...)\n      if set[elem] then\n         removed = removed or {}\n         insert(removed, elem)\n         set[elem] = nil\n      end\n   end\n   if removed then\n      return(unpack(removed))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal nkeys = assert(table.nkeys)\n\nfunction Set_M.__len(set)\n   return nkeys(set)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fix(tab)\n   if getmetatable(tab) == Set_M then\n      return tab, true\n   else\n      return Set(tab), false\n   end\nend\n\nlocal function _binOp(left, right)\n   local l_p, r_p;\n   left, l_p = _fix(left)\n   right, r_p = _fix(right)\n   return left, right, l_p, r_p\nend\n\n\n\n\n\n\nlocal clone = assert(require \"table.clone\")\n\nfunction Set_M.__add(left, right)\n   local l_isSet, r_isSet;\n   left, right, l_isSet, r_isSet = _binOp(left, right)\n   local set, other;\n   if #left > #right then\n      if l_isSet then\n         set = clone(left)\n      else\n         set = left\n      end\n      other = right\n   else\n      if r_isSet then\n         set = clone(right)\n      else\n         set = right\n      end\n      other = left\n   end\n\n   for elem in pairs(other) do\n      set[elem] = true\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\nfunction Set_M.__sub(left, right)\n   left, right =  _binOp(left, right)\n   local set = {}\n   for k in pairs(left) do\n      if not right[k] then\n         set[k] = true\n      end\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__mod(left, right)\n   left, right = _binOp(left, right)\n   local set = {}\n   for elem in pairs(left) do\n      if right[elem] then\n         set[elem] = true\n      end\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function not_missing(left, right)\n   for elem in pairs(left) do\n      if not right[elem] then\n         return false\n      end\n   end\n   return true\nend\n\n\n\nfunction Set_M.__eq(left, right)\n   if not #left == #right then return false end\n   return not_missing(left, right)\nend\n\n\n\n\n\n\n\n\nfunction Set_M.__lt(left, right)\n   if #left >= #right then return false end\n   return not_missing(left, right)\nend\n\n\n\n\n\n\n\n\n\nfunction Set_M.__lte(left, right)\n   if #left > #right then return false end\n   return not_missing(left, right)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate, Token\nlocal sortedpairs = assert(core.table.sortedpairs)\n\nfunction Set_M.__repr(set, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n\n   return wrap(function()\n      yield(Token(\"#{ \", { color = \"base\", event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for v, _ in sortedpairs(set) do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n         end\n         for t in tabulate(v, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn Set\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/uv",
hash = "8a282fc2970e23856075b573ca8f19e0c4ee03774676a5dc44360e495ba8a0ee",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\nlocal assert = assert or error \"no assert\"\n\nlocal Uv = {}\n\nlocal uv = assert(require \"luv\")\n\n\n\n\n\n\n\n\n\n\nfunction Uv.deferby(event, ms)\n   ms =  ms or 0\n   local timer = uv.new_timer()\n\n   local _event = function()\n      event()\n      timer:stop()\n   end\n\n   timer:start(ms, 0, _event)\n\n   return;\nend\n\n\n\n\nreturn Uv\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/table",
hash = "7fce89048cdd89006079b525bba2bcf8d9ee6681fb4c341dda12166d3d444fad",
branch = "the-big-refactor",
binary = "\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\nlocal meta = require \"core/meta\"\nlocal Tab = {}\nfor k, v in pairs(table) do\n   Tab[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal N_M = {}\nN_M.__index = N_M\n\nfunction N_M.__len(tab)\n   return tab.n\nend\n\nfunction N_M.__ipairs(tab)\n   local i = 1\n   return function()\n      if i >= tab.n then return nil end\n      i = i + 1\n      return i - 1, tab[i - 1]\n   end\nend\n\nfunction Tab.n_table(tab, djikstra)\n   tab = tab or {}\n   tab.n = 0\n   return setmetatable(tab, N_M)\nend\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction Tab.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(tab, field)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(maybeIndex, field)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if success and result ~= nil then\n            return result\n         end\n      end\n   end\n   return nil\nend\n\n\n\nlocal function _hf__index(has_field, field)\n   has_field[field] = function(tab)\n      return _hasfield(tab, field)\n   end\n   return has_field[field], \"hmm\"\nend\n\nlocal function _hf__call(_, tab, field)\n   return _hasfield(tab, field)\nend\n\nTab.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive \" .. tostring(depth))\n   local clone = {}\n   for k,v in next, tab do\n      if depth > 1 and type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return setmetatable(clone, getmetatable(tab))\nend\nTab.clone = _clone\n\n\n\n\n\n\n\n\nfunction Tab.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            -- copy the metatable after, in case it contains\n            -- __index or __newindex behaviors\n            copy = setmetatable(copy, _deep(getmetatable(val)))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.cloneinstance(tab)\n   assert(type(tab) == \"table\",\n          \"cannot cloneinstance of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            copy = setmetatable(copy, getmetatable(val))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.isarray(tab)\n   local i = 1\n   for k,_ in next, tab do\n      if k ~= i then return false end\n      i = i + 1\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Tab.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert (could be =insert(ret, (fn(val)))=...)\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.compact(tab, n)\n   n = assert(n or tab.n, \"a numeric value must be provided for non-ntables\")\n   local cursor, slot, empty = 1, nil, nil\n   while cursor <= n do\n      slot = tab[cursor]\n      if slot == nil and empty == nil then\n         -- mark the empty position\n         empty = cursor\n      end\n      if slot ~= nil and empty ~= nil then\n         tab[empty] = slot\n         tab[cursor] = nil\n         cursor = empty\n         empty = nil\n      end\n      cursor = cursor + 1\n   end\n   if tab.n then\n      tab.n = #tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.inverse(tab)\n   local bat = {}\n   for k,v in pairs(tab) do\n      if bat[v] then\n         error(\"duplicate value on key \" .. k)\n      end\n      bat[v] = k\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.flatten(tab, level)\n   local ret, copies = {}, {}\n   local function _flat(t, depth)\n      if level and depth > level then\n         ret[#ret + 1] = t\n         return nil\n      end\n      for _,v in ipairs(t) do\n         if type(v) ~= \"table\" then\n            ret[#ret + 1] = v\n         else\n            if not copies[v] then\n               copies[v] = true\n               _flat(v, depth + 1)\n            end\n         end\n      end\n   end\n   _flat(tab, 0)\n   return ret\nend\n\n\n\n\n\n\n\n\n\nTab.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\nfunction Tab.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\nfunction Tab.select()\n   error \"this no longer exists, and I thought it wasn\'t used.\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.keysort(a, b)\n   local A, B = type(a), type(b)\n   if (A == \'string\' and B == \'string\')\n      or (A == \'number\' and B == \'number\') then\n      return a < b\n   elseif A == \'number\' and B == \'string\' then\n      return false\n   elseif A == \'string\' and B == \'number\' then\n      return true\n   elseif A == \'string\' or A == \'number\' then\n      -- we want these tags at the bottom\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal keysort = assert(Tab.keysort)\nlocal nkeys, _sort = assert(table.nkeys), assert(table.sort)\nlocal keys; -- as defined below\n\nfunction Tab.sortedpairs(tab, sort, threshold)\n   sort = sort or keysort\n   if threshold and threshold > nkeys(tab) then\n      return pairs(tab)\n   end\n   local _keys = keys(tab)\n   _sort(_keys, keysort)\n   local i, top = 0, #_keys\n   return function()\n      i = i + 1\n      if i > top then return nil end\n      return _keys[i], tab[_keys[i]]\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.deleterange(tab, start, stop)\n   if start > stop then return end\n   local offset = stop - start + 1\n   for i = start, #tab do\n      tab[i] = tab[i + offset]\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local keys = {}\n   for k, _ in pairs(tab) do\n      keys[#keys + 1] = k\n   end\n\n   return keys, #keys\nend\n\nkeys = Tab.keys\n\n\n\n\n\n\nfunction Tab.values(tab)\n   assert(type(tab) == \"table\", \"values must receive a table\")\n   local vals = {}\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nlocal function push(queue, x)\n   queue.tail = queue.tail + 1\n   queue[queue.tail] = x\nend\n\nlocal function pop(queue)\n   if queue.tail == queue.head then return nil end\n   queue.head = queue.head + 1\n   return queue[queue.head]\nend\n\nfunction Tab.splice(tab, index, to_add)\n   assert(type(tab) == \"table\", _e_1)\n   if to_add == nil then\n      to_add = index\n      index = nil\n   end\n   if index == nil then\n      index = #tab + 1\n   end\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n\n   index = index - 1\n   local queue = { head = 0, tail = 0}\n   local i = 1\n   -- replace elements, spilling onto queue\n   for j = 1, #to_add do\n      push(queue, tab[i + index])\n      tab[i + index] = to_add[j]\n      i = i + 1\n   end\n   -- run the queue up the remainder of the table\n   local elem = pop(queue)\n   while elem ~= nil do\n      push(queue, tab[i + index])\n      tab[i + index] = elem\n      i = i + 1\n      elem = pop(queue)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compact, splice = Tab.compact, Tab.splice\n\nfunction Tab.replace(tab, index, to_add, span)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n   span = span or #to_add\n   -- easiest to handle the three cases as distinct.\n   if span == #to_add then\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n   elseif span > #to_add then\n      local top = #tab\n      -- replace #to_add worth of elements\n      for i = index, index + #to_add - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- nil out remaining elements\n      for i = index + #to_add, index + span - 1 do\n         tab[i] = nil\n      end\n      compact(tab, top)\n   else -- if span < #to_add\n      -- replace span worth of elements\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- make a table to hold the rest, copy\n      local spill = {}\n      for i = 1, #to_add - span do\n        spill[i] = to_add[i + span]\n      end\n      splice(tab, index + span, spill)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.addall(tab, to_add)\n   for k, v in pairs (to_add) do\n      tab[k] = v\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.pget(tab, key)\n   local ok, val = pcall(function() return tab[key] end)\n   if ok then\n      return val\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.safeget(tab, key)\n   while tab ~= nil do\n      local val = rawget(tab, key)\n      if val ~= nil then return val end\n      local M = getmetatable(tab)\n      if M then\n         tab = rawget(M, \'__index\')\n         if type(tab) ~= \'table\' then\n            return nil\n         end\n      else\n         tab = nil\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.fromkeys(tab, ...)\n   local answer = {}\n   local keys = pack(...)\n   for _, k in ipairs(keys) do\n      answer[k] = tab[k]\n   end\n   return answer\nend\n\n\n\nreturn Tab\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core/thread",
hash = "62f59045500bef4e68e8a1fe13e48f6ec13444b1486c5a85e7bab9bcd290b5fb",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal thread = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal select       = select\nlocal setmetatable = setmetatable\nlocal create       = coroutine.create\nlocal isyieldable  = coroutine.isyieldable -- luacheck: ignore\nlocal resume       = coroutine.resume\nlocal running      = coroutine.running\nlocal status       = coroutine.status\nlocal wrap         = coroutine.wrap\nlocal yield        = coroutine.yield\n\n\n\n\n\n\n\n\nlocal _tagged = setmetatable({}, {__mode = \'kv\'})\n\nlocal str_tags = setmetatable({}, {__mode = \'v\'})\n\n\n\n\n\n\nfunction thread.nest(tag)\n\n\n\n\n\n\n\n\n\n\n\n  if type(tag) == \'string\' then\n     local _tag = str_tags[tag] or {}\n     str_tags[tag] = _tag\n     tag = _tag\n  end\n\n  tag = tag or {}\n\n  if _tagged[tag] then\n     return _tagged[tag]\n  end\n\n\n\n\n\n\n\n\n\n\n  local coroutine = {\n    isyieldable = isyieldable,\n    running     = running,\n    status      = status,\n  }\n\n  _tagged[tag] = coroutine\n\n\n\n\n\n\n\n\n  function coroutine.create (f)\n    return create (function (...)\n      return tag, f (...)\n    end)\n  end\n\n\n  function coroutine.yield (...)\n    return yield (tag, ...)\n  end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  local function for_resume (co, ok, ...)\n    if not ok then\n      return ok, ...\n    elseif tag == ... then\n      return ok, select (2, ...)\n    else\n      return for_resume (co, resume (co, yield (...)))\n    end\n  end\n\n  function coroutine.resume (co, ...)\n    return for_resume (co, resume (co, ...))\n  end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  local function for_wrap (co, ...)\n    if tag == ... then\n      return select (2, ...)\n    else\n      return for_wrap (co, co (yield (...)))\n    end\n  end\n\n  function coroutine.wrap (f)\n    local co = wrap (function (...)\n      return tag, f (...)\n    end)\n    return function (...)\n      return for_wrap (co, co (...))\n    end\n  end\n\n\n\n\n\n\n  return coroutine\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.onloop()\n   local _, main = running()\n   return main and uv.loop_alive()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\nreturn thread\n\n",
},
  { 
vc_hash = "8ab9c738f5d8278745198015af74f4422f594855\n",
name = "core",
hash = "8c417d50a9118e1a40cbbe1b887b28b6d86e5bdd86ac91cffd81f962c7817503",
branch = "the-big-refactor",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"qor:core/_base\" . lazyloader {\n   cluster    = \"qor:core/cluster\",\n   coro       = \"qor:core/coro\",\n   fn         = \"qor:core/fn\",\n   debug      = \"qor:core/debug\",\n   math       = \"qor:core/math\",\n   meta       = \"qor:core/meta\",\n   [\"module\"] = \"qor:core/module\",\n   string     = \"qor:core/string\",\n   table      = \"qor:core/table\",\n   thread     = \"qor:core/thread\",\n   env        = \"qor:core/env\",\n   uv         = \"qor:core/uv\",\n   set        = \"qor:core/set\",\n}\n\n",
},
} }