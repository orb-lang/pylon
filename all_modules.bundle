return { {
  project = {
    repo = "git@gitlab.com:special-circumstance/anterm.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/anterm.git",
    home = "",
    website = "",
    name = "anterm",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "e9fbe93b834243240afe7cc37a297fc5d38d0449",
name = "anterm",
hash = "2423e16b13e3c9ef3b189ded3f6944ce22f4a4779f4140c305d629e8606385a3",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert (pairs)\nlocal tostring = assert (tostring)\nlocal setmeta = assert (setmetatable)\nlocal error = assert (error)\nlocal require = assert (require)\nlocal rawget = assert (rawget)\n\nlocal schar = assert(string.char)\nlocal sub   = assert(string.sub)\nlocal rep   = assert(string.rep)\nlocal byte  = assert(string.byte)\nlocal bit   = assert(bit, \"anterm requires Luajit \'bit\' or compatible in _G\")\nlocal rshift = assert(bit.rshift)\nlocal core = require \"core:core\"\nbit = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anterm = {}\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\'\n\n\n\n\n\n\n\n\n\n\n\nlocal colormt = {}\ncolormt.__index = colormt\n\n\n\n\n\n\n\n\nfunction colormt.__eq(a,b)\n   return a.value == b.value and a.reset == b.reset\nend\n\n\n\n\n\n\n\n\n\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        bold = 1,\n        dim = 2,\n        italic = 3,\n        underscore = 4,\n        underline = 4,\n        reverse = 7,\n        hidden = 8,\n        strikeout = 9,\n        double_underscore = 21,\n        clear_bold = 22,\n        clear_dim  = 22,\n        clear_italic = 23,\n        clear_underline = 24,\n        clear_inverse = 27,\n        clear_hidden = 28,\n        clear_strikeout = 29 },\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = CSI .. value ..\"m\",\n        name = name,\n        kind = kind }\n    return setmeta(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        anterm[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt.__tostring(color)\n    return color.value\nend\n\nfunction colormt.__concat(color, other)\n    return tostring(color) .. tostring(other)\nend\n\nlocal clear_fg, clear_bg, clear = anterm.clear_fg.value,\n                                  anterm.clear_bg.value,\n                                  anterm.clear.value\n\nlocal clear_attribute = { bright = anterm.clear_bold,\n                          bold = anterm.clear_bold,\n                          dim = anterm.clear_dim,\n                          italic = anterm.clear_italic,\n                          underscore = anterm.clear_underline,\n                          underline = anterm.clear_underline,\n                          reverse = anterm.clear_reverse,\n                          hidden = anterm.clear_hidden,\n                          strikeout = anterm.clear_strikeout,\n                          double_underscore = anterm.clear_underline }\n\nsetmeta(clear_attribute, {__index = function() return clear end})\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    if color.kind == \"fg\" then\n        return clear_fg\n    elseif color.kind == \"bg\" then\n        return clear_bg\n    elseif color.kind == \"attribute\" then\n       return clear_attribute[color.name]\n    elseif color.kind == \"embedded\" then\n       return color.reset.value\n    end\nend\n\nlocal __ts = colormt.__tostring\n\nfunction colormt.__call(color, str)\n    if str then\n        return __ts(color) .. str .. reset(color)\n    else\n        return __ts(color)\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function byte_panic(byte_p)\n   if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n      error \"xterm value must be 8 bit unsigned\"\n   end\nend\n\nlocal _color_cache = setmeta({}, {__mode = \"v\"})\n\nlocal function _make_color(value, kind)\n   if _color_cache[value] then\n       return _color_cache[value]\n   end\n   local color = setmeta({value = value, kind = kind}, colormt)\n   _color_cache[value] = color\n   return color\nend\n\n\nlocal ansi_fg_pre = CSI .. \"38;5;\"\n\nlocal function ansi_fg(byte)\n   byte_panic(byte)\n   local value = ansi_fg_pre .. byte .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal ansi_bg_pre = CSI .. \"48;5;\"\n\nlocal function ansi_bg(byte)\n   byte_panic(byte)\n   local value = ansi_bg_pre .. byte .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fg24pre = CSI .. \"38;2;\"\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = fg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal bg24pre = CSI .. \"48;2;\"\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = bg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\nanterm[\"fg\"], anterm[\"bg\"] = ansi_fg, ansi_bg\n\nanterm[\"fg24\"], anterm[\"bg24\"] = fg24, bg24\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction anterm.embedded(outer, inner)\n   outer = cloneinstance(outer)\n   outer.kind = \"embedded\"\n   outer.reset = inner\n   return outer\nend\n\n\n\n\n\n\nlocal cursor = {}\n\nfunction cursor.stash()\n   return \"\\x1b7\"\nend\n\nfunction cursor.pop()\n   return \"\\x1b8\"\nend\n\nfunction cursor.hide()\n   return \"\\x1b[?25l\"\nend\n\nfunction cursor.show()\n   return \"\\x1b[?25h\"\nend\n\nanterm.cursor = cursor\n\n\n\n\n\nlocal jump = {}\n\nfunction jump.up(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"A\"\nend\n\nfunction jump.down(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"B\"\nend\n\nfunction jump.forward(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"C\"\nend\n\njump.right = jump.forward\n\nfunction jump.back(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"D\"\nend\n\njump.left = jump.back\n\nlocal __nl = CSI .. 1 .. \"B\" .. CSI .. 1 .. \"G\"\n\nfunction jump.nl()\n   return __nl\nend\n\nlocal function Jump(_,row,column)\n    return CSI..row..\";\"..column..\"H\"\nend\n\nlocal J = { __call = Jump}\nsetmeta(jump,J)\n\nanterm[\"jump\"] = jump\n\nfunction anterm.rc(row, column)\n   return CSI .. row .. \";\" .. column .. \"H\"\nend\n\nanterm.rowcol = anterm.rc\n\nfunction anterm.colrow(col, row)\n   return CSI .. row .. \";\" .. col .. \"H\"\nend\n\nfunction anterm.col(col)\n   col = col or 1\n   return CSI .. col .. \"G\"\nend\n\n\n\n\n\n\nlocal erase = {}\nanterm.erase = erase\n\nlocal e__below = CSI .. \"0J\"\nlocal e__above = CSI .. \"1J\"\nlocal e__all   = CSI .. \"2J\"\nlocal e__right = CSI .. \"0K\"\nlocal e__left  = CSI .. \"1K\"\nlocal e__line  = CSI .. \"2K\"\n\nfunction erase.below() return e__below end\n\nfunction erase.above() return e__above end\n\nfunction erase.all()   return e__all   end\n\nfunction erase.right() return e__right end\n\nfunction erase.left()  return e__left  end\n\nfunction erase.line()  return e__line  end\n\n\n\n\n\n\n\nfunction erase.box(tc, tr, bc, br, dash)\n   dash = dash or \" \"\n   assert(tr <= br and tc <= bc, \"box must be at least 1 by 1: \"\n          .. \" tc: \" .. tc .. \" tr: \" .. tr\n          .. \" bc: \" .. bc .. \" br: \" .. br)\n   local phrase = cursor.stash()\n               .. Jump(nil, tr, tc)\n   br = br + 1\n   bc = bc + 1\n   local blanks = rep(dash, bc - tc)\n   local nl = anterm.col(tc) .. jump.down(1)\n   for i = 1, br - tr do\n      phrase = phrase .. blanks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\nlocal random = assert(math.random)\n\nfunction erase.checker(tc, tr, bc, br, dash, mod)\n   mod = mod or 3\n   dash = dash or \".\"\n   local space = jump.forward()\n   assert(tr <= br and tc <= bc, \"box must be at least 1 by 1\")\n   local skip = random(1, mod)\n   local phrase = cursor.stash()\n               .. Jump(nil, tr, tc)\n   br = br + 1\n   bc = bc + 1\n\n   local nl = anterm.col(tc) .. jump.down(1)\n   for i = 1, br - tr do\n      local checks = \"\"\n      for j = 1, bc - tc do\n         if skip % mod == 0 then\n            checks = checks .. dash\n         else\n            checks = checks .. space\n         end\n         skip = skip + 1\n      end\n      phrase = phrase .. checks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\n\nlocal mouse = {}\nanterm.mouse = mouse\n\nlocal buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}\n\n\n\n\n\n\n\n\n\n\nfunction mouse.track(on)\n   if on == true then\n      return \"\\x1b[?1003h\"\n   end\n\n   return \"\\x1b[?1003l\"\nend\n\n\n\nfunction mouse.ismousemove(seq)\n   if sub(seq, 1, 3) == \"\\x1b[M\" then\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction mouse.parse_fast(seq)\n   local kind, col, row = byte(seq,4), byte(seq, 5), byte(seq, 6)\n   kind = kind - 32\n   local m = {row = row - 32, col = col - 32}\n   -- Get button\n   m.button = buttons[kind % 4]\n   -- Get modifiers\n   kind = rshift(kind, 2)\n   m.shift = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.meta = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.ctrl = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.moving = kind % 2 == 1\n   -- we skip a bit that seems to just mirror .moving\n   m.scrolling = kind == 2\n   return m\nend\n\n\n\n\n\n\n\n\nfunction mouse.parse(seq)\n   if mouse.ismousemove(seq) then\n      return mouse.parsefast(seq)\n   else\n      return nil, \"sequence was not a mouse move\", seq\n   end\nend\n\n\n\n\n\nfunction anterm.alternate_screen(use_alt)\n  return CSI .. \"?47\" .. (use_alt and \"h\" or \"l\")\nend\n\n\n\n\n\nfunction anterm.paste_bracketing(bracket_enable)\n   return CSI .. \"?2004\" .. (bracket_enable and \"h\" or \"l\")\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal report = {}\n\nfunction report.area()\n   return \"\\x1b[18t\"\nend\nanterm.report = report\n\n\n\n\n\n\n\n\n\nlocal totty = {}\nlocal lines = assert(core.lines)\nlocal collect = assert(core.collect)\n\n\n\n\n\n\n\n\n\n\n\nfunction totty.nl_to_jumps(str)\n  local l = collect(lines, str)\n  local phrase = \"\"\n  local length = 0\n  for i,v in ipairs(l) do\n    phrase = phrase..v..a.jump.down()..a.jump.back(utf8.width(v))\n    if length < utf8.width(v) then\n      length = utf8.width(v)\n    end\n  end\n  return phrase, length, #l\nend\n\n--- takes a string and a width in columns.\n--  Returns the amount of string which fits the width.\nfunction totty.truncate(str, width)\n  local trunc = utf8.sub(str,1,width)\n  if utf8.len(trunc) == utf8.width(trunc) then\n    return trunc\n  else\n    local i = 1\n    while utf8.width(trunc) > width do\n      -- io.write(\"width is \", utf8.width(trunc), \"  target: \", width, \"\\n\")\n      trunc = utf8.sub(str,1,width-i)\n      i = i + 1\n    end\n    return trunc\n  end\nend\n\n-- takes a string, returning a string which, when printed, will:\n-- print the string as a column, return to the top, and move one beyond\n-- the column thereby printed.\nfunction totty.collimate(str)\n  local phrase, length, lines = totty.nl_to_jumps(str)\n  return phrase..a.jump.up(lines)..a.jump.forward(length)\nend\n\nanterm.totty = totty\n\n\n\n\n\n\n\n\n\n\n\nanterm.iTerm = {}\nlocal iTerm = anterm.iTerm\nlocal LEET = OSC .. \"1337;\"\n\n\n\n\n\n\n\n\nlocal function iTerm__call(_anterm)\n   local term_str = os.getenv \"TERM_PROGRAM\"\n   if term_str == \"iTerm.app\" then\n      return true\n   else\n      return false\n   end\nend\n\nsetmeta(iTerm, {__call = iTerm__call})\n\n\n\n\n\n\n\n\nfunction iTerm.notify(msg)\n   return OSC .. \"9;\" .. msg .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal _iTerm_cursors = { block = 0,\n                         vertical = 1,\n                         underline = 2,\n                         [0] = \'0\', \'1\', \'2\' }\n\nfunction iTerm.cursor_shape(shape)\n   if not _iTerm_cursors[shape] then\n      error(\"bad parameter passed to cursor_shape: \" .. tostring(shape))\n   end\n   return LEET .. \"CursorShape=\" .. _iTerm_cursors[shape] .. \"\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.yank(text)\n   return LEET .. \"CopyToClipboard=general\\a\" .. text\n       .. LEET .. \"EndCopy\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.link(url, slug)\n   return OSC .. \"8;;\" .. url .. \'\\a\' .. slug .. OSC .. \"8;;\\a\"\nend\n\n\n\n\n\n\n\n\n\nfunction iTerm.annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\nfunction iTerm.hidden_annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddHiddenAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.fireworks()\n   return LEET .. \"RequestAttention=fireworks\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.bounce_icon()\n   return LEET .. \"RequestAttention=yes\\a\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __navigation = {  UP       = \"\\x1b[A\",\n                        DOWN     = \"\\x1b[B\",\n                        RIGHT    = \"\\x1b[C\",\n                        LEFT     = \"\\x1b[D\",\n                        SHIFT_UP = \"\\x1b[1;2A\",\n                        SHIFT_DOWN = \"\\x1b[1;2B\",\n                        SHIFT_RIGHT = \"\\x1b[1;2C\",\n                        SHIFT_LEFT  = \"\\x1b[1;2D\",\n                        HYPER_UP    = \"\\x1b[5~\",\n                        HYPER_DOWN  = \"\\x1b[6~\",\n                        HYPER_RIGHT = \"\\x1b[F\",\n                        HYPER_LEFT  = \"\\x1b[H\",\n                        ALT_UP    = \"\\x1b[1;3A\",\n                        ALT_DOWN  = \"\\x1b[1;3B\",\n                        ALT_RIGHT = \"\\x1b[1;3C\", -- heh\n                        ALT_LEFT  = \"\\x1b[1;3D\",\n                        SHIFT_ALT_UP = \"\\x1b[1;10A\",\n                        SHIFT_ALT_DOWN = \"\\x1b[1;10B\",\n                        SHIFT_ALT_RIGHT = \"\\x1b[1;10C\",\n                        SHIFT_ALT_LEFT  = \"\\x1b[1;10D\",\n                        SHIFT_TAB  = \"\\x1b[Z\",\n                        ALT_TAB    = \"\\x1b\\t\",\n                        NEWLINE    = \"\\n\",\n                        RETURN     = \"\\r\",\n                        SHIFT_RETURN = \"\\x1b[13;2u\",\n                        CTRL_RETURN = \"\\x1b[13;5u\",\n                        ALT_RETURN = \"\\x1b\\r\",\n                        TAB        = \"\\t\",\n                        BACKSPACE  = \"\\127\",\n                        DELETE     = \"\\x1b[3~\",\n                        ESC        = \"\\x1b\",\n                     }\n\n\n\n\n\n\nlocal __alt_nav = {  UP    = \"\\x1bOA\",\n                     DOWN  = \"\\x1bOB\",\n                     RIGHT = \"\\x1bOC\",\n                     LEFT  = \"\\x1bOD\"\n                  }\n\n\n\n\n\n\n\n__alt_nav.ALT_LEFT  = \"\\x1bb\"\n__alt_nav.ALT_RIGHT = \"\\x1bf\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal navigation = {}\n\nfor k,v in pairs(__navigation) do\n   navigation[v] = k\nend\nfor k,v in pairs(__alt_nav) do\n   navigation[v] = k\nend\n\n__navigation, __alt_nav = nil, nil\n\nanterm.navigation = navigation\n\nfunction anterm.is_nav(seq)\n   if navigation[seq] then\n      return navigation[seq]\n   else\n      return false, \"not a recognized NAV token\", seq\n   end\nend\n\n\n\n\n\n\nlocal PASTE_START = CSI .. \"200~\"\nlocal PASTE_END   = CSI .. \"201~\"\nfunction anterm.is_paste(seq)\n   if seq:sub(1, #PASTE_START) == PASTE_START then\n      assert(seq:sub(-#PASTE_END) == PASTE_END, \"Partial paste encountered\")\n      return true\n   else\n      return false\n   end\nend\n\nfunction anterm.parse_paste(seq)\n   return seq:sub(#PASTE_START + 1, -#PASTE_END - 1)\nend\n\n\n\nreturn anterm\n",
},
  { 
vc_hash = "e9fbe93b834243240afe7cc37a297fc5d38d0449",
name = "anterm/palette",
hash = "34d5d4d4bcef71863bbfa0b7ab389df51a1adf3941275e30a0d3e4ce2998808e",
branch = "trunk",
binary = "\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal meta = assert(require \"core:core/meta\".meta)\nlocal table = require \"core:core/table\"\n\n\n\nlocal Palette = meta {}\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(table.cloneinstance)\n\nfunction Palette.__newindex(palette, name, color)\n   color = cloneinstance(color)\n   color.name = name\n   rawset(palette, name, color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Palette.change(palette, name, color)\n   local old_c = palette[name]\n   color = cloneinstance(color)\n   color.name = name\n   palette[name] = color\n   if not old_c then\n      return false\n   end\n   for n, c in pairs(palette) do\n      if c.kind == \'embedded\'\n         and c.reset == old_c\n         and c.reset.name == old_c.name then\n         c.reset = color\n      end\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(color_tab)\n   local palette = setmetatable({}, Palette)\n   if color_tab then\n      for name, color in pairs(color_tab) do\n         palette[name] = color\n      end\n   end\n   return palette\nend\n\nPalette.idEst = new\n\n\n\n\nreturn new\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/bridge",
    repo_alternates = "https://gitlab.special-circumstanc.es/atman/br.git",
    home = "",
    website = "",
    name = "br",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "letters/mikemike",
hash = "05503e0e0e1302e4f705a86e4bebed565716ac866157b8d7752f3472d9e025bf",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _doSeveralThings(obj)\n   obj:doFirstThing()\n   yield(obj:secondMessage(_passed))\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "s/kore/ansi",
hash = "057140b07fa4aae76ec862821fcc2acd9c4b743b79aa329bdfeb0970f7ee8a78",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = pairs\nlocal tostring = tostring\nlocal setmetatable = setmetatable\nlocal error = error\nlocal require = require\nlocal rawget = rawget\nlocal io = io\nlocal schar = string.char\n\nlocal _M = {}\n\n\nlocal colormt = {}\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        dim = 2,\n        underscore = 4,\n        blink = 5,\n        reverse = 7,\n        hidden = 8},\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = schar(27)..\'[\'..tostring(value)..\'m\',\n        name = name,\n        kind = kind }\n    return setmetatable(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        _M[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt:__tostring()\n    return self.value\nend\n\nfunction colormt:__concat(other)\n    return tostring(self) .. tostring(other)\nend\n\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    -- complex but tractable for attributes\n    if color.kind == \"fg\" then\n        return _M.clear_fg\n    elseif color.kind == \"bg\" then\n        return _M.clear_bg\n    elseif color.kind == \"attribute\" then\n        --error \"attribute reset NYI\"\n        return _M.clear\n    end\nend\n\nfunction colormt:__call(s)\n    if s then\n        return tostring(self) .. s .. reset(self)\n    else\n        return tostring(self)\n    end\nend\n\ncolormt.__metatable = {}\n\nlocal function byte_panic(byte_p)\n       if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n        error \"xterm value must be 8 bit unsigned\"\n    end\nend\n\nlocal function ansi_fg(byte)\n    local store = {} -- repeated allocation is a sin.\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[38;5;\"..byte..\"m\",\n                        kind = \"fg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function ansi_bg(byte)\n    local store = {}\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[48;5;\"..byte..\"m\",\n                        kind = \"bg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[38;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"fg\" }\n   return setmetatable(color, colormt)\nend\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[48;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"bg\" }\n   return setmetatable(color, colormt)\nend\n\n_M[\"fg\"], _M[\"bg\"] = ansi_fg, ansi_bg\n\n_M[\"fg24\"], _M[\"bg24\"] = fg24, bg24\n\n--- Jumps\n\nlocal jump = {}\n\nlocal CSI = schar(27)..\'[\'\n\njump.up = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"A\"\nend\n\njump.down = function(num)\n    if not num then num = \"\" end\n        return CSI..num..\"B\"\nend\n\njump.forward = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"C\"\nend\n\njump.back = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"D\"\nend\n\nlocal function Jump(_,row,column)\n    return CSI..row..\";\"..column..\"H\"\nend\n\nlocal J = { __call = Jump}\nsetmetatable(jump,J)\n\n_M[\"jump\"] = jump\n\n\nreturn _M\n\n\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "cluster/idEst",
hash = "d60c40bcadfb8f728697079c477e34d3db225d3adf46380f4c4abf9836419536",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\nNode = require \"espalier:espalier/node\"\n\nnode = Node(\"a new node\")\n\nif node.idEst == Node then\n   -- do class-specific stuff here\nend\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "s/kore/color",
hash = "c7320fa01612d7048ffd42df750c8046bef5191753aad9a6244d7672cd4a9d02",
branch = "master",
binary = "\n\n\n\n\nlocal a = require \"kore/ansi\"\n\nlocal C = {}\nC.color = {}\nC.color.number = a.fg(42)\nC.color.string = a.fg(222)\nC.color.table  = a.fg(64)\nC.color.func   = a.fg24(210,12,120)\nC.color.truth  = a.fg(231)\nC.color.falsehood  = a.fg(94)\nC.color.nilness   = a.fg(93)\nC.color.field  = a.fg(111)\n\nC.color.alert = a.fg24(250, 0, 40)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hints = { field = C.color.field,\n                  fn  = C.color.func }\n\nlocal anti_G = {}\n\nfor k, v in pairs(_G) do\n   anti_G [v] = k\nend\n\nfunction C.ts(value, hint)\n   local c = C.color\n   local str = tostring(value)\n   if hint == \"\" then\n      return str -- or just use tostring()?\n   end\n   if hint then\n      return hints[hint](str)\n   end\n\n   local typica = type(value)\n   if typica == \'number\' then\n      str = c.number(str)\n   elseif typica == \'table\' then\n      str = c.table(str)\n   elseif typica == \'function\' then\n      if anti_G[value] then\n         -- we have a global name for this function\n         str = c.func(anti_G[value])\n      else\n         local func_handle = \"func:\" .. string.sub(str, -6)\n         str = c.func(func_handle)\n      end\n   elseif typica == \'boolean\' then\n      str = value and c.truth(str) or c.falsehood(str)\n   elseif typica == \'string\' then\n      str = c.string(str)\n   elseif typica == \'nil\' then\n      str = c.nilness(str)\n   end\n   return str\nend\n\n\n\nreturn C\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "s/kore/check",
hash = "ea35dbd59af61db62ddc5a995c1ca1bcd41992d7adfaa85c0160605eeee33f90",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = require \"kore/color\"\nlocal ts = c.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ItIndex(Itself, verb)\n\tif verb == \"won\" or verb == \"did\" then\n\t\treturn nil\n\tend\n\tverb = verb and verb or \"\"\n\tlocal it = Itself.current\n\tlocal result = {success = false}\n\tresult.why = \"`check` does not understand the verb \" .. ts(verb)\n\t\t\t\t\t.. \" at least, not yet\"\n\tio.write(result.why .. \"\\n\")\n\tit.did.also(result)\n\treturn function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal call = function (it)\n\tif it.won == nil then\n\t\tit = it:collate()\n\tend\n\tif it.won then\n\t\treturn it.subject, it\n\telse\n\t\treturn nil, it\n\tend\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n\tif Object.isIt and Object.isIt == It then\n\t\treturn Object\n\tend\n\n\tlocal itself = setmetatable({}, {__index = It,\n\t\t                              __call = call})\n\tIt.current  = itself  -- THIS IS NOT RE_ENTRANT FIND A BETTER WAY\n\titself.isIt = It\n\titself.name = name and name or \"it\"\n\titself.subject = Object\n\titself = must(itself)\n\titself.did = {}\n\titself.did.also = function(result)\n\t\t\t\t\t\t result.modal = itself.modal\n\t\t                 itself.did[#itself.did + 1] = result\n\t\t                 return itself\n\t\t              end\n \titself.did.last = function() return itself.did[#itself.did] end\n\n\treturn itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\nlocal function verdict(it, subject, verb, object)\n\tlocal subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n\treturn it.name .. \": \" .. subj .. it.modal.inThatIt\n\t       .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal must = setmetatable({}, Modal)\n\tmust.beTrue = true\n\tmust.because = because\n\tmust.inThatIt = \"must\"\n\tit.modal = must\n\treturn it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal mustnt = setmetatable({}, Modal)\n\tmustnt.because = because or \"\"\n\tmustnt.beTrue = false\n\tmustnt.inThatIt = \"mustn\'t\"\n\tit.modal = mustnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n\tlocal should = setmetatable({}, Modal)\n\tshould.because = because or \"\"\n\tshould.beTrue = true\n\tshould.inThatIt = \"should\"\n\tit.modal = should\n\treturn it\nend\n\nfunction It.shouldnt(it, because)\n\tlocal shouldnt = setmetatable({}, Modal)\n\tshouldnt.because = because or \"\"\n\tshouldnt.beTrue = false\n\tshouldnt.inThatIt = \"shouldn\'t\"\n\tit.modal = shouldnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n\tlocal result = {}\n\tlocal success = it.subject == rValue and true or false\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tif success then\n\t\tresult.why =  verdict(it, it.subject, \"equal\", rValue)\n\telse\n\t\tresult.why = verdict(it, it.subject, \"not equal\", rValue)\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal having = it.subject[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having\n\n\tif having == nil then\n\t\t-- todo better message if \'has\' failed,\n\t\t-- the more common case.\n\t\tresult.why = \"equalTo must follow have/has\"\n\telse\n\t\tsuccess = having == rValue and true or false\n\t\tlocal subj, obj\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\t\tsubj, obj = having, rValue\n\t\telse\n\t\t\tsubj, obj = rValue, having\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because or verdict(it, subj, \"==\", obj)\n\t    else\n\t    \tresult.why = because or verdict(it, subj, \"~=\", obj)\n\t    end\n\t    result.having = having -- to chain field checks\n\tend\n\n\tresult.success = success\n\treturn it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did[#it.did]\n\tlocal having = last.having\n\tif type(len) ~= \"number\" then\n\t\tresult.why = \"ofLen param must be a number\"\n\telseif not having then\n\t\tresult.why = \"ofLen must have a value on it.did\"\n\telse\n\t\tsuccess = #having == len and true or false\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because\n\t\t\t             or verdict(it, \"#\" .. ts(having), \"==\", len)\n\t    else\n\t    \tresult.why = because\n\t    \t             or verdict(it, \"#\" .. ts(having), \"~=\", len)\n\t    end\n\tend\n\n\tresult.success = success\n\tresult.inThatIt = it.modal.inThatIt\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n\tlocal result = { success = false,\n                     why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n\treturn {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n\tlocal method = last.having\n\tif not method then\n\t\tresult.why = \"calling must be performed on a value\"\n\telseif not type(method) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name .. \" field must be function: \" .. last.field)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = method(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.field  = last.field\n\t\tlocal callee = ts(last.field, \"field\") .. \"(\"\n\t\tif result.arg and result.arg.n >= 1 then\n\t\t\tfor i = 1, result.arg.n do\n\t\t\t\tcallee = callee .. ts(result.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tcallee = string.sub(callee, 1, -3)\n\t\tend\n\t\tcallee = callee .. \")\"\n\t\tresult.why    = verdict(it, \"\", \"be callable with\", callee)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name\n\t\t\t          .. \" passedTo needs a function: \" .. fn)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = fn(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.fn     = fn\n\t\tresult.why    = verdict(it, \"\", \"be passed to\", fn)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did.last()\n\tlocal answer = last.answer\n\tif answer == nil then\n\t\tresult.why = \"prior clause must provide an answer\"\n\telse\n\t\t-- build strings for verdict\n\t\tlocal callee = \":anon:\"\n\t\tif last.field then\n\t\t\tcallee = it.name .. ts(\":\" ..last.field, \"field\")\n\t\telseif last.fn then\n\t\t\tcallee = ts(last.fn)\n\t\tend\n\t\tlocal param = \"(\"\n\t\tif last.fn then\n\t\t\tparam = param .. it.name\n\t\tend\n\t\tif last.arg and last.arg.n >= 1 then\n\t\t\tif last.fn then param = param .. \", \" end\n\t\t\tfor i = 1, last.arg.n do\n\t\t\t\tparam = param .. ts(last.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tparam = string.sub(param, 1, -3)\n\t\tend\n\t\tparam = param .. \")\"\n\n\t\tlocal isSame = answer == rValue and true or false\n\t\tif isSame then\n\t\t\tif not last.b then\n\t\t\t\tsuccess = true\n\t\t\t\tresult.why = verdict(it, callee .. param, \"give\", ts(answer))\n\t\t\telseif b then\n\t\t\t\tlocal gives = {ts(answer)}\n\t\t\t\tlocal is_b_same  = last.b == b and true or false\n\t\t\t\tgives[2] = ts(last.b)\n\t\t\t\tsuccess = true and is_b_same\n\t\t\t\tresult.why = vertict(it, callee .. param, \"give\", gives[1]\n\t\t\t\t\t          .. \" \" .. gives[2])\n\t\t\tend\n\t\telse\n\t\t\tresult.why = it.name .. \":\" .. callee .. param .. \" \" .. it.modal.inThatIt\n\t\t\t              .. \" give \" .. ts(rValue) .. \" not \" .. ts(answer)\n\t\tend\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\n\tresult.success = success\n\n\n\treturn it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n\treturn it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n\tphrase = \"\"\n\tlocal Yes, No\n\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\tYes, No = \"âœ…   \",  \"âŒ   \"\n\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\tYes, No = \"ðŸŒŸ   \",  \"ðŸ˜¡   \"\n\telseif mood == \"can\" then\n\t\tYes, No = \"ðŸ‘   \",  \"ðŸ‘Ž   \"\n\tend\n\tif did.success then\n\t\tphrase = phrase .. \"   \" .. Yes .. did.why\n\telse\n\t\tphrase = phrase .. \"   \" .. No .. did.why\n\tend\n\tphrase = phrase .. \"\\n\"\n\tdid.digest = phrase\n\treturn phrase\nend\n\n\n\n\nfunction It.collate(it)\n\tlocal winning = true\n\tlocal wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n\tlocal musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n\tlocal phrase = it.name .. \":\\n\"\n\tfor _, did in ipairs(it.did) do\n\t\twinning = winning and did.success\n\t\tlocal mood = did.modal.inThatIt\n\t\tlocal digest = digestLine(did, mood)\n\t\tphrase = phrase .. digest\n\n\t\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\t\tmusts = musts + 1\n\t\t\tif did.success then\n\t\t\t\twins.must = wins.must + 1\n\t\t\tend\n\t\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\t\tshoulds = shoulds + 1\n\t\t\tif did.success then\n\t\t\t\twins.should = wins.should + 1\n\t\t\tend\n\t\tend\n\t-- etc\n\tend\n\tif musts > 0 then\n\t\tphrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n\tend\n\tif shoulds > 0 then\n\t\tphrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n\tend\n\tit.won = winning\n\tif it.won then\n\t\tphrase = \"All clear!\\n\" .. phrase\n\telse\n\t\tphrase = \"Needs work:\\n\" .. phrase\n\tend\n\tphrase = phrase .. \"\\n\"\n\tit.digest = phrase\n\n\treturn it\nend\n\n\n\nfunction It.report(it)\n \tit = it:collate()\n\tio.write(it.digest)\n\treturn it\nend\n\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n\tIt[#It + 1] = it\n\treturn it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n\tlocal winning = true\n\tfor _, that in ipairs(It) do\n\t\tthat:report()\n\t\twinning = winning and that.won\n\tend\n\treturn it, winning\nend\n\nfunction It.allFailure(it)\n\tfor _, that in ipairs(It) do\n\t\tthat:check()\n\t\tfor _, did in ipairs(that.did) do\n\t\t\tif not did.success then\n\t\t\t\tio.write(did.digest)\n\t\t\tend\n\t\tend\n\tend\n\treturn it\nend\n\n\n\nreturn check\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "s/kore/status",
hash = "9f8c739d9011a74d6c8ad227ae1b2684c618b7cde5aaf95d172bd3df68910ec7",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- #todo this should just be anterm\nlocal a = pcall(require, \"anterm\") or require \"ansi\"\nlocal debug = require \"debug\"\n\nlocal status = {}\n\nstatus.DjikstraWasRight = true -- I swear I\'m going to use this for something. Watch.\n\nstatus.chatty = true\nstatus.verbose = false\nstatus.grumpy = true\nstatus.angry = true\n\nstatus.traceOnComplain = true\n\n-- ** Status:halt(message)\n--\n--   This dies in pipeline modes.\n--\n-- In the fleshed-out Lun/Clu environment, this will pause execution\n-- and present as much of a debugger as it can.\n\nfunction status.halt(statusQuo, message, exitCode)\n    local bye = exitCode or 1\n    io.write(message.. \"\\n\")\n    assert(false)\n    os.exit(bye)\nend\n\nfunction status.chat(statusQuo, message)\n    if statusQuo.chatty then\n        io.write(message .. \"\\n\")\n    end\nend\n\nfunction status.verb(statusQuo, message)\n    if statusQuo.verbose then\n        io.write(message .. \"\\n\")\n    end\nend\n\n\n-- Complaints are recoverable problems that still shouldn\'t happen.\n--\n--  Almost time to orbify the library collection...\n--  The value parameter is being passed in so improved Status can\n--  do things with it.\n--\nfunction status.complain(statusQuo, topic, message, value)\n    if not message then\n        message = topic\n    else\n        topic = a.red(topic)\n    end\n    if statusQuo.grumpy then\n        io.write(topic .. \": \" .. message .. \"\\n\")\n    end\n    if statusQuo.traceOnComplain then\n        io.write(debug.traceback())\n    end\n    if statusQuo.angry then\n        os.exit(1)\n    end\nend\n\nlocal function call(statusQuo)\n    return setmetatable({}, {__index = statusQuo, __call = call})\nend\n\n\nreturn setmetatable(status, {__call = call})\n",
},
  { 
vc_hash = "76554031f9ccc6b402980eb3adc80840ef383374",
name = "design/lun",
hash = "eacb2ea0581214037486115742f271a59542dc42b5b913a8a5dc886abd4f4fd8",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/bundle.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/bundle.git",
    home = "",
    website = "",
    name = "bundle",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "47bd51d5e9b8af7c6ec6e4a6f752b6183284f100",
name = "import",
hash = "6140377c9b2d0ef111677bb32fa2c7babc7c7d96bf795894ae444db30f0ccc65",
branch = "export-all",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n\n\n\n\nreturn import\n",
},
  { 
vc_hash = "47bd51d5e9b8af7c6ec6e4a6f752b6183284f100",
name = "export",
hash = "763e9bd868bfae41ffa7ba17e13686d3c99662a08d6f9c5d6cadf8dfbcbba733",
branch = "export-all",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal Phrase = require \"singletons/phrase\"\n\n\n\nlocal Export = {}\n\n\n\n\n\nlocal latest_ids = [[\nSELECT\n   bundle_id, version, project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal latest_versioned_ids = [[\nSELECT\n   bundle_id, bundle.version, bundle.project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nINNER JOIN\n   version\nON\n   version.version_id = bundle.version\nWHERE\n   project.name = :project\nAND\n   version.major = :major\nAND\n   version.minor = :minor\nAND\n   version.patch = :patch\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal get_modules = [[\nSELECT\n   module.name, module.vc_hash, module.branch,\n   code.hash, code.binary\nFROM\n   module\nINNER JOIN\n   code\nON\n   module.code = code.code_id\nWHERE\n   module.bundle = ?\n;\n]]\n\n\n\nlocal get_version = [[\nSELECT * FROM version WHERE version_id = ?;\n]]\n\n\n\nlocal get_project = [[\nSELECT * FROM project WHERE project_id = ?;\n]]\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function exportProject(project, version)\n   local conn = _Bridge.modules_conn\n   local bundle_result\n   if version then\n      version.project = project\n      bundle_result = conn:prepare(latest_versioned_ids)\n                                :bindkv(version):step()\n      if not bundle_result then\n         error(\"unable to find \" .. project .. \" in the specified version\")\n      end\n   else\n      bundle_result = conn:prepare(latest_ids):bind(project):step()\n      if not bundle_result then\n         error(\"no bundle found for project \" .. project)\n      end\n   end\n   local bundle_id = bundle_result[1]\n   local version_id = bundle_result[2]\n   local project_id = bundle_result[3]\n   local mods = toRow(conn:prepare(get_modules):bind(bundle_id):resultset(\"ihk\"))\n   local version = conn:prepare(get_version):bind(version_id):resultset(\"ihk\")\n   local project = conn:prepare(get_project):bind(project_id):resultset(\"ihk\")\n   version = toRow(version)\n   project = toRow(project)\n   return version, mods, project\nend\n\nExport.exportProject = exportProject\n\n\n\n\n\n\nlocal toLuaString = Codepoints.toLuaString\n\nlocal function bundle(version, modules, project)\n   -- A project can exist without modules, in which case, we skip it\n   if modules == nil then return nil end\n   local phrase = Phrase \"{\\n  project = {\\n\"\n   for key, val in pairs(project) do\n      if key ~= \"project_id\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n            error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  version = {\"\n   for key, val in pairs(version) do\n      if key ~= \"version_id\" and key ~= \"project\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n             error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  modules = { \"\n   for _, mod in ipairs(modules) do\n      phrase = phrase .. \"  { \\n\"\n      for key, val in pairs(mod) do\n         phrase = phrase .. key .. \" = \" .. toLuaString(val) .. \",\\n\"\n      end\n      phrase = phrase .. \"},\\n\"\n   end\n   phrase = phrase .. \"} }\"\n   return tostring(phrase)\nend\nExport.bundle = bundle\n\n\n\n\n\n\n\n\n\n\nfunction Export.export(projects, version)\n   if type(projects) == \"table\" then\n      local phrase = Phrase \"return { \"\n      for _, project in ipairs(projects) do\n         local bundle_str = bundle(exportProject(project, version))\n         if bundle_str then\n            phrase = phrase .. bundle_str .. \",\\n\"\n         end\n      end\n      phrase = phrase .. \"}\"\n      return tostring(phrase)\n   elseif type(projects) == \"string\" then\n      local phrase = Phrase \"return \"\n      phrase = phrase .. bundle(exportProject(projects, version))\n      return tostring(phrase)\n   else\n      error(\"bad argument to export of type \" .. type(projects))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Export.exportAll(version)\n   -- ignoring the version parameter for now.\n   if not version then\n      local conn = _Bridge.modules_conn\n      local projects = conn:exec \"SELECT name FROM project;\"\n      return Export.export(projects.name, version)\n   end\nend\n\n\n\nreturn Export\n",
},
  { 
vc_hash = "47bd51d5e9b8af7c6ec6e4a6f752b6183284f100",
name = "revert",
hash = "bc388686a91164d3747423ad4537590bfa3807be6ae4f567e448e77990120796",
branch = "export-all",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal Dir = require \"fs:directory\"\n\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT\n   bundle_id\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project_id = project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time DESC\nLIMIT 1\n;\n]]\n\n\n\nlocal delete_from_bundle = [[\nDELETE FROM bundle WHERE bundle_id = ? ;\n]]\n\n\n\n\nlocal ts = require \"helm:repr\" . ts\nlocal function revert()\n   local pwd = Dir(uv.cwd())\n   local conn = _Bridge.modules_conn\n   conn.pragma.foreign_keys(true)\n   local project = _Bridge.args.project or pwd.path[#pwd.path]\n   print(\"reverting latest commit to project \" .. project)\n   local bundle_id = conn:prepare(get_latest_bundle):bind(project):step()\n   bundle_id = bundle_id[1]\n   if bundle_id then\n      conn:prepare(delete_from_bundle):bind(bundle_id):step()\n   else\n      print(\"no bundle_id found for project \" .. project)\n   end\nend\n\n\n\n\nreturn revert\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/atman/clu.git",
    repo_alternates = "https://gitlab.com/special-circumstance/clu.git",
    home = "",
    website = "",
    name = "clu",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/clu",
hash = "970cf6182e4c7afa670b52ef444b9a4f0552f14fc3442efd04cc2cb00ab21a9d",
branch = "master",
binary = "\n\n\nlocal s = require \"singletons/status\" ()\nlocal a = require \"singletons/anterm\"\ns.verbose = true\ns.angry = false\n\n\n\n\n\n\n\n\nlocal Clu = {}\n\nlocal read = require \"clu/reader\"\n\nClu.read = read\n\nlocal _C, macroEnv = require \"clu/C\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compile\nif _VERSION == \"Lua 5.1\" then\n   compile = load\nelse\n   compile = loadstring\nend\n\nlocal function eval(ast, name, env)\n   local env = env or _C\n   local name = name or \"\"\n   local lua_chunk = tostring(ast:toLua())\n    -- This is 5.2 style\n   local catch, err = load(lua_chunk, name, nil, env)\n   if not catch and err then\n      s:complain(\"load error\", tostring(err))\n   else\n      return catch()\n   end\nend\n\nClu.eval = eval\n\n\n\n\n\n\n\n\n\nlocal function reader_evaluator(name, env, _Mac)\n   local env = env or _C\n   local name = name or \"Clu\"\n\n   --  Return anonymous method\n   return function (_, str)\n      if type(str) == \'table\' then\n         --  A couple possibilities\n         if str.isNode then\n            return eval(str, name, env, _Mac)\n         elseif str.isPhrase then\n            return eval(read(tostring(str)), name, env, Mac)\n         else\n            s:complain(\"table error in read_eval\",\n                      \"don\'t know what to do with\" .. tostring(str))\n         end\n      end\n      local ast, err = read(str)\n\n      if err then\n         s:complain(\"reader error\", err.msg)\n         return ast, err\n      end\n\n      return eval(ast, name, env)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function new_reader_evaluator(name, env, _Mac)\n   local Meta = { __index = Clu }\n   Meta.__call = reader_evaluator(name, env, _Mac)\n   local clu = setmetatable({}, Meta)\n   if _Mac then\n      clu._Mac = _Mac\n   end\n   return clu\nend\n\n\n\nlocal function new(CluInstance, name, env, _Mac)\n   local _Mac =  new_reader_evaluator(\"CluMacro\", macroEnv, _Mac)\n   return new_reader_evaluator(name, env, _Mac)\nend\n\n\n\n\n\nreturn setmetatable({}, {__call = new,\n                         __index = Clu})\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/comment",
hash = "12e459b36e0294db7e2f4def080e13425f69a82e08ae640ce7dd4eaea0a4b6f3",
branch = "master",
binary = "\n\n\nlocal Comment = require \"clu/twig\" : inherit ()\n\nfunction Comment.toLua(comment, st)\n   return st:indent() .. \"--\" .. string.sub(comment:span(), 2) .. \"\\n\"\nend\n\nreturn Comment\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/field",
hash = "59e2810faa6a86109cee1a2d940504a65b821515640ab09b7638322634591e0c",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Field = Twig:inherit()\n\nfunction Field.toLua(field, st)\n   return field[1]:toLua() .. \".\" .. field[2]:toLua(), st\nend\n\nreturn Field\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/symbol",
hash = "5b66942f8468ef826ca1a68de71e3d2ecb596580df4bb91fe54e3b1744ad0965",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Symbol = Twig:inherit()\n\n\n\n\n\n\n\n\n\n\nlocal function mangle(span)\n   return span:gsub(\"!\", \"_ZAP\"):gsub(\"?\", \"_WUT\"):gsub(\"%+\", \"_LUS\")\n            -- and so on for really quite awhile, let\'s add an important one\n            :gsub(\"-\", \"_\"):gsub(\"%%\", \"_CEN\"):gsub(\"%*\", \"_TAR\")\nend\n\nfunction Symbol.toLua(symbol)\n   if symbol.__MANGLED then\n      return symbol.__MANGLED\n   else\n      symbol.__MANGLED = mangle(symbol:span())\n      return symbol.__MANGLED\n   end\nend\n\nreturn Symbol\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/vararg",
hash = "2f734b2b588bc3a9b5c52f8ce53105f37eb3456bf5c55870f99087d0d560d545",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Vararg = Twig : inherit ()\n\nfunction Vararg.toLua(vararg, st)\n   return vararg:span()\nend\n\nreturn Vararg\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/unary",
hash = "f851f315f0b51acc661ca8340a54a83667ba5ceb65acea0fc2b4b1893efe8bc5",
branch = "master",
binary = "\n\n\n\nlocal Unary = require \"clu/twig\" : inherit ()\n\nfunction Unary.toLua(unary, st)\n   if unary[1].id == \"quote\" then\n      return unary[1]:toLua(st(), unary)\n   end\nend\n\nreturn Unary\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/map",
hash = "844353b7958573f4a2d7825c85ef3f434519295ae2e34edce81966e1367a05da",
branch = "master",
binary = "\n\n\nlocal Map = require \'clu/twig\' : inherit ()\n\n\nfunction Map.toLua(map, st)\n   assert(st.indent)\n   assert(#map % 2 == 0, \'maps must have an even number of forms\')\n   local phrase = st.phrase\n   local longMap = #map > 2\n   phrase = \'(function() local MAP = {} \'\n   if longMap then\n      st.dent = st.dent + 1\n      phrase = phrase .. \';\\n\'\n   end\n   for i = 1, #map, 2 do\n      local key, keyId = map[i]:toLua(st()), map[i].id\n      local val = map[i + 1]:toLua(st())\n      if longMap then \n         phrase = phrase .. st:indent()\n      end\n      phrase = phrase .. \' MAP\'\n      if keyId == \'symbol\' then\n         phrase = phrase .. \".\" .. key\n      else \n         phrase = phrase .. \"[\" .. key .. \"]\"\n      end\n      phrase = phrase .. \" = \" .. val .. \" \"\n      if longMap then\n         phrase = phrase .. \";\\n\"\n      end\n   end\n   if longMap then\n      st.dent = st.dent - 1\n      phrase = phrase .. st:indent()\n   else \n      phrase = phrase .. \" \"\n   end\n   phrase = phrase .. \"return MAP end)()\"\n   return phrase, st \nend\n\nreturn Map\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/boolean",
hash = "89203402ed04abe98d60fefc6f5b079af482da66422fe2889e5fd930b7fb921b",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Boolean = Twig : inherit()\n\n\n\nfunction Boolean.toLua(bool, st)\n   return bool:span()\nend\n\n\n\nreturn Boolean\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/number",
hash = "1d6eddb8cc07472e7e19b5044c178d7ea7bc66e69ec53da9fe43577840f14e25",
branch = "master",
binary = "\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Num = Twig:inherit()\n\nfunction Num.toLua(number, st)\n   return number.span(number), st\nend\n\nreturn Num\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/reader",
hash = "4e554d3db41170bbd4998bf92135e8f69c92d0d558152772672326e28bd09fc5",
branch = "master",
binary = "\n\n\n\n\n\n\n\nlocal Clu_metas = { require \"clu/twig\",\n                    clu        =  require \"clu/cluprime\",\n                    template   =  require \"clu/templates\",\n                    expr       =  require \"clu/expr\",\n                    vector     =  require \"clu/vector\",\n                    symbol     =  require \"clu/symbol\",\n                    map        =  require \"clu/map\",\n                    multiple   =  require \"clu/multiple\",\n                    null       =  require \"clu/nil\",\n                    boolean    =  require \"clu/boolean\",\n                    vararg     =  require \"clu/vararg\",\n                    number     =  require \"clu/number\",\n                    operator   =  require \"clu/operator\",\n                    quote      =  require \"clu/quote\",\n                    comparison =  require \"clu/comparison\",\n                    methodcall =  require \"clu/methodcall\",\n                    field      =  require \"clu/field\",\n                    comment    =  require \"clu/comment\",\n                    string     =  require \"clu/string\",\n                    unary      =  require \"clu/unary\"  }\n\n\n\nlocal L = require \"espalier/elpatt\"\n\nlocal V, P, R, S, E, EOF = L.V, L.P, L.R, L.S, L.E, L.EOF\n\nlocal Grammar = require \"espalier/grammar\"\n\nlocal glyph_symbol =  S(\"!\", \"$\", \"%\", \"^\", \"*\",\n                        \"+\", \"=\", \"<\", \">\", \"&\",\n                        \"?\", \"-\", \"/\")\n\n\n\n\nlocal function clu_fn(_ENV)\n   START \"clu\"\n   SUPPRESS (\"compound\", \"form\", \"atom\", \"unarymark\", \"WS\",\n             \"verb\", \"letter\", \"digit\", \"ssyntax\", \"symchars\")\n\n   clu = V\"form\"^1 * V\"pipe\"^0 * EOF(\"no-end\")\n\n   pipe = P\"|\"\n\n   form =  V\"WS\" * ( (V\"unary\")\n                +  (V\"atom\")\n                +  (V\"compound\") ) * V\"WS\"\n\n\n   unary = V\"unarymark\"^1 * P\" \"^0 * (V\"atom\" + V\"compound\")\n\n   unarymark = V\"quote\"\n         + V\"unquote_splice\"\n         + V\"unquote\"\n         + V\"quasiquote\"\n         + V\"reader_macro\"\n\n      quote = P\"\'\"\n\n      unquote = P\"~\"\n\n      quasiquote = P\"`\"\n\n      unquote_splice = P\"~@\"\n\n   atom = V\"WS\" * ( V\"ssyntax\"\n                  + V\"number\"\n                  + V\"boolean\"\n                  + V\"null\"\n                  + V\"vararg\"\n                  + V\"symbol\"\n                  + V\"string\" ) * V\"WS\"\n\n   compound = V\"WS\" * ( V\"expr\"\n                      + V\"map\"\n                      + V\"vector\"\n                      + V\"type_rule\"\n                      + V\"multiple\" ) * V\"WS\"\n\n   expr = P\"(\" * (V\"verb\" * V\"form\"^0)^0 * P\")\"\n\n   verb  = V\"WS\" * ( V\"template\"\n                   + V\"comparison\"\n                   + V\"operator\"\n                   + V\"ssyntax\"\n                   + V\"symbol\" ) * V\"WS\"\n\n   template = S(\"def\", \"for\", \"fn\", \"if\", \"Î»\", \"set\", \"use\")\n\n   operator = S(\"+\", \"-\", \"*\", \"/\", \"%\", \"..\",\n                \"==\", \"~=\", \"and\", \"or\", \"not\")\n\n   comparison = S(\"<\", \">\", \"<=\", \"=>\")\n\n   map = P\"{\" * (V\"form\" * (V\"form\" + E\"noform\"))^0 * V\"WS\" * P\"}\"\n\n   vector = P\"[\" * V\"form\"^0 * V\"WS\" * P\"]\"\n\n   type_rule =  P\"âŸ¨\" * V\"form\"^0 * P\"âŸ©\"\n             +  P\"#|\" * V\"form\"^0 * P\"|#\"\n\n   multiple = P\"\\\\\" * (V\"form\"^1 - P\"\\\\\") * P\"\\\\\"\n\n   digit    = R\"09\"\n\n   number   =  V\"float\" + V\"int\"\n   int    = P\"-\"^-1 * V\"digit\"^1\n   float  = P\"-\"^-1 * V\"digit\"^1 * P\".\" * V\"digit\"^1\n               * ((P\"e\" + P\"E\") * V\"digit\"^1)^0\n\n   boolean = P\"true\" + P\"false\"\n\n   null    = P\"nil\"\n\n   vararg  = P\"...\"\n\n   letter = R\"AZ\" + R\"az\"\n\n   symchars = (V\"letter\" + V\"digit\" + glyph_symbol)\n   symbol = ((V\"letter\" + glyph_symbol)^1 * V\"symchars\"^0) + \"_\"\n\n   ssyntax = V\"methodcall\" + V\"field\"\n\n   methodcall = V\"symbol\" * \":\" * (V\"symbol\" + V\"ssyntax\")\n   field      = V\"symbol\" * \".\" * (V\"symbol\" + V\"ssyntax\")\n\n   string = P\"\\\"\" * (P(1) - (P\"\\\"\" * - P\"\\\\\\\"\"))^0 * P\"\\\"\"\n\n   WS = V\"comment\" + V\"dent\" + (P\" \" + P\"\\t\" + P\",\")^0\n   comment = P\";\" * (-P\"\\n\" * P(1))^0 * V\"WS\"\n   dent = P\"\\n\" * (P\" \" + P\"\\t\" + P\"\\n\")^0\n\n   reader_macro = P\"Hashtags are ossum, possum\"\nend\n\nreturn Grammar(clu_fn, Clu_metas)\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "br/br",
hash = "73e9ad8b0bfb4f9df5428e852a1aadf6f54f84c970c18c0a316146c8f52f1af6",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--require \"pl.strict\"\nlocal Bridge = {} -- This should inherit from a Cluster base type\n\n\n\n\n\n\n\n\n\n\nBridge.CODEX_PATH =  \"./?.lua;./?/?.lua;./lib/?.lua;./src/?.lua;./src/?/?.lua;\"\n                  .. \"./lib/?/?.lua;./lib/?/src/?.lua;./lib/?/src/?/?.lua;\"\n\nfunction Bridge.init(bridge)\n   io.write \"Welcome to bridge\\n\"\n   bridge.cache_PATH = \"\"\n   if package.path then\n      bridge.cache_PATH = package.path\n      return Bridge.CODEX_PATH .. package.path\n   end\n   return bridge.cache_PATH\nend\n\n\n\nfunction Bridge.exit(bridge)\n   package.path = bridge.cache_PATH or \"\"\nend\n\n\n\n\nreturn Bridge\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/nil",
hash = "4cadc0d33909e284829ee9791956bdcd32d230cb4acf0af65c5e594a2839a5b9",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Nil = Twig : inherit()\n\n\n\nfunction Nil.toLua(null, st)\n   return null:span()\nend\n\n\n\nreturn Nil\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/templates",
hash = "da488fac676c1d0c5516e40146f1dc378f077beb6c10283a0c4c7143d5c0d16e",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\nlocal Node = require \"espalier/node\"\nlocal s    = require \"status\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal Templates, temps = Twig:inherit()\nTemplates.__index = Templates\nTemplates.isTemplate = true\n\n\n\n\n\n\n\n\nlocal Use = Templates:inherit()\nUse.id = \"use\"\n\nfunction Use.toLua(use, st, par_expr)\n   local phrase = st.phrase()\n   return \"local \" .. par_expr[3]:toLua(st()) .. \" = \"\n          .. \"require \\\"\" .. par_expr[2]:toLua(st()) .. \"\\\"\",\n          st\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Def = Templates:inherit()\nDef.id = \"def\"\n\nfunction Def.toLua(def, st, par_expr)\n   return \"local \" .. par_expr[2]:toLua(st())\n          .. \" = \" .. par_expr[3]:toLua(st()) .. \"\\n\",\n          st\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Fn = Templates:inherit()\nFn.id = \"fn\"\n\n\n\n\n\n\nfunction Fn.toLua(fn, st, par_expr)\n   local phrase = Phrase \"function \"\n   local params = \"(\"\n   local len = #par_expr\n   if par_expr[2].id == \"expr\" then\n      error(\"two-form Î» is not yet implemented\")\n   end\n   if par_expr[2].id == \'vector\' then\n      for i, v in ipairs(par_expr[2]) do\n         local expr = v:toLua(st())\n         params = params .. expr\n         if i < #par_expr[2] then\n            params = params .. \", \"\n         end\n      end\n   elseif par_expr[2].id == \'symbol\' then\n      params = params .. par_expr[2]:toLua(st())\n   else\n      s:halt(\"arguments to Î» must be symbol or vector, given \" .. par_expr[2].id)\n   end\n   phrase = phrase .. params .. \")\\n\"\n\n   st.dent = st.dent + 1\n   for i = 3, len do\n      local mayReturn = \"\"\n      -- A\n      if i == len then\n         local head = par_expr[len][1] and par_expr[len][1].id or \"\"\n         if head ~= \"if\"\n            and head ~= \"do\"\n            and head ~= \"set\"\n            and head ~= \"def\"\n            and head ~= \"let\" then\n\n            mayReturn = \"return \"\n         end\n      end\n      phrase =  phrase .. st:indent() .. mayReturn .. par_expr[i]:toLua(st()) .. \"\\n\"\n   end\n   st.dent = st.dent -1\n   return phrase .. st:indent() .. \"end\", st\nend\n\n\n\n\n\n\n\nlocal If = Templates:inherit()\nIf.id = \"if\"\n\nfunction If.toLua(fn, st, par_expr)\n   assert(3 <= #par_expr and #par_expr <= 4,\n         \"if must have two or three forms, not \" .. tostring(#par_expr))\n   local phrase = st.phrase\n   local isElse = (par_expr[4] ~= nil)\n   phrase = phrase .. st:indent() .. \"if (\"\n   local predicate = par_expr[2]:toLua(st())\n    phrase = phrase .. predicate .. \")\"\n    phrase = phrase .. \" then\\n\"\n    st.dent   = st.dent + 1\n   local ifTrue = par_expr[3]:toLua(st()) .. \"\\n\"\n   phrase = phrase .. st:indent() .. ifTrue\n   if isElse then\n      local ifFalse = par_expr[4]:toLua(st()) .. \"\\n\"\n      phrase = phrase .. st:dedent() .. \"else\\n\" .. st:indent() .. ifFalse\n   end\n   st.dent = st.dent - 1\n   return phrase .. st:indent() .. \"end\", st\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal For = Templates:inherit()\nFor.id = \"for\"\n\nfunction For.toLua(fn, st, par_expr)\n   assert(#par_expr >= 3, \"for takes at least two forms, given \" .. tostring(#par_expr))\n   local phrase = st.phrase.idEst() .. st:indent() .. \"for \"\n   local params = par_expr[2]\n   if params.id == \'vector\' then\n      --  Build parameters\n      phrase = phrase .. params[1]:toLua(st()) .. \" = \" -- catch non-symbol?\n             .. params[2]:toLua(st()) .. \", \" .. params[3]:toLua(st())\n      if params[4] then\n         phrase = phrase .. \", \" .. params[4]:toLua(st())\n      end\n   elseif params.id == \'map\' then\n      local key, val = params[1], params[2]\n      if key.id == \'vector\' or key.id == \'multiple\' then\n         for i = 1, #key do\n            phrase = phrase .. key[i]:toLua(st())\n            if i ~= #key then\n               phrase = phrase .. \", \"\n            end\n         end\n      elseif key.id == \'symbol\' then\n         phrase = phrase .. key:toLua(st())\n      else\n         s:halt(\"key of map parameter in for must be symbol or vector, given \" .. key.id)\n      end\n      phrase = phrase .. \" in \" .. val:toLua(st())\n   else\n      s:halt(\"second parameter of for must be a vector, given \" .. par_expr[2].id)\n   end\n\n   phrase = phrase .. \" do\\n\"\n   --  Add chunk\n   st.dent = st.dent + 1\n   for i = 3, #par_expr do\n      phrase = phrase .. st:indent() .. par_expr[i]:toLua(st()) .. \"\\n\"\n   end\n   st.dent = st.dent - 1\n   return phrase  .. st:indent() .. \"end\\n\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"clu/set\"\nSet.isTemplate = true\n\nlocal function new(template, str)\n   local id = Node.span(template)\n\n   if id == \"fn\" or id == \"Î»\" then\n     return setmetatable(template, Fn)\n   elseif id == \"if\" then\n        return setmetatable(template, If)\n   elseif id == \"for\" then\n        return setmetatable(template, For)\n   elseif id == \"set\" then\n        return setmetatable(template, Set)\n   elseif id == \"def\" then\n        return setmetatable(template, Def)\n   elseif id == \"let\" then\n        return setmetatable(template, Let)\n   elseif id == \"use\" then\n      return setmetatable(template, Use)\n   end\n\n   return setmetatable(template, Templates)\nend\n\n\n\nreturn new\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu",
hash = "16466dae1e76582c122b685fb98250503be8a70f769389884e2e897a05334ad0",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal br = nil\nlocal ok, br = pcall(require, \"br/br\")\n\nif not ok then\n   br = require \"src/br/br\"\nend\n\n\n\n\n\npackage.path  = br:init()\n\n\n\n\n\nlocal cluster = require \"clu:cluster\"\nClu  = require \"clu:clu/clu\" ()\nlocal s = require \"singletons/status\" ()\nlocal a = require \"singletons/anterm\"\n\ns():chat(\"hello\")\n\n\n\n\n\n\nlocal clu_bar =    [==[\n(clu 12)\n\n(def con {answer 42})\n\n(fn\n  [bar bingo bongo]\n   (baz)\n   (query forth)\n   bux.quux\n   (fn\n     [who dat]\n     (it dis)\n     (oh yeah))\n   5)\n\n(for [i 1 10]\n     (print i)\n     (print con))\n\n(for { [key val]  (ipairs con) }\n     (print val))\n\n#_(if this\n    th2at\n    !?the-other) ]==]\n\nlocal why_hello =  [==[\n(use lpeg lpeg)\n(def con 34)\n(def con-print(fn\n    [x%+!?*] ; unused parameter...\n    (set con 23)\n    (print con)\n    (print (string.sub \"hello world\" 2 3))))\n\n((Î» x (print 23)) Clu)\n\n(def \\my-map my-fn\\\n         \\{ one-form two-form\n            red-form blue-form }\n          ((Î» x (print x)) Clu)\\)\n\n(def ten (< 1 2 3 4))\n\n(for { \\k v\\ (ipairs [1 2 3]) }\n   (print v))\n\n(print ten)\n\ncon-print ; this works\n]==]\n\n\nlocal long_fn = [[\n(set long-fn\n  (Î» [_ x bar baz]\n    (if _\n       (print bar)\n       (print baz))))\n\n(long-fn true \"bar\" \"baz\")\n\n;((fn z (print z )) 12)\n\n(print \'(print 23) \"\\n\")\n\n;((fn (print $) \"quux\")\n]]\n\n\nlocal long_fn_ast = Clu.read(long_fn)\nlong_fn_ast:validate()\nio.write(tostring(long_fn_ast))\nio.write(a.cyan(tostring(long_fn_ast:toLua())))\nClu(long_fn)\nio.write(\"that\'s all folks!\\n\")\n\n\n\n\n\n\n\n\nbr:exit()\nreturn require \"clu/clu\"\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/methodcall",
hash = "ce8e6e1296a2eddfd09a935dd9935dda96fd624598065d47087caba4879a46d1",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Meth = Twig:inherit()\n\nfunction Meth.toLua(meth, st)\n   return meth[1]:span() .. \":\" .. meth[2]:toLua(), st\nend\n\nreturn Meth\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/set",
hash = "880c390e94b86d028d20ed77bf1a9f9e0abd46b56b38ef174672c4a5f111b159",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"clu/twig\" : inherit()\nSet.id = \"set\"\n\n\n\n\nfunction Set.toLua(set, st, par_expr)\n   local phrase = st.phrase() .. st:indent()\n   assert(#par_expr >= 3, \"missing parameter(s) in set\")\n   phrase = phrase .. par_expr[2]:toLua(st()) .. \" = \"\n            .. par_expr[3]:toLua(st())  .. \"\\n\"\n   return phrase, st\nend\n\n\n\nreturn Set\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/vector",
hash = "8da22939e311a6d69c98ef13cb9857ceffb5f863ab5420928af4d3f886c7f2ab",
branch = "master",
binary = "\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Vec = Twig:inherit()\n\nfunction Vec.toLua(vector)\n   local phrase = \"{ \"\n   for i, v in ipairs(vector) do\n      phrase = phrase .. v:toLua() .. \", \"\n   end\n   return phrase .. \" }\"\nend\n\nreturn Vec\n\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/clupeg",
hash = "4e7d86a974165a0932efbaf0dc45708ec71c3aa635cda77c61fe36280c7ad984",
branch = "master",
binary = "\n\n\n\n\n\n\n\nlocal clu_peg = [[\n         clu :  _ form* / EOF\n\n        form : _  unarymark* (atom / compound ) _\n\n `unarymark` :  ( quote\n             /    splice\n             /    unquote\n             /    quasiquote\n             /    readermacro ) _\n\n       quote : \"\'\"\n      splice : \"~@\"\n     unquote : \"~\"\n  quasiquote : \"`\"\n readermacro : \"#\" ; this rule bears some expansion...\n\n    `atom` :  null\n           /  boolean\n           /  ssyntax\n           /  keyword\n           /  symbol\n           /  number\n           /  vararg\n\n`compound` :  expr\n           /  map\n           /  vector\n           /  multiple\n\n   symbol  :  latin !(forbidden) ANYTHING\n   keyword :  \":\" symbol\n\n    expr   :  \"(\" form* \")\"\n    hash   :  \"{\" (form form)* \"}\"\n    vector :  \"[\" form* \"]\"\n  multiple :  \"\\\\\" form \"\\\\\"\nforbidden  : {\\t\\r\\n\\\"\\\'[]()~@#`:.,} / \"{\" / \"}\"\n\n     latin :  ([A-Z] / [a-z])\n\n   comment :  \";\" (!\"\\n\" 1)* \"\\n\"\n\n         _ :  comment / { \\t\\r\\n}*\n]]\n\n\n\nreturn Peg(clu_peg) -- add Reader metatables from separate module\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/cluprime",
hash = "f6455d8f5a718bc223baf9f6629468b55c2b050e031dfae1e97b1d6f020e4f5f",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\nlocal Stator = require \"clu/stator\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal s = require \"status\" ()\n\nassert(Stator.indent)\n\nlocal CluPrime = Twig:inherit()\nCluPrime.isClu = true\n\nfunction CluPrime.toLua(clu)\n   local phrase = Phrase()\n   local st = Stator()\n   st.phrase = phrase\n   st.dent = 0\n   local len = #clu\n   for i = 1, len - 1 do\n      if clu[i].toLua then\n         phrase = phrase .. clu[i]:toLua(st()) .. \"\\n\"\n      else\n         s:halt(\"no toLua method for \" .. clu[i].id)\n      end\n   end\n   phrase = phrase .. \"return \" .. clu[len]:toLua(st()) .. \"\\n\"\n   return phrase\nend\n\nreturn CluPrime\n\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/comparison",
hash = "f8c0a0fc80c0682c83e17ebf60b624f36d4d42d6f282804ab2dd20be0501de2d",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Compare = require \"clu/twig\" : inherit ()\n\nfunction Compare.toLua(comp, st, par_expr)\n   local op = par_expr[1]:span()\n   local phrase = st.phrase\n   phrase = phrase .. \"(\" .. par_expr[2]:toLua(st()) .. \" \"\n                  .. op .. \" \" ..  par_expr[3]:toLua(st())\n   if #par_expr > 3 then\n      for i = 4, #par_expr do\n         phrase = phrase .. \" and \" .. par_expr[i - 1]:toLua(st())\n                  .. \" \" .. op .. \" \" .. par_expr[i]:toLua(st())\n       end\n   end\n\n   return phrase .. \")\", st\nend\n\nreturn Compare\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/expr",
hash = "e01fd66467dd7e6dcbd3f6a1d1496b332cfd48f51f4ab6c951cbf7f1a62d3dfb",
branch = "master",
binary = "\n\n\n\nlocal Twig = require \"clu/twig\"\nlocal s = require \"status\"\n\nlocal Expr = Twig:inherit()\n\n\n\n\nfunction Expr.toLua(expr, st)\n   local phrase = st.phrase.idEst()\n   if not expr[1] then return phrase end\n\n   if expr[1].isTemplate\n      or expr[1].id == \"operator\"\n      or expr[1].id == \"comparison\" then\n      return phrase .. expr[1]:toLua(st(), expr)\n   else\n      if expr[1].id == \"expr\" then\n         phrase = st:indent() .. \"(\" .. expr[1]:toLua(st()) .. \")(\"\n      else\n         phrase =  expr[1]:toLua(st()) .. \" (\"\n      end\n      local len = #expr\n      for i = 2, len do\n         phrase = phrase .. expr[i]:toLua(st())\n         if i < len then\n            phrase = phrase .. \", \"\n         end\n      end\n      return phrase .. \")\", st\n   end\nend\n\n\n\nreturn Expr\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/string",
hash = "42d2d7a718fd56e4e3c66a66b1b01ca9ec9b1117059df71fd7852c3f73f02deb",
branch = "master",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Str = Twig:inherit()\n\nfunction Str.toLua(str)\n   return str:span()\nend\n\nreturn Str\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/quote",
hash = "38eb88ff881ba899e0a61e152f49f5f4a43de9930e390e3fe46fd78e5dd51e6b",
branch = "master",
binary = "\n\n\nlocal Quote = require \"clu/twig\" : inherit ()\n\nfunction Quote.toLua(quote, st, par_expr)\n   local phrase = st.phrase.idEst()\n   phrase = phrase .. st:indent() .. \"read([==[\\n\"\n   for i = 2, #par_expr do\n        phrase = phrase .. st:indent() .. par_expr[i]:span()\n   end\n   return phrase .. st:indent() ..  \"]==])\\n\"\nend\n\nreturn Quote\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/operator",
hash = "fc987ff439178f0c344eaa73d02b98a6b8256184f3d1848c61d01a104e3819c9",
branch = "master",
binary = "\n\n\nlocal Operator = require \"clu/twig\" : inherit ()\nlocal Phrase = require \"singletons/phrase\"\n\n\nfunction Operator.toLua(operator, st, par_expr)\n   local op = par_expr[1]:span()\n   local phrase = Phrase \"(\"\n   phrase = phrase .. par_expr[2]:toLua(st()) .. \" \" .. op\n                  .. \" \" ..  par_expr[3]:toLua(st())\n   if par_expr[4] then\n      for i = 4, #par_expr do\n         phrase = phrase .. \" \" .. op .. \" \" .. par_expr[i]:toLua(st())\n      end\n   end\n   return phrase .. \")\", st\nend\n\nreturn Operator\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/multiple",
hash = "b38e4f52a43ffb38653a82aa4961c81d58a3c9b9c83d9224956c0e69db8f16a4",
branch = "master",
binary = "\n\n\nlocal Multi = require \"clu/twig\" : inherit ()\n\n\nfunction Multi.toLua(multi, st)\n   local phrase = st.phrase\n      for i = 1, #multi do\n      phrase = phrase .. multi[i]:toLua(st())\n      if i < #multi then\n         phrase = phrase .. \", \"\n      end\n   end\n\n   return phrase, st\nend\n\n\n\nreturn Multi\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/twig",
hash = "e5908f22c95a85c70de4986f382952cefbe93972efeba3bc5b36a7c22dc2afac",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"espalier/node\" : inherit ()\n\n\n\nfunction Twig.toLua(twig, st)\n   error(\"no toLua method for \" .. twig.id)\nend\n\nreturn Twig\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "clu/C",
hash = "8b2dd9c75c05df13d8b9ed6641ef2f51d184e0d8782a8c5b5e6e08f3e7845109",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = { _VERSION =  \'Clu 0.0.18 SNAPSHOT\',\n               read     =  require \"clu/reader\",\n               assert   =  assert,\n               require  =  require,\n               print    =  print,\n               getfenv  =  getfenv,\n               getmeta  =  getmetatable,\n               ipairs   =  ipairs,\n               pairs    =  pairs,\n               next     =  next,\n               pcall    =  pcall,\n               eq       =  rawequal,\n               get      =  rawget,\n               rawget   =  rawget,\n               rawset   =  rawset,\n               select   =  select,\n               tonum    =  tonumber,\n               repr     =  tostring,\n               type     =  type,\n               unpack   =  unpack,\n               xpcall   =  xpcall,\n               coro     =  coroutine.create,\n               resume   =  coroutine.resume,\n               running  =  coroutine.running,\n               status   =  coroutine.status,\n               wrap     =  coroutine.wrap,\n               yield    =  coroutine.yield,  }\n\n\n\n\n\n\n\n\n\n\nlocal libs  = { string   =  string,\n                debug    =  debug,\n                io       =  io,\n                math     =  math,\n                os       =  os,\n                package  =  package,\n                table    =  table,\n                L        =  require \"lpeg\",\n                _S       =  require \"status\",\n                _B       =  require \"br/br\",\n                _A       =  require \"ansi\",      }\n\n\n\nlocal _C = {}\n\nfor k, v in pairs(core) do\n   _C[k] = v\nend\n\nfor k, v in pairs(libs) do\n   -- iterating a table to own the libs\n   _C[k] = v\nend\n\n\n\n\nreturn _C, core, libs\n",
},
  { 
vc_hash = "a00cec46eca70e88afb19aee7457d278d5735cd7",
name = "cluster/cluster",
hash = "840cd679c13a54a334e0c8aba89f2915bafe7ed0618c69777e891d7ce606472d",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n-- Function to export modules\n-- \n-- The first argument of util.inherit being filled with methods,\n-- the second argument is passed to util.export as =mod=, along\n-- with a function =constructor= which will serve to create a\n-- new instance.\n-- \nfunction cluster.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n-- A synonym is \"build\" because we don\'t always use it as a return\n-- value\ncluster.build = cluster.export\nreturn cluster\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/core.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/core.git",
    home = "",
    website = "",
    name = "core",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/_base",
hash = "3beae5f45f998b349d4ea10b3b42e9d905ffa65aae3ab215505627560e37edaa",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\nlocal _base = {}\n\n\n\n\n\n\n\n\nfunction _base.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction _base.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...), 2)\n   end\nend\n\n\n\nreturn _base\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/string",
hash = "ac0080622bc478da8d473d58a488f7d97cad37d0590487533dd63d8ee882c2a5",
branch = "trunk",
binary = "\n\n\n\nlocal String = {}\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/_base\".assertfmt\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\n\nString.assertfmt = assertfmt\n\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction String.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.findall(str, patt)\n   local matches = {}\n   local index = 1\n   local left, right\n   repeat\n     left, right = find(str, patt, index)\n     if left then\n        matches[#matches + 1] = {left, right}\n        index = right + 1\n     end\n   until left == nil\n   if #matches > 0 then\n      return matches\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction String.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction String.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\nString.cleave = cleave\n\n\n\n\n\n\n\n\n\n\nlocal find = assert(string.find)\nfunction String.isidentifier(str)\n   return find(str, \"^[a-zA-Z_][a-zA-Z0-9_]+$\") == 1\nend\n\n\n\n\n\n\n\nfunction String.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction String.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, {__index = _str_M})\nend\n\n\n\n\n\n\n\n\nfunction String.slurp(filename)\n  local f = io.open(filename, \"rb\")\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction String.splice(to_split, to_splice, index)\n   assert(type(to_split) == \"string\", \"bad argument #1 to splice: \"\n           .. \"string expected, got %s\", type(to_split))\n   assert(type(to_splice) == \"string\", \"bad argument #2 to splice: \"\n           .. \"string expected, got %s\", type(to_splice))\n   assert(type(index) == \"number\", \"bad argument #2 to splice: \"\n          .. \" number expected, got %s\", type(index))\n   assert(index >= 0 and index <= #to_split, \"splice index out of bounds\")\n   local head, tail = sub(to_split, 1, index), sub(to_split, index + 1)\n   return head .. to_splice .. tail\nend\n\n\n\nreturn String\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core",
hash = "c4f2749893cddefd93905f4410bd33ef665b239c36a7c2de549afa288504265f",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mods = {}\nlocal core = {}\nlocal insert = assert(table.insert)\ninsert(mods, require \"core:core/meta\")\ninsert(mods, require \"core:core/fn\")\ninsert(mods, require \"core:core/string\")\ninsert(mods, require \"core:core/table\")\ninsert(mods, require \"core:core/coro\")\ninsert(mods, require \"core:core/math\")\nfor _, mod in ipairs(mods) do\n   for k,v in pairs(mod) do\n      core[k] = v\n   end\nend\nreturn core\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/thread",
hash = "2583f7df742bd6748afa223383ea11108fc93ef02628e9c39af3713cba7c8e2b",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal thread = {}\n\n\n\nlocal running, yield = assert(coroutine.running),\n                       assert(coroutine.yield)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.onloop()\n   local _, main = running()\n   return main and uv.loop_alive()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\nreturn thread\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/module",
hash = "629173e0f911fd125fadf5f2ba2860dbc0384c9f83d8cace0a13df2f4421362b",
branch = "trunk",
binary = "\n\n\n\n\n\nlocal Mod = {}\nlocal assert = assert(require \"core:core/_base\" . assertfmt)\n\n\n\nlocal require, pack, unpack = assert(require), assert(pack), assert(unpack)\n\nfunction Mod.import(req_str, ...)\n   local mod = require(req_str)\n   local fields, exports = pack(...), {}\n   for i = 1, fields.n do\n       exports[i] = assert(mod[fields[i]], \"can\'t require %s\", fields[i])\n   end\n   exports.n = fields.n\n   return unpack(exports)\nend\n\n\n\nreturn Mod\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/meta",
hash = "c410e803cdca2efad02c39bcc61ab30610c1cf5693d02fdd414782963b41bd55",
branch = "trunk",
binary = "\n\n\n\nlocal meta = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   if sub(mmethod,1,2) == \"__\" then\n      return rawget(M, mmethod)\n   else\n      return rawget(M, \"__\" .. mmethod)\n   end\nend\n\nmeta.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert(pairs)\n\nfunction meta.endow(Meta)\n   local MC = {}\n   for k, v in pairs(Meta) do\n      MC[k] = v\n   end\n   return MC\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.instanceof(obj, Class)\n   if type(Class) == \"string\" then\n      return type(obj) == Class\n   else\n      return type(obj) == \"table\" and obj.idEst == Class\n   end\nend\n\n\n\nreturn meta\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/cluster",
hash = "a6ba452af4069c2d75ed699d9fad709603e8008b989f6588f1afba1e0bb52d10",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\nlocal cluster = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal isempty = table.isempty\n                or\n                function(tab)\n                   local count = 0\n                   for _,__ in pairs(tab) do\n                      count = count + 1\n                   end\n                   return count == 0\n                end\n\nfunction cluster.meta(Meta)\n   if Meta and Meta.__index then\n      -- inherit\n      local tab = {}\n      for field, value in next, Meta, nil do\n         if sub(field, 1, 2) == \"__\" then\n            tab[field] = value\n         end\n      end\n      setmetatable(tab, Meta)\n      return tab\n   elseif Meta\n      and type(Meta) == \"table\"\n      and isempty(Meta) then\n      -- decorate\n      Meta.__index = Meta\n      return Meta\n   elseif not Meta then\n      local _M = {}\n      _M.__index = _M\n      return _M\n   end\n   -- callable tables and constructors here\n   error \"cannot make metatable\"\nend\n\n\n\nreturn cluster\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/fn",
hash = "78466c1963e8c425dc748f845794ff810e91a61592295e28baaa0c06e8c20837",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal fn = {}\n\n\n\n\n\n\n\n\n\nfn.thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.partial(fn, ...)\n   local args = pack(...)\n   return function(...)\n      return fn(unpack(args, 1, args.n), ...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.itermap(fn, iter)\n   local ret, res = {}\n   while true do\n      res = pack(fn(iter()))\n      if #res == 0 then\n         return ret\n      else\n         ret[#ret + 1] = res\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _dynamics_call = setmetatable({}, {__mode = \'k\'})\nlocal _dynamics_registry  = setmetatable({}, {__mode = \'kv\'})\n\nfunction fn.dynamic(fn)\n   -- make a unique table as key\n   local uid = {}\n   local function dyn_fn(...)\n      return _dynamics_call[uid](...)\n   end\n   _dynamics_call[uid] = fn\n   _dynamics_registry[dyn_fn] = uid\n   return dyn_fn\nend\n\n\n\n\n\n\n\n\n\nfunction fn.patch_dynamic(dyn_fn, fn)\n   assert(_dynamics_registry[dyn_fn], \"cannot patch a non-dynamic function\")\n   local uid = _dynamics_registry[dyn_fn]\n   _dynamics_call[uid] = fn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _hooks = setmetatable({}, {__mode = \"k\"})\n\nlocal function hookable_newindex()\n   error \"Attempt to assign value to a hookable function\"\nend\n\nlocal function call_with_hooks(hooked, fn, ...)\n   local pre, post = _hooks[hooked].pre, _hooks[hooked].post\n\n   if pre and post then\n      local new_arg = pack(pre(...))\n      return post(fn(unpack(new_arg)), unpack(new_arg))\n   elseif pre then\n      return fn(pre(...))\n   elseif post then\n      return post(fn(...), ...)\n   else\n      return fn(...)\n   end\nend\n\nlocal function hookPre(hooked, pre_hook)\n   _hooks[hooked].pre = pre_hook\nend\n\nlocal function hookPost(hooked, post_hook)\n   _hooks[hooked].post = post_hook\nend\n\nlocal function unhookPre(hooked)\n   _hooks[hooked].pre = nil\nend\n\nlocal function unhookPost(hooked)\n   _hooks[hooked].post = nil\nend\n\nlocal hook_index = { hookPre    =  hookPre,\n                     hookPost   =  hookPost,\n                     unhookPre  =  unhookPre,\n                     unhookPost =  unhookPost }\n\nfunction fn.hookable(fn, pre, post)\n   local hook_m = { __newindex = hookable_newindex,\n                    __index    = hook_index,\n                    __call = function(hooked, ...)\n                                return call_with_hooks(hooked, fn, ...)\n                             end }\n   local hooked = setmetatable({}, hook_m)\n   local hook_attr = { pre = pre, post = post }\n   _hooks[hooked] = hook_attr\n   return hooked\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfn.assertfmt = _base.assertfmt\n\n\n\nreturn fn\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/coro",
hash = "a00fba264178563c95c094a4cf5b3b12d8fbaaa433f079dd809dbcdd2c7b3d2b",
branch = "trunk",
binary = "\n\n\nlocal coro = {}\n\n\n\n\nlocal _base = require \"core:core/_base\"\nlocal thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\nlocal coro = {}\nfor k,v in next, coroutine do\n   coro[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction coro.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction coro.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction coro.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coro.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\nreturn coro\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/table",
hash = "a5146448a8c65070412a560df517e6ec6c3b4ee0c656d0b8e45a22710c890a42",
branch = "trunk",
binary = "\n\n\n\nlocal meta = require \"core/meta\"\nlocal Tab = {}\nfor k, v in pairs(table) do\n   Tab[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal N_M = {}\nN_M.__index = N_M\n\nfunction N_M.__len(tab)\n   return tab.n\nend\n\nfunction N_M.__ipairs(tab)\n   local i = 1\n   return function()\n      if i >= tab.n then return nil end\n      i = i + 1\n      return i - 1, tab[i - 1]\n   end\nend\n\nfunction Tab.n_table(tab, djikstra)\n   tab = tab or {}\n   tab.n = 0\n   return setmetatable(tab, N_M)\nend\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction Tab.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(tab, field)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(maybeIndex, field)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if success and result ~= nil then\n            return result\n         end\n      end\n   end\n   return nil\nend\n\nlocal function _hf__index(_, field)\n   return function(tab)\n      return _hasfield(tab, field)\n   end\nend\n\nlocal function _hf__call(_, tab, field)\n   return _hasfield(tab, field)\nend\n\nTab.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive \" .. tostring(depth))\n   local _M = getmetatable(tab)\n   local clone = _M and setmetatable({}, _M) or {}\n   for k,v in pairs(tab) do\n      if depth > 1 and type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return clone\nend\nTab.clone = _clone\n\n\n\n\n\n\n\n\nfunction Tab.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            -- copy the metatable after, in case it contains\n            -- __index or __newindex behaviors\n            copy = setmetatable(copy, _deep(getmetatable(val)))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.cloneinstance(tab)\n   assert(type(tab) == \"table\",\n          \"cannot cloneinstance of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            copy = setmetatable(copy, getmetatable(val))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.isarray(tab)\n   local i = 1\n   for k,_ in pairs(tab) do\n      if k ~= i then return false end\n      i = i + 1\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Tab.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.compact(tab, n)\n   n = assert(n or tab.n, \"a numeric value must be provided for non-ntables\")\n   local cursor, slot, empty = 1, nil, nil\n   while cursor <= n do\n      slot = tab[cursor]\n      if slot == nil and empty == nil then\n         -- mark the empty position\n         empty = cursor\n      end\n      if slot ~= nil and empty ~= nil then\n         tab[empty] = slot\n         tab[cursor] = nil\n         cursor = empty\n         empty = nil\n      end\n      cursor = cursor + 1\n   end\n   if tab.n then\n      tab.n = #tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.inverse(tab)\n   local bat = {}\n   for k,v in pairs(tab) do\n      if bat[v] then\n         error(\"duplicate value on key \" .. k)\n      end\n      bat[v] = k\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.flatten(tab, level)\n   local ret, copies = {}, {}\n   local function _flat(t, depth)\n      if level and depth > level then\n         ret[#ret + 1] = t\n         return nil\n      end\n      for _,v in ipairs(t) do\n         if type(v) ~= \"table\" then\n            ret[#ret + 1] = v\n         else\n            if not copies[v] then\n               copies[v] = true\n               _flat(v, depth + 1)\n            end\n         end\n      end\n   end\n   _flat(tab, 0)\n   return ret\nend\n\n\n\n\n\n\n\n\nlocal hasmetamethod = assert(meta.hasmetamethod)\n\nfunction Tab.iscallable(val)\n   return type(val) == \"function\"\n      or hasmetamethod(\"__call\", val)\nend\n\n\n\n\n\n\n\nfunction Tab.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _select(collection, tab, key, cycle)\n   cycle = cycle or {}\n   for k,v in pairs(tab) do\n      if key == k then\n         collection[#collection + 1] = v\n      end\n      if type(v) == \"table\" and not cycle[v] then\n         cycle[v] = true\n         collection = _select(collection, v, key, cycle)\n      end\n   end\n   return collection\nend\n\nfunction Tab.select(tab, key)\n   return _select({}, tab, key)\nend\n\n\n\n\n\n\n\n\nfunction Tab.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.deleterange(tab, start, stop)\n   if start > stop then return end\n   local offset = stop - start + 1\n   for i = start, #tab do\n      tab[i] = tab[i + offset]\n   end\nend\n\n\n\n\n\n\n\nfunction Tab.keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local keys = {}\n   for k, _ in pairs(tab) do\n      keys[#keys + 1] = k\n   end\n\n   return keys, #keys\nend\n\n\n\n\n\n\nfunction Tab.values(tab)\n   assert(type(tab) == \"table\", \"vals must receive a table\")\n   local vals = {}\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nfunction Tab.splice(tab, idx, into)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(idx) == \"number\" or idx == nil, _e_2)\n   if idx == nil then\n      idx = #tab + 1\n   end\n   assert(type(into) == \"table\", _e_3)\n    idx = idx - 1\n    local i = 1\n    for j = 1, #into do\n        insert(tab,i+idx,into[j])\n        i = i + 1\n    end\n    return tab\nend\n\n\n\n\n\n\n\n\nfunction Tab.addall(tab, to_add)\n   for k, v in pairs (to_add) do\n      tab[k] = v\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.safeget(tab, key)\n   local val = rawget(tab, key)\n   if val ~= nil then\n      return val\n   end\n   local _M = getmetatable(tab)\n   while _M ~= nil and rawget(_M, \"__index\") ~= nil do\n      local index_t = type(_M.__index)\n      if index_t == \"table\" then\n         val = rawget(_M.__index, key)\n      elseif index_t == \"function\" then\n         local success\n         success, val = pcall(_M.__index, table, key)\n         if success then\n            return val\n         else\n            val = nil\n         end\n      else\n         error(\"somehow, __index is of type \" .. index_t)\n      end\n      if val ~= nil then\n         return val\n      end\n      _M = index_t == \"table\" and getmetatable(_M.__index) or nil\n   end\n   return nil\nend\n\n\n\n\nreturn Tab\n",
},
  { 
vc_hash = "f7b9ef1168b494cd7bd782f96633ae1afc4325fc",
name = "core/math",
hash = "4c77b1acb418ca7dd78058879ccc945abdbc7835a8878bd548470d64ce3a5cb5",
branch = "trunk",
binary = "\n\n\nlocal Math = {}\n\n\n\n\n\n\n\n\nfunction Math.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\nfunction Math.bound(value, lower, upper)\n  if lower and value < lower then\n    value = lower\n  end\n  if upper and value > upper then\n    value = upper\n  end\n  return value\nend\n\n\n\n\nreturn Math\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/deque.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/deque.git",
    home = "",
    website = "",
    name = "deque",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "9c4762fb3c74af1f2d8a81806f99998fc992222a",
name = "deque",
hash = "c2b219dc5b9b7f5c7d4854ef8116573bf385dc40b557f8ea2fb4a04225e59d3f",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\nlocal Deque;\n\n\n\n\n\n\nlocal function flipped_contents(deque)\n   local r = {}\n   for i = deque.tail, deque.head + 1, -1 do\n      r[#r + 1] = deque[i]\n   end\n   return r\nend\n\nlocal directions = { push = \"push_left\",\n                     pop  = \"pop_right\",\n                     peek = \"peek_right\",\n                     iter = \"iter_right\",\n                     push_right = \"push_left\",\n                     push_left  = \"push_right\",\n                     peek_right = \"peek_left\",\n                     peek_left  = \"peek_right\",\n                     pop_right  = \"pop_left\",\n                     pop_left   = \"pop_right\",\n                     rotate_right = \"rotate_left\",\n                     rotate_left  = \"rotate_right\",\n                     remove_right = \"remove_left\",\n                     remove_left  = \"remove_right\",\n                     iter_right   = \"iter_left\",\n                     iter_left    = \"iter_right\",\n                     contents     = true, }\n\nlocal function _flip(deque)\n   if deque.flipped then return end\n   for method, reversal in pairs(directions) do\n      deque[method] = Deque[reversal]\n   end\n   -- add backward contents\n   deque.contents = flipped_contents\n   deque.flipped = true\nend\n\nlocal function _unflip(deque)\n   if not deque.flipped then return end\n   for method in pairs(directions) do\n      deque[method] = nil\n   end\n   deque.flipped = nil\nend\n\nlocal function reverse_queue(deque)\n   if deque.flipped then\n      _unflip(deque)\n   else\n      _flip(deque)\n   end\nend\n\nlocal function _reset_on_empty(deque)\n   if deque.head == deque.tail then\n      deque.head, deque.tail = 0,0\n      _unflip(deque)\n   end\nend\n\nlocal function push_right(deque, x)\n   assert(x ~= nil)\n   deque.tail = deque.tail + 1\n   deque[deque.tail] = x\nend\n\nlocal function push_left(deque, x)\n   assert(x ~= nil)\n   deque[deque.head] = x\n   deque.head = deque.head - 1\nend\n\nlocal function peek_right(deque)\n   return deque[deque.tail]\nend\n\nlocal function peek_left(deque)\n   return deque[deque.head+1]\nend\n\nlocal function pop_right(deque)\n   if deque:is_empty() then return nil end\n   local r = deque[deque.tail]\n   deque[deque.tail] = nil\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\n   return r\nend\n\nlocal function pop_left(deque)\n   if deque:is_empty() then return nil end\n   local r = deque[deque.head+1]\n   deque.head = deque.head + 1\n   local r = deque[deque.head]\n   deque[deque.head] = nil\n   _reset_on_empty(deque)\n   return r\nend\n\nlocal function rotate_right(deque, n)\n   n = n or 1\n   if deque:is_empty() then return nil end\n   for i = 1, n do deque:push_left(deque:pop_right()) end\nend\n\nlocal function rotate_left(deque, n)\n   n = n or 1\n   if deque:is_empty() then return nil end\n   for i = 1, n do deque:push_right(deque:pop_left()) end\nend\n\nlocal function _remove_at_internal(deque, idx)\n   for i = idx, deque.tail do deque[i] = deque[i+1] end\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\nend\n\nlocal function remove_right(deque, x)\n   for i = deque.tail, deque.head + 1, -1 do\n     if deque[i] == x then\n        _remove_at_internal(deque, i)\n        return true\n      end\n   end\n   return false\nend\n\nlocal function remove_left(deque, x)\n   for i = deque.head + 1, deque.tail do\n      if deque[i] == x then\n         _remove_at_internal(deque, i)\n         return true\n      end\n   end\n   return false\nend\n\nlocal function length(deque)\n   return deque.tail - deque.head\nend\n\nlocal function is_empty(deque)\n   return deque.tail == deque.head\nend\n\nlocal function contents(deque)\n   local r = {}\n   for i = deque.head + 1, deque.tail do\n      r[i-deque.head] = deque[i]\n   end\n   return r\nend\n\nlocal function iter_right(deque)\n   local i = deque.tail + 1\n   return function()\n      if i > deque.head + 1 then\n         i = i - 1\n         return deque[i]\n      end\n   end\nend\n\nlocal function iter_left(deque)\n   local i = deque.head\n   return function()\n      if i < deque.tail then\n         i = i + 1\n         return deque[i]\n      end\n   end\nend\n\nDeque = {\n          push = push_right,\n          pop = pop_left,\n          peek = peek_left,\n          iter = iter_left,\n          push_right = push_right,\n          push_left = push_left,\n          peek_right = peek_right,\n          peek_left = peek_left,\n          pop_right = pop_right,\n          pop_left = pop_left,\n          rotate_right = rotate_right,\n          rotate_left = rotate_left,\n          remove_right = remove_right,\n          remove_left = remove_left,\n          iter_right = iter_right,\n          iter_left = iter_left,\n          length = length,\n          is_empty = is_empty,\n          contents = contents,\n          reverse = reverse_queue }\n\nDeque.__index = Deque\n\nlocal function new(size)\n   local deque;\n   if size then\n       deque = table.new(size, 8)\n   else\n      deque = {}\n   end\n   deque.head, deque.tail = 0, 0\n   return setmetatable(deque, Deque)\nend\n\nDeque.idEst = new\n\nreturn new\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/espalier",
    repo_alternates = "https://gitlab.com/special-circumstance/espalier.git/\nhttps://gitlab.special-circumstanc.es/bridge-tools/espalier.git",
    home = "",
    website = "",
    name = "espalier",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/dot",
hash = "0b0dd91bcea6e6fe4e22fa819874ff165dcdcf0adbdd2b69817c29ff5558a986",
branch = "select-from",
binary = "\n\n\n\n\n\n\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\nlocal L       =  require \"espalier/elpatt\"\n\nlocal P, R, E, V, S    =  L.P, L.R, L.E, L.V, L.S\n\nlocal _ = (P\" \" + P\"\\n\" + P\"\\t\" + P\"\\r\")^0\n\nlocal IDstart =  R(\"az\", \"AZ\") + \"_\" -- dot is actually latin-1 but\nlocal IDrest  =  IDstart + R\"09\"\n\nlocal num     =  P\"-\"^0 * (P\".\" + R\"09\"^1)\n              +  R\"09\"^1 * P\".\"^0 * R\"09\"^0\n\nlocal string_patt = P\"\\\"\" * (P(1) - (P\"\\\"\" * - P\"\\\\\\\"\"))^0 * P\"\\\"\"\n\nlocal function dot_fn(_ENV)\n   START \"dot\"\n\n   dot =  _ * P\"strict\"^0 * _ * (P\"graph\" + P\"digraph\")\n       *  _ * V\"ID\"^0 * _ * \"{\" * _ * V\"statment_list\" * _ * \"}\" * _\n\n   statement_list =  V\"statement\"^0 * _ * P\";\"^0 * _ * V\"statement\"^0\n\n   statement  =  V\"node_statement\"\n              +  V\"edge_statement\"\n              +  V\"attr_statement\"\n              +  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n              +  V\"subgraph\"\n\n   attr_statement =  (P\"graph\" + \"node\" + \"edge\") * V\"attr_list\"\n   attr_list      =  P\"[\" * _ * V\"a_list\"^0 * _ * P\"]\" * _ * V\"attr_list\"^0\n   a_list         =  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n                  * (P\";\" + P\",\")^0 * _ * V\"a_list\"^0\n\n   edge_statement =  (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\" * V\"attr_list\"^0\n   edgeRHS        =  V\"edgeop\" * _ * (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\"^0\n\n   node_statement =  V\"node_id\" * _ * V\"attr_list\"^0\n   node_id        =  V\"ID\" * _ * V\"port\"^0\n   port           =  P\":\" * _ * V\"ID\" * _ * (P\":\" * _ * V\"compass_point\")^0\n\n   subgraph       =  (V\"subgraph\" * _ * V\"ID\"^0)^0 * _\n                  *  \"{\" * _ * V\"statement_list\" * _ * \"}\"\n\n   compass_point  =  S(\"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\",\"_\")\n\n   ID    =  (V\"IDstart\"^1 * V\"IDrest\"^0) + V\"num\" + V\"string_patt\"\n\n   -- Add C-style comments\n\nend\n\nreturn Grammar(dot_fn)\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/node",
hash = "586fd39f2a7ec6efaa4ca7f3e1c51f5c22b18c49096698224c56020a596af6f7",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\nlocal yield = assert(coroutine.yield, \"uses coroutines\")\nlocal wrap = assert(coroutine.wrap)\nlocal sub, find = assert(string.sub, \"uses string\"), assert(string.find)\nlocal setmeta, getmeta = assert(setmetatable), assert(getmetatable)\n\n\n\n\n\n\nlocal s = require \"singletons\" . status ()\nlocal a = require \"singletons/anterm\"\nlocal c_bw = require \"singletons/color\" . no_color\nlocal core = require \"core:core\"\nlocal Phrase = require \"singletons/phrase\"\nlocal dot = require \"espalier/dot\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = {}\nNode.__index = Node\nNode.isNode = Node\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toLua(node)\n  s:halt(\"No toLua method for \" .. node.id)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction  Node.strTag(node, c)\n   c = c or c_bw\n   local phrase = Phrase \"\"\n   phrase = phrase .. c.bold(node.id) .. \"    \"\n      .. c.number(node.first) .. \"-\" .. c.number(node.last)\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.strExtra(node, c)\n   return \"\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _truncate(str, base_color, c)\n   local phrase\n   if #str > 56 then\n       --  Truncate in the middle\n       local pre, post = sub(str, 1, 26), sub(str, -26, -1)\n       phrase = base_color(pre)\n                     .. c.bold(\"â€¦â€¦â€¦\") .. base_color(post)\n   else\n       phrase = base_color(str)\n   end\n   return phrase\n           : gsub(\"\\n\", \"â—¼ï¸Ž\")\n           : gsub(\"[ ]+\", c.greyscale(\"_\")\n           .. base_color())\nend\n\nfunction Node.strLine(node, c)\n   c = c or c_bw\n   local phrase = Phrase \"\"\n   phrase = phrase .. node:strTag(c)\n   if node[1] then\n      phrase = phrase .. \" \" .. node:strExtra(c) .. \"   \"\n               .. _truncate(node:span(), c.greyscale, c) .. \"\\n\"\n   else\n      local val = node.str:sub(node.first, node.last)\n      phrase = phrase .. \"    \" .. _truncate(val, c.string,c)  .. \"\\n\"\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toString(node, depth, c)\n   depth = depth or 0\n   local line =  node:strLine(c)\n   local phrase = Phrase \"\"\n   if tostring(line) ~= \"\" then\n      phrase = phrase .. (\"  \"):rep(depth)\n      phrase = phrase .. line\n   end\n   ---[[\n   if node[1] then\n      for _,v in ipairs(node) do\n         if (v.isNode) then\n            phrase = phrase .. v:toString(depth + 1, c)\n         end\n      end\n   end\n   --]]\n   return phrase\nend\n\n\n\nlocal function __tostring(node)\n   if not node.str then\n      return \"Node\"\n   end\n   return tostring(node:toString())\nend\n\nNode.__tostring = __tostring\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nlocal function __repr(node, phrase, c)\n   local node__repr = tostring(node:toString(0, c))\n   return lines(node__repr)\nend\n\nNode.__repr = __repr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.span(node)\n   return sub(node.str, node.first, node.last)\nend\n\n\n\n\n\n\n\n\n\nfunction Node.bounds(node)\n   return node.first, node.last\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.len(node)\n    return 1 + node.last - node.first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gap(left, right)\n  assert(left.last, \"no left.last\")\n  assert(right.first, \"no right.first\")\n  assert(right.last, \"no right.last\")\n  assert(left.first, \"no left.first\")\n  if left.first >= right.last then\n    local left, right = right, left\n  elseif left.last > right.first then\n    s:halt(\"overlapping regions or str issue\")\n  end\n  local gap = left - right - 1\n  if gap >= 0 then\n    return gap\n  else\n    s:halt(\"some kind of situation where gap is \" .. tostring(gap))\n  end\n\n  return nil\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.dotLabel(node)\n  return node.id\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.label(node)\n   return node.id\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toMarkdown(node)\n  if not node[1] then\n    return sub(node.str, node.first, node.last)\n  else\n    s:halt(\"no toMarkdown for \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\nfunction Node.dot(node)\n  return dot.dot(node)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.toValue(node)\n  if node.__VALUE then\n    return node.__VALUE\n  end\n  if node.str then\n    return node.str:sub(node.first,node.last)\n  else\n    s:halt(\"no str on node \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _root(node)\n   if node.parent == node then\n      return node\n   end\n   return _root(node.parent)\nend\n\nNode.root = _root\n\n\n\n\n\n\n\n\nfunction Node.walkPost(node)\n    local function traverse(ast)\n        if not type(ast) == \'table\' and ast.isNode then return nil end\n\n        for _, v in ipairs(ast) do\n            if type(v) == \'table\' and v.isNode then\n              traverse(v)\n            end\n        end\n        yield(ast)\n    end\n\n    return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\nfunction Node.walk(node)\n  local function traverse(ast)\n    if not type(ast) == \'table\' and ast.isNode then return nil end\n    yield(ast)\n    for _, v in ipairs(ast) do\n      if type(v) == \'table\' and v.isNode then\n        traverse(v)\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.coro_select(node, pred)\n   local function qualifies(ast, pred)\n      if type(pred) == \'string\' then\n         if type(ast) == \'table\'\n          and ast.id and ast.id == pred then\n            return true\n         else\n            return false\n         end\n      elseif type(pred) == \'function\' then\n         return pred(ast)\n      else\n         s:halt(\"cannot select on predicate of type \" .. type(pred))\n      end\n   end\n\n   local function traverse(ast)\n      -- breadth first\n      if qualifies(ast, pred) then\n         yield(ast)\n      end\n      if type(ast) == \'table\' and ast.isNode then\n         for _, v in ipairs(ast) do\n            traverse(v)\n         end\n      end\n   end\n\n   return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\nlocal function qualifies(ast, pred)\n    if type(pred) == \'string\' then\n       if type(ast) == \'table\'\n        and ast.id and ast.id == pred then\n          return true\n       else\n          return false\n       end\n    elseif type(pred) == \'function\' then\n       return pred(ast)\n    else\n       s:halt(\"cannot select on predicate of type \" .. type(pred))\n    end\n end\n\nlocal remove = assert(table.remove)\n\nfunction Node.select(node, pred)\n   -- build up all the nodes that match\n   local matches = {}\n   local function traverse(ast)\n      -- depth-first, right to left\n      if type(ast) == \'table\' and ast.isNode then\n         for i = #ast, 1, -1 do\n            traverse(ast[i])\n         end\n      end\n      if qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n   traverse(node)\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.selectFrom(node, pred, index)\n   -- build up all the nodes that match\n   local matches = {}\n   local function traverse(ast)\n      -- depth-first, right to left\n      if type(ast) == \'table\' and ast.isNode then\n         for i = #ast, 1, -1 do\n            if ast[i].last >= index then\n               traverse(ast[i])\n            end\n         end\n      end\n      if ast.first > index and qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n   traverse(node)\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Node.tokens(node)\n  local function traverse(ast)\n    for node in Node.walk(ast) do\n      if not node[1] then\n        yield(node:toValue())\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nfunction Node.lines(node)\n  return lines(node:span())\nend\n\n\n\n\n\n\n\n\n\nlocal _nl_map = setmetatable({}, { __mode = \'kv\' })\nlocal findall = assert(require \"core:core/string\".findall)\n\nlocal function _findPos(nl_map, target, start)\n   local line = start or 1\n   local cursor = 0\n   local col\n   while true do\n      if line > #nl_map then\n         -- technically two possibilities: node.last is after the\n         -- end of node.str, or it\'s on a final line with no newline.\n         -- the former would be quite exceptional, so we assume the latter\n         -- here.\n         -- so we need the old cursor back:\n         cursor = nl_map[line - 1][1] + 1\n         return line, target - cursor + 1\n      end\n      local next_nl = nl_map[line][1]\n      if target > next_nl then\n         -- advance\n         cursor = next_nl + 1\n         line = line + 1\n      else\n         return line, target - cursor + 1\n      end\n   end\nend\n\nfunction Node.linePos(node)\n   local nl_map\n   if _nl_map[node.str] then\n      nl_map = _nl_map[node.str]\n   else\n      nl_map = findall(node.str, \"\\n\")\n      _nl_map[node.str] = nl_map\n   end\n   if not nl_map then\n      -- there are no newlines:\n      return 1, node.first, 1, node.last\n   end\n   -- otherwise find the offsets\n   local line_first, col_first = _findPos(nl_map, node.first)\n   local line_last, col_last = _findPos(nl_map, node.last, line_first)\n   return line_first, col_first, line_last, col_last\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _lastLeaf(node)\n  if #node == 0 then\n    return node\n  else\n    return _lastLeaf(node[#node])\n  end\nend\n\nNode.lastLeaf = _lastLeaf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gather(node, pred)\n  local gathered = {}\n  for ast in node:select(pred) do\n    gathered[#gathered + 1] = ast\n  end\n\n  return gathered\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction Node.clone(node)\n   return cloneinstance(node)\nend\n\n\n\n\n\n\n\n\n\nlocal function _pluck(node, str, offset, parent)\n   local clone = setmetatable({}, getmetatable(node))\n   parent = parent or clone\n   for k, v in pairs(node) do\n      if type(k) == \"number\" then\n        clone[k] = _pluck(v, str, offset, clone)\n      elseif k == \"first\" or k == \"last\" then\n        clone[k] = v + offset\n      elseif k == \"parent\" then\n        clone.parent = parent\n      else\n        clone[k] = v\n      end\n   end\n   clone.str = str\n   return clone\nend\n\nfunction Node.pluck(node)\n   local str = node:span()\n   local offset = - node.first + 1\n   local plucked = _pluck(node, str, offset)\n--   assert(plucked.first == 1)\n   return plucked\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.isValid(node)\n  assert(node.isNode == Node, \"isNode flag must be Node metatable, id: \"\n         .. node.id .. \" \" .. tostring(node))\n  assert(node.first, \"node must have first\")\n  assert(type(node.first) == \"number\", \"node.first must be of type number\")\n  assert(node.last, \"node must have last\")\n  assert(type(node.last) == \"number\", \"node.last must be of type number\")\n  assert(node.str, \"node must have str\")\n  assert(type(node.str) == \"string\"\n         or node.str.isPhrase, \"str must be string or phrase\")\n  assert(node.parent and node.parent.isNode == Node, \"node must have parent\")\n  assert(type(node:span()) == \"string\", \"span() must yield string\")\n  return true\nend\n\n\n\n\n\n\n\n\nfunction Node.validate(node)\n  for twig in node:walk() do\n    twig:isValid()\n  end\n  return true\nend\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function _isCompact(node, breaks)\n   local is_compact = true\n   local subCompact\n   if #node > 0 then\n      -- node.first must match first of subnode\n      local first_match = node.first == node[1].first\n      if not first_match then\n        -- register the \'break\'\n        local line, col = node:linePos()\n        insert(breaks.pre, {node.id, node[1].first - node.first,\n                            line, col,\n                            node.str:sub(node.first, node[1].first - 1)})\n      end\n      is_compact = is_compact and first_match\n      for i = 2, #node do\n        -- check gap between subNodes\n        local left, right = node[i-1].last, node[i].first\n        local inter_match = left == right - 1\n        if not inter_match then\n           local _, __, line, col =  node[i-1]:linePos()\n           insert(breaks.inter, {node[i-1].id, i, node[i].id,\n                                 right - left - 1, line, col + 1,\n                                 node.str:sub(left + 1, right - 1)})\n        end\n        is_compact = is_compact and inter_match\n        -- run isCompact recursively\n        subCompact = _isCompact(node[i-1], breaks)\n        is_compact = is_compact and subCompact\n      end\n      -- test last node\n      subCompact = _isCompact(node[#node], breaks)\n      is_compact = is_compact and subCompact\n      -- node.last must match last of subnode\n      local last_match = node.last == node[#node].last\n      if not last_match then\n        local _, __, line, col = node[#node]:linePos()\n        insert(breaks.post, {node.id, node.last - node[#node].last,\n                             line, col + 1,\n                             node.str:sub(node[#node].last + 1, node.last)})\n      end\n      is_compact = is_compact and last_match\n   end\n   return is_compact\nend\n\nfunction Node.isCompact(node)\n   local breaks = { pre = {}, inter = {}, post = {} }\n   local is_compact = _isCompact(node, breaks)\n   return is_compact, breaks\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.inherit(node, id)\n  local Meta = setmeta({}, node)\n  Meta.__index = Meta\n  local _repr, _tostring = __repr, __tostring\n  local node_M = getmetatable(node)\n  if node_M then\n    _repr = node_M.__repr\n    _tostring = node_M.__tostring\n  end\n  Meta.__repr = _repr\n  Meta.__tostring = _tostring\n  if id then\n    Meta.id = id\n  end\n  return Meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.export(_, mod, constructor)\n  mod.__call = constructor\n  return setmeta({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn Node\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/peg",
hash = "58c6ee10f2844b1d9fc3997ddc4bc5e7d55689c7efe4fa0c751ffa922586f7d6",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier/elpatt\"\nlocal D, E, P, R, S, V   =  L.D, L.E, L.P, L.R, L.S, L.V\nlocal Grammar = require \"espalier/grammar\"\nlocal pegMetas = require \"espalier/grammars/pegmeta\"\n\n\n\n\n\n\nlocal function pegylator(_ENV)\n   START \"rules\"\n   ---[[\n   SUPPRESS (\"enclosed\", \"form\",\n            \"element\" , \"WS\",\n            \"elements\", \"allowed_repeated\",\n            \"allowed_prefixed\", \"allowed_suffixed\", \"allowed_referred\",\n            \"simple\", \"compound\", \"prefixed\", \"suffixed\",\n            \"referred\", \"named_suffix\", \"back_referred\", \"equal_referred\",\n            \"greater_equal_referred\", \"greater_referred\",\n            \"lesser_equal_referred\", \"lesser_referred\",\n            \"pel\", \"per\" )\n   --]]\n   local comment_m  = -P\"\\n\" * P(1)\n   local comment_c =  comment_m^0\n   local letter = R\"AZ\" + R\"az\"\n   local valid_sym = letter + P\"-\" + P\"_\"\n   local digit = R\"09\"\n   local sym = valid_sym + digit\n   local symbol = letter * (sym)^0\n   local d_string = P \"\\\"\" * (P \"\\\\\" * P(1) + (1 - P \"\\\"\"))^0 * P \"\\\"\"\n   local h_string = P \"`\" * (P \"\\\\\" * P(1) + (1 - P \"`\"))^0 * P \"`\"\n   local s_string = P \"\'\" * (P \"\\\\\" * P(1) + (1 - P \"\'\"))^0 * P \"\'\"\n   local range_match =  -P\"-\" * -P\"\\\\\" * -P\"]\" * P(1)\n   local range_capture = (range_match + P\"\\\\-\" + P\"\\\\]\" + P\"\\\\\")^1\n   local range_c  = range_capture^1 * P\"-\" * range_capture^1\n   local set_match = -P\"}\" * -P\"\\\\\" * P(1)\n   local set_c    = (set_match + P\"\\\\}\" + P\"\\\\\")^1\n   local some_num_c =   digit^1 * P\"..\" * digit^1\n                +   (P\"+\" + P\"-\")^0 * digit^1\n\n\n   rules   =  V\"rule\"^1\n   rule    =  V\"lhs\" * V\"rhs\"\n\n\n   lhs     =  V\"WS\" * V\"pattern\" * V\"WS\" * (P\"=\" + \":=\" + P\"<-\" + P\"â†\")\n   rhs     =  V\"form\" * V\"WS\"\n\n   pattern =  symbol\n           +  V\"hidden_pattern\"\n           +  V\"ws\"\n\n   hidden_pattern =  P\"`\" * symbol * P\"`\"\n                  +  P\"`_`\"\n\n   -- SUPPRESSED\n   form    =  V\"element\" * V\"elements\"\n\n   element  =   -V\"lhs\" * V\"WS\"\n            *  ( V\"simple\"\n            +    V\"compound\")\n\n   elements  =  V\"choice\"\n             +  V\"cat\"\n             +  P\"\"\n   -- /SUPPRESSED\n\n   choice =  V\"WS\" * P\"/\" * V\"form\"\n   cat =  V\"WS\" * V\"form\"\n\n   -- SUPPRESSED\n   compound =  V\"group\"\n          +  V\"enclosed\"\n          +  V\"hidden_match\"\n   -- /SUPPRESSED\n\n   group   =  V\"WS\" * V\"pel\"\n           *  V\"WS\" * V\"form\" * V\"WS\"\n           *  V\"per\"\n\n   hidden_match =  V\"WS\" * P\"``\"\n                *  V\"WS\" * V\"form\" * V\"WS\"\n                *  P\"``\"\n   -- SUPPRESSED\n   pel     = P \"(\"\n   per     = P \")\"\n\n   simple   =  V\"prefixed\"\n            +  V\"repeated\"\n            +  V\"named\"\n            +  V\"suffixed\"\n            +  V\"atom\"\n            +  V\"number\"\n\n   enclosed =  V\"literal\"\n            +  V\"hidden_literal\"\n            +  V\"set\"\n            +  V\"range\"\n\n   prefixed =  V\"not_predicate\"\n            +  V\"and_predicate\"\n\n   suffixed =  V\"zero_or_more\"\n            +  V\"one_or_more\"\n            +  V\"optional\"\n\n   allowed_prefixed =  V\"suffixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n   allowed_suffixed =  V\"prefixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n\n   allowed_repeated =  V\"prefixed\"\n                    +  V\"suffixed\"\n                    +  V\"compound\"\n                    +  V\"atom\"\n                    +  V\"number\"\n\n   -- /SUPPRESSED\n\n   not_predicate = P\"!\" * V\"WS\" * V\"allowed_prefixed\"\n   and_predicate = P\"&\" * V\"WS\" * V\"allowed_prefixed\"\n\n   literal =  d_string\n           +  s_string\n\n   hidden_literal =  h_string\n\n           set =  P\"{\" * set_c^1 * P\"}\"\n\n       range   =  P\"[\" * V\"range_start\" * P\"-\" * V\"range_end\" * P\"]\"\n   range_start = range_capture\n   range_end   = range_capture\n\n    zero_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"*\"\n     one_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"+\"\n        optional =  V\"allowed_suffixed\" * V\"WS\" * P\"?\"\n        repeated =  V\"allowed_repeated\" * V\"WS\" * P\"%\" * V\"number_repeat\"\n           named =  V\"allowed_repeated\" * V\"WS\" * V\"named_suffix\"\n\n   named_suffix  =  P\"@\" * ( V\"named_match\"\n                           + V\"back_referred\"\n                           + V\"equal_referred\"\n                           + V\"greater_equal_referred\"\n                           + V\"greater_referred\"\n                           + V\"lesser_equal_referred\"\n                           + V\"lesser_referred\" )\n\n   back_referred   =  P\"(\" * V\"back_reference\" * P\")\"\n   equal_referred  =  P\"(#\" * V\"equal_reference\" * P\")\"\n   greater_equal_referred = P\"(>=\" * V\"gte_reference\" * P\")\"\n   greater_referred = P\"(>\" * V\"gt_reference\" * P\")\"\n   lesser_equal_referred = P\"(<=\" * V\"lte_reference\" * P\")\"\n   lesser_referred = P\"(>\" * V\"gt_reference\" * P\")\"\n\n   named_match     = symbol\n   back_reference  = symbol\n   equal_reference = symbol\n   gte_reference   = symbol\n   gt_reference    = symbol\n   lte_reference   = symbol\n   lt_reference    = symbol\n\n   referred    =  V\"reference\" * \"$\"\n   reference     =  symbol\n   number_repeat =  some_num_c\n   named_repeat  =  symbol\n\n   comment  =  P\";\" * comment_c\n\n   atom =  V\"ws\" + symbol\n\n   number = P\"-\"^-1 * digit^1\n\n   WS = (V\"comment\" + V\"dent\" + P\' \' + P\'\\t\' + P\'\\r\')^0\n\n   dent = P\"\\n\" * (P\"\\n\" + P\" \")^0\n\n   ws = P\"_\"\nend\n\n\n\nlocal PegGrammar = Grammar(pegylator, pegMetas)\n\n\n\nlocal function new(peg_str, metas, pre, post)\n   local peg_node = PegGrammar(peg_str)\n   if not peg_node then return nil end\n   local ok\n   ok, peg_node.parse, peg_node.grammar = pcall(Grammar,peg_node:toLpeg(),\n                                              metas, pre, post)\n   if not ok then\n      peg_node.parse, peg_node.grammar = nil, nil\n   end\n   return peg_node\nend\n\n\n\nreturn new\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/error",
hash = "f6d48b9965ccd8536f234795ec4755dfcf2123ed3788b0838ef872dfb482612f",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L   = require \"lpeg\"\nlocal s = require \"singletons\" . status ()\nlocal Carg, Cc, Cp, P = L.Carg, L.Cc, L.Cp, L.P\n\n\n\nlocal Err = require \"espalier/node\" : inherit()\nErr.id = \"ERROR\"\n\n\n\n\n\n\n\n\n\nfunction Err.toLua(err)\n  local line, col = err:linePos(err.first)\n  s:halt(\"ERROR at line: \" .. line .. \" col: \" .. col)\nend\n\n\n\n\n\n\n\n\nlocal function parse_error(pos, name, msg, patt, str)\n   local message = msg or name or \"Not Otherwise Specified\"\n   s:verb(\"Parse Error: \", message)\n   local errorNode =  setmetatable({}, Err)\n   errorNode.first =  pos\n   errorNode.last  =  #str -- See above\n   errorNode.msg   =  message\n   errorNode.name  =  name\n   errorNode.str   =  str\n   errorNode.rest  =  string.sub(str, pos)\n   errorNode.patt  =  patt\n\n   return errorNode\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Err.Err(name, msg, patt)\n  return Cp() * Cc(name) * Cc(msg) * Cc(patt) * Carg(1) / parse_error\nend\n\nErr.E = Err.Err\n\nfunction Err.EOF(name, msg)\n  return -P(1) + Err.Err(name, msg), Cp()\nend\n\nreturn Err\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "phrase",
hash = "7749dba7ffeea6ab6810a84f719796e0ef43f46b06b4a63e1b902f727cc32f5f",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal init, new\nlocal s = require \"core/status\" ()\ns.angry = false\nlocal Phrase = {}\nPhrase.it = require \"core/check\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function spill(phrase)\n   local new_phrase = init()\n   for k, v in pairs(phrase) do\n      new_phrase[k] = v\n   end\n   new_phrase.intern = nil\n\n   return new_phrase\nend\n\n\nlocal function __concat(head_phrase, tail_phrase)\n   if type(head_phrase) == \'string\' then\n      -- bump the tail phrase accordingly\n      if tail_phrase.intern then\n         tail_phrase = spill(tail_phrase)\n      end\n\n      table.insert(tail_phrase, 1, head_phrase)\n      tail_phrase.len = tail_phrase.len + #head_phrase\n      return tail_phrase\n   end\n   local typica = type(tail_phrase)\n   if typica == \"string\" then\n      if head_phrase.intern then\n         head_phrase = spill(head_phrase)\n      end\n      head_phrase[#head_phrase + 1] = tail_phrase\n      head_phrase.len = head_phrase.len + #tail_phrase\n      return head_phrase\n      elseif typica == \"table\" and tail_phrase.idEst == new then\n      local new_phrase = init()\n      head_phrase.intern = true -- head_phrase is now in the middle of a string\n      tail_phrase.intern = true -- tail_phrase shouldn\'t be bump-catted\n      new_phrase[1] = head_phrase\n      new_phrase[2] = tail_phrase\n      new_phrase.len = head_phrase.len + tail_phrase.len\n      return new_phrase\n   end\n\n   return nil, \"tail phrase was unsuitable for concatenation\"\nend\n\n\n\n\n\n\n\n\nlocal function __tostring(phrase)\n   local str = \"\"\n   for i,v in ipairs(phrase) do\n      str = str .. tostring(v)\n   end\n\n   return str\nend\n\n\n\nlocal PhraseMeta = {__index = Phrase,\n                  __concat = __concat,\n                  __tostring = __tostring}\n\n\n\n\ninit = function()\n   return setmetatable ({}, PhraseMeta)\nend\n\nnew = function(phrase_seed)\n   phrase_seed = phrase_seed or \"\"\n   local phrase = init()\n   local typica = type(phrase_seed)\n   if typica == \"string\" then\n      phrase[1] = phrase_seed\n      phrase.len = #phrase_seed\n   else\n      s:complain(\"Error in Phrase\", \"cannot accept phrase seed of type\" .. typica,\n                 phrase_seed)\n   end\n   return phrase\nend\n\nPhrase.idEst = new\n\n\n\n\n\n\n\n\nlocal function spec()\n   local a = new \"Sphinx of \" .. \"black quartz \"\n   a: it \"phrase-a\"\n      : passedTo(tostring)\n      : gives \"Sphinx of black quartz \"\n      : fin()\n\n   local b = a .. \"judge my \" .. \"vow.\"\n   b: it \"phrase-b\"\n      : passedTo(tostring)\n      : gives \"Sphinx of black quartz judge my vow.\"\n      : fin()\n\nend\n\nspec()\n\n\n\n\nreturn new\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/lua",
hash = "cbf7097e9791d27aa4b06ce9656becb07c05199b721b1495f8d687adf0b19de9",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\n\n\n\nlocal lua_str = [=[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr \",\" expr (\",\" expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]=]\n\n\n\nreturn Peg(lua_str)\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/serve",
hash = "7e07afe405f8257a7eef714ca6b74fbaf6471be9b069d66217527dc714985579",
branch = "select-from",
binary = "\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\nlocal input = \"\"\nwhile true do\n   local newline = io.stdin:read()\n   if newline == nil or string.byte(newline) == 17 then\n      os.exit(0)\n   end\n   input = input .. newline .. \"\\n\"\n   local res, err = loadstring(input)\n   if res then\n      res_tab = res()\n      if type(res_tab) == table and res_tab.grammar and res_tab.input then\n         local ok, peg = pcall(Peg, res_tab.grammar)\n         if ok then\n            local output = {grammar = peg:toString()}\n            local parse = peg:toGrammar()\n            local tree\n            ok, tree = pcall(parse, res_tab.input)\n            if ok then\n               output.tree = tree:toString()\n            end\n            io.stdout:write(output.grammar .. \"\\n\\n\")\n            if output.tree then\n               io.stdout:write(output.tree)\n            end\n         end\n      else\n         io.stdout:write \"must return a table with grammar and input fields\"\n      end\n      input = \"\"\n   end\nend\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/date",
hash = "4500a08f488ebe543e8f292ce17b4f6b6c69b6a0b09b6b56ba9dc9914cabc717",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal date_peg = [[\n   date  =  yearMonthDayTime\n         /  yearMonthDay\n         /  yearMonth\n         /  year\n\n   `yearMonthDay` = year \"-\" monthDay\n   `yearMonth` = year \"-\" month\n\n   year = positiveYear / negativeYear / \"0000\"\n\n   `positiveYear` =  [1-9] [0-9] [0-9] [0-9]\n                  /  \"0\"   [1-9] [0-9] [0-9]\n                  /  \"00\"        [1-9] [0-9]\n                  /  \"000\"             [1-9]\n   `negativeYear` = \"-\" positiveYear\n\n   `monthDay` =  m31 \"-\" day\n              /  m30 \"-\" (!longMonth day)\n              /  mFeb \"-\" (!threeDecan day)\n   m31      =  \"01\" / \"03\" / \"05\" / \"07\" / \"08\" / \"10\" / \"12\"\n   m30      =  \"06\" / \"04\" / \"09\" / \"11\"\n   mFeb     =  \"02\"\n\n   ; only used in negative lookahead\n   longMonth = \"31\"\n   threeDecan = \"31\" / \"30\"\n\n   month  =  m31 / m30 / mFeb\n\n   day  =  \"0\" [1-9]\n        /  (\"1\" / \"2\") [0-9]\n        /  (\"30\" / \"31\")\n\n   `yearMonthDayTime` = yearMonthDay separator time\n   `separator` = \"T\" / \" \" / \"::\" ; opinionated!\n\n\n   time = hourMinuteSecond\n        / hourMinute\n        / hour\n\n   `hourMinuteSecond` = hour \":\" minute \":\" second fracSecond? timeZone?\n   `hourMinute` = hour \":\" minute\n   hour = [0-1] [1-9] / \"2\" [0-3]\n   minute = sexigesimal\n   second = sexigesimal\n   fracSecond = \".\" [0-9] [0-9]? [0-9]?\n\n   timeZone = zulu /  offset\n   `offset` = (positive / negative) (hour \":\" minute / hour minute / hour)\n   positive = \"+\"\n   negative = \"-\"\n   zulu = \"Z\"\n   `sexigesimal` = [0-5] [0-9]\n]]\n\n\n\nreturn Peg(date_peg):toGrammar()\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "stator",
hash = "5d93466c2bc0d01d4e852f02795752bfc8f697d01a4beae5f9282747b0c879f0",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable)\n\n\n\nlocal Stator = meta {}\n\n\n\n\n\n\n\n\n-- local _weakstate = setmeta({}, {__mode = \'v\'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(stator, _weakstate)\n   local _weakstate = _weakstate or setmeta({}, {__mode = \'v\'})\n   local _M = setmeta({}, {__index = stator, __call = call })\n   _M._weakstate =  _weakstate\n   return _M\nend\n\n\n\n\n\n\n\n\n\nlocal function new(Stator, _weakstate)\n   local stator = call(Stator, _weakstate)\n   stator.g, stator.G, stator._G = stator, stator, stator\n   return stator\nend\n\n\n\n\nreturn setmetatable(Stator, {__call = new})\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "spec",
hash = "959554c370499e0e6974ef5f82a577b0e180e842178a08a3542ba01449b162bb",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n--local u = require \"util\"\nlocal m = require \"Orbit/morphemes\"\n\nlocal Grammar = require \"espalier/grammar\"\nlocal Node = require \"espalier/node\"\nlocal elpatt = require \"espalier/elpatt\"\nlocal D = elpatt.D\nlocal L = require \"lpeg\"\nlocal P = L.P\nlocal V = L.V\nlocal C = L.C\n\n\n\n\n\nlocal Spec = {}\nSpec.dot = require \"espalier/grammars/dot\"\nSpec.peg = require \"espalier/grammars/peg\"\n\n\n\n\n\n\n\n\n\nlocal function epsilon(_ENV)\n   START \"any\"\n   any = V\"anything\" + V\"other\"\n   anything = P(1)\n   other = P(1)^0\nend\n\nlocal function a(_ENV)\n   START \"A\"\n   A = P\"a\" + P\"A\"\nend\n\nlocal function ab(_ENV)\n   START \"AB\"\n   AB = V\"B\" + V\"A\"\n   A = P\"a\" + P\"A\"\n   B = V\"bmatch\" + (V\"A\" * V\"bmatch\")\n   bmatch = P\"b\" + P\"B\"\nend\n\nlocal function clu_gm(_ENV)\n   local WS = D(P(m._ + m.NL)^0)\n   START \"clu\"\n   SUPPRESS \"form\"\n   clu = V\"form\"^1\n   form = D((V\"number\" * WS))\n        + (V\"atom\" * WS)\n        + (V\"expr\" * WS)\n   expr = D(m.pal) * WS * V\"form\"^0 * WS * D(m.par)\n   atom = m.symbol\n   number = m.number\nend\n\n\n\n\n\nSpec.trivial = Grammar(epsilon)\nSpec.a = Grammar(a)\nSpec.clu = Grammar(clu_gm)\n\n\n\n\n\n\nlocal metas = {}\n\nlocal meta = meta or u.inherit\n\nlocal AMt, amt = meta(Node)\n\nlocal function Anew(A, t, str)\n   local a = setmetatable(t, AMt)\n   a.id = \"A\"\n   return a\nend\n\nmetas[\"A\"] = u.export(amt, Anew)\n\n\n\nSpec.ab = Grammar(ab, metas)\n\n\n\nreturn Spec\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/elpatt",
hash = "8024c166f460b4301e9b387468981ed78433f080b906151579ec794060a48f7b",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal s = require \"singletons\" . status ()\ns.verbose = false\nlocal Node = require \"espalier/node\"\nlocal elpatt = {}\nelpatt.P, elpatt.B, elpatt.V, elpatt.R = L.P, L.B, L.V, L.R\n\nlocal P, C, Cc, Cp, Ct, Carg = L.P, L.C, L.Cc, L.Cp, L.Ct, L.Carg\n\n\n\n\n\nlocal Err = require \"espalier/error\"\nelpatt.E, elpatt.EOF = Err.E, Err.EOF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function num_bytes(str)\n--returns the number of bytes in the next character in str\n   local c = str:byte(1)\n   if type(c) == \'number\' then\n      if c >= 0x00 and c <= 0x7F then\n         return 1\n      elseif c >= 0xC2 and c <= 0xDF then\n         return 2\n      elseif c >= 0xE0 and c <= 0xEF then\n         return 3\n      elseif c >= 0xF0 and c <= 0xF4 then\n         return 4\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal DROP = {}\nelpatt.DROP = DROP\n\nlocal function make_drop(caps)\n   local dropped = setmetatable({}, DROP)\n   dropped.DROP = DROP\n   dropped.first = caps[1]\n   dropped.last = caps[3]\n   return dropped\nend\n\nfunction elpatt.D(patt)\n   return Ct(Cp() * Ct(patt) * Cp()) / make_drop\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.S(a, ...)\n   if not a then return nil end\n   local arg = {...}\n   local set = P(a)\n   for _, patt in ipairs(arg) do\n      set = set + P(patt)\n   end\n   return set\nend\n\n\n\nreturn elpatt\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammar",
hash = "dbe70124e16b695b750f940c5bc9eb376c8a2494bca4ce3fd10d8adbc08d0719",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"singletons\" . status ()\ns.verbose = false\ns.angry   = false\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal a = require \"singletons/anterm\"\nlocal compact = assert(require \"core/table\" . compact)\nlocal Node = require \"espalier/node\"\nlocal elpatt = require \"espalier/elpatt\"\n\nlocal DROP = elpatt.DROP\n\n\n\n\n\n\n\n\n\n\nlocal assert = assert\nlocal string, io = assert( string ), assert( io )\nlocal sub = assert(string.sub)\nlocal remove = assert(table.remove)\nlocal VER = sub( assert( _VERSION ), -4 )\nlocal _G = assert( _G )\nlocal error = assert( error )\nlocal pairs = assert( pairs )\nlocal next = assert( next )\nlocal type = assert( type )\nlocal tostring = assert( tostring )\nlocal setmeta = assert( setmetatable )\nif VER == \" 5.1\" then\n   local setfenv = assert( setfenv )\n   local getfenv = assert( getfenv )\nend\n\n\n\n\n\n\n\n\nlocal function make_ast_node(id, first, t, last, str, metas, offset)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   t.first = first + offset\n   t.last  = last + offset - 1\n   t.str   = str\n   if metas[id] then\n      local meta = metas[id]\n      if type(meta) == \"function\" then\n        t.id = id\n        t = meta(t, offset)\n      else\n        t = setmeta(t, meta)\n      end\n      assert(t.id, \"no id on Node\")\n   else\n      t.id = id\n      setmeta(t, metas[1])\n   end\n\n   if not t.parent then\n      t.parent = t\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local top, touched = #t, false\n   for i = 1, top do\n      local cap = t[i]\n      if type(cap) ~= \"table\" or not cap.isNode then\n         touched = true\n         t[i] = nil\n      else\n         cap.parent = t\n      end\n   end\n   if touched then\n      compact(t, top)\n   end\n   -- post conditions\n   assert(t.isNode, \"failed isNode: \" .. id)\n   assert(t.str)\n   assert(t.parent, \"no parent on \" .. t.id)\n   return t\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cp = L.Cp\nlocal Cc = L.Cc\nlocal Ct = L.Ct\nlocal arg1_str = L.Carg(1)\nlocal arg2_metas = L.Carg(2)\nlocal arg3_offset = L.Carg(3)\n\n\n\n\n\n\nlocal function define(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit than\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fromString(g_str)\n   local maybe_lua, err = loadstring(g_str)\n   if maybe_lua then\n      return maybe_lua()\n   else\n      s : halt (\"cannot make function:\\n\" .. err)\n   end\nend\n\nlocal function _toFunction(maybe_grammar)\n   if type(maybe_grammar) == \"string\" then\n      return _fromString(maybe_grammar)\n   elseif type(maybe_grammar) == \"table\" then\n      -- we may as well cast it to string, since it might be\n      -- and sometimes is a Phrase class\n      return _fromString(tostring(maybe_grammar))\n   end\nend\n\nlocal P = assert(L.P)\n\nlocal function new(grammar_template, metas, pre, post)\n   if type(grammar_template) ~= \"function\" then\n      -- see if we can coerce it\n      grammar_template = _toFunction(grammar_template)\n   end\n\n   local metas = metas or {}\n   metas = refineMetas(metas)\n   local grammar = define(grammar_template, nil, metas)\n\n   local function parse(str, start, finish)\n      local sub_str, begin = str, 1\n      local offset = start and start - 1 or 0\n      if start and finish then\n         sub_str = sub(str, start, finish)\n      end\n      if start and not finish then\n         begin = start\n         offset = 0\n      end\n      if pre then\n         str = pre(str)\n         assert(type(str) == \"string\")\n      end\n\n      local match = L.match(grammar, sub_str, begin, str, metas, offset)\n      if match == nil then\n         return nil\n      elseif type(match) == \'number\' then\n         return sub(sub_str, 1, match)\n      end\n      if post then\n        match = post(match)\n      end\n      match.complete = match.last == #sub_str + offset\n      return match\n   end\n\n   return parse, grammar\nend\n\n\n\nreturn new\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier",
hash = "f7dfc421639918d8ae18fa5645b744d603917eb68569cf3dd0f78de9a61e99f7",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\nlocal ss      = require \"singletons\"\nlocal dot     = require \"espalier/dot\"\nlocal elpatt  = require \"espalier/elpatt\"\nlocal Node    = require \"espalier/node\"\n-- local Spec    = require \"espalier/spec\"\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg  = require \"espalier/peg\"\n\nlocal ortho8600 = require \"espalier/grammars/ortho-8600\"\n\nlocal dot_grammar  = require \"espalier/grammars/dot\"\n\nlocal lua_grammar  = require \"espalier/grammars/lua\"\n\n\n\nlocal lisp_grammar = require \"espalier/grammars/microlisp\"\n\nlocal date_grammar = require \"espalier/grammars/date\"\n\nlocal luatoken_grammar = require \"espalier/grammars/luatoken\"\n\nlocal lexemes = require \"espalier/lexemes\"\n\nlocal grammars = { ortho8600 = ortho8600,\n                   dot       = dot_grammar,\n                   lua       = lua_grammar,\n                   lisp      = lisp_grammar,\n                   date      = date_grammar,\n                   luatoken  = luatoken_grammar }\n\nreturn { dot      = dot,\n         elpatt   = elpatt,\n         node     = Node,\n         lex      = lexemes,\n         peg      = Peg,\n --        spec    = Spec,\n         phrase   = ss.Phrase,\n         grammar  = Grammar,\n         grammars = grammars,\n         stator   = ss.Stator }\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/subgrammar",
hash = "336f8cfa6b2dbdece2718aae092d07ce26e04c91750583df247d53ab73f13742",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\n\nlocal function subgrammar(grammar, meta, errstring)\n   meta = meta or Node\n   return function (t)\n      local match = grammar(t.str, t.first, t.last)\n      if match then\n         if match.last == t.last then\n            return match\n         else\n            match.should_be = match.id\n            match.id = \"INCOMPLETE\"\n            return match\n         end\n      end\n      if errstring then\n         t.errstring = errstring\n         t.should_be = t.id\n         t.id        = \"NOMATCH\"\n      end\n      return setmetatable(t, meta)\n   end\nend\n\nreturn subgrammar\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/ortho-8600",
hash = "03ffa6c0af0fb960f45515691b4f0e499be19cecd2b39d2cdc218c3171fc2b72",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--local Node    =  require \"espalier/node\"\n--local Grammar =  require \"espalier/grammar\"\nlocal require = assert(require)\nlocal L       =  require \"espalier/elpatt\"\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\n\nlocal P, R, E, V, S, D   =  L.P, L.R, L.E, L.V, L.S, L.D\n\n\n\n\n\n\nlocal Day = Node : inherit ()\nDay.id = \"day\"\nlocal Month = Node : inherit ()\nMonth.id = \"month\"\nlocal Year = Node : inherit ()\nYear.id =  \"year\"\n\nlocal date_metas = { oneThru30 = Day,\n                     oneThru29 = Day,\n                     m31       = Month,\n                     m30       = Month,\n                     mFeb      = Month,\n                     year      = Year }\n\n\n\n\n\nlocal function _date_fn(_ENV)\n\n   START \"date\"\n\n   SUPPRESS (\"positiveYear\", \"negativeYear\"\n            , \"yearMonth\", \"yearMonthDay\", \"monthDay\"\n             -- , \"oneThru12\", \"oneThru29\",\n             -- , \"oneThru30\", \"oneThru31\"\n             )\n\n   date         = V\"yearMonthDay\"\n                + V\"yearMonth\"\n                + V\"year\"\n\n   year         = V\"positiveYear\" + V\"negativeYear\" + P\"0000\"\n\n   positiveYear = R\"19\"  * R\"09\" * R\"09\" * R\"09\"\n                + P\"0\"   * R\"19\" * R\"09\" * R\"09\"\n                + P\"00\"  * R\"19\" * R\"09\"\n                + P\"000\" * R\"19\"\n\n   negativeYear =  P\"-\" * V\"positiveYear\"\n\n   monthDay     = V\"m31\"  * P\"-\" * V\"day\"\n                + V\"m30\"  * P\"-\" * (-V\"longMonth\" * V\"day\")\n                + V\"mFeb\" * P\"-\" * (-V\"threeDecan\" * V\"day\")\n\n   m31          = (P\"01\" + P\"03\" + P\"05\" + P\"07\" + \"08\" + \"10\" + \"12\")\n\n   m30          = (P\"04\" + P\"06\" + P\"09\" + P\"11\")\n\n   mFeb         = P\"02\"\n\n   yearMonth    = V\"year\" * P\"-\" * V\"month\"\n\n   yearMonthDay = V\"year\" * P\"-\" *  V\"monthDay\"\n\n   month        = V\"m31\" + V\"m30\" + V\"mFeb\"\n\n   day          = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n                + P\"30\"\n                + P\"31\"\n\n   oneThru12    = (P\"0\" *  R\"19\") + P\"10\" + P\"11\" + P\"12\"\n\n   oneThru29    = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n\n   oneThru30    = P\"30\" + V\"oneThru29\"\n\n   oneThru31    = V\"longMonth\" + V\"oneThru30\"\n\n   longMonth    = P\"31\"\n\n   threeDecan   = V\"longMonth\" + P\"30\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   uaDate        = V\"yearMonthDay\" * V\"uaSymbol\"\n\n   uaSymbol      = P\"?\" + P\"~\" + P\"%\"\n\n   reducedDate   = (V\"year\" + V\"yearMonth\") * V\"uaSymbol\"\n\n   qualifiedDate = V\"uaSymbol\"^0 * V\"year\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"month\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"day\" * V\"uaSymbol\"^0\n\n   unspecifiedDate    = (V\"yearMonth\" * P\"-XX\")\n                      + (V\"year\" * P\"-XX-XX\")\n                      * P \"XXXX-XX-XX\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn Grammar(_date_fn, date_metas, nil, nil)\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/luatoken",
hash = "2fefc9687136352c1b989d56b8a88690f581d1f01521cdd3bf32fd9b47500fb2",
branch = "select-from",
binary = "\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal lua_tok_str = [[\nlua = _ (token _)+\n`token` = keyword / operator\n\nkeyword = \"function\" / \"local\" / \"for\" / \"in\" / \"do\"\n           / \"and\" / \"or\" / \"not\" / \"true\" / \"false\"\n           / \"while\" / \"break\" / \"if\" / \"then\" / \"else\" / \"elseif\"\n           / \"goto\" / \"repeat\" / \"until\" / \"return\" / \"nil\"\n           / \"end\"\n\noperator = \"+\" / \"-\" / \"*\" / \"/\" / \"%\" / \"^\" / \"#\"\n           / \"==\" / \"~=\" / \"<=\" / \">=\" / \"<\" / \">\"\n           / \"=\" / \"(\" / \")\" / \"{\" / \"}\" / \"[\" / \"]\"\n           / \";\" / \":\" / \"...\" / \"..\" / \".\" / \",\"\n\n _     = { \\t\\n,}*\n\n]]\n\n\n\nreturn Peg(lua_tok_str):toGrammar()\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/dot",
hash = "d340c957dbebe7074abb92627540d9e2cc7a01a613dcc6b15ee7b9df12e195fa",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal t = {}\n\nlocal dot_header = [=[\ndigraph lpegNode {\n\nnode [fontname=Helvetica]\nedge [style=dashed]\n\n]=]\n\nlocal dot_footer = [=[\n\n}\n]=]\n\nlocal leaf_font  = \"Inconsolata\"\nlocal leaf_color = \"Gray\"\n\nlocal function sanitize_string(str)\n   -- filter \\ and \"\n   local phrase = str:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\'\"\', \'\\\\\"\')\n   if phrase:sub(-1,-1) == \"\\n\" then\n      return phrase:sub(1, -2)\n   else\n      return phrase\n   end\nend\n\nlocal function ast_to_label(ast, leaf_count)\n   -- nodes need unique names, so we append a leaf_count and increment it\n   local label      = ast.id.. \"_\" .. leaf_count \n   local label_line = label .. \" [label=\\\"\"\n      .. sanitize_string(ast:dotLabel()) .. \"\\\"]\\n\"\n   return label, label_line, leaf_count + 1\nend\n\nlocal function list_from_table(tab)\n   local table_list = \"\"\n   for _,v in ipairs(tab) do\n      table_list = table_list..\" \"..v\n   end\n   return table_list\nend\n\nlocal function value_to_label(value, leaf_count)\n   -- Generates a name and label for a leaf node.\n   -- Returns these with an incremented leaf_count.\n   local value = sanitize_string(value)\n   local name  = \"leaf_\"..leaf_count\n   local label = \" [color=\"..leaf_color..\",shape=rectangle,fontname=\"\n         ..leaf_font..\",label=\\\"\"..value..\"\\\"]\\n\"\n\n   return name, label, leaf_count + 1\nend\n\n\n\n\n\n\n\n\n\nlocal function dot_ranks(ast, phrase, leaf_count, ast_label)\n   local leaf_count = leaf_count or 0\n\n   -- Add the node we\'re working on\n   if ast.isNode then\n      local label = \"\"\n      local label_line = \"\"\n      local child_labels = {}\n      local child_label_lines = {}\n\n      -- Handle anonymous nodes\n      if not ast_label then\n         label, label_line, leaf_count = ast_to_label(ast, leaf_count)\n         phrase = phrase .. label_line .. \"\\n\\n\"\n      else \n         label = ast_label \n      end\n\n      -- Document child nodes\n      for i,v in ipairs(ast) do\n         -- assemble labels and label lines for all child nodes\n         if v.isNode then\n            child_labels[i], child_label_lines[i], leaf_count = \n               ast_to_label(v, leaf_count)\n         end\n      end\n\n      local child_list = list_from_table(child_labels)\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..label..\" -> {\"..child_list..\"}\\n\"\n         phrase = phrase..\"{rank=same;\"..list_from_table(child_labels)..\"}\\n\\n\"\n      end\n\n      -- Concatenate child label lines\n      for _, v in ipairs(child_label_lines) do\n         phrase = phrase..v..\"\\n\"\n      end\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..\"\\n\"\n      end\n\n      local leaf_val = nil\n\n      if ast.val then\n         leaf_val = ast.val\n      elseif ast.toValue then\n         leaf_val = ast:toValue()\n      end\n\n      -- Document value of leaf nodes\n      if (not ast[1]) and leaf_val then\n         local name = \"\" ; local val_label = \"\"\n         name, val_label, leaf_count = value_to_label(leaf_val, leaf_count)\n         phrase = phrase..label..\" -> \"..name..\"\\n\"\n         phrase = phrase..name..\" \"..val_label\n      end\n\n      local separator = \"// END RANK \" .. label .. \"\\n\\n\"\n      phrase = phrase .. separator\n\n      -- Execute recursively for all nodes\n      for i, v in ipairs(ast) do\n         if v.isNode  then\n            phrase, leaf_count = dot_ranks(v, phrase, leaf_count, child_labels[i])\n         end\n      end\n   end\n\n   return phrase, leaf_count\nend\n\n\n\n\n\nfunction t.dot(ast)\n   local phrase = dot_header\n\n   return  dot_ranks(ast, phrase) .. dot_footer\nend\n\nreturn t\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/microlisp",
hash = "0a82a86616850b7ae0a9502c7a099b7b013cfe7edbd45181b3acd067eebf5de4",
branch = "select-from",
binary = "\n\n\n\n\n\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg = require \"espalier/peg\"\nlocal Node = require \"espalier/node\"\n\n\n\n\n\n\nlocal micro_lisp_peg = [[\nlisp = _ ((atom)+ / list)\nlist = pel _ (atom / list)* per _\natom = _(number / symbol)_\nsymbol = _(alpha / other) (alpha / digit / other)*_\nnumber = float / integer\n`integer` = [0-9]+\n`float` = [0-9]+ \".\" [0-9]+ ; expand\n`pel` = \'(\'\n`per` = \')\'\n`alpha` = [A-Z]/[a-z]\n`digit` = [0-9]\n`other` = {-_-=+!@#$%^&*:/?.\\\\~}\n  `_`     = { \\t\\r\\n,}*\n]]\n\n\n\nlocal micro_lisp_metas = { lisp = Node : inherit \"lisp\",\n                           atom = Node : inherit \"atom\",\n                           symbol = Node : inherit \"symbol\",\n                           number = Node : inherit \"number\" }\n\n\n\nreturn Peg(micro_lisp_peg) : toGrammar(micro_lisp_metas)\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/lexemes",
hash = "0eb6abde818d273e4f84a582dfe93349780dcf8a9f9ba08880b46a65e7cb258c",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\nlocal sub, gsub = assert(string.sub), assert(string.gsub)\nlocal concat = assert(table.concat)\nlocal c = require \"singletons/color\"\nlocal codepoints = require \"singletons/codepoints\"\n\n\n\n\n\n\n\n\n\n\n\nlocal Lex = meta {}\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal KW = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal OP = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\\\"\'[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (letter^1 + P\"_\"^1)\n               * (letter + digit + P\"_\")^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)\n\n\n\nreturn { lua = { number      = number,\n                 digit       = digit,\n                 symbol      = symbol,\n                 comment     = comment,\n                 string      = string_short,\n                 string_long = string_long,\n                 WS          = WS,\n                 terminal    = terminal,\n                 keyword     = KW,\n                 operator    = OP },\n         digit  = digit,\n         number = number,\n         string = { str        = string_short,\n                    single     = single_str,\n                    double     = double_str,\n                    str_escape = str_esc },\n         higit   = higit,\n         hex     = _hexadecimal,\n         decimal = _decimal,\n         letter  = { latin = letter } }\n",
},
  { 
vc_hash = "8ad5c91eee55fb1d0bc4bcd4711fad84f078c337",
name = "espalier/grammars/pegmeta",
hash = "b53b7812dd900b6e1fcb98b2ca2cb6c5e4ff93da2f4e5cea172ae0c8d9f75b37",
branch = "select-from",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier/node\"\nlocal Grammar = require \"espalier/grammar\"\nlocal core = require \"singletons/core\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal inherit = assert(core.inherit)\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\nlocal s = require \"singletons/status\" ()\n\n\n\n\n\n\nlocal ok, lex = pcall(require, \"helm:helm/lex\")\nif not ok then\n   lex = function(repr) return tostring(repr) end\nelse\n   local lua_thor = lex.lua_thor\n   lex = function(repr)\n            local toks = lua_thor(tostring(repr))\n            return concat(toks)\n         end\nend\n\n\n\n\n\n\nlocal Peg, peg = Node : inherit()\nPeg.id = \"peg\"\n\n\n\n\n\n\n\n\n\nlocal PegPhrase = Phrase : inherit ({__repr = lex})\n\n\n\n\n\n\nlocal nl_map = { rule = true }\nlocal function _toSexpr(peg)\n   depth = depth or 0\n   local sexpr_line = { (\" \"):rep(depth), \"(\" } -- Phrase?\n   local name = peg.name or peg.id\n   insert(sexpr_line, name)\n   insert(sexpr_line, \" \")\n   for _, sub_peg in ipairs(peg) do\n      local _toS = sub_peg.toSexpr or _toSexpr\n      insert(sexpr_line, _toS(sub_peg))\n      insert(sexpr_line, \" \")\n   end\n   remove(sexpr_line)\n   insert(sexpr_line, \")\")\n   if nl_map[name] then\n      insert(sexpr_line, \"\\n\")\n   end\n\n   return concat(sexpr_line)\nend\n\nPeg.toSexpr = _toSexpr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __repr(repr, phrase, c)\n   return _toSexpr(repr[1])\nend\n\nlocal ReprMeta = { __repr = __repr,\n                   __tostring = __repr }\nReprMeta.__index = ReprMeta\n\nlocal function newRepr(peg)\n   local repr = setmetatable({}, ReprMeta)\n   repr[1] = peg\n   return repr\nend\n\n\n\nfunction Peg.toSexprRepr(peg)\n   return newRepr(peg)\nend\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"singletons/anterm\"\nfunction Peg.toLpeg(peg)\n   local phrase = PegPhrase \"\"\n   for _, sub in ipairs(peg) do\n      phrase = phrase .. sub:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\nlocal PegMetas = Peg : inherit()\nPegMetas.id = \"pegMetas\"\n\n\n\n\n\n\n\n\n\n\n\nlocal Rules = PegMetas : inherit \"rules\"\n\n\n\n\n\n\n\n\nfunction Rules.__call(rules, str, start, finish)\n   if not rules.parse then\n      rules.parse, rules.grammar = Grammar(rules:toLpeg())\n   end\n   return rules.parse(str, start, finish)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = PegPhrase ([[\nlocal L = assert(require \"lpeg\")\nlocal P, V, S, R = L.P, L.V, L.S, L.R\nlocal C, Cg, Cb, Cmt = L.C, L.Cg, L.Cb, L.Cmt\n]])\n\n\n\nlocal backref_rules = {\n   back_reference = [[\nlocal function __EQ_EXACT(s, i, a, b)\n   return a == b\nend\n]],\n   equal_reference = [[\nlocal function __EQ_LEN(s, i, a, b)\n   return #a == #b\nend\n]],\n   gte_reference = [[\nlocal function __GTE_LEN(s, i, a, b)\n   return #a >= #b\nend\n]],\n   gt_reference = [[\nlocal function __GT_LEN(s, i, a, b)\n   return #a > #b\nend\n]],\n   lte_reference = [[\nlocal function __LTE_LEN(s, i, a, b)\n   return #a <= #b\nend\n]],\n   lt_reference = [[\nlocal function __LT_LEN(s, i, a, b)\n   return #a < #b\nend\n]]\n}\n\n\n\n\n\n\n\n\nlocal function _normalize(str)\n   return str:gsub(\"%-\", \"%_\")\nend\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function _suppressHiddens(peg_rules)\n   local hiddens = {}\n   for hidden_patt in peg_rules : select \"hidden_pattern\" do\n      local normal = _normalize(hidden_patt:span():sub(2,-2))\n      insert(hiddens, normal)\n   end\n   if #hiddens == 0 then\n      -- no hidden patterns\n      return nil\n   end\n   local len = 14\n   local phrase = PegPhrase \"   \" .. \"SUPPRESS\" .. \" \" .. \"(\"\n   for i, patt in ipairs(hiddens) do\n      phrase = phrase .. \"\\\"\" .. patt .. \"\\\"\"\n      len = len + #patt + 2\n      if i < #hiddens then\n         phrase = phrase .. \",\" .. \" \"\n         if len > 80 then\n            phrase = phrase .. \"\\n\" .. (\" \"):rep(14)\n            len = 14\n         end\n      end\n   end\n   return phrase .. \")\" .. \"\\n\\n\"\nend\n\nfunction Rules.toLpeg(peg_rules, extraLpeg)\n   local phrase = PegPhrase()\n   -- Add matching functions if those rules are used\n   for rule, fn_str in pairs(backref_rules) do\n       if peg_rules:select(rule)() then\n          phrase = phrase .. fn_str\n       end\n   end\n   phrase = phrase .. \"\\n\"\n   -- the first rule should have an atom:\n   -- peg_rules[1]   -- this is the first rule\n   local grammar_patt = peg_rules : select \"rule\" ()\n                         : select \"pattern\" ()\n   local grammar_name = grammar_patt:span()\n   -- the root pattern can conceivably be hidden:\n   if grammar_name:sub(1,1) == \"`\" then\n      grammar_name = grammar_name:sub(2,-2)\n   end\n   grammar_name = _normalize(grammar_name)\n   local grammar_fn  = \"_\" .. grammar_name ..\"_fn\"\n   phrase = phrase .. \"local function \" .. grammar_fn .. \"(_ENV)\\n\"\n   phrase = phrase .. \"   \" .. \"START \" .. \"\\\"\" .. grammar_name .. \"\\\"\\n\"\n   -- Build the SUPPRESS function here, this requires finding the\n   -- hidden rules and suppressing them\n   local suppress = _suppressHiddens(peg_rules)\n   if suppress then\n      phrase = phrase .. suppress\n   end\n   -- add initial indentation:\n   phrase = phrase .. peg_rules.str:sub(1, grammar_patt.first - 1)\n   --\n   -- stick everything else in here...\n   ---[[\n   for rule in peg_rules : select \"rule\" do\n      phrase = phrase .. rule:toLpeg()\n   end\n   --]]\n   phrase = phrase .. (extraLpeg or \"\")\n   phrase = phrase .. \"\\nend\\n\\n\"\n   local appendix = PegPhrase \"return \" .. grammar_fn .. \"\\n\"\n   return _PREFACE .. phrase .. appendix\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rules.toGrammar(rules, metas, pre, post, extraLpeg, header)\n   metas = metas or {}\n   header = header or \"\"\n   local rule_str = rules:toLpeg(extraLpeg)\n   rule_str = header .. rule_str\n   rules.parse, rules.grammar = Grammar(rule_str, metas, pre, post)\n   return rules.parse\nend\n\n\n\n\n\n\n\n\nlocal Rule = PegMetas : inherit \"rule\"\n\nlocal function _pattToString(patt)\n   local is_hidden = patt : select \"hidden_pattern\" ()\n   if is_hidden then\n      return is_hidden:span():sub(2, -2)\n   else\n      return patt:span()\n   end\nend\n\nfunction Rule.toLpeg(rule)\n   local phrase = PegPhrase \"\"\n   local patt = _normalize(_pattToString(rule:select \"pattern\" ()))\n   phrase = phrase .. patt .. \" = \"\n   return phrase .. rule:select \"rhs\" () : toLpeg ()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rhs = PegMetas : inherit \"rhs\"\n\nfunction Rhs.toLpeg(rhs)\n   local phrase = PegPhrase()\n   for _, twig in ipairs(rhs) do\n      phrase = phrase .. \" \" .. twig:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Choice = PegMetas : inherit \"choice\"\n\nfunction Choice.toLpeg(choice)\n   local phrase = PegPhrase \"+\"\n   for _, sub_choice in ipairs(choice) do\n      phrase = phrase .. \" \" .. sub_choice:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Cat = PegMetas : inherit \"cat\"\n\nfunction Cat.toLpeg(cat)\n   local phrase = PegPhrase \"*\"\n   for _, sub_cat in ipairs(cat) do\n      phrase = phrase .. \" \" .. sub_cat:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Group = PegMetas : inherit \"group\"\n\nfunction Group.toLpeg(group)\n   local phrase = PegPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. \" \" .. sub_group:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Not_predicate = PegMetas : inherit \"not_predicate\"\n\nfunction Not_predicate.toLpeg(not_pred)\n   local phrase = PegPhrase \"-(\"\n   for _, sub_not_pred in ipairs(not_pred) do\n      phrase = phrase .. sub_not_pred:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\nlocal And_predicate = PegMetas : inherit \"and_predicate\"\n\nfunction And_predicate.toLpeg(and_predicate)\n   local phrase = PegPhrase \"#\"\n   for _, sub_and_predicate in ipairs(and_predicate) do\n      phrase = phrase .. \" \" .. sub_and_predicate:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\nlocal Literal = PegMetas : inherit \"literal\"\n\nfunction Literal.toLpeg(literal)\n   return PegPhrase \"P\" .. literal:span()\nend\n\n\n\n\n\n\nlocal Set = PegMetas : inherit \"set\"\n\nfunction Set.toLpeg(set)\n   return PegPhrase \"S\\\"\" .. set:span():sub(2,-2) .. \"\\\"\"\nend\n\n\n\n\n\n\nlocal Range = PegMetas : inherit \"range\"\n\n\n\nfunction Range.toLpeg(range)\n   local phrase = PegPhrase \"R\\\"\"\n   phrase = phrase .. range : select \"range_start\" () : span()\n   return phrase .. range : select \"range_end\" () : span() .. \"\\\" \"\nend\n\n\n\n\n\n\nlocal Zero_or_more = PegMetas : inherit \"zero_or_more\"\n\nfunction Zero_or_more.toLpeg(zero_or_more)\n   local phrase = PegPhrase()\n   for _, sub_zero in ipairs(zero_or_more) do\n      phrase = phrase .. \" \" .. sub_zero:toLpeg()\n   end\n   return phrase .. \"^0\"\nend\n\n\n\n\n\n\nlocal One_or_more = PegMetas : inherit \"one_or_more\"\n\nfunction One_or_more.toLpeg(one_or_more)\n   local phrase = PegPhrase()\n   for _, sub_more in ipairs(one_or_more) do\n      phrase = phrase .. \" \" .. sub_more:toLpeg()\n   end\n   return phrase .. \"^1\"\nend\n\n\n\n\n\n\nlocal Optional = PegMetas : inherit \"optional\"\n\nfunction Optional.toLpeg(optional)\n   local phrase = PegPhrase()\n   for _, sub_optional in ipairs(optional) do\n      phrase = phrase .. \" \" .. sub_optional:toLpeg()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Repeated = PegMetas : inherit \"repeated\"\n\nfunction Repeated.toLpeg(repeated)\n   local phrase = PegPhrase \"\"\n   local condition = repeated[1]:toLpeg():intern()\n   local times = repeated[2]:span()\n      -- match at least times - 1 and no more than times\n   phrase = phrase .. \"#\" .. condition .. \"^\" .. times\n               .. \" * \" .. condition .. \"^-\" .. PegPhrase(times)\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nlocal Named = PegMetas : inherit \"named\"\n\nfunction Named.toLpeg(named)\n   local phrase = PegPhrase \"\"\n   local condition = named[1]:toLpeg():intern()\n   if named[2].id == \"named_match\" then\n     -- make a capture group\n     phrase = phrase .. \"Cg(\" .. condition .. \",\'\" .. named[2]:span()\n               .. PegPhrase \"\')\"\n   elseif named[2].id == \"back_reference\" then\n     -- make a back reference with equality comparison\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_EXACT)\"\n   elseif named[2].id == \"equal_reference\" then\n     -- make a back reference, compare by length\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GTE_LEN)\"\n   elseif named[2].id == \"gt_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GT_LEN)\"\n   elseif named[2].id == \"lte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LTE_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LT_LEN)\"\n   else\n      error(\"unexpected back reference, id \" .. tostring(named[2].id))\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Comment = PegMetas : inherit \"comment\"\n\nfunction Comment.toSexpr(comment)\n   return \"\"\nend\n\nfunction Comment.toLpeg(comment)\n   local phrase = PegPhrase \"--\"\n   return phrase .. comment:span():sub(2)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Atom = PegMetas : inherit \"atom\"\n\nfunction Atom.toLpeg(atom)\n   local phrase = PegPhrase \"V\"\n   phrase = phrase .. \"\\\"\" .. _normalize(atom:span()) .. \"\\\"\"\n   return phrase\nend\n\n\n\n\n\n\nlocal Number = PegMetas : inherit \"number\"\n\nfunction Number.toLpeg(number)\n   local phrase = PegPhrase \"P(\"\n   return phrase .. number:span() .. \")\"\nend\n\n\n\n\n\n\n\n\n\nlocal Dent = PegMetas : inherit \"dent\"\n\nfunction Dent.toLpeg(dent)\n   return dent:span()\nend\n\nfunction Dent.strLine(dent)\n   return \"\"\nend\n\n\n\n\n\n\nlocal Whitespace = PegMetas : inherit \"WS\"\n\nfunction Whitespace.toLpeg(whitespace)\n   return PegPhrase(whitespace:span())\nend\n\n\n\nreturn { Peg,\n         rules   = Rules,\n         rule    = Rule,\n         rhs     = Rhs,\n         comment = Comment,\n         choice  = Choice,\n         cat     = Cat,\n         group   = Group,\n         atom    = Atom,\n         number  = Number,\n         set     = Set,\n         range   = Range,\n         literal = Literal,\n         zero_or_more  = Zero_or_more,\n         one_or_more   = One_or_more,\n         not_predicate = Not_predicate,\n         and_predicate = And_predicate,\n         optional  = Optional,\n         repeated  = Repeated,\n         named     = Named,\n         WS        = Whitespace,\n         dent      = Dent }\n",
},
} },
{
  project = {
    repo = "",
    repo_alternates = "",
    home = "",
    website = "",
    name = "esquilite",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "1d9d399d99ca30ad9578d5fd8e5e00203a872ba6",
name = "esquilite",
hash = "242cd00ab28e2cdc92344d88f35ac390c61cf6090e18856dc9c386e31656b494",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migrate(conn, migration, ...)\n   conn.pragma.foreign_keys(false)\n   conn:exec \"BEGIN TRANSACTION;\"\n   if type(migration) == \'function\' then\n      migration(conn, ...)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, ...)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\n   conn:exec \"COMMIT;\"\n   conn.pragma.foreign_keys(true)\nend\n\n\n\nlocal format = assert(string.format)\nlocal open = assert(sql.open)\n\n\nlocal function boot(conn, migrations)\n   version = #migrations\n   conn = type(conn) == \'string\' and open(conn) or conn\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      for i = user_version + 1, version do\n         migrate(conn, migrations[i])\n      end\n      conn.pragma.user_version(version)\n   elseif user_version > version then\n      error(format(\"Error: helm.sqlite is version %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn { migrate = migrate,\n         boot    = boot }\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/fs.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/fs.git",
    home = "",
    website = "",
    name = "fs",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "8d07a27469b47b1f714afb7cce0dda2aa2913b91",
name = "fs/directory",
hash = "2e2bce4f65a11d34cc5ac4af5e9cfc6abacf583d9df41cfecc40a039430d0a76",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal s = require \"singletons/status\" ()\ns.chatty = true\ns.verbose = false\n\nlocal sh = require \"orb:util/sh\"\n\nlocal Path = require \"fs:fs/path\"\nlocal File = require \"fs:fs/file\"\n\n\n\nlocal new\n\n\n\nlocal Dir = {}\nDir.it = require \"singletons/check\"\n\n-- Cache to keep each Dir unique by path name\nlocal __Dirs = setmetatable({}, {__mode = \"v\"})\n\n\n\n\n\n\nfunction Dir.exists(dir)\n   local stat = uv.fs_stat(tostring(dir.path))\n   if stat and stat.type == \"directory\" then\n      return true\n   elseif stat and stat.type ~= \"directory\" then\n      return false, tostring(dir.path) .. \" is a \" .. stat.type\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function mkdir(dir, mode)\n   if mode then\n      if type(mode) == \'string\' then\n         mode = tonumber(mode, 8)\n      elseif type(mode) ~= \'number\' then\n         error(\"bad argument #1 to mkdir method: expected string or number\"\n               .. \"got \" ..type(mode))\n      end\n   else\n      mode = 493 -- drwxr-xr-x\n   end\n\n   local exists, msg = dir:exists()\n   if exists or msg then\n      return false, msg or \"directory already exists\"\n   else\n      -- There is no good way to do recursive mkdir with primitives.\n      -- the filesystem will happily open, stat, etc. from memory, without\n      -- writing to disk; unless the directory actually exists on disk, mkdir\n      -- for the subdirectory will fail.\n      --\n      -- So, we shell out.\n      local parent = new(dir.path:parentDir())\n      if parent and (not parent:exists()) then\n         return sh.mkdir(\"-p\", \"\'\" .. dir.path.str:gsub(\"\'\", \"\'\\\\\'\'\") .. \"\'\")\n      else\n         local success, msg, code = uv.fs_mkdir(dir.path.str, mode)\n         if success then\n            return success\n         else\n            code = tostring(code)\n            s:complain(\"mkdir failure # \" .. code, msg, dir)\n            return false, msg\n         end\n      end\n   end\nend\n\nDir.mkdir = mkdir\n\n\n\n\n\nfunction Dir.basename(dir)\n   return dir.path:basename()\nend\n\n\n\n\n\nfunction Dir.parentDir(dir)\n   return new(dir.path:parentDir())\nend\n\n\n\n\n\n\nlocal insert, sort = assert(table.insert), assert(table.sort)\nlocal sub = assert(string.sub)\n\nlocal div = Path \"\" . divider\n\nfunction Dir.getsubdirs(dir)\n   local dir_str = tostring(dir)\n   if sub(dir_str, -1) == div then\n      dir_str = sub(dir_str, 1, -2)\n   end\n   local uv_fs_t = uv.fs_opendir(dir_str)\n   local subdirs, done = {}, false\n   repeat\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if file_obj then\n         if file_obj[1].type == \"directory\" then\n            insert(subdirs, dir_str .. div .. file_obj[1].name)\n         end\n      else\n         done = true\n      end\n   until done\n   uv.fs_closedir(uv_fs_t)\n   sort(subdirs)\n   for i, subdir in ipairs(subdirs) do\n      subdirs[i] = new(subdir)\n   end\n   return subdirs\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Dir.swapDirFor(dir, nestDir, newNest)\n   local dir_str, nest_str = tostring(dir), tostring(nestDir)\n   local first, last = string.find(dir_str, nest_str)\n   if first == 1 then\n      -- swap out\n      return new(Path(tostring(newNest) .. string.sub(dir_str, last + 1)))\n   else\n      return nil, nest_str.. \" not found in \" .. dir_str\n   end\nend\n\n\n\n\n\n\n\n\nfunction Dir.attributes(dir)\n   return uv.fs_stat(tostring(dir.path))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Dir.getfiles(dir)\n   local dir_str = tostring(dir)\n   local uv_fs_t, err = uv.fs_opendir(dir_str)\n   if not uv_fs_t then\n      return nil, err\n   end\n   local files, done = {}, false\n   repeat\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if file_obj then\n         if file_obj[1].type == \"file\" then\n            insert(files, dir_str .. div .. file_obj[1].name)\n         end\n      else\n         done = true\n      end\n   until done\n   uv.fs_closedir(uv_fs_t)\n   sort(files)\n   for i, file in ipairs(files) do\n      files[i] = File(file)\n   end\n   return files\nend\n\n\n\n\n\n\n\n\n\n\nfunction Dir.files(dir)\n   local dir_str = tostring(dir)\n   local uv_fs_t, err = uv.fs_opendir(dir_str)\n   if not uv_fs_t then\n      return nil, err\n   end\n   local iter = function()\n      if not uv_fs_t then return nil end\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if not file_obj then\n         uv.fs_closedir(uv_fs_t)\n         uv_fs_t = nil\n         return nil\n      end\n      if file_obj[1].type == \'file\' then\n         return File(dir_str .. div .. file_obj[1].name)\n      else\n         iter()\n      end\n   end\n   return iter\nend\n\n\n\n\n\nlocal function __tostring(dir)\n   return dir.path.str\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __concat(dir, path)\n      if type(dir) == \"string\" then\n            return new(dir .. path)\n      end\n      return new(dir.path.str .. tostring(path))\nend\n\n\n\n\n\n\n\n\nlocal function __eq(a, b)\n   local stat_a, stat_b = uv.fs_stat(a.path.str), uv.fs_stat(b.path.str)\n   if (not stat_a) or (not stat_b) then\n      -- same premise as NaN ~= NaN\n      return false\n   end\n   return stat_a.ino == stat_b.ino\nend\n\n\n\n\nlocal Dir_M = { __index    = Dir,\n                __tostring = __tostring,\n                __concat   = __concat,\n                __eq       = __eq }\n\nnew = function(path)\n   local path_str = tostring(path)\n   -- bail on empty string\n   if path_str == \"\" then\n      return nil, \"can\'t make directory from empty string\"\n   end\n   -- strip trailing \"/\"\n   if sub(path_str, -1) == div then\n      path_str = sub(path_str, 1, -2)\n   end\n   local stat = uv.fs_stat(path_str)\n   if stat and __Dirs[stat.ino] then\n      return __Dirs[stat.ino]\n   elseif __Dirs[path_str] then\n      return __Dirs[path_str]\n   end\n   if stat and stat.type ~= \"directory\" then\n      return nil, path_str .. \" is a \" .. stat.type .. \", not a directory\"\n   end\n   local dir = setmetatable({}, Dir_M)\n   dir.path = Path(path_str)\n   local key = stat and stat.ino or path_str\n   __Dirs[key] = dir\n\n   return dir\nend\n\n\n\nDir.idEst = new\nreturn new\n",
},
  { 
vc_hash = "8d07a27469b47b1f714afb7cce0dda2aa2913b91",
name = "fs/path",
hash = "1301f0643de4b0421a569e8d36d53e7206f32f7f4b418c72da269393177a188d",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal core = require \"singletons/core\"\n\n\n\nlocal new\nlocal Path = {}\nPath.__index = Path\n\nlocal __Paths = {} -- one Path per real Path\n\nlocal s = require \"singletons/status\" ()\ns.angry = false\n\nPath.it = require \"singletons/check\"\n\nPath.divider = \"/\"\nPath.div_patt = \"%/\"\nPath.dir_sep = \":\"\nPath.parent_dir = \"..\"\nPath.same_dir = \".\"\nlocal sub, find = assert(string.sub), assert(string.find)\n\n\n\n\n\n\n\n\n\n\n\nlocal function clone(path)\n   local new_path = {}\n   for k,v in pairs(path) do\n      new_path[k] = v\n   end\n   setmetatable(new_path, getmetatable(path))\n   return new_path\nend\n\n\n\n\n\n\n\n\n\nlocal function stringAwk(path, str)\n    local div, div_patt = Path.divider, Path.div_patt\n    local phrase = \"\"\n   if sub(str,1,1) == \"/\" then\n      path.is_abs = true\n   end\n    local remain = str\n   -- chew the string like Pac Man\n    while remain  do\n        local dir_index = find(remain, div_patt)\n        if dir_index then\n          -- add the handle minus div\n         local handle = sub(remain, 1, dir_index - 1)\n         if handle ~= \"\" then\n               path[#path + 1] = handle\n         end\n            -- then the div\n            path[#path + 1] = div\n            local new_remain = sub(remain, dir_index + 1)\n            assert(#new_remain < #remain, \"remain must decrease\")\n            remain = new_remain\n            if remain == \"\" then\n                remain = nil\n            end\n        else\n          -- single file/directory\n            path[#path + 1] = remain\n            path.filename = remain\n            remain = nil\n        end\n    end\n\n    return path\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __concat(head_path, tail_path)\n   local head, tail = tostring(head_path), tostring(tail_path)\n  return new(head .. tail)\nend\n\n\n\n\n\n\n\n\nlocal function __tostring(path)\n  return path.str\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function __eq(a,b)\n   return tostring(a) == tostring(b)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.parentDir(path)\n   local parent_offset\n   if path[#path] == Path.divider then\n      parent_offset = #path[#path-1] + 2\n   else\n      parent_offset = #path[#path] + 1\n   end\n   local parent = sub(path.str, 1, - parent_offset)\n   local p_last = sub(parent, -1)\n   -- make the parent of an abspath \"/\"\n   if parent == \"\" and path.is_abs then\n      parent = \"/\"\n   end\n   return new(parent)\nend\n\n\n\n\n\n\n\n\nlocal function fromString(path, str)\n   local div, div_patt = Path.divider, Path.div_patt\n   return stringAwk(path, str, div, div_patt)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.relPath(path, rel)\n   error \"no longer implemented\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Path.absPath(path, base)\n   if path.is_abs then return path end\n   base = base or uv.cwd()\n   local abspath\n   -- make a copy of base to \'re-base\' upon\n   if type(base) == \'string\' then\n      abspath = clone(new(base))\n   else\n      abspath = clone(base)\n   end\n   insert(abspath, Path.divider)\n   for _, element in ipairs(path) do\n      insert(abspath, element)\n   end\n   abspath.str = abspath.str .. Path.divider .. path.str\n   abspath.is_abs = true\n   return abspath\nend\n\n\n\n\n\n\n\n\n\n\nlocal litpat = core.litpat\nlocal extension -- defined below\n\nfunction Path.subFor(path, base, newbase, ext)\n   local path, base, newbase = tostring(path),\n                               tostring(base),\n                               tostring(newbase)\n   if find(path, litpat(base)) then\n      local rel = sub(path, #base + 1)\n      if ext then\n         if sub(ext, 1, 1) ~= \".\" then\n            ext = \".\" .. ext\n         end\n         local old_ext = extension(path)\n         rel = sub(rel, 1, - #old_ext - 1) .. ext\n      end\n      return new(newbase .. rel)\n   else\n      s:complain(\"path error\", \"cannot sub \" .. newbase .. \" for \" .. base\n                 .. \" in \" .. path)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function splitext(path)\n    local i = #path\n    local ch = sub(path, i, i)\n    while i > 0 and ch ~= \'.\' do\n        if ch == Path.divider or ch == Path.dir_sep then\n            return path, \'\'\n        end\n        i = i - 1\n        ch = sub(path, i, i)\n    end\n    if i == 0 then\n        return path, \'\'\n    else\n        return sub(path, 1, i-1), sub(path, i)\n    end\nend\n\nlocal function splitpath(path)\n    local i = #path\n    local ch = sub(path, i, i)\n    while i > 0 and ch ~= Path.divider and ch ~= Path.dir_sep do\n        i = i - 1\n        ch = sub(path,i, i)\n    end\n    if i == 0 then\n        return \'\', path\n    else\n        return sub(path, 1, i-1), sub(path, i+1)\n    end\nend\n\n\n\nfunction Path.extension(path)\n   local _ , ext = splitext(tostring(path))\n  return ext\nend\n\nextension = Path.extension\n\n\n\n\n\nfunction Path.basename(path)\n   local _, base = splitpath(tostring(path))\n   return base\nend\n\n\n\n\n\n\n\n\nfunction Path.dirname(path)\n   local dir = splitpath(tostring(path))\n   return dir\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.barename(path)\n   return sub(path:basename(), 1, -(#path:extension() + 1))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Path.has(path, substr)\n   for _, v in ipairs(path) do\n      if v == substr then\n         return true\n      end\n   end\n\n   return false\nend\n\n\n\n\n\n\n\n\n\nfunction Path.exists(path)\n   local stat = uv.fs_stat(tostring(path))\n   if not stat then\n      return false\n   else\n      return true, stat.type\n   end\nend\n\n\n\n\n\n\nfunction Path.isDir(path)\n   local stat = uv.fs_stat(tostring(path))\n   if stat and stat.type == \'directory\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction Path.isFile(path)\n   local stat = uv.fs_stat(tostring(path))\n   if stat and stat.type == \'file\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal PathMeta = {__index = Path,\n                  __concat = __concat,\n                  __tostring = __tostring}\n\nnew  = function (path_seed)\n   if __Paths[path_seed] then\n      return __Paths[path_seed]\n   end\n   local path = setmetatable({}, PathMeta)\n   if type(path_seed) == \'string\' then\n      path.str = path_seed\n      path =  fromString(path, path_seed)\n   elseif type(path_seed) == \'table\' then\n    if path_seed.idEst == new then return path_seed end\n      s:complain(\"NYI\", \'cannot construct Path from this table parameter\')\n   end\n\n   __Paths[path_seed] = path\n   return path\nend\n\nPath.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n",
},
  { 
vc_hash = "8d07a27469b47b1f714afb7cce0dda2aa2913b91",
name = "fs/file",
hash = "608ea62ff1002c4d3dd2e62802622d86b35dc09172a76b4b4ae38fed6d150b9f",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.chatty = true\nlocal Path = require \"fs:path\"\nlocal running, resume, yield = assert(coroutine.running),\n                               assert(coroutine.resume),\n                               assert(coroutine.yield)\n\n\n\nlocal new\nlocal File = {}\nlocal _Files = setmetatable({}, {__mode = \"v\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction File.dirPath(file)\n   return file.path:parentDir()\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction File.exists(file)\n   local stat = uv.fs_stat(tostring(file.path))\n   if stat then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nfunction File.basename(file)\n   return file.path:basename()\nend\n\n\n\n\n\n\n\n\n\n\nfunction File.extension(file)\n   return file.path:extension()\nend\n\n\n\n\n\n\n\n\nfunction File.read(file)\n   local co, main = running()\n   local file_str = tostring(file.path)\n   s:verb(\"opening %s for read\", file_str)\n   if main or (not uv.loop_alive()) then\n      s:verb(\"blocking read\")\n      local f = io.open(file_str, \"r\")\n      if not f then\n         return nil, \"cannot open for read: \" .. file_str\n      end\n      local content = f:read(\"*a\")\n      f:close()\n      return content\n   else\n      -- 292 == 0444 == -r--r--r--\n      s:verb(\"opening %s\", file_str)\n      uv.fs_open(file_str, \"r\", 292, function(err, fd)\n         s:verb(\"entered open callback: %s\", file_str)\n         if err then\n            s:complain(\"failed to open %s: %s\", file_str, err)\n            return resume(co, nil, \"error opening \" .. file_str\n                                    .. \": \" .. err)\n         end\n         local stat, err = uv.fs_stat(file_str)\n         if not stat then\n            s:complain(\"failed to stat %s\", file_str)\n            return resume(co, nil, \"error statting file: \" .. err)\n         end\n         -- rejoin the threadpool on read\n         uv.fs_read(fd, stat.size, 0, function(err, content)\n            if err then\n               s:complain(\"failed to read %s: %s\", file_str, err)\n               return resume(co, nil, \"error reading \" .. file_str\n                                      .. \": \" .. err)\n            end\n            uv.fs_close(fd)\n            return resume(co, content)\n         end)\n      end)\n      return yield()\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _withMode(flags)\n   return function (file, doc)\n      if uv.loop_alive() then\n         -- 416 == 0640 == -rw-r-----\n         uv.fs_open(file.path.str, flags, 416, function(err, fd)\n            if err then\n               error(\"unable to open for write: \" .. file.path.str)\n            end\n            uv.fs_write(fd, tostring(doc), -1, function()\n               uv.fs_close(fd)\n            end)\n         end)\n      else\n         local f = io.open(file.path.str, flags)\n         if not f then\n            error(\"cannot open for write: \" .. file.path.str)\n         end\n         f:write(tostring(doc))\n         f:close()\n      end\n   end\nend\n\nFile.write = _withMode \"w\"\nFile.append = _withMode \"a\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __eq(a,b)\n   local stat_a, stat_b = uv.fs_stat(a.path.str), uv.fs_stat(b.path.str)\n   if (not stat_a) or (not stat_b) then\n      return false\n   end\n   return stat_a.ino == stat_b.ino\nend\n\n\n\n\n\n\nlocal function __tostring(file)\n   return tostring(file.path)\nend\n\n\n\n\n\n\nlocal FileMeta = { __index    = File,\n                   __tostring = __tostring,\n                   __eq       = __eq }\n\nnew = function (file_path)\n   local file_str = tostring(file_path)\n   -- I believe it\'s safe to say that path is a sufficient, but not\n   -- necessary, guarantee of uniqueness:\n   if _Files[file_str] then\n      return _Files[file_str]\n   end\n   local stat = uv.fs_stat(file_str)\n   if stat and stat.type ~= \"file\" then\n      return nil, file_str .. \" is a \" .. stat.type .. \", not a file\"\n   end\n\n   local file = setmetatable({}, FileMeta)\n   local file_path = Path(file_str)\n   if file_path:isDir() then\n      error(\"cannot make file: \" .. file_path.str .. \" is a directory\")\n   end\n   file.path = file_path\n   _Files[file_str] = file\n\n   return file\nend\n\nFile.idEst = new\n\n\n\nreturn new\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/ggg.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/ggg.git",
    home = "",
    website = "",
    name = "ggg",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "fcd16fdd0c23152903ebd0eb794c70405d202eb9",
name = "hammer",
hash = "6dffffa6bddc4c4272a6a83b94474a8d34ddeb635338aef709d05282500f55c4",
branch = "master",
binary = "\n\n\n\n\n\nlocal ffi = require(\"ffi\")\nffi.cdef[[\ntypedef enum HParserBackend_ {\n  PB_MIN = 0,\n  PB_PACKRAT = PB_MIN, // PB_MIN is always the default.\n  PB_REGULAR,\n  PB_LLk,\n  PB_LALR,\n  PB_GLR,\n  PB_MAX = PB_GLR\n} HParserBackend;\n\ntypedef enum HTokenType_ {\n  TT_NONE = 1,\n  TT_BYTES = 2,\n  TT_SINT = 4,\n  TT_UINT = 8,\n  TT_SEQUENCE = 16,\n  TT_RESERVED_1, // reserved for backend-specific internal use\n  TT_ERR = 32,\n  TT_USER = 64,\n  TT_MAX\n} HTokenType;\n\ntypedef struct HBytes_ {\n  const uint8_t *token;\n  size_t len;\n} HBytes;\n\ntypedef struct HArena_ HArena ; // hidden implementation\n\ntypedef struct HCountedArray_ {\n  size_t capacity;\n  size_t used;\n  HArena * arena;\n  struct HParsedToken_ **elements;\n} HCountedArray;\n\ntypedef struct HParsedToken_ {\n  HTokenType token_type;\n  union {\n    HBytes bytes;\n    int64_t sint;\n    uint64_t uint;\n    double dbl;\n    float flt;\n    HCountedArray *seq; // a sequence of HParsedToken\'s\n    void *user;\n  };\n  size_t index;\n  size_t bit_length;\n  char bit_offset;\n} HParsedToken;\n\ntypedef struct HParseResult_ {\n  const HParsedToken *ast;\n  int64_t bit_length;\n  HArena * arena;\n} HParseResult;\n\ntypedef struct HParserVtable_ HParserVtable;\ntypedef struct HCFChoice_ HCFChoice;\n\ntypedef struct HParser_ {\n  const HParserVtable *vtable;\n  HParserBackend backend;\n  void* backend_data;\n  void *env;\n  HCFChoice *desugared;\n} HParser;\n\ntypedef struct HAllocator_ HAllocator;\n\ntypedef HParsedToken* (*HAction)(const HParseResult *p, void* user_data);\ntypedef bool (*HPredicate)(HParseResult *p, void* user_data);\ntypedef HParser* (*HContinuation)(HAllocator *mm__, const HParsedToken *x, void *env);\n\nHParseResult* h_parse(const HParser* parser, const uint8_t* input, size_t length);\nHParser* h_token(const uint8_t *str, const size_t len);\nHParser* h_ch(const uint8_t c);\nHParser* h_ch_range(const uint8_t lower, const uint8_t upper);\nHParser* h_int_range(const HParser *p, const int64_t lower, const int64_t upper);\nHParser* h_bits(size_t len, bool sign);\nHParser* h_int64();\nHParser* h_int32();\nHParser* h_int16();\nHParser* h_int8();\nHParser* h_uint64();\nHParser* h_uint32();\nHParser* h_uint16();\nHParser* h_uint8();\nHParser* h_whitespace(const HParser* p);\nHParser* h_left(const HParser* p, const HParser* q);\nHParser* h_right(const HParser* p, const HParser* q);\nHParser* h_middle(const HParser* p, const HParser* x, const HParser* q);\nHParser* h_action(const HParser* p, const HAction a, void* user_data);\nHParser* h_in(const uint8_t *charset, size_t length);\nHParser* h_not_in(const uint8_t *charset, size_t length);\nHParser* h_end_p();\nHParser* h_nothing_p();\nHParser* h_sequence(HParser* p, ...);\nHParser* h_choice(HParser* p, ...);\nHParser* h_permutation(HParser* p, ...);\nHParser* h_butnot(const HParser* p1, const HParser* p2);\nHParser* h_difference(const HParser* p1, const HParser* p2);\nHParser* h_xor(const HParser* p1, const HParser* p2);\nHParser* h_many(const HParser* p);\nHParser* h_many1(const HParser* p);\nHParser* h_repeat_n(const HParser* p, const size_t n);\nHParser* h_optional(const HParser* p);\nHParser* h_ignore(const HParser* p);\nHParser* h_sepBy(const HParser* p);\nHParser* h_sepBy1(const HParser* p);\nHParser* h_epsilon_p();\nHParser* h_length_value(const HParser* length, const HParser* value);\nHParser* h_attr_bool(const HParser* p, HPredicate pred, void* user_data);\nHParser* h_and(const HParser* p);\nHParser* h_not(const HParser* p);\nHParser* h_indirect(const HParser* p);\nvoid h_bind_indirect(HParser* indirect, const HParser* inner);\nHParser* h_with_endianness(char endianness, const HParser* p);\nHParser* h_put_value(const HParser* p, const char* name);\nHParser* h_get_value(const char* name);\nHParser* h_bind(const HParser *p, HContinuation k, void *env);\n\nint h_compile(HParser* parser, HParserBackend backend, const void* params);\n\nstatic const uint8_t BYTE_BIG_ENDIAN = 0x1;\nstatic const uint8_t BIT_BIG_ENDIAN = 0x2;\nstatic const uint8_t BYTE_LITTLE_ENDIAN = 0x0;\nstatic const uint8_t BIT_LITTLE_ENDIAN = 0x0;\n]]\nlocal h = ffi.load(\"hammer\")\n\nlocal function helper(a, n, b, ...)\n  if   n == 0 then return a\n  else             return b, helper(a, n-1, ...) end\nend\nlocal function append(a, ...)\n  return helper(a, select(\'#\', ...), ...)\nend\n\n-- Exponents do a lot of heavy lifting in Lpeg,\n-- which is the overloading template we\'re going to follow\nlocal function __pow(rule, power)\n  assert(type(power) == \"number\")\n  if power == 0 then\n    return h.h_many(rule)\n  elseif power == 1 then\n    return h.h_many1(rule)\n  elseif power == -1 then\n    return h.h_optional(rule)\n  end\nend\n\n\nlocal mt = {\n  __index = {\n    parse = function(p, str) return h.h_parse(p, str, #str) end,\n  },\n  __add = function(left, right)\n    return h.h_choice(left, right)\n  end,\n  __mul = function(left, right)\n    return h.h_sequence(left, right)\n  end,\n  __pow = __pow,\n  __len = function(rule)\n    return h.h_and(rule)\n  end,\n  __unm = function(rule)\n    return h.h_not(rule)\n  end,\n  __sub = function(left, right)\n    return h.h_sequence(left, h.h_not(right))\n  end,\n  -- Lpeg doesn\'t use modulus, let\'s use it for n number of\n  -- repetitions\n  __mod = function(rule, reps)\n    assert(type(reps) == \"number\")\n    return h.h_repeat_n(rule, reps)\n  end,\n  __div = function(rule, cb)\n    return h.h_action(rule, cb, nil)\n  end\n}\n\nlocal hammer = {}\nhammer.parser = ffi.metatype(\"HParser\", mt)\n\nlocal counted_array\n\n\n\nlocal function _castCountedArray(array)\n    if array == nil then return nil end\n    if array.elements == nil then return nil end\n    local ret = {}\n    for i = 0, tonumber(array.used) do\n       ret[#ret+1] = array.elements[i]()\n    end\n    if #ret == 1 and type(ret[1]) == \"table\" then\n       return ret[1]\n    end\n    if #ret == 0 then\n       return nil\n    end\n    return ret\nend\n\nlocal arr_mt = {\n  __index = function(table, key)\n    return table.elements[key]\n  end,\n  __len = function(table) return table.used end,\n  __ipairs = function(table)\n    local i, n = -1, #table\n    return function()\n      i = i + 1\n      if i < n then\n        return i, table.elements[i]\n      end\n    end\n  end,\n  __call = _castCountedArray,\n}\ncounted_array = ffi.metatype(\"HCountedArray\", arr_mt)\n\nlocal bytes_mt = {\n  __call = function(self)\n    local ret = \"\"\n    for i = 0, tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.len)))-1\n      do ret = ret .. string.char(self.token[i])\n    end\n    return ret\n  end\n}\nlocal byte_string = ffi.metatype(\"HBytes\", bytes_mt)\n\nlocal result_mt = {\n   __call = function(self)\n      if self == nil then return nil end\n      return self.ast()\n   end\n}\n\nlocal parse_result = ffi.metatype(\"HParseResult\", result_mt)\n\nlocal token_types = ffi.new(\"HTokenType\")\n\n\nlocal parsed_token\nlocal tok_mt = {\n  __call = function(self)\n     if self == nil then return nil end\n     if self.token_type == ffi.C.TT_BYTES then\n       return self.bytes()\n     elseif self.token_type == ffi.C.TT_SINT then\n       return tonumber(ffi.cast(\"intptr_t\", ffi.cast(\"void *\", self.sint)))\n     elseif self.token_type == ffi.C.TT_UINT then\n       return tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.uint)))\n     elseif self.token_type == ffi.C.TT_SEQUENCE then\n       return self.seq()\n     end\n     return nil\n  end\n}\nparsed_token = ffi.metatype(\"HParsedToken\", tok_mt)\n\nfunction hammer.token(str)\n  return h.h_token(str, #str)\nend\nfunction hammer.ch(c)\n  if type(c) == \"number\" then\n    return h.h_ch(c)\n  else\n    return h.h_ch(c:byte())\n  end\nend\nfunction hammer.ch_range(lower, upper)\n  if type(lower) == \"number\" and type(upper) == \"number\" then\n    return h.h_ch_range(lower, upper)\n  -- FIXME this is really not thorough type checking\n  else\n    return h.h_ch_range(lower:byte(), upper:byte())\n  end\nend\nfunction hammer.int_range(parser, lower, upper)\n  return h.h_int_range(parser, lower, upper)\nend\nfunction hammer.bits(len, sign)\n  return h.h_bits(len, sign)\nend\nfunction hammer.int64()\n  return h.h_int64()\nend\nfunction hammer.int32()\n  return h.h_int32()\nend\nfunction hammer.int16()\n  return h.h_int16()\nend\nfunction hammer.int8()\n  return h.h_int8()\nend\nfunction hammer.uint64()\n  return h.h_uint64()\nend\nfunction hammer.uint32()\n  return h.h_uint32()\nend\nfunction hammer.uint16()\n  return h.h_uint16()\nend\nfunction hammer.uint8()\n  return h.h_uint8()\nend\nfunction hammer.whitespace(parser)\n  return h.h_whitespace(parser)\nend\nfunction hammer.left(parser1, parser2)\n  return h.h_left(parser1, parser2)\nend\nfunction hammer.right(parser1, parser2)\n  return h.h_right(parser1, parser2)\nend\nfunction hammer.middle(parser1, parser2, parser3)\n  return h.h_middle(parser1, parser2, parser3)\nend\n-- There could also be an overload of this that doesn\'t\n-- bother with the env pointer, and passes it as NIL by\n-- default, but I\'m not going to deal with overloads now.\nfunction hammer.action(parser, action, user_data)\n  local cb = ffi.cast(\"HAction\", action)\n  return h.h_action(parser, cb, user_data)\nend\nfunction hammer.in_(charset)\n  local cs = ffi.new(\"const unsigned char[\" .. #charset .. \"]\", charset)\n  return h.h_in(cs, #charset)\nend\nfunction hammer.not_in(charset)\n  return h.h_not_in(charset, #charset)\nend\nfunction hammer.end_p()\n  return h.h_end_p()\nend\nfunction hammer.nothing_p()\n  return h.h_nothing_p()\nend\nfunction hammer.sequence(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_sequence(parser, parsers)\nend\nfunction hammer.choice(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_choice(parser, parsers)\nend\nfunction hammer.permutation(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_permutation(parser, parsers)\nend\nfunction hammer.butnot(parser1, parser2)\n  return h.h_butnot(parser1, parser2)\nend\nfunction hammer.difference(parser1, parser2)\n  return h.h_difference(parser1, parser2)\nend\nfunction hammer.xor(parser1, parser2)\n  return h.h_xor(parser1, parser2)\nend\nfunction hammer.many(parser)\n  return h.h_many(parser)\nend\nfunction hammer.many1(parser)\n  return h.h_many1(parser)\nend\nfunction hammer.repeat_n(parser, n)\n  return h.h_repeat_n(parser, n)\nend\nfunction hammer.optional(parser)\n  return h.h_optional(parser)\nend\nfunction hammer.ignore(parser)\n  return h.h_ignore(parser)\nend\nfunction hammer.sepBy(parser)\n  return h.h_sepBy(parser)\nend\nfunction hammer.sepBy1(parser)\n  return h.h_sepBy1(parser)\nend\nfunction hammer.epsilon_p()\n  return h.h_epsilon_p()\nend\nfunction hammer.length_value(length, value)\n  return h.h_length_value(length, value)\nend\nfunction hammer.attr_bool(parser, predicate, user_data)\n  local cb = ffi.cast(\"HPredicate\", predicate)\n  return h.h_attr_bool(parser, cb, user_data)\nend\nfunction hammer.and_(parser)\n  return h.h_and(parser)\nend\nfunction hammer.not_(parser)\n  return h.h_not(parser)\nend\nfunction hammer.indirect(parser)\n  return h.h_indirect(parser)\nend\nfunction hammer.bind_indirect(indirect, inner)\n  return h.h_bind_indirect(indirect, inner)\nend\nfunction hammer.with_endianness(endianness, parser)\n  return h.h_with_endianness(endianness, parser)\nend\nfunction hammer.put_value(parser, name)\n  return h.h_put_value(parser, name)\nend\nfunction hammer.get_value(name)\n  return h.h_get_value(name)\nend\nfunction hammer.bind(parser, continuation, env)\n  local cb = ffi.cast(\"HContinuation\", continuation)\n  return h.h_bind(parser, cb, env)\nend\n\nfunction hammer.compile(parser, backend, params)\n  return h.h_compile(parser, backend, params)\nend\n\nhammer.BYTE_BIG_ENDIAN = 0x1;\nhammer.BIT_BIG_ENDIAN = 0x2;\nhammer.BYTE_LITTLE_ENDIAN = 0x0;\nhammer.BIT_LITTLE_ENDIAN = 0x0;\nreturn hammer\n",
},
  { 
vc_hash = "fcd16fdd0c23152903ebd0eb794c70405d202eb9",
name = "hlib",
hash = "5c39a1ce6d071181321c0762f34b3be137df280ad2178ca238f6d6f51c5acec8",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\nlocal h = require \"ggg:hammer\"\nlocal utf8 = require \"lua-utf8\"\n\n\n\n\n\n\nlocal hlib = {}\n\n\n\n\n\n\nlocal sub = utf8.sub\n\n\nfunction hlib.from_range(head, tail)\n   local first = sub(head,1,1)\n   if first == \"Â¢\" then\n      -- character range\n      return h.ch_range(sub(head,2), sub(tail, 2))\n   elseif first == \"0\" then\n      -- binary or hex\n      local hnum, tnum = tonumber(head), tonumber(tail)\n      assert(hnum <= tnum, \"hnum cannot be greater than tnum\")\n      if tnum <= 255 then\n         return h.int_range(h.uint8(), hnum, tnum)\n      elseif tnum <= 65535 then\n         return h.int_range(h.unit16(), hnum, tnum)\n      elseif tnum <= 4294967295 then\n         return h.int_range(h.uint32(), hnum, tnum)\n      else\n         -- actually only 53 bits of range, for the usual reasons...\n         -- this will probably do something dumb like segfault if coerced into\n         -- a float\n         return h.int_range(h.uint64(), hnum, tnum)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction hlib.pR_toTok(hParseResult)\n   return ffi.cast(\"HParsedToken *\", hParseResult.ast)\nend\n\n\n\n\n\nfunction hlib.from_binary(bin)\n   error \"NYI: from_binary\"\nend\n\n\n\n\n\n\nfunction hlib.from_hex(hex)\n   error \"NYI: from_hex\"\nend\n\n\n\n\n\n\nfunction hlib.from_wildcard(wildcard)\n   error \"NYI: from_wildcard\"\nend\n\n\n\n\n\n\nfunction hlib.from_base64(base64)\n   error \"NYI: from_base64\"\nend\n\n\n\n\nreturn hlib\n",
},
  { 
vc_hash = "fcd16fdd0c23152903ebd0eb794c70405d202eb9",
name = "gggmeta",
hash = "15a4a4490f3e74d949ed34a3890a3225f28e91b7a42de21d242bcc45870c29b2",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\nlocal Phrase = require \"singletons/phrase\"\nlocal Node = require \"espalier/node\"\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal c_map = {a.fg(1), a.fg(2), a.fg(3), a.fg(4), a.fg(5), a.fg(6)}\nlocal function _G__repr(ggg)\n   local count = 0\n   local g_match = function(str)\n      local match = str\n      if str == \"(\" then\n         count = count + 1\n      end\n      if c_map[count] then\n         match = c_map[count](str)\n      end\n      if str == \")\" then\n         count = count - 1\n      end\n      return match\n   end\n   return tostring(ggg):gsub(\"[%(%)]\", g_match)\nend\nlocal GGGPhrase = Phrase:inherit{ __repr = _G__repr }\n\n\n\n\n\nlocal GGGMetas = Node : inherit \"ggg_metas\"\n\nfunction GGGMetas.toHammer(ggg_metas)\n   error (\"not yet implemented: \" .. ggg_metas.id)\nend\n\nfunction GGGMetas.normalize(ggg_metas)\n   return ggg_metas:span()\nend\n\nfunction GGGMetas.toParseIR(ggg_metas)\n   local phrase = \"(\" .. ggg_metas.id .. GGGPhrase \" \"\n   if #ggg_metas == 0 then\n      return phrase .. \")\"\n   end\n   for i = 1, #ggg_metas - 1 do\n      phrase = phrase .. ggg_metas[i]:toParseIR() .. \" \"\n   end\n   return phrase .. ggg_metas[#ggg_metas] : toParseIR() .. \")\"\nend\n\n\n\n\n\n\nlocal GGG  = { GGGMetas,\n   ggg       = GGGMetas : inherit \"ggg\",\n   rule      = GGGMetas : inherit \"rule\",\n   lhs       = GGGMetas : inherit \"lhs\",\n   rhs       = GGGMetas : inherit \"rhs\",\n   cat       = GGGMetas: inherit \"cat\",\n   regchoice = GGGMetas : inherit \"regchoice\",\n   pegchoice = GGGMetas : inherit \"pegchoice\",\n   alt       = GGGMetas : inherit \"alt\",\n   group     = GGGMetas : inherit \"group\",\n   action    = GGGMetas : inherit \"action\",\n   negativelook = GGGMetas : inherit \"negativelook\",\n   positivelook = GGGMetas : inherit \"positivelook\",\n   negativereg  = GGGMetas : inherit \"negativereg\",\n   many      = GGGMetas : inherit \"many\",\n   oneormore = GGGMetas : inherit \"oneormore\",\n   optional  = GGGMetas : inherit \"optional\",\n   lazymany  = GGGMetas : inherit \"lazymany\",\n   lazyoneormore = GGGMetas : inherit \"lazyoneormore\",\n   range     = GGGMetas : inherit \"range\",\n   wildcard  = GGGMetas : inherit \"wildcard\",\n   binary    = GGGMetas : inherit \"binary\",\n   hex       = GGGMetas : inherit \"hex\",\n   base64    = GGGMetas : inherit \"base64\",\n   litstring = GGGMetas : inherit \"litstring\",\n   litchar      = GGGMetas : inherit \"litchar\",\n   symbol    = GGGMetas : inherit \"symbol\",\n   indent    = GGGMetas : inherit \"indent\",\n}\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = GGGPhrase [[\nlocal h = require \"ggg:hammer\"\nlocal hlib = require \"ggg:hlib\"\n\n]]\n\nfunction GGG.ggg.toHammer(ggg, actions)\n   local phrase = GGGPhrase \"\"\n   actions = actions and (\"--ACTIONS\\n\" .. actions) or \"\"\n   local first_name = ggg : select \"lhs\" () : span()\n   for lhs in ggg:select \"lhs\" do\n      phrase = phrase .. \"local \" .. lhs:span() .. \" = h.indirect()\\n\"\n   end\n   for i, rule in ipairs(ggg) do\n      if rule.toHammer then\n         phrase = phrase .. rule:toHammer()\n      end\n   end\n   phrase = phrase .. \"\\n\" .. \"return \" .. first_name\n   return _PREFACE .. actions .. \"\\n--BODY\\n\" .. phrase\nend\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParser(ggg, actions)\n   actions = actions or \"\"\n   local p_str= actions .. \"\\n\" .. tostring(ggg:toHammer(actions))\n   ggg.parser = loadstring(p_str)()\n   return function(str)\n      return ggg.parser:parse(str)\n   end, GGGPhrase(p_str)\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParseIR(ggg)\n   local phrase = GGGPhrase \"(grammar (rules (\"\n   for _, v in ipairs(ggg) do\n      phrase = phrase .. v:toParseIR() .. \" \"\n   end\n   return phrase .. \")))\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.__call(ggg, str)\n   if not ggg.parser then\n      ggg.parser = loadstring(tostring(ggg:toHammer()))()\n   end\n   return ggg.parser:parse(str)()\nend\n\n\n\n\n\n\nfunction GGG.rule.toHammer(rule)\n   return \"h.bind_indirect(\" .. rule:select \"lhs\" () : span()\n          .. \", \" .. rule:select \"rhs\" () : toHammer() .. GGGPhrase \")\\n\"\nend\n\n\n\n\n\n\nfunction GGG.lhs.toParseIR(lhs)\n   return lhs:span()\nend\n\n\n\n\n\n\nfunction GGG.rhs.toHammer(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toHammer() .. \" \"\n   end\n\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.rhs.toParseIR(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toParseIR()\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.cat.toHammer(cat)\n   local phrase = cat[1]:toHammer()\n   return phrase .. \" * \" .. cat[2]:toHammer()\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.alt.toHammer(alt)\n   local phrase = alt[1]:toHammer()\n   return phrase .. \" + \" .. alt[2]:toHammer()\nend\n\nGGG.pegchoice.toHammer = GGG.alt.toHammer\nGGG.regchoice.toHammer = GGG.alt.toHammer\n\n\n\n\n\n\nfunction GGG.group.toHammer(group)\n   local phrase = GGGPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. sub_group:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.action.toHammer(action)\n   local phrase = GGGPhrase \"/ \"\n   return phrase .. action[1]:span()\nend\n\n\n\n\n\n\nfunction GGG.positivelook.toHammer(poslook)\n   local phrase = GGGPhrase \"#\"\n   for _, sub_look in ipairs(poslook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.negativelook.toHammer(neglook)\n   -- use () to force unary minus\n   local phrase = GGGPhrase \"(-\"\n   for _, sub_look in ipairs(neglook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.many.toHammer(many)\n   local phrase = GGGPhrase \"\"\n   for _, sub_many in ipairs(many) do\n      phrase = phrase .. sub_many:toHammer()\n   end\n   return phrase .. \"^0\"\nend\nGGG.lazymany.toHammer = GGG.many.toHammer\n\n\n\n\nfunction GGG.oneormore.toHammer(more)\n   local phrase = GGGPhrase \"\"\n   for _, sub_more in ipairs(more) do\n      phrase = phrase .. sub_more:toHammer()\n   end\n   return phrase .. \"^1\"\nend\nGGG.lazyoneormore.toHammer = GGG.oneormore.toHammer\n\n\n\nfunction GGG.optional.toHammer(optional)\n   local phrase = GGGPhrase \"\"\n   for _, sub_option in ipairs(optional) do\n      phrase = phrase .. sub_option:toHammer()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\nfunction GGG.range.toHammer(range)\n   local phrase = GGGPhrase \"hlib.from_range(\"\n   phrase = phrase .. \"\'\" .. range[1]:normalize()\n            .. \"\', \'\" .. range[2]:normalize()\n   return phrase .. \"\')\"\nend\n\n\n\n\n\n\nfunction GGG.wildcard.toHammer(wildcard)\n   local phrase = GGGPhrase \"hlib.from_wildcard(\'\"\n   phrase = phrase .. wildcard:span():sub(2) .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.symbol.toHammer(symbol)\n   return GGGPhrase(symbol:span())\nend\n\n\n\n\n\n\nGGG.symbol.toParseIR = GGG.symbol.toHammer\n\n\n\n\n\n\n\n\n\nfunction GGG.litstring.toHammer(str)\n   phrase = GGGPhrase \"h.token(\"\n   phrase = phrase .. str:span() .. \") \"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.litstring.toParseIR(litstring)\n   return \"(literal \" .. litstring:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\nfunction GGG.litchar.toHammer(char)\n   local phrase =  GGGPhrase \"h.token(\'\"\n   phrase = phrase  .. char:select \"utf8\" ():span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.litchar.normalize(char)\n   return \"Â¢\" .. char:select\"utf8\"():span()\nend\n\n\n\n\n\n\nfunction GGG.binary.toHammer(binary)\n   local phrase = GGGPhrase \"hlib.from_binary(\'\"\n   phrase = phrase .. binary:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.binary.toParseIR(binary)\n   return \"(literal \" .. binary:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\nfunction GGG.hex.toHammer(hex)\n   local phrase = GGGPhrase \"hlib.from_hex(\'\"\n   phrase = phrase .. hex:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\nfunction GGG.hex.toParseIR(hex)\n   return \"(literal \" .. hex:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\n\nfunction GGG.base64.toHammer(base64)\n   local phrase = GGGPhrase \"hlib.from_base64(\'\"\n   phrase = phrase .. base64:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.base64.toParseIR(base64)\n   local phrase = GGGPhrase \'(literal (base64 \"\'\n   phrase = phrase .. base64:span():sub(3) -- Â£ is two bytes wide\n   return phrase .. \'\"))\'\n\nend\n\n\n\n\n\n\n\nfunction GGG.indent.toHammer(indent)\n   return indent:span()\nend\nGGG.indent.toParseIR = GGG.indent.toHammer\n\n\n\n\n\n\nGGG.indent.toParseIR = GGG.indent.toHammer\n\n\n\n\n\n\n\nreturn {GGG, GGGPhrase}\n",
},
  { 
vc_hash = "fcd16fdd0c23152903ebd0eb794c70405d202eb9",
name = "ggg",
hash = "4c05e8606bd5843b7408534dff0429911fe61724e6ffd51634a774e325ddea36",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal GGG_M = require \"ggg:gggmeta\"\n\n\n\n\nlocal GGG_str = [[\nggg   â† rule+\nrule  â† _ lhs _ sep _ rhs _ \";\"\n`sep` â† \":=\" / \"=\" / \":\"\nlhs â† letter symbol-valid*\n\nrhs    â† rulexpr\n`rulexpr` â† operations+ / element\n\n`operations` â†  reg-choice / peg-choice / alt / cat / action\n\ncat â† element _ rulexpr\nreg-choice â† element _ \"|\" _ rulexpr\npeg-choice â† element _ \"/\" _ rulexpr\nalt      â† element _ \"Â¦\" _ rulexpr\naction   â† \"[\" _ rulexpr _ atom _ \"]\"\n\n`element`  â† simple / group\ngroup â† \"(\" _ rulexpr _ \")\" _\n\n`simple` â† prefixed / suffixed / atom\n\n`prefixed` â† negativelook / positivelook / negativereg\nnegativelook â† \"Â¿\" _ allowed-prefixed\npositivelook â† \"?\" _ allowed-prefixed\nnegativereg  â† \"!\" _ allowed-prefixed\n`allowed-prefixed` â† group / suffixed / atom\n\n`suffixed` â† many / one-or-more / optional / lazymany / lazyone-or-more\nmany       â† allowed-suffixed _ \"*\"\none-or-more  â† allowed-suffixed _ \"+\"\noptional   â† allowed-suffixed _ \"Â±\"\nlazymany   â† allowed-suffixed _ \"\\\\*\"\nlazyone-or-more â† allowed-suffixed _ \"\\\\+\"\n`allowed-suffixed` â† group / prefixed / atom\n\n`atom`   â† range / wildcard\n         / binary / hex / base64 / litstring / litchar\n         / symbol\n\nbinary   â† \"0b\" (\"0\"/\"1\")+\nhex      â† \"0x\" ([0-9]/[A-F]/[a-f])+\nbase64   â† (\"Â£\"/\"$$\") ([A-Z]/[a-z]/[0-9]/\"+\"/\"-\")+ (\"==\"/\"=\")?\nlitstring â† \"Â«placeholderÂ»\" / jankstring\n`jankstring` â† \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' 1))* \'\"\'\nlitchar  â† (\"Â¢\"/\"\\\\\\\\\") utf8\nutf8 â† 1 ; this should actually match utf8...\n\n\nrange      â† binary \"..\" binary\n           / hex \"..\" hex\n           / litchar \"..\" litchar\nwildcard   â† \"~\" (\"#\"/\",\"/\"0\"/\"1\")+\n\n`_`  â† indent / { \\t}*\nindent â† (\"\\r\"? \"\\n\") { \\t}*\nsymbol â† letter symbol-valid*\n`letter` â† [a-z] / [A-Z]\n`symbol-valid` â† letter / digit / \"_\"\n`digit` â† [0-9]\n]]\n\n\n\n\n\n\nlocal GGG_peg = Peg(GGG_str)\nGGG_peg:toGrammar(GGG_M[1])\n\n\n\n\nreturn GGG_peg\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/femto",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/helm.git",
    home = "",
    website = "",
    name = "helm",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/selection_list",
hash = "ec29851c6044a0899e0fc3c2d85120a122d06c7d9badf4b3ca57039b93be5560",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\nfunction SelectionList.selectNext(list)\n   if list.selected_index < #list then\n      list.selected_index = list.selected_index + 1\n      return true\n   else\n      return false\n   end\nend\n\nfunction SelectionList.selectPrevious(list)\n   if list.selected_index > 1 then\n      list.selected_index = list.selected_index - 1\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\nfunction SelectionList.selectedItem(list)\n   return list[list.selected_index]\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal concat = assert(table.concat)\n\nlocal function _highlight(line, frag, best, max_disp, c)\n   local frag_index = 1\n   -- Collapse multiple spaces into one for display\n   line = line:gsub(\" +\",\" \")\n   local codes = Codepoints(line)\n   local disp = 0\n   local stop_at\n   for i, char in ipairs(codes) do\n      local char_disp = 1\n      if char == \"\\n\" then\n         char = c.stresc .. \"\\\\n\" .. c.base\n         codes[i] = char\n         char_disp =  2\n      end\n      -- Reserve one space for ellipsis unless this is the\n      -- last character on the line\n      local reserved_space = i < #codes and 1 or 0\n      if disp + char_disp + reserved_space > max_disp then\n         char = c.alert(\"â€¦\")\n         codes[i] = char\n         disp = disp + 1\n         stop_at = i\n         break\n      end\n      disp = disp + char_disp\n      if frag_index <= #frag and char == frag:sub(frag_index, frag_index) then\n         local char_color\n         -- highlight the last two differently if this is a\n         -- \'second best\' search\n         if not best and #frag - frag_index < 2 then\n            char_color = c.alert\n         else\n            char_color = c.search_hl\n         end\n         char = char_color .. char .. c.base\n         codes[i] = char\n         frag_index = frag_index + 1\n      end\n   end\n   return c.base(concat(codes, \"\", 1, stop_at)), disp\nend\n\nfunction SelectionList.__repr(list, window, c)\n   assert(c, \"must provide a color table\")\n   if #list == 0 then\n      return c.alert \"No results found\"\n   end\n   local i = 1\n   return function()\n      local line = list[i]\n      local len\n      if line == nil then return nil end\n      line, len = _highlight(line, list.frag, list.best, window.remains - 4, c)\n      if list.show_shortcuts then\n         local alt_seq = \"    \"\n         if i < 10 then\n            alt_seq = c.bold(\"M-\" .. tostring(i) .. \" \")\n         end\n         line = alt_seq .. line\n         len = len + 4\n      end\n      if i == list.selected_index then\n         line = c.highlight(line)\n      end\n      i = i + 1\n      return line, len\n   end\nend\n\n\n\n\n\n\nnew = function()\n   local list = meta(SelectionList)\n   list.selected_index = 0\n   -- list.n = 0\n   return list\nend\n\n\n\nSelectionList.idEst = new\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/repr/names",
hash = "bc359446ba85b8e0d756b64dc539cdf29ac378beb0ebe778664401b9185fb580",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\nlocal Token = require \"helm/repr/token\"\nlocal import = assert(require \"core/module\" . import)\n\n\n\n\n\nlocal names = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anti_G = setmetatable({ _G = \"_G\" }, {__mode = \"k\"})\nnames.all_symbols = { _G = true }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function tie_break(old, new)\n   return #old > #new\nend\n\nlocal isidentifier = import(\"core/string\", \"isidentifier\")\n\nlocal addName, loadNames\n\naddName = function(value, name, aG)\n   local existing = aG[value]\n   if not existing or tie_break(existing, name) then\n      aG[value] = name\n      if type(value) == \"table\" then\n         loadNames(value, name, aG)\n      end\n   end\nend\n\nloadNames = function(tab, prefix, aG)\n   if prefix ~= \"\" then\n      prefix = prefix .. \".\"\n   end\n   aG = aG or anti_G\n   for k, v in pairs(tab) do\n      if type(k) == \"string\" then\n         -- Only add legal identifiers to all_symbols, since this is\n         -- used for autocomplete\n         if isidentifier(k) then\n            names.all_symbols[k] = true\n         end\n      else\n         -- #todo should we put <> around non-identifier strings? I guess\n         -- it seems fine not to, since this is just for display...\n         k = \"<\" .. tostring(k) .. \">\"\n      end\n      local name = prefix .. k\n      local typica = type(v)\n      if typica == \"table\"  or typica == \"function\"\n      or typica == \"thread\" or typica == \"userdata\" then\n         addName(v, name, aG)\n      end\n      local _M = getmetatable(v)\n      if typica == \"table\" and _M then\n         addName(_M, \"âŸ¨\" .. name .. \"âŸ©\", aG)\n      end\n   end\nend\n\nfunction names.addName(value, name)\n   addName(value, name, anti_G)\nend\n\nfunction names.loadNames(tab, prefix)\n   tab = tab or _G\n   prefix = prefix or \"\"\n   loadNames(tab, prefix, anti_G)\nend\n\nfunction names.clearNames()\n   anti_G = {_G = \"_G\"}\n   names.all_symbols = {}\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _rawtostring(val)\n   local ts\n   if type(val) == \"table\" then\n      -- get metatable and check for __tostring\n      local M = getmetatable(val)\n      if M and M.__tostring then\n         -- cache the tostring method and put it back\n         local __tostring = M.__tostring\n         M.__tostring = nil\n         ts = tostring(val)\n         M.__tostring = __tostring\n      end\n   end\n   if not ts then\n      ts = tostring(val)\n   end\n   return ts\nend\n\nfunction names.nameFor(value, c, hint)\n   local str\n   -- Hint provides a means to override the \"type\" of the value,\n   -- to account for cases more specific than mere type\n   local typica = hint or type(value)\n   -- Start with the color corresponding to the type--may be overridden below\n   local color = c[typica]\n   local cfg = {}\n\n   -- Value types are generally represented by their tostring()\n   if typica == \"string\"\n      or typica == \"number\"\n      or typica == \"boolean\"\n      or typica == \"nil\" then\n      str = tostring(value)\n      if typica == \"string\" then\n         cfg.wrappable = true\n      elseif typica == \"boolean\" then\n         color = value and c[\"true\"] or c[\"false\"]\n      end\n      return Token(str, color, cfg)\n   end\n\n   -- For other types, start by looking for a name in anti_G\n   if anti_G[value] then\n      str = anti_G[value]\n      if typica == \"thread\" then\n         -- Prepend coro: even to names from anti_G to more clearly\n         -- distinguish from functions\n         str = \"coro:\" .. str\n      end\n      return Token(str, color, cfg)\n   end\n\n   -- If not found, construct one starting with the tostring()\n   str = _rawtostring(value)\n   if typica == \"metatable\" then\n      str = \"âŸ¨\" .. \"mt:\" .. str:sub(-6) .. \"âŸ©\"\n   elseif typica == \"table\" then\n      str = \"t:\" .. str:sub(-6)\n   elseif typica == \"function\" then\n      local f_label = str:sub(11)\n      str = f_label:sub(1,5) == \"built\"\n                and f_label\n                or \"f:\" .. str:sub(-6)\n   elseif typica == \"thread\" then\n      str = \"coro:\" .. str:sub(-6)\n   elseif typica == \"userdata\" then\n      local name_end = str:find(\":\")\n      if name_end then\n         str = str:sub(1, name_end - 1)\n      end\n   end\n\n   return Token(str, color, cfg)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function c_data(value, str, phrase)\n   --local meta = reflect.getmetatable(value)\n   yield(str, #str)\n   --[[\n   if meta then\n      yield(c.base \" = \", 3)\n      yield_name(meta)\n   end\n   --]]\nend\n\n\n\nreturn names\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/vmdef",
hash = "fe98d9b81afceb8a70bb7604bb0c2503b12679b0dab5ca942605ef50ec8d5279",
branch = "hang-on-exit",
binary = "\n\n\n\n\n-- This is a generated file. DO NOT EDIT!\n\nreturn {\n\nbcnames = \"ISLT  ISGE  ISLE  ISGT  ISEQV ISNEV ISEQS ISNES ISEQN ISNEN ISEQP ISNEP ISTC  ISFC  IST   ISF   ISTYPEISNUM MOV   NOT   UNM   LEN   ADDVN SUBVN MULVN DIVVN MODVN ADDNV SUBNV MULNV DIVNV MODNV ADDVV SUBVV MULVV DIVVV MODVV POW   CAT   KSTR  KCDATAKSHORTKNUM  KPRI  KNIL  UGET  USETV USETS USETN USETP UCLO  FNEW  TNEW  TDUP  GGET  GSET  TGETV TGETS TGETB TGETR TSETV TSETS TSETB TSETM TSETR CALLM CALL  CALLMTCALLT ITERC ITERN VARG  ISNEXTRETM  RET   RET0  RET1  FORI  JFORI FORL  IFORL JFORL ITERL IITERLJITERLLOOP  ILOOP JLOOP JMP   FUNCF IFUNCFJFUNCFFUNCV IFUNCVJFUNCVFUNCC FUNCCW\",\n\nirnames = \"LT    GE    LE    GT    ULT   UGE   ULE   UGT   EQ    NE    ABC   RETF  NOP   BASE  PVAL  GCSTEPHIOP  LOOP  USE   PHI   RENAMEPROF  KPRI  KINT  KGC   KPTR  KKPTR KNULL KNUM  KINT64KSLOT BNOT  BSWAP BAND  BOR   BXOR  BSHL  BSHR  BSAR  BROL  BROR  ADD   SUB   MUL   DIV   MOD   POW   NEG   ABS   ATAN2 LDEXP MIN   MAX   FPMATHADDOV SUBOV MULOV AREF  HREFK HREF  NEWREFUREFO UREFC FREF  STRREFLREF  ALOAD HLOAD ULOAD FLOAD XLOAD SLOAD VLOAD ASTOREHSTOREUSTOREFSTOREXSTORESNEW  XSNEW TNEW  TDUP  CNEW  CNEWI BUFHDRBUFPUTBUFSTRTBAR  OBAR  XBAR  CONV  TOBIT TOSTR STRTO CALLN CALLA CALLL CALLS CALLXSCARG  \",\n\nirfpm = { [0]=\"floor\", \"ceil\", \"trunc\", \"sqrt\", \"exp\", \"exp2\", \"log\", \"log2\", \"log10\", \"sin\", \"cos\", \"tan\", \"other\", },\n\nirfield = { [0]=\"str.len\", \"func.env\", \"func.pc\", \"func.ffid\", \"thread.env\", \"tab.meta\", \"tab.array\", \"tab.node\", \"tab.asize\", \"tab.hmask\", \"tab.nomm\", \"udata.meta\", \"udata.udtype\", \"udata.file\", \"cdata.ctypeid\", \"cdata.ptr\", \"cdata.int\", \"cdata.int64\", \"cdata.int64_4\", },\n\nircall = {\n[0]=\"lj_str_cmp\",\n\"lj_str_find\",\n\"lj_str_new\",\n\"lj_strscan_num\",\n\"lj_strfmt_int\",\n\"lj_strfmt_num\",\n\"lj_strfmt_char\",\n\"lj_strfmt_putint\",\n\"lj_strfmt_putnum\",\n\"lj_strfmt_putquoted\",\n\"lj_strfmt_putfxint\",\n\"lj_strfmt_putfnum_int\",\n\"lj_strfmt_putfnum_uint\",\n\"lj_strfmt_putfnum\",\n\"lj_strfmt_putfstr\",\n\"lj_strfmt_putfchar\",\n\"lj_buf_putmem\",\n\"lj_buf_putstr\",\n\"lj_buf_putchar\",\n\"lj_buf_putstr_reverse\",\n\"lj_buf_putstr_lower\",\n\"lj_buf_putstr_upper\",\n\"lj_buf_putstr_rep\",\n\"lj_buf_puttab\",\n\"lj_buf_tostr\",\n\"lj_tab_new_ah\",\n\"lj_tab_new1\",\n\"lj_tab_dup\",\n\"lj_tab_clear\",\n\"lj_tab_newkey\",\n\"lj_tab_len\",\n\"lj_gc_step_jit\",\n\"lj_gc_barrieruv\",\n\"lj_mem_newgco\",\n\"lj_math_random_step\",\n\"lj_vm_modi\",\n\"sinh\",\n\"cosh\",\n\"tanh\",\n\"fputc\",\n\"fwrite\",\n\"fflush\",\n\"lj_vm_floor\",\n\"lj_vm_ceil\",\n\"lj_vm_trunc\",\n\"sqrt\",\n\"exp\",\n\"lj_vm_exp2\",\n\"log\",\n\"lj_vm_log2\",\n\"log10\",\n\"sin\",\n\"cos\",\n\"tan\",\n\"lj_vm_powi\",\n\"pow\",\n\"atan2\",\n\"ldexp\",\n\"lj_vm_tobit\",\n\"softfp_add\",\n\"softfp_sub\",\n\"softfp_mul\",\n\"softfp_div\",\n\"softfp_cmp\",\n\"softfp_i2d\",\n\"softfp_d2i\",\n\"lj_vm_sfmin\",\n\"lj_vm_sfmax\",\n\"lj_vm_tointg\",\n\"softfp_ui2d\",\n\"softfp_f2d\",\n\"softfp_d2ui\",\n\"softfp_d2f\",\n\"softfp_i2f\",\n\"softfp_ui2f\",\n\"softfp_f2i\",\n\"softfp_f2ui\",\n\"fp64_l2d\",\n\"fp64_ul2d\",\n\"fp64_l2f\",\n\"fp64_ul2f\",\n\"fp64_d2l\",\n\"fp64_d2ul\",\n\"fp64_f2l\",\n\"fp64_f2ul\",\n\"lj_carith_divi64\",\n\"lj_carith_divu64\",\n\"lj_carith_modi64\",\n\"lj_carith_modu64\",\n\"lj_carith_powi64\",\n\"lj_carith_powu64\",\n\"lj_cdata_newv\",\n\"lj_cdata_setfin\",\n\"strlen\",\n\"memcpy\",\n\"memset\",\n\"lj_vm_errno\",\n\"lj_carith_mul64\",\n\"lj_carith_shl64\",\n\"lj_carith_shr64\",\n\"lj_carith_sar64\",\n\"lj_carith_rol64\",\n\"lj_carith_ror64\",\n},\n\ntraceerr = {\n[0]=\"error thrown or hook called during recording\",\n\"trace too short\",\n\"trace too long\",\n\"trace too deep\",\n\"too many snapshots\",\n\"blacklisted\",\n\"retry recording\",\n\"NYI: bytecode %d\",\n\"leaving loop in root trace\",\n\"inner loop in root trace\",\n\"loop unroll limit reached\",\n\"bad argument type\",\n\"JIT compilation disabled for function\",\n\"call unroll limit reached\",\n\"down-recursion, restarting\",\n\"NYI: unsupported variant of FastFunc %s\",\n\"NYI: return to lower frame\",\n\"store with nil or NaN key\",\n\"missing metamethod\",\n\"looping index lookup\",\n\"NYI: mixed sparse/dense table\",\n\"symbol not in cache\",\n\"NYI: unsupported C type conversion\",\n\"NYI: unsupported C function type\",\n\"guard would always fail\",\n\"too many PHIs\",\n\"persistent type instability\",\n\"failed to allocate mcode memory\",\n\"machine code too long\",\n\"hit mcode limit (retrying)\",\n\"too many spill slots\",\n\"inconsistent register allocation\",\n\"NYI: cannot assemble IR instruction %d\",\n\"NYI: PHI shuffling too complex\",\n\"NYI: register coalescing too complex\",\n},\n\nffnames = {\n[0]=\"Lua\",\n\"C\",\n\"assert\",\n\"type\",\n\"next\",\n\"pairs\",\n\"ipairs_aux\",\n\"ipairs\",\n\"getmetatable\",\n\"setmetatable\",\n\"getfenv\",\n\"setfenv\",\n\"rawget\",\n\"rawset\",\n\"rawequal\",\n\"unpack\",\n\"select\",\n\"tonumber\",\n\"tostring\",\n\"error\",\n\"pcall\",\n\"xpcall\",\n\"loadfile\",\n\"load\",\n\"loadstring\",\n\"dofile\",\n\"gcinfo\",\n\"collectgarbage\",\n\"newproxy\",\n\"print\",\n\"coroutine.status\",\n\"coroutine.running\",\n\"coroutine.isyieldable\",\n\"coroutine.create\",\n\"coroutine.yield\",\n\"coroutine.resume\",\n\"coroutine.wrap_aux\",\n\"coroutine.wrap\",\n\"math.abs\",\n\"math.floor\",\n\"math.ceil\",\n\"math.sqrt\",\n\"math.log10\",\n\"math.exp\",\n\"math.sin\",\n\"math.cos\",\n\"math.tan\",\n\"math.asin\",\n\"math.acos\",\n\"math.atan\",\n\"math.sinh\",\n\"math.cosh\",\n\"math.tanh\",\n\"math.frexp\",\n\"math.modf\",\n\"math.log\",\n\"math.atan2\",\n\"math.pow\",\n\"math.fmod\",\n\"math.ldexp\",\n\"math.min\",\n\"math.max\",\n\"math.random\",\n\"math.randomseed\",\n\"bit.tobit\",\n\"bit.bnot\",\n\"bit.bswap\",\n\"bit.lshift\",\n\"bit.rshift\",\n\"bit.arshift\",\n\"bit.rol\",\n\"bit.ror\",\n\"bit.band\",\n\"bit.bor\",\n\"bit.bxor\",\n\"bit.tohex\",\n\"string.byte\",\n\"string.char\",\n\"string.sub\",\n\"string.rep\",\n\"string.reverse\",\n\"string.lower\",\n\"string.upper\",\n\"string.dump\",\n\"string.find\",\n\"string.match\",\n\"string.gmatch_aux\",\n\"string.gmatch\",\n\"string.gsub\",\n\"string.format\",\n\"table.maxn\",\n\"table.insert\",\n\"table.concat\",\n\"table.sort\",\n\"table.new\",\n\"table.clear\",\n\"io.method.close\",\n\"io.method.read\",\n\"io.method.write\",\n\"io.method.flush\",\n\"io.method.seek\",\n\"io.method.setvbuf\",\n\"io.method.lines\",\n\"io.method.__gc\",\n\"io.method.__tostring\",\n\"io.open\",\n\"io.popen\",\n\"io.tmpfile\",\n\"io.close\",\n\"io.read\",\n\"io.write\",\n\"io.flush\",\n\"io.input\",\n\"io.output\",\n\"io.lines\",\n\"io.type\",\n\"os.execute\",\n\"os.remove\",\n\"os.rename\",\n\"os.tmpname\",\n\"os.getenv\",\n\"os.exit\",\n\"os.clock\",\n\"os.date\",\n\"os.time\",\n\"os.difftime\",\n\"os.setlocale\",\n\"debug.getregistry\",\n\"debug.getmetatable\",\n\"debug.setmetatable\",\n\"debug.getfenv\",\n\"debug.setfenv\",\n\"debug.getinfo\",\n\"debug.getlocal\",\n\"debug.setlocal\",\n\"debug.getupvalue\",\n\"debug.setupvalue\",\n\"debug.upvalueid\",\n\"debug.upvaluejoin\",\n\"debug.sethook\",\n\"debug.gethook\",\n\"debug.debug\",\n\"debug.traceback\",\n\"jit.on\",\n\"jit.off\",\n\"jit.flush\",\n\"jit.status\",\n\"jit.attach\",\n\"jit.util.funcinfo\",\n\"jit.util.funcbc\",\n\"jit.util.funck\",\n\"jit.util.funcuvname\",\n\"jit.util.traceinfo\",\n\"jit.util.traceir\",\n\"jit.util.tracek\",\n\"jit.util.tracesnap\",\n\"jit.util.tracemc\",\n\"jit.util.traceexitstub\",\n\"jit.util.ircalladdr\",\n\"jit.opt.start\",\n\"jit.profile.start\",\n\"jit.profile.stop\",\n\"jit.profile.dumpstack\",\n\"ffi.meta.__index\",\n\"ffi.meta.__newindex\",\n\"ffi.meta.__eq\",\n\"ffi.meta.__len\",\n\"ffi.meta.__lt\",\n\"ffi.meta.__le\",\n\"ffi.meta.__concat\",\n\"ffi.meta.__call\",\n\"ffi.meta.__add\",\n\"ffi.meta.__sub\",\n\"ffi.meta.__mul\",\n\"ffi.meta.__div\",\n\"ffi.meta.__mod\",\n\"ffi.meta.__pow\",\n\"ffi.meta.__unm\",\n\"ffi.meta.__tostring\",\n\"ffi.meta.__pairs\",\n\"ffi.meta.__ipairs\",\n\"ffi.clib.__index\",\n\"ffi.clib.__newindex\",\n\"ffi.clib.__gc\",\n\"ffi.callback.free\",\n\"ffi.callback.set\",\n\"ffi.cdef\",\n\"ffi.new\",\n\"ffi.cast\",\n\"ffi.typeof\",\n\"ffi.typeinfo\",\n\"ffi.istype\",\n\"ffi.sizeof\",\n\"ffi.alignof\",\n\"ffi.offsetof\",\n\"ffi.errno\",\n\"ffi.string\",\n\"ffi.copy\",\n\"ffi.fill\",\n\"ffi.abi\",\n\"ffi.metatype\",\n\"ffi.gc\",\n\"ffi.load\",\n},\n\n}\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/repr",
hash = "2c782801f8a255171f87d5cd62228f833facfe46bfc1f5e496f6c81da22f9e92",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal C = require \"singletons/color\"\nlocal Composer = require \"helm/repr/composer\"\nlocal tabulate = require \"helm/repr/tabulate\"\n\nlocal concat = assert(table.concat)\n\n\n\n\n\n\n\nlocal repr = {}\n\n\n\n\n\n\n\n\n\n\nfunction repr.lineGen(tab, disp_width, color)\n   color = color or C.color\n   local generator = Composer(tabulate)\n   return generator(tab, disp_width, color)\nend\n\nfunction repr.lineGenBW(tab, disp_width)\n   return repr.lineGen(tab, disp_width, C.no_color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction repr.ts(val, disp_width, color)\n   local phrase = {}\n   for line in repr.lineGen(val, disp_width, color or C.no_color) do\n      phrase[#phrase + 1] = line\n   end\n   return concat(phrase, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\nfunction repr.ts_color(val, disp_width, color)\n   return repr.ts(val, disp_width, color or C.color)\nend\n\n\n\nreturn repr\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/page",
hash = "69b01178c946d84ab527b8a5202ee63f26d9252e16125cfdf5d589af604605f2",
branch = "hang-on-exit",
binary = "\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal RagaBase = require \"helm:helm/raga/base\"\n\n\n\nlocal Page = clone(RagaBase, 2)\n\nPage.name = \"page\"\nPage.prompt_char = \"â“\"\n\nlocal alias = require \"helm/raga/aliaser\" (Page)\n\n\n\n\n\n\n\n\nlocal function toZone(fn)\n   return function(modeS, category, value)\n      return modeS.zones.popup[fn](modeS.zones.popup)\n   end\nend\n\n\n\n\n\nalias{ toZone \"scrollDown\",\n       NAV   = {\"DOWN\", \"SHIFT_DOWN\", \"RETURN\"},\n       ASCII = {\"e\", \"j\"},\n       CTRL  = {\"^N\", \"^E\", \"^J\"} }\n\nalias{ toZone \"scrollUp\",\n       NAV   = {\"UP\", \"SHIFT_UP\", \"SHIFT_RETURN\"},\n       ASCII = {\"y\", \"k\"},\n       CTRL  = {\"^Y\", \"^P\", \"^K\"} }\n\nalias{ toZone \"pageDown\",\n       NAV   = {\"PAGE_DOWN\"},\n       ASCII = {\" \", \"f\"},\n       CTRL  = {\"^V\", \"^F\"} }\nalias{ toZone \"pageUp\",\n       NAV   = {\"PAGE_UP\"},\n       ASCII = {\"b\"},\n       CTRL  = {\"^B\"} }\n\nalias{ toZone \"halfPageDown\",\n       ASCII = {\"d\"},\n       CTRL  = {\"^D\"} }\nalias{ toZone \"halfPageUp\",\n       ASCII = {\"u\"},\n       CTRL  = {\"^U\"} }\n\nalias{ toZone \"scrollToTop\",\n       NAV   = {\"HOME\"},\n       ASCII = {\"g\", \"<\"} }\nalias{ toZone \"scrollToBottom\",\n       NAV   = {\"END\"},\n       ASCII = {\"G\", \">\"} }\n\n\n\n\nlocal function _quit(modeS)\n   -- #todo should have a stack of ragas and switch back to the one\n   -- we entered from, but this will do for now\n   modeS.shift_to = \"nerf\"\nend\n\nalias{_quit, NAV = {\"ESC\"}, ASCII = {\"q\"} }\n\n\n\n\n\nfunction Page.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.zones.popup:scrollUp()\n      elseif value.button == \"MB1\" then\n         modeS.zones.popup:scrollDown()\n      end\n   end\nend\n\n\n\n\n\n\n\n\nfunction Page.onShift(modeS)\n   modeS.zones.popup:show()\nend\nfunction Page.onUnshift(modeS)\n   modeS.zones.popup:hide()\nend\n\n\n\nreturn Page\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/repr/composer",
hash = "e2341b205b3cbc13fc9c8116d7e32794bef0c02ef67af91a769b034e7dc679cc",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core/meta\" . meta\nlocal Token = require \"helm/repr/token\"\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\n\nlocal Composer = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\nfunction Composer.indent(composer)\n   -- If the first token is the second half of a wrap,\n   -- we won\'t include any indentation\n   if composer.pos > 0 and composer[1].wrapped then return 0 end\n   return 2 * composer.level\nend\n\n\n\n\n\n\n\n\nfunction Composer.disp(composer)\n   local disp = composer:indent()\n   for i = 1, composer.pos do\n      disp = disp + composer[i].total_disp\n   end\n   return disp\nend\n\n\n\n\n\n\n\nfunction Composer.remains(composer)\n   return composer.width - composer:disp()\nend\n\n\n\n\n\n\n\n\nfunction Composer.peek(composer)\n   if composer.more and not composer[composer.pos + 1] then\n      composer[composer.pos + 1] = composer.token_source()\n   end\n   if not composer[composer.pos + 1] then\n      composer.more = false\n   end\n   return composer[composer.pos + 1]\nend\n\n\n\n\n\n\n\n\n\n\nfunction Composer.advance(composer)\n   local token = composer:peek()\n   if token then\n      composer.pos = composer.pos + 1\n   end\n   return token, composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\nlocal STAGED_EVENTS = {\n   array = true,\n   map = true\n}\n\nfunction Composer.checkPushStage(composer)\n   local token = composer[composer.pos]\n   if STAGED_EVENTS[token.event] then\n      insert(composer.stages, {\n         start_token = token,\n         event = token.event,\n         long = false })\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Composer.checkPopStage(composer)\n   local token = composer[composer.pos]\n   if token.event == \"end\" then\n      local next_token = composer:peek()\n      -- If the following token is a separator, don\'t end the stage here...\n      if not (next_token and next_token.event == \"sep\") then\n         remove(composer.stages)\n      end\n   elseif token.event == \"sep\" then\n      local prev = composer[composer.pos - 1]\n      -- ...because, if we encounter a separator and the *previous* token\n      -- is an =end=, *now* it\'s time to end the stage\n      if prev and prev.event == \"end\" then\n         remove(composer.stages)\n      end\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\nfunction Composer.enterLongMode(composer)\n   for i = 1, composer.level do\n      assert(composer.stages[i].long,\n         \"Cannot print a long stage inside a short one\")\n   end\n   local long_stage_index = composer.level\n   local stage\n   repeat\n      long_stage_index = long_stage_index + 1\n      stage = composer.stages[long_stage_index]\n      assert(stage, \"No new stage to put in long mode\")\n   until not stage.long\n   stage.long = true\n   for i = long_stage_index + 1, #composer.stages do\n      composer.stages[i] = nil\n   end\n   for i, token in ipairs(composer) do\n      if token == stage.start_token then\n         composer.pos = i\n         return token, composer.stages[#composer.stages]\n      end\n   end\n   error(\"Could not find start of stage\")\nend\n\n\n\n\n\n\n\n\nfunction Composer.emit(composer)\n   if composer.pos == 0 then\n      return nil\n   end\n   local output = { (\" \"):rep(composer:indent()) }\n   for i = 1, composer.pos do\n      insert(output, composer[i]:toString(composer.color))\n   end\n   -- Erase what we just copied to the output and shift\n   -- any remaining tokens back\n   for i = 1, #composer do\n      if i > composer.pos then\n         composer[i - composer.pos] = composer[i]\n      end\n      composer[i] = nil\n   end\n   composer.pos = 0\n   composer.level = #composer.stages\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\nlocal function errLine(...)\n   io.stderr:write(format(...))\n   io.stderr:write(\"\\n\")\n   io.stderr:flush()\nend\nfunction Composer.logDebugInfo(composer)\n   errLine(\"STAGES (level = %d):\", composer.level)\n   for i = 0, #composer.stages do\n      local stage = composer.stages[i]\n      errLine(\"%d: %s (%s)%s\",\n         i,\n         stage.event,\n         stage.long and \"long\" or \"short\",\n         i == composer.level and \" <- LEVEL\" or \"\")\n   end\n   errLine((\"-\"):rep(40))\n   errLine(\"TOKENS (width = %d, disp = %d, remains = %d):\",\n      composer.width, composer:disp(), composer:remains())\n   for i, token in ipairs(composer) do\n      errLine(\"%02d   %s%s\",\n         token.total_disp, tostring(token),\n         i == composer.pos and \" <- POS\" or \"\")\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal MIN_SPLIT_WIDTH = 20\n\nfunction Composer.splitToken(composer, token)\n   local token = composer[composer.pos]\n   -- Step back one token to exclude the one we\'re about to split\n   composer.pos = composer.pos - 1\n   -- Reserve one space for the ~ indicating a wrapped line\n   local remaining = composer:remains() - 1\n   token.wrapped = true\n   -- Only split strings, and only if they\'re long enough to be worth it\n   -- In the extreme event that a non-string token is longer than the\n   -- entire available width, split it too to avoid an infinite loop\n   if token.wrappable and token.total_disp > MIN_SPLIT_WIDTH\n      or token.total_disp >= composer.width then\n      token = token:split(remaining)\n      -- Pad with spaces if we were forced to split a couple chars short\n      for i = 1, remaining - token.total_disp do\n         token:insert(\" \")\n      end\n   -- Short strings and other token types just get bumped to the next line\n   else\n      token = Token((\" \"):rep(remaining), composer.color.no_color)\n   end\n   -- Done splitting, step forward again\n   composer.pos = composer.pos + 1\n   insert(composer, composer.pos, token)\n   -- Leave the ~ ready to be consumed by the next advance()--we need to finish\n   -- processing the first half of the split first.\n   insert(composer, composer.pos + 1, Token(\"~\", composer.color.alert, { event = \"break\" }))\n   return token\nend\n\n\n\n\n\nfunction Composer.isReadyToEmit(composer)\n   local token, stage = composer[composer.pos], composer.stages[#composer.stages]\n   -- It\'s a forced break, obviously end of line\n   if token:isForceBreak() then return true end\n   -- We\'re in short mode, so no other break conditions are possible\n   if not stage.long then return false end\n   -- Break on separators, which includes after the arrow in a metatable\n   -- and after the metatable itself\n   if token.event == \"sep\" then return true end\n   -- At this point, the only possible place to break is after an opening brace\n   if token ~= stage.start_token then return false end\n   -- But not after the very outermost opening brace\n   if #composer.stages == 1 then return false end\n   -- Nor if the table has a metatable\n   local next_token = composer:peek()\n   if next_token and next_token.event == \"metatable\" then return false end\n   -- Nor after the opening brace *of* a metatable\n   local prev_token = composer[composer.pos - 1]\n   if prev_token and prev_token.event == \"metatable\" then return false end\n   -- Okay, we\'ve run the gauntlet, yes, this is a good place to stop\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.composeLine(composer)\n   repeat\n      local token = composer:advance()\n      if not token then break end\n\n      local stage = composer:checkPushStage()\n      if not stage then\n         error(\"No stage while processing: \" .. tostring(token))\n      end\n\n      if token:isForceBreak() and not stage.long then\n         token, stage = composer:enterLongMode()\n      end\n      -- If we know we are going to end the line after this token no matter\n      -- what, we can allow it to exactly fill the line--no need to reserve\n      -- space for a ~. We can also ignore any trailing spaces it may contain.\n      -- Note, we don\'t want to mess with repr lines here.\n      local reserved_space = 1\n      if composer:isReadyToEmit() and token.event ~= \"repr_line\" then\n         token:removeTrailingSpaces()\n         reserved_space = 0\n      end\n      if composer:remains() < reserved_space then\n         assert(token.event ~= \"break\", \"~ token overflowing line\")\n         if not stage.long then\n            token, stage = composer:enterLongMode()\n         -- Never wrap output from __repr--likely to do more harm than good\n         -- until/unless we can parse out color escape sequences\n         elseif token.event ~= \"repr_line\" then\n            token = composer:splitToken()\n         end\n      end\n      stage = composer:checkPopStage()\n   until composer:isReadyToEmit()\n   return composer:emit()\nend\n\nComposer.__call = Composer.composeLine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set\"\nlocal FUNCTION_WINDOWS = Set{ \"remains\", \"case\" }\nlocal FIELD_WINDOWS = Set{ \"width\", \"color\" }\nlocal VALUE_WINDOWS = Set{ \"depth\", \"cycle\" }\n\nlocal function make_window__index(composer, field)\n   return function(window, field)\n      if FIELD_WINDOWS[field] then\n         return composer[field]\n      elseif FUNCTION_WINDOWS[field] then\n         return composer[field](composer)\n      elseif VALUE_WINDOWS[field] then\n         return rawget(window, field)\n      else\n         error (\"window has no method \" .. field .. \"n\" .. debug.traceback())\n      end\n   end\nend\n\nlocal function _window__newindex(window, key, value)\n   if VALUE_WINDOWS[key] then\n      rawset(window, key, value)\n   else\n      error(tostring(key) .. \" = \" .. tostring(value) ..\n         \": not a writable field on window\\n\" .. debug.traceback())\n   end\nend\n\nfunction Composer.window(composer)\n   local window = setmetatable({}, { __index = make_window__index(composer),\n      __newindex = _window__newindex})\n   return window\nend\n\n\n\n\n\n\nlocal function new(iter_gen, cfg)\n   cfg = cfg or {}\n   local function generator(val, disp_width, color)\n      assert(color, \"Must provide a color table to Composer\")\n      local width = disp_width or 80\n      local composer = setmetatable({\n         color = color,\n         width = width,\n         more = true,\n         pos = 0,\n         stages = {[0] = { long = true }},\n         level = 0,\n         long = false\n      }, Composer)\n      for k,v in pairs(cfg) do\n        composer[k] = v\n      end\n      composer.token_source = iter_gen(val, composer:window(), color)\n      return composer\n   end\n   return generator\nend\n\nComposer.idEst = new\n\nreturn new\n\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/reflect",
hash = "52e9f4c89778a3705d4a6d8cc953dde24b0752536564dfdf75413e78f1b01c08",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ffi = require \"ffi\"\nlocal bit = require \"bit\"\nlocal reflect = {}\n\nlocal CTState, init_CTState\nlocal miscmap, init_miscmap\n\nlocal function gc_str(gcref) -- Convert a GCref (to a GCstr) into a string\n  if gcref ~= 0 then\n    local ts = ffi.cast(\"uint32_t*\", gcref)\n    return ffi.string(ts + 4, ts[3])\n  end\nend\n\nlocal typeinfo = rawget(ffi, \"typeinfo\")\n\ntypeinfo = typeinfo or function(id)\n  -- ffi.typeof is present in LuaJIT v2.1 since 8th Oct 2014 (d6ff3afc)\n  -- this is an emulation layer for older versions of LuaJIT\n  local ctype = (CTState or init_CTState()).tab[id]\n  return {\n    info = ctype.info,\n    size = bit.bnot(ctype.size) ~= 0 and ctype.size,\n    sib = ctype.sib ~= 0 and ctype.sib,\n    name = gc_str(ctype.name),\n  }\nend\n\nlocal function memptr(gcobj)\n  return tonumber(tostring(gcobj):match\"%x*$\", 16)\nend\n\ninit_CTState = function()\n  -- Relevant minimal definitions from lj_ctype.h\n  ffi.cdef [[\n    typedef struct CType {\n      uint32_t info;\n      uint32_t size;\n      uint16_t sib;\n      uint16_t next;\n      uint32_t name;\n    } CType;\n\n    typedef struct CTState {\n      CType *tab;\n      uint32_t top;\n      uint32_t sizetab;\n      void *L;\n      void *g;\n      void *finalizer;\n      void *miscmap;\n    } CTState;\n  ]]\n\n  -- Acquire a pointer to this Lua universe\'s CTState\n  local co = coroutine.create(function()end) -- Any live coroutine will do.\n  local uint32_ptr = ffi.typeof(\"uint32_t*\")\n  local G = ffi.cast(uint32_ptr, ffi.cast(uint32_ptr, memptr(co))[2])\n  -- In global_State, `MRef ctype_state` is immediately before `GCRef gcroot[GCROOT_MAX]`.\n  -- We first find (an entry in) gcroot by looking for a metamethod name string.\n  local anchor = ffi.cast(\"uint32_t\", ffi.cast(\"const char*\", \"__index\"))\n  local i = 0\n  while math.abs(tonumber(G[i] - anchor)) > 64 do\n    i = i + 1\n  end\n  -- We then work backwards looking for something resembling ctype_state.\n  repeat\n    i = i - 1\n    CTState = ffi.cast(\"CTState*\", G[i])\n  until ffi.cast(uint32_ptr, CTState.g) == G\n\n  return CTState\nend\n\ninit_miscmap = function()\n  -- Acquire the CTState\'s miscmap table as a Lua variable\n  local t = {}; t[0] = t\n  local tvalue = ffi.cast(\"uint32_t*\", memptr(t))[2]\n  ffi.cast(\"uint32_t*\", tvalue)[ffi.abi\"le\" and 0 or 1] = ffi.cast(\"uint32_t\", ffi.cast(\"uintptr_t\", (CTState or init_CTState()).miscmap))\n  miscmap = t[0]\n  return miscmap\nend\n\n-- Information for unpacking a `struct CType`.\n-- One table per CT_* constant, containing:\n-- * A name for that CT_\n-- * Roles of the cid and size fields.\n-- * Whether the sib field is meaningful.\n-- * Zero or more applicable boolean flags.\nlocal CTs = {[0] =\n  {\"int\",\n    \"\", \"size\", false,\n    {0x08000000, \"bool\"},\n    {0x04000000, \"float\", \"subwhat\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n    {0x00400000, \"long\"},\n  },\n  {\"struct\",\n    \"\", \"size\", true,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"union\", \"subwhat\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"ptr\",\n    \"element_type\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"ref\", \"subwhat\"},\n  },\n  {\"array\",\n    \"element_type\", \"size\", false,\n    {0x08000000, \"vector\"},\n    {0x04000000, \"complex\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"void\",\n    \"\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n  },\n  {\"enum\",\n    \"type\", \"size\", true,\n  },\n  {\"func\",\n    \"return_type\", \"nargs\", true,\n    {0x00800000, \"vararg\"},\n    {0x00400000, \"sse_reg_params\"},\n  },\n  {\"typedef\", -- Not seen\n    \"element_type\", \"\", false,\n  },\n  {\"attrib\", -- Only seen internally\n    \"type\", \"value\", true,\n  },\n  {\"field\",\n    \"type\", \"offset\", true,\n  },\n  {\"bitfield\",\n    \"\", \"offset\", true,\n    {0x08000000, \"bool\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n  },\n  {\"constant\",\n    \"type\", \"value\", true,\n    {0x02000000, \"const\"},\n  },\n  {\"extern\", -- Not seen\n    \"CID\", \"\", true,\n  },\n  {\"kw\", -- Not seen\n    \"TOK\", \"size\",\n  },\n}\n\n-- Set of CType::cid roles which are a CTypeID.\nlocal type_keys = {\n  element_type = true,\n  return_type = true,\n  value_type = true,\n  type = true,\n}\n\n-- Create a metatable for each CT.\nlocal metatables = {\n}\nfor _, CT in ipairs(CTs) do\n  local what = CT[1]\n  local mt = {__index = {}}\n  metatables[what] = mt\nend\n\n-- Logic for merging an attribute CType onto the annotated CType.\nlocal CTAs = {[0] =\n  function(a, refct) error(\"TODO: CTA_NONE\") end,\n  function(a, refct) error(\"TODO: CTA_QUAL\") end,\n  function(a, refct)\n    a = 2^a.value\n    refct.alignment = a\n    refct.attributes.align = a\n  end,\n  function(a, refct)\n    refct.transparent = true\n    refct.attributes.subtype = refct.typeid\n  end,\n  function(a, refct) refct.sym_name = a.name end,\n  function(a, refct) error(\"TODO: CTA_BAD\") end,\n}\n\n-- C function calling conventions (CTCC_* constants in lj_refct.h)\nlocal CTCCs = {[0] =\n  \"cdecl\",\n  \"thiscall\",\n  \"fastcall\",\n  \"stdcall\",\n}\n\nlocal function refct_from_id(id) -- refct = refct_from_id(CTypeID)\n  local ctype = typeinfo(id)\n  local CT_code = bit.rshift(ctype.info, 28)\n  local CT = CTs[CT_code]\n  local what = CT[1]\n  local refct = setmetatable({\n    what = what,\n    typeid = id,\n    name = ctype.name,\n  }, metatables[what])\n\n  -- Interpret (most of) the CType::info field\n  for i = 5, #CT do\n    if bit.band(ctype.info, CT[i][1]) ~= 0 then\n      if CT[i][3] == \"subwhat\" then\n        refct.what = CT[i][2]\n      else\n        refct[CT[i][2]] = true\n      end\n    end\n  end\n  if CT_code <= 5 then\n    refct.alignment = bit.lshift(1, bit.band(bit.rshift(ctype.info, 16), 15))\n  elseif what == \"func\" then\n    refct.convention = CTCCs[bit.band(bit.rshift(ctype.info, 16), 3)]\n  end\n\n  if CT[2] ~= \"\" then -- Interpret the CType::cid field\n    local k = CT[2]\n    local cid = bit.band(ctype.info, 0xffff)\n    if type_keys[k] then\n      if cid == 0 then\n        cid = nil\n      else\n        cid = refct_from_id(cid)\n      end\n    end\n    refct[k] = cid\n  end\n\n  if CT[3] ~= \"\" then -- Interpret the CType::size field\n    local k = CT[3]\n    refct[k] = ctype.size or (k == \"size\" and \"none\")\n  end\n\n  if what == \"attrib\" then\n    -- Merge leading attributes onto the type being decorated.\n    local CTA = CTAs[bit.band(bit.rshift(ctype.info, 16), 0xff)]\n    if refct.type then\n      local ct = refct.type\n      ct.attributes = {}\n      CTA(refct, ct)\n      ct.typeid = refct.typeid\n      refct = ct\n    else\n      refct.CTA = CTA\n    end\n  elseif what == \"bitfield\" then\n    -- Decode extra bitfield fields, and make it look like a normal field.\n    refct.offset = refct.offset + bit.band(ctype.info, 127) / 8\n    refct.size = bit.band(bit.rshift(ctype.info, 8), 127) / 8\n    refct.type = {\n      what = \"int\",\n      bool = refct.bool,\n      const = refct.const,\n      volatile = refct.volatile,\n      unsigned = refct.unsigned,\n      size = bit.band(bit.rshift(ctype.info, 16), 127),\n    }\n    refct.bool, refct.const, refct.volatile, refct.unsigned = nil\n  end\n\n  if CT[4] then -- Merge sibling attributes onto this type.\n    while ctype.sib do\n      local entry = typeinfo(ctype.sib)\n      if CTs[bit.rshift(entry.info, 28)][1] ~= \"attrib\" then break end\n      if bit.band(entry.info, 0xffff) ~= 0 then break end\n      local sib = refct_from_id(ctype.sib)\n      sib:CTA(refct)\n      ctype = entry\n    end\n  end\n\n  return refct\nend\n\nlocal function sib_iter(s, refct)\n  repeat\n    local ctype = typeinfo(refct.typeid)\n    if not ctype.sib then return end\n    refct = refct_from_id(ctype.sib)\n  until refct.what ~= \"attrib\" -- Pure attribs are skipped.\n  return refct\nend\n\nlocal function siblings(refct)\n  -- Follow to the end of the attrib chain, if any.\n  while refct.attributes do\n    refct = refct_from_id(refct.attributes.subtype or typeinfo(refct.typeid).sib)\n  end\n\n  return sib_iter, nil, refct\nend\n\nmetatables.struct.__index.members = siblings\nmetatables.func.__index.arguments = siblings\nmetatables.enum.__index.values = siblings\n\nlocal function find_sibling(refct, name)\n  local num = tonumber(name)\n  if num then\n    for sib in siblings(refct) do\n      if num == 1 then\n        return sib\n      end\n      num = num - 1\n    end\n  else\n    for sib in siblings(refct) do\n      if sib.name == name then\n        return sib\n      end\n    end\n  end\nend\n\nmetatables.struct.__index.member = find_sibling\nmetatables.func.__index.argument = find_sibling\nmetatables.enum.__index.value = find_sibling\n\nfunction reflect.typeof(x) -- refct = reflect.typeof(ct)\n  return refct_from_id(tonumber(ffi.typeof(x)))\nend\n\nfunction reflect.getmetatable(x) -- mt = reflect.getmetatable(ct)\n  return (miscmap or init_miscmap())[-tonumber(ffi.typeof(x))]\nend\n\nreturn reflect\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/txtbuf",
hash = "88b40329f537e0023bae4625deaf561b652f2d67893b7aede75866f9e121ac31",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta)\nlocal Codepoints = require \"singletons/codepoints\"\nlocal lines = import(\"core/string\", \"lines\")\nlocal clone, collect, slice, splice =\n   import(\"core/table\", \"clone\", \"collect\", \"slice\", \"splice\")\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\nlocal Txtbuf = meta {}\n\n\n\n\n\n\nlocal function cat(l)\n   if type(l) == \"string\" then\n      return l\n   elseif type(l) == \"table\" then\n      if l[1] ~= nil then\n         return concat(l)\n      else\n         return \"\"\n      end\n   end\n\n   error(\"called private fn cat with type\" .. type(l))\nend\n\n\n\n\nfunction Txtbuf.__tostring(txtbuf)\n   local closed_lines = {}\n   for k, v in ipairs(txtbuf.lines) do\n      closed_lines[k] = cat(v)\n   end\n   return concat(closed_lines, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.currentPosition(txtbuf)\n   local row, col = txtbuf.cursor.row, txtbuf.cursor.col\n   return txtbuf.lines[row], col, row\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core_math = require \"core/math\"\nlocal bound, inbounds = assert(core_math.bound), assert(core_math.inbounds)\n\nfunction Txtbuf.makeCursor(txtbuf, rowOrTable, col, basedOn)\n   local row\n   if type(rowOrTable) == \"table\" then\n      row, col = rowOrTable.row, rowOrTable.col\n   else\n      row = rowOrTable\n   end\n   row = row or basedOn.row\n   col = col or basedOn.col\n   assert(inbounds(row, 1, #txtbuf.lines))\n   txtbuf:openRow(row)\n   assert(inbounds(col, 1, nil))\n   col = bound(col, nil, #txtbuf.lines[row] + 1)\n   return {row = row, col = col}\nend\n\nfunction Txtbuf.setCursor(txtbuf, rowOrTable, col)\n   txtbuf.cursor = txtbuf:makeCursor(rowOrTable, col, txtbuf.cursor)\n   txtbuf.cursor_changed = true\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.cursorIndex(txtbuf)\n   local index = txtbuf.cursor.col\n   for row = txtbuf.cursor.row - 1, 1, -1 do\n      index = index + #txtbuf.lines[row] + 1\n   end\n   return index\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.openRow(txtbuf, row_num)\n   if row_num < 1 or row_num > #txtbuf.lines then\n      return nil\n   end\n   if type(txtbuf.lines[row_num]) == \"string\" then\n      txtbuf.lines[row_num] = Codepoints(txtbuf.lines[row_num])\n   end\n   return txtbuf.lines[row_num], row_num\nend\n\n\n\n\n\n\n\nfunction Txtbuf.advance(txtbuf)\n   txtbuf.lines[#txtbuf.lines + 1] = {}\n   txtbuf.contents_changed = true\n   txtbuf:setCursor(#txtbuf.lines, 1)\nend\n\n\n\n\n\n\n\n\n\nlocal _openers = { [\"(\"] = \")\",\n                   [\'\"\'] = \'\"\',\n                   [\"\'\"] = \"\'\",\n                   [\"{\"] = \"}\",\n                   [\"[\"] = \"]\"}\n\nlocal _closers = {}\nfor o, c in pairs(_openers) do\n   _closers[c] = o\nend\n\nlocal function _should_insert(line, cursor, frag)\n   return not (frag == line[cursor] and _closers[frag])\nend\n\nlocal function _should_pair(line, cursor, frag)\n   -- Only consider inserting a pairing character if this is an \"opener\"\n   if not _openers[frag] then return false end\n   -- Translate end-of-line to the implied newline\n   local next_char = line[cursor] or \"\\n\"\n   -- Insert a pair if we are before whitespace, or the next char is a\n   -- closing brace--that is, a closing character that is different\n   -- from its corresponding open character, i.e. not a quote\n   return next_char:match(\"%s\") or\n      _closers[next_char] and _closers[next_char] ~= next_char\nend\n\nfunction Txtbuf.insert(txtbuf, frag)\n   local line, cur_col = txtbuf.lines[txtbuf.cursor.row], txtbuf.cursor.col\n   if _should_insert(line, cur_col, frag) then\n      if _should_pair(line, cur_col, frag) then\n         insert(line, cur_col, _openers[frag])\n      end\n      insert(line, cur_col, frag)\n      txtbuf.contents_changed = true\n   end\n   txtbuf:setCursor(nil, cur_col + 1)\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.paste(txtbuf, frag)\n   frag = frag:gsub(\"\\t\", \"   \")\n   local frag_lines = collect(lines, frag)\n   local num_lines_before = #txtbuf.lines\n   for i, frag_line in ipairs(frag_lines) do\n      if i > 1 then txtbuf:nl() end\n      local codes = Codepoints(frag_line)\n      local line, cur_col, cur_row = txtbuf:currentPosition()\n      splice(line, cur_col, codes)\n      txtbuf:setCursor(nil, cur_col + #codes)\n   end\n   txtbuf.contents_changed = true\nend\n\n\n\n\n\n\n\n\nlocal function _is_paired(a, b)\n   return _openers[a] == b\nend\n\nfunction Txtbuf.deleteBackward(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_row == 1 and cur_col == 1 then\n      return false\n   end\n   -- At this point we will definitely make a change\n   txtbuf.contents_changed = true\n   if cur_col > 1 then\n      if _is_paired(line[cur_col - 1], line[cur_col]) then\n         remove(line, cur_col)\n      end\n      remove(line, cur_col - 1)\n      txtbuf:setCursor(nil, cur_col - 1)\n      return false\n   else\n      txtbuf:openRow(cur_row - 1)\n      local new_col = #txtbuf.lines[cur_row - 1] + 1\n      splice(txtbuf.lines[cur_row - 1], nil, line)\n      remove(txtbuf.lines, cur_row)\n      txtbuf:setCursor(cur_row - 1, new_col)\n      return true\n   end\nend\n\n\n\n\n\n\nfunction Txtbuf.deleteForward(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_row == #txtbuf.lines and cur_col > #line then\n      return false\n   end\n   txtbuf.contents_changed = true\n   if cur_col <= #line then\n      remove(line, cur_col)\n      return false\n   else\n      txtbuf:openRow(cur_row + 1)\n      splice(line, nil, txtbuf.lines[cur_row + 1])\n      remove(txtbuf.lines, cur_row + 1)\n      return true\n   end\nend\n\n\n\n\n\n\nfunction Txtbuf.killToEndOfLine(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_col == #line + 1 then return false end\n   txtbuf.contents_changed = true\n   for _ = #line, cur_col, -1 do\n      remove(line)\n   end\n   return true\nend\n\n\n\n\n\n\nfunction Txtbuf.killToBeginningOfLine(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_col == 1 then return false end\n   local final, shift = #line, 1\n   -- copy remainder, if any\n   for i = cur_col, #line do\n      line[shift] = line[i]\n      shift = shift + 1\n   end\n   for i = shift, final do\n      line[i] = nil\n   end\n   txtbuf.contents_changed = true\n   txtbuf:setCursor(nil, 1)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.transposeLetter(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_col == 1 then return false end\n   if cur_col == 2 and #line == 1 then return false end\n   local left, right = cur_col - 1, cur_col\n   if cur_col == #line + 1 then\n      left, right = left - 1, right - 1\n   end\n   local stash = line[right]\n   line[right] = line[left]\n   line[left] = stash\n   txtbuf:setCursor(nil, right + 1)\n   txtbuf.contents_changed = true\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.left(txtbuf, disp)\n   disp = disp or 1\n   local line, new_col, new_row = txtbuf:currentPosition()\n   new_col = new_col - disp\n   while new_col < 1 do\n      _, new_row = txtbuf:openRow(new_row - 1)\n      if not new_row then\n         txtbuf:setCursor(nil, 1)\n         return false\n      end\n      new_col = #line + 1 + new_col\n   end\n   txtbuf:setCursor(new_row, new_col)\n   return true\nend\n\n\n\n\n\n\nfunction Txtbuf.right(txtbuf, disp)\n   disp = disp or 1\n   local line, new_col, new_row = txtbuf:currentPosition()\n   new_col = new_col + disp\n   while new_col > #line + 1 do\n      _, new_row = txtbuf:openRow(new_row + 1)\n      if not new_row then\n         txtbuf:setCursor(nil, #line + 1)\n         return false\n      end\n      new_col = new_col - (#txtbuf.lines[new_row - 1] + 1)\n   end\n   txtbuf:setCursor(new_row, new_col)\n   return true\nend\n\n\n\n\n\n\nfunction Txtbuf.startOfLine(txtbuf)\n   txtbuf:setCursor(nil, 1)\nend\n\nfunction Txtbuf.endOfLine(txtbuf)\n   txtbuf:setCursor(nil, #txtbuf.lines[txtbuf.cursor.row] + 1)\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.startOfText(txtbuf)\n   txtbuf:setCursor(1, 1)\nend\n\nfunction Txtbuf.endOfText(txtbuf)\n   txtbuf:setCursor(#txtbuf.lines, #txtbuf.lines[#txtbuf.lines] + 1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal match = assert(string.match)\n\nfunction Txtbuf.scanFor(txtbuf, pattern, reps, forward)\n   local change = forward and 1 or -1\n   reps = reps or 1\n   local found_other_char, moved = false, false\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local search_pos, search_row = cur_col, cur_row\n   local search_char\n   local epsilon = forward and 0 or -1\n   while true do\n      local at_boundary = (forward and search_pos > #line)\n                       or (not forward and search_pos == 1)\n      search_char = at_boundary and \"\\n\" or line[search_pos + epsilon]\n      if not match(search_char, pattern) then\n         found_other_char = true\n      elseif found_other_char then\n         reps = reps - 1\n         if reps == 0 then break end\n         found_other_char = false\n      end\n      if at_boundary then\n         -- break out on txtbuf boundaries\n         if search_row == (forward and #txtbuf.lines or 1) then break end\n         line, search_row = txtbuf:openRow(search_row + change)\n         search_pos = forward and 1 or #line + 1\n      else\n         search_pos = search_pos + change\n      end\n      moved = true\n   end\n\n   return moved, search_pos - cur_col, search_row - cur_row\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.leftToBoundary(txtbuf, pattern, reps)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colÎ”, rowÎ” = txtbuf:scanFor(pattern, reps, false)\n   if moved then\n      txtbuf:setCursor(cur_row + rowÎ”, cur_col + colÎ”)\n      return true\n   else\n      return false\n   end\nend\n\nfunction Txtbuf.rightToBoundary(txtbuf, pattern, reps)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colÎ”, rowÎ” = txtbuf:scanFor(pattern, reps, true)\n   if moved then\n      txtbuf:setCursor(cur_row + rowÎ”, cur_col + colÎ”)\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction Txtbuf.killToEndOfWord(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colÎ”, rowÎ” = txtbuf:scanFor(\'%W\', reps, true)\n   if moved then\n      -- check if the row has changed\n      -- if so, delete to end of line\n      -- otherwise, delete colÎ” codepoints\n      txtbuf.contents_changed = true\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction Txtbuf.killToBeginningOfWord(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colÎ”, rowÎ” = txtbuf:scanFor(\'%W\', reps, false)\n   if moved then\n      -- check if the row has changed\n      -- if so, delete to beginning of line\n      -- otherwise, delete -colÎ” codepoints\n      -- and relocate the cursor accordingly\n      txtbuf.contents_changed = true\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.firstNonWhitespace(txtbuf)\n   local line = txtbuf.lines[txtbuf.cursor.row]\n   local new_col = 1\n   while new_col <= #line do\n      if match(line[new_col], \'%S\') then\n         txtbuf:setCursor(nil, new_col)\n         return true\n      end\n      new_col = new_col + 1\n   end\n   return false\nend\n\n\n\n\n\nfunction Txtbuf.leftWordAlpha(txtbuf, reps)\n   return txtbuf:leftToBoundary(\'%W\', reps)\nend\n\nfunction Txtbuf.rightWordAlpha(txtbuf, reps)\n   return txtbuf:rightToBoundary(\'%W\', reps)\nend\n\nfunction Txtbuf.leftWordWhitespace(txtbuf, reps)\n   return txtbuf:leftToBoundary(\'%s\', reps)\nend\n\nfunction Txtbuf.rightWordWhitespace(txtbuf, reps)\n   return txtbuf:rightToBoundary(\'%s\', reps)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.up(txtbuf)\n   if not txtbuf:openRow(txtbuf.cursor.row - 1) then\n      txtbuf:setCursor(nil, 1)\n      return false\n   end\n   txtbuf:setCursor(txtbuf.cursor.row - 1, nil)\n   return true\nend\n\n\n\nfunction Txtbuf.down(txtbuf)\n   if not txtbuf:openRow(txtbuf.cursor.row + 1) then\n      txtbuf:setCursor(nil, #txtbuf.lines[txtbuf.cursor.row] + 1)\n      return false\n   end\n   txtbuf:setCursor(txtbuf.cursor.row + 1, nil)\n   return true\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.nl(txtbuf)\n   line, cur_col, cur_row = txtbuf:currentPosition()\n   -- split the line\n   local first = slice(line, 1, cur_col - 1)\n   local second = slice(line, cur_col)\n   txtbuf.lines[cur_row] = first\n   insert(txtbuf.lines, cur_row + 1, second)\n   txtbuf.contents_changed = true\n   txtbuf:setCursor(cur_row + 1, 1)\n   return false\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.shouldEvaluate(txtbuf)\n   -- Most txtbufs are one line, so we always evaluate from\n   -- a one-liner, regardless of cursor location.\n   local linum = #txtbuf.lines\n   if linum == 1 then\n      return true\n   end\n   local _, cur_col, cur_row = txtbuf:currentPosition()\n   -- Evaluate if we are at the end of the first or last line (the default\n   -- positions after scrolling up or down in the history)\n   if (cur_row == 1 or cur_row == linum) and cur_col > #txtbuf.lines[cur_row] then\n      return true\n   end\nend\n\n\n\n\n\nfunction Txtbuf.suspend(txtbuf)\n   for i, v in ipairs(txtbuf.lines) do\n      txtbuf.lines[i] = cat(v)\n   end\n   return txtbuf\nend\n\n\n\nfunction Txtbuf.resume(txtbuf)\n   txtbuf:openRow(txtbuf.cursor.row)\n   return txtbuf\nend\n\n\n\nfunction Txtbuf.clone(txtbuf)\n   -- Clone to depth of 3 to get tb, tb.lines, and each lines\n   local tb = clone(txtbuf, 3)\n   return tb:resume()\nend\n\n\n\n\n\n\nlocal function new(str)\n   str = str or \"\"\n   local txtbuf = meta(Txtbuf)\n   local lines = collect(lines, str)\n   if #lines == 0 then\n      lines[1] = {}\n   end\n   txtbuf.lines = lines\n   txtbuf:endOfText()\n   txtbuf.contents_changed = false\n   txtbuf.cursor_changed = false\n   return txtbuf\nend\n\nTxtbuf.idEst = new\n\n\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/ljprof",
hash = "bc7a93af1fa54f4e56ce7630263f40f8d38710bb4eab8be2e807b03bd845bc55",
branch = "hang-on-exit",
binary = "\n\n\n\n\n----------------------------------------------------------------------------\n-- LuaJIT profiler.\n--\n-- Copyright (C) 2005-2017 Mike Pall. All rights reserved.\n-- Released under the MIT license. See Copyright Notice in luajit.h\n----------------------------------------------------------------------------\n--\n-- This module is a simple command line interface to the built-in\n-- low-overhead profiler of LuaJIT.\n--\n-- The lower-level API of the profiler is accessible via the \"jit.profile\"\n-- module or the luaJIT_profile_* C API.\n--\n-- Example usage:\n--\n--   luajit -jp myapp.lua\n--   luajit -jp=s myapp.lua\n--   luajit -jp=-s myapp.lua\n--   luajit -jp=vl myapp.lua\n--   luajit -jp=G,profile.txt myapp.lua\n--\n-- The following dump features are available:\n--\n--   f  Stack dump: function name, otherwise module:line. Default mode.\n--   F  Stack dump: ditto, but always prepend module.\n--   l  Stack dump: module:line.\n--   <number> stack dump depth (callee < caller). Default: 1.\n--   -<number> Inverse stack dump depth (caller > callee).\n--   s  Split stack dump after first stack level. Implies abs(depth) >= 2.\n--   p  Show full path for module names.\n--   v  Show VM states. Can be combined with stack dumps, e.g. vf or fv.\n--   z  Show zones. Can be combined with stack dumps, e.g. zf or fz.\n--   r  Show raw sample counts. Default: show percentages.\n--   a  Annotate excerpts from source code files.\n--   A  Annotate complete source code files.\n--   G  Produce raw output suitable for graphical tools (e.g. flame graphs).\n--   m<number> Minimum sample percentage to be shown. Default: 3.\n--   i<number> Sampling interval in milliseconds. Default: 10.\n--\n----------------------------------------------------------------------------\n\n-- Cache some library functions and objects.\nlocal jit = require(\"jit\")\nassert(jit.version_num == 20100, \"LuaJIT core/library version mismatch\")\nlocal profile = require(\"jit.profile\")\nlocal vmdef = assert(jit.vmdef)\nlocal math = math\nlocal pairs, ipairs, tonumber, floor = pairs, ipairs, tonumber, math.floor\nlocal sort, format = table.sort, string.format\nlocal stdout = io.stdout\nlocal zone -- Load jit.zone module on demand.\n\n-- Output file handle.\nlocal out\n\n------------------------------------------------------------------------------\n\nlocal prof_ud\nlocal prof_states, prof_split, prof_min, prof_raw, prof_fmt, prof_depth\nlocal prof_ann, prof_count1, prof_count2, prof_samples\n\nlocal map_vmmode = {\n  N = \"Compiled\",\n  I = \"Interpreted\",\n  C = \"C code\",\n  G = \"Garbage Collector\",\n  J = \"JIT Compiler\",\n}\n\n-- Profiler callback.\nlocal function prof_cb(th, samples, vmmode)\n  prof_samples = prof_samples + samples\n  local key_stack, key_stack2, key_state\n  -- Collect keys for sample.\n  if prof_states then\n    if prof_states == \"v\" then\n      key_state = map_vmmode[vmmode] or vmmode\n    else\n      key_state = zone:get() or \"(none)\"\n    end\n  end\n  if prof_fmt then\n    key_stack = profile.dumpstack(th, prof_fmt, prof_depth)\n    key_stack = key_stack:gsub(\"%[builtin#(%d+)%]\", function(x)\n      return vmdef.ffnames[tonumber(x)]\n    end)\n    if prof_split == 2 then\n      local k1, k2 = key_stack:match(\"(.-) [<>] (.*)\")\n      if k2 then key_stack, key_stack2 = k1, k2 end\n    elseif prof_split == 3 then\n      key_stack2 = profile.dumpstack(th, \"l\", 1)\n    end\n  end\n  -- Order keys.\n  local k1, k2\n  if prof_split == 1 then\n    if key_state then\n      k1 = key_state\n      if key_stack then k2 = key_stack end\n    end\n  elseif key_stack then\n    k1 = key_stack\n    if key_stack2 then k2 = key_stack2 elseif key_state then k2 = key_state end\n  end\n  -- Coalesce samples in one or two levels.\n  if k1 then\n    local t1 = prof_count1\n    t1[k1] = (t1[k1] or 0) + samples\n    if k2 then\n      local t2 = prof_count2\n      local t3 = t2[k1]\n      if not t3 then t3 = {}; t2[k1] = t3 end\n      t3[k2] = (t3[k2] or 0) + samples\n    end\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Show top N list.\nlocal function prof_top(count1, count2, samples, indent)\n  local t, n = {}, 0\n  for k in pairs(count1) do\n    n = n + 1\n    t[n] = k\n  end\n  sort(t, function(a, b) return count1[a] > count1[b] end)\n  for i=1,n do\n    local k = t[i]\n    local v = count1[k]\n    local pct = floor(v*100/samples + 0.5)\n    if pct < prof_min then break end\n    if not prof_raw then\n      out:write(format(\"%s%2d%%  %s\\n\", indent, pct, k))\n    elseif prof_raw == \"r\" then\n      out:write(format(\"%s%5d  %s\\n\", indent, v, k))\n    else\n      out:write(format(\"%s %d\\n\", k, v))\n    end\n    if count2 then\n      local r = count2[k]\n      if r then\n   prof_top(r, nil, v, (prof_split == 3 or prof_split == 1) and \"  -- \" or\n             (prof_depth < 0 and \"  -> \" or \"  <- \"))\n      end\n    end\n  end\nend\n\n-- Annotate source code\nlocal function prof_annotate(count1, samples)\n  local files = {}\n  local ms = 0\n  for k, v in pairs(count1) do\n    local pct = floor(v*100/samples + 0.5)\n    ms = math.max(ms, v)\n    if pct >= prof_min then\n      local file, line = k:match(\"^(.*):(%d+)$\")\n      if not file then file = k; line = 0 end\n      local fl = files[file]\n      if not fl then fl = {}; files[file] = fl; files[#files+1] = file end\n      line = tonumber(line)\n      fl[line] = prof_raw and v or pct\n    end\n  end\n  sort(files)\n  local fmtv, fmtn = \" %3d%% | %s\\n\", \"      | %s\\n\"\n  if prof_raw then\n    local n = math.max(5, math.ceil(math.log10(ms)))\n    fmtv = \"%\"..n..\"d | %s\\n\"\n    fmtn = (\" \"):rep(n)..\" | %s\\n\"\n  end\n  local ann = prof_ann\n  for _, file in ipairs(files) do\n    local f0 = file:byte()\n    if f0 == 40 or f0 == 91 then\n      out:write(format(\"\\n====== %s ======\\n[Cannot annotate non-file]\\n\", file))\n      break\n    end\n    local fp, err = io.open(file)\n    if not fp then\n      out:write(format(\"====== ERROR: %s: %s\\n\", file, err))\n      break\n    end\n    out:write(format(\"\\n====== %s ======\\n\", file))\n    local fl = files[file]\n    local n, show = 1, false\n    if ann ~= 0 then\n      for i=1,ann do\n   if fl[i] then show = true; out:write(\"@@ 1 @@\\n\"); break end\n      end\n    end\n    for line in fp:lines() do\n      if line:byte() == 27 then\n   out:write(\"[Cannot annotate bytecode file]\\n\")\n   break\n      end\n      local v = fl[n]\n      if ann ~= 0 then\n   local v2 = fl[n+ann]\n   if show then\n     if v2 then show = n+ann elseif v then show = n\n     elseif show+ann < n then show = false end\n   elseif v2 then\n     show = n+ann\n     out:write(format(\"@@ %d @@\\n\", n))\n   end\n   if not show then goto next end\n      end\n      if v then\n   out:write(format(fmtv, v, line))\n      else\n   out:write(format(fmtn, line))\n      end\n    ::next::\n      n = n + 1\n    end\n    fp:close()\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Finish profiling and dump result.\nlocal function prof_finish()\n  if prof_ud then\n    profile.stop()\n    local samples = prof_samples\n    if samples == 0 then\n      if prof_raw ~= true then out:write(\"[No samples collected]\\n\") end\n      return\n    end\n    if prof_ann then\n      prof_annotate(prof_count1, samples)\n    else\n      prof_top(prof_count1, prof_count2, samples, \"\")\n    end\n    prof_count1 = nil\n    prof_count2 = nil\n    prof_ud = nil\n  end\nend\n\n-- Start profiling.\nlocal function prof_start(mode)\n  local interval = \"\"\n  mode = mode:gsub(\"i%d*\", function(s) interval = s; return \"\" end)\n  prof_min = 3\n  mode = mode:gsub(\"m(%d+)\", function(s) prof_min = tonumber(s); return \"\" end)\n  prof_depth = 1\n  mode = mode:gsub(\"%-?%d+\", function(s) prof_depth = tonumber(s); return \"\" end)\n  local m = {}\n  for c in mode:gmatch(\".\") do m[c] = c end\n  prof_states = m.z or m.v\n  if prof_states == \"z\" then zone = require(\"jit.zone\") end\n  local scope = m.l or m.f or m.F or (prof_states and \"\" or \"f\")\n  local flags = (m.p or \"\")\n  prof_raw = m.r\n  if m.s then\n    prof_split = 2\n    if prof_depth == -1 or m[\"-\"] then prof_depth = -2\n    elseif prof_depth == 1 then prof_depth = 2 end\n  elseif mode:find(\"[fF].*l\") then\n    scope = \"l\"\n    prof_split = 3\n  else\n    prof_split = (scope == \"\" or mode:find(\"[zv].*[lfF]\")) and 1 or 0\n  end\n  prof_ann = m.A and 0 or (m.a and 3)\n  if prof_ann then\n    scope = \"l\"\n    prof_fmt = \"pl\"\n    prof_split = 0\n    prof_depth = 1\n  elseif m.G and scope ~= \"\" then\n    prof_fmt = flags..scope..\"Z;\"\n    prof_depth = -100\n    prof_raw = true\n    prof_min = 0\n  elseif scope == \"\" then\n    prof_fmt = false\n  else\n    local sc = prof_split == 3 and m.f or m.F or scope\n    prof_fmt = flags..sc..(prof_depth >= 0 and \"Z < \" or \"Z > \")\n  end\n  prof_count1 = {}\n  prof_count2 = {}\n  prof_samples = 0\n  profile.start(scope:lower()..interval, prof_cb)\n  prof_ud = newproxy(true)\n  getmetatable(prof_ud).__gc = prof_finish\nend\n\n------------------------------------------------------------------------------\n\nlocal function start(mode, outfile)\n  if not outfile then outfile = os.getenv(\"LUAJIT_PROFILEFILE\") end\n  if outfile then\n    out = outfile == \"-\" and stdout or assert(io.open(outfile, \"w\"))\n  else\n    out = stdout\n  end\n  prof_start(mode or \"f\")\nend\n\n-- Public module functions.\nreturn {\n  start = start, -- For -j command line option.\n  stop = prof_finish\n}\n\n\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/suggest",
hash = "dac3af5e6a4be8b83a43912764a04fa91f0359b4e55e72d5d5768c0e18e47e20",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\nlocal Lex = require \"helm/lex\"\nlocal SelectionList = require \"helm/selection_list\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal names = require \"helm/repr/names\"\nlocal concat, insert, sort = assert(table.concat),\n                             assert(table.insert),\n                             assert(table.sort)\nlocal c = import(\"singletons/color\", \"color\")\n\n\n\n\n\nlocal Suggest = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _cursorContext(modeS)\n   local lex_tokens = {}\n   -- Ignore whitespace and comments\n   for _, token in ipairs(modeS.lex(modeS.txtbuf)) do\n      if token.color ~= c.no_color and token.color ~= c.comment then\n         insert(lex_tokens, token)\n      end\n   end\n   -- Find the index of the token containing the cursor\n   local index, context\n   for i, token in ipairs(lex_tokens) do\n      if token.cursor_offset then\n         index = i\n         context = token\n         break\n      end\n   end\n   -- #todo once we\'re using =palette=, we\'ll be able to check the name\n   -- of the color rather than needing the color table ourselves\n   if not context or context.color ~= c.field then\n      -- We\'re in a non-completable token\n      return nil\n   end\n   -- Work backwards from there to determine the dotted path, if any,\n   -- that we are completing within\n   local path = {}\n   local expect_sym = false\n   index = index - 1\n   while index > 0 do\n      local path_token = lex_tokens[index]\n      if expect_sym then\n         if path_token.color == c.field then\n            insert(path, 1, tostring(path_token))\n         else\n            -- After a function call or [] subscript, we can\'t safely retrieve\n            -- a table to complete against. A non-operator token is either a\n            -- function call with a single string arg (this also most likely\n            -- applies to a closing table brace), or an error.\n            -- In all such cases, we want to complete against the full list\n            -- of possible symbols.\n            if tostring(path_token) == \")\"\n               or tostring(path_token) == \"]\"\n               or tostring(path_token) == \"}\"\n               or path_token.color ~= c.operator then\n               path = nil\n            end\n            break\n         end\n      else\n         -- Expected a . or :, got absolutely anything else, we\'ve finished\n         -- this dotted path.\n         if path_token.color ~= c.operator\n            or (tostring(path_token) ~= \".\"\n            and tostring(path_token) ~= \":\") then\n            break\n         end\n      end\n      expect_sym = not expect_sym\n      index = index - 1\n   end\n   return context, path\nend\n\n\n\n\n\n\n\n\nlocal function _suggest_sort(a, b)\n   if a.score ~= b.score then\n      return a.score < b.score\n   elseif #a.sym ~= #b.sym then\n      return #a.sym < #b.sym\n   else\n      return a.sym < b.sym\n   end\nend\n\nlocal isidentifier = import(\"core/string\", \"isidentifier\")\nlocal hasmetamethod = import(\"core/meta\", \"hasmetamethod\")\nlocal hasfield = import(\"core:core/table\", \"hasfield\")\nlocal fuzz_patt = require \"helm:helm/fuzz_patt\"\n\nfunction Suggest.update(suggest, modeS)\n   local context, path = _cursorContext(modeS)\n   if context == nil then\n      suggest:cancel(modeS)\n      return\n   end\n\n   -- First, build a list of candidate symbols--those that would be valid\n   -- in the current position.\n   local candidate_symbols, complete_against\n   if path then\n      complete_against = __G\n      for _, key in ipairs(path) do\n         complete_against = hasfield(complete_against, key)\n      end\n      -- If what we end up with isn\'t a table, we can\'t complete against it\n      if type(complete_against) ~= \"table\" then\n         complete_against = nil\n      end\n   end\n   if complete_against ~= nil then\n      candidate_symbols = {}\n      repeat\n         for k, _ in pairs(complete_against) do\n            if isidentifier(k) then\n               candidate_symbols[k] = true\n            end\n         end\n         local index_table = hasmetamethod(\"__index\", complete_against)\n         -- Ignore __index functions, no way to know what they might handle\n         complete_against = type(index_table) == \"table\" and index_table or nil\n      until complete_against == nil\n   -- Either no path was provided, or some part of it doesn\'t\n   -- actually exist, fall back to completing against all symbols\n   else\n      candidate_symbols = names.all_symbols\n   end\n\n   -- Now we can actually filter those candidates for whether they match or not\n   local suggestions = SelectionList()\n   suggestions.best = true\n   suggestions.frag = tostring(context):sub(1, context.cursor_offset)\n   suggestions.lit_frag = suggestions.frag\n   local match_patt = fuzz_patt(suggestions.frag)\n   local matches = {}\n   for sym in pairs(candidate_symbols) do\n      local score = match_patt:match(sym)\n      if score then\n         insert(matches, { score = score, sym = sym })\n      end\n   end\n   if #matches == 0 then\n      suggest:cancel(modeS)\n      return\n   end\n   sort(matches, _suggest_sort)\n   for _, match in ipairs(matches) do\n      insert(suggestions, match.sym)\n   end\n   if modeS.raga.name == \"complete\" then\n      suggestions.selected_index = 1\n   end\n   suggestions = Rainbuf { [1] = suggestions, n = 1,\n                               live = true, made_in = \"suggest.update\" }\n   suggest.active_suggestions = suggestions\n   modeS.zones.suggest:replace(suggestions)\nend\n\n\n\n\n\n\nfunction Suggest.cancel(suggest, modeS)\n   suggest.active_suggestions = nil\n   modeS.zones.suggest:replace(\"\")\nend\n\n\n\n\n\nfunction Suggest.accept(suggest, modeS)\n   local suggestion = suggest.active_suggestions[1]:selectedItem()\n   local context = _cursorContext(modeS)\n   -- #todo do this in one call, probably by making :deleteBackward()\n   -- accept a parameter of how many characters to delete\n   for i = 1, context.cursor_offset do\n      modeS.txtbuf:deleteBackward()\n   end\n   modeS.txtbuf:paste(suggestion)\nend\n\n\n\n\n\n\nnew = function()\n   local suggest = meta(Suggest)\n   return suggest\nend\n\n\n\n\nSuggest.idEst = new\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/sqlayer",
hash = "534304ed2a828551a1d014eaf7df78539937763ecaf8de7d7d3f124b58da2e73",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal sql = require \"sqlite\"\nlocal pcall = assert (pcall)\nlocal gsub = assert(string.gsub)\nlocal format = assert(string.format)\nlocal ffi = require \"ffi\"\nassert(ffi)\nffi.reflect = require \"reflect\"\nassert(ffi.reflect)\n\n\n\n\n\n\n\n\n\n\n-- get a conn object via in-memory DB\nlocal conn = sql.open \":memory:\"\nlocal conn_mt = ffi.reflect.getmetatable(conn)\nlocal stmt = conn:prepare \"CREATE TABLE IF NOT EXISTS test(a,b);\"\nlocal stmt_mt = ffi.reflect.getmetatable(stmt)\n\nstmt:close()\nconn:close() -- polite\nconn, stmt = nil, nil\n\n\n\n\n\n\n\nlocal function san(str)\n   return gsub(str, \"\'\", \"\'\'\")\nend\n\nsql.san = san\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sql.format(str, ...)\n   local argv = {...}\n   str = gsub(str, \"%%s\", \"\'%%s\'\"):gsub(\"\'\'%%s\'\'\", \"\'%%s\'\")\n   for i, v in ipairs(argv) do\n      if type(v) == \"string\" then\n         argv[i] = san(v)\n      elseif type(v) == \"cdata\" then\n         -- assume this is a number of some kind\n         argv[i] = tonumber(v)\n      else\n         argv[i] = v\n      end\n   end\n   local success, ret = pcall(format, str, unpack(argv))\n   if success then\n      return ret\n   else\n      return success, ret\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction sql.pexec(conn, stmt, col_str)\n   -- conn:exec(stmt)\n   col_str = col_str or \"hik\"\n   local success, result, nrow = pcall(conn.exec, conn, stmt, col_str)\n   if success then\n      return result, nrow\n   else\n      return false, result\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction sql.lastRowId(conn)\n   local result = conn:rowexec \"SELECT CAST(last_insert_rowid() AS REAL)\"\n   return result\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pragma_pre = \"PRAGMA \"\n\n-- Builds and returns a pragma string\nlocal function __pragma(prag, value)\n   local val\n   if value == nil then\n      return pragma_pre .. prag .. \";\"\n   end\n   if type(value) == \"boolean\" then\n      val = value and \" = 1\" or \" = 0\"\n   elseif type(value) == \"string\" then\n      val = \"(\'\" .. san(value) .. \"\')\"\n   elseif type(value) == \"number\" then\n      val = \" = \" .. tostring(value)\n   else\n      error(false, \"value of type \" .. type(value) .. \", \" .. tostring(value))\n   end\n   return pragma_pre .. prag .. val .. \";\"\nend\n\n-- Sets a pragma and checks its new value\nlocal function _prag_set(conn, prag)\n   return function(value)\n      local prag_str = __pragma(prag, value)\n      conn:exec(prag_str)\n      -- check for a boolean\n      -- #todo make sure this gives sane results for a method-call pragma\n      local answer = conn:exec(pragma_pre .. prag .. \";\")\n      if answer[1] and answer[1][1] then\n         if answer[1][1] == 1 then\n            return true\n         elseif answer[1][1] == 0 then\n            return false\n         else\n            return nil\n         end\n      end\n   end\nend\n\n\n\n\n\n\nlocal function new_conn_index(conn, key)\n   local function _prag_index(_, prag)\n      return _prag_set(conn, prag)\n   end\n   if key == \"pragma\" then\n      return setmetatable({}, {__index = _prag_index})\n   else\n      return conn_mt[key]\n   end\nend\n\nconn_mt.__index = new_conn_index\n\n\n\n\nreturn sql\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/painter",
hash = "c690bc6ce57d72c54b5a994340cd4879dd131ed75b9836367980127f4997a53f",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta)\nassert(type)\n\n\n\nlocal Paint = meta {}\n\n\n\n\n\n\n\nlocal STATCOL = 81\nlocal STAT_TOP = 1\nlocal STAT_RUN = 2\n\nlocal function colwrite(str, col, row)\n   col = col or STATCOL\n   row = row or STAT_TOP\n   local dash = a.stash()\n             .. a.cursor.hide()\n             .. a.jump(row, col)\n             .. a.erase.right()\n             .. str\n             .. a.pop()\n             .. a.cursor.show()\n   write(dash)\nend\n\nlocal STAT_ICON = \"â—‰ \"\n\nlocal function tf(bool)\n   if bool then\n      return ts(\"t\", \"true\")\n   else\n      return ts(\"f\", \"false\")\n   end\nend\n\nlocal function pr_mouse(m)\n   local phrase = a.magenta(m.button) .. \": \"\n                     .. a.bright(m.kind) .. \" \" .. tf(m.shift)\n                     .. \" \" .. tf(m.meta)\n                     .. \" \" .. tf(m.ctrl) .. \" \" .. tf(m.moving) .. \" \"\n                     .. tf(m.scrolling) .. \" \"\n                     .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)\n   return phrase\nend\n\nlocal function mk_paint(fragment, shade)\n   return function(category, action)\n      return shade(category .. fragment .. action)\n   end\nend\n\nlocal act_map = { MOUSE  = pr_mouse,\n                  NAV    = mk_paint(\": \", a.italic),\n                  CTRL   = mk_paint(\": \", c.field),\n                  ALT    = mk_paint(\": \", a.underscore),\n                  ASCII  = mk_paint(\": \", c.table),\n                  NYI    = mk_paint(\": \", a.red)}\n\nlocal icon_map = { MOUSE = mk_paint(STAT_ICON, c.userdata),\n                   NAV   = mk_paint(STAT_ICON, a.magenta),\n                   CTRL  = mk_paint(STAT_ICON, a.blue),\n                   ALT   = mk_paint(STAT_ICON, c[\"function\"]),\n                   ASCII = mk_paint(STAT_ICON, a.green),\n                   NYI   = mk_paint(STAT_ICON .. \"! \", a.red) }\n\nlocal function icon_paint(category, value)\n   assert(icon_map[category], \"icon_paint NYI:\" .. category)\n   if category == \"MOUSE\" then\n      return colwrite(icon_map[category](\"\", pr_mouse(value)))\n    end\n   return colwrite(icon_map[category](\"\", ts(value)))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Paint.inBox(painter, rainbuf, box)\n   local tc, tr, bc, br = box[1], box[2], box[3], box[4]\n   if type(rainbuf) == \"string\" then\n      -- string painter\n   elseif type(rainbuf) == \"table\" then\n      -- Detect rainbuf.idEst, paint the rainbuf\n   end\nend\n\n\n\nlocal function new(_stdout)\n   local painter = meta(Paint)\n   painter.out  = _stdout\n   return painter\nend\n\n\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/resbuf",
hash = "8e7308f5439385c3f23a846f9cf123190a970dff2a7b7a2df7b7d2341edf4ebd",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\nassert (meta)\nassert (ipairs)\nlocal color = require \"singletons/color\"\n\n\n\nlocal Resbuf = meta {}\n\nfunction Resbuf.ts(resbuf)\n   local res_map = {}\n   if resbuf.frozen then\n      for i, v in ipairs(resbuf) do\n         res_map[i] = v\n      end\n   else\n      for i, v in ipairs(resbuf) do\n         res_map[i] = color.ts(v)\n      end\n   end\n\n   return res_map\nend\n\nlocal function new(results, frozen)\n   local resbuf = meta(Resbuf)\n   if frozen then resbuf.frozen = true end\n   for k, v in pairs(results) do\n      resbuf[k] = v\n   end\n   return resbuf\nend\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/repr/token",
hash = "f5606bd03c0dee9e07176ec1aa599f4efd06ac7f4a4a1641fadd2a4ac2f30dd5",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal utf8 = require \"lua-utf8\"\nlocal utf8_len, utf8_sub = utf8.len, utf8.sub\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\nlocal meta = require \"core/meta\" . meta\n\n\n\n\n\n\nlocal Token = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.toString(token, c)\n   if not token.wrappable then\n      return token.color(utf8_sub(token.str, token.start))\n   end\n   local output = {}\n   for i = token.start, #token.codepoints do\n      local frag = token.codepoints[i]\n      if token.escapes[frag] then\n         frag = c.stresc .. frag .. token.color\n      elseif token.err and token.err[i] then\n         frag = c.alert .. frag .. token.color\n      end\n      insert(output, frag)\n   end\n   return token.color(concat(output))\nend\n\n\n\n\n\n\n\n\n\nfunction Token.__tostring(token)\n   if token.wrappable then\n      return concat(token.codepoints, \"\", token.start)\n   else\n      return utf8_sub(token.str, token.start)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.split(token, max_disp)\n   local first\n   local cfg = { event = token.event,\n                 wrappable = token.wrappable,\n                 wrapped = token.wrapped }\n   if token.wrappable then\n      cfg.escapes = token.escapes\n      first = new(nil, token.color, cfg)\n      for i = token.start, #token.codepoints do\n         if first.total_disp + token.disps[i] > max_disp then\n            token.start = i\n            token.total_disp = token.total_disp - first.total_disp\n            break\n         end\n         first:insert(token.codepoints[i], token.disps[i], token.err and token.err[i])\n      end\n   else\n      first = new(utf8_sub(token.str, token.start, token.start + max_disp - 1), token.color, cfg)\n      token.start = token.start + max_disp\n      token.total_disp = token.total_disp - max_disp\n   end\n   return first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.insert(token, pos, frag, disp, err)\n   assert(token.start == 1, \"Cannot insert into a token with a start offset\")\n   if type(pos) ~= \"number\" then\n      err = disp\n      disp = frag\n      frag = pos\n      -- If we have a codepoints array, our total_disp might exceed its length\n      -- because of escapes. If not, total_disp is assumed equal to the\n      -- number of codepoints in the string\n      pos = (token.codepoints and #token.codepoints or token.total_disp) + 1\n   end\n   -- Assume one cell if disp is not specified.\n   -- Cannot use #frag because of Unicode--might be two bytes but one cell.\n   disp = disp or 1\n   if token.wrappable then\n      insert(token.codepoints, pos, frag)\n      insert(token.disps, pos, disp)\n      -- Create the error array if needed, and/or shift it if it exists (even\n      -- if this fragment is not in error) to keep indices aligned\n      if token.err or err then\n         token.err = token.err or {}\n         insert(token.err, pos, err)\n      end\n   else\n      token.str = utf8_sub(token.str, 1, pos - 1) .. frag .. utf8_sub(token.str, pos)\n   end\n   token.total_disp = token.total_disp + disp\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.remove(token, pos)\n   assert(token.start == 1, \"Cannot remove from a token with a start offset\")\n   local removed, rem_disp, err\n   if token.wrappable then\n      removed = remove(token.codepoints, pos)\n      rem_disp = remove(token.disps, pos)\n      err = token.err and remove(token.err, pos)\n   else\n      pos = pos or token.total_disp\n      removed = utf8_sub(token.str, pos, pos)\n      rem_disp = 1\n      token.str = utf8_sub(token.str, 1, pos - 1) .. utf8_sub(token.str, pos + 1)\n   end\n   token.total_disp = token.total_disp - rem_disp\n   return removed, rem_disp, err\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal string_sub = assert(string.sub)\n\nfunction Token.removeTrailingSpaces(token)\n   assert(not token.wrappable, \"removeTrailingSpaces not implemented \\\n      for wrappable tokens\")\n   assert(token.start == 1, \"removeTrailingSpaces not implemented \\\n      for tokens with a start offset\")\n   -- Note that we can ignore Unicode here, as we only care about spaces\n   local last_non_space = -1\n   while string_sub(token.str, last_non_space, last_non_space) == \" \" do\n      last_non_space = last_non_space - 1\n   end\n   token.str = string_sub(token.str, 1, last_non_space)\n   token.total_disp = token.total_disp + last_non_space + 1\nend\n\n\n\n\n\n\nfunction Token.isForceBreak(token)\n   return token.event == \"break\" or token.event == \"repr_line\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escapes_map = {\n   [\'\"\'] = \'\\\\\"\',\n   [\"\'\"] = \"\\\\\'\",\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nlocal byte, find, format = assert(string.byte),\n                           assert(string.find),\n                           assert(string.format)\n\nnew = function(str, color, cfg)\n   local token = meta(Token)\n   token.str = str\n   token.start = 1\n   token.color = color\n   cfg = cfg or {}\n   if cfg.wrappable then\n      token.codepoints = Codepoints(str or \"\")\n      token.err = token.codepoints.err\n      token.disps = {}\n      token.escapes = {}\n      token.total_disp = 0\n      for i, frag in ipairs(token.codepoints) do\n         -- For now, start by assuming that all codepoints occupy one cell.\n         -- This is wrong, but *usually* does the right thing, and\n         -- handling Unicode properly is hard.\n         local disp = 1\n         if escapes_map[frag] or find(frag, \"%c\") then\n            frag = escapes_map[frag] or format(\"\\\\x%02x\", byte(frag))\n            token.codepoints[i] = frag\n            -- In the case of an escape, we know all of the characters involved\n            -- are one-byte, and each occupy one cell\n            disp = #frag\n            token.escapes[frag] = true\n         end\n         token.disps[i] = disp\n         token.total_disp = token.total_disp + disp\n      end\n      -- Note that we don\'t quote if str was nil, only if it was an actual\n      -- empty string. nil is used to create a blank token into which chars\n      -- will later be inserted (see :split()).\n      if str and find(str, \'^ *$\') then\n         -- Need to assign this over now so :insert() behaves properly\n         token.wrappable = true\n         token:insert(1, \'\"\')\n         token:insert(\'\"\')\n      end\n   else -- not cfg.wrappable\n      token.total_disp = utf8_len(str)\n   end\n   for k, v in pairs(cfg) do\n      token[k] = v\n   end\n   return token\nend\n\nToken.idEst = new\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/lex",
hash = "da445d6805a6a6deb00fbfde7d4161ad7e63bdfccb98cf65355778934254d429",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\nlocal Lex = meta {}\nlocal sub, gsub = assert(string.sub), assert(string.gsub)\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal c = require \"singletons/color\"\n\n\n\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal keyword = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal operator = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\'\\\"[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (-digit * -terminal * P(1))^1\n               * (-terminal * P(1))^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)^1\n\nlocal lua_toks = {comment, keyword, string_long, string_short, number, operator, symbol,\n                  WS, NL, ERR}\n\nlocal color_map = {\n   [keyword] = c.color.keyword,\n   [operator] = c.color.operator,\n   [number] = c.color.number,\n   [symbol] = c.color.field,\n   [string_short] = c.color.string,\n   [string_long] = c.color.string,\n   [comment] = c.color.comment,\n   [ERR] = c.color.error,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function chomp_token(lb, start_pos)\n   for _,v in ipairs(lua_toks) do\n      local end_pos = match(v, lb, start_pos)\n      if end_pos ~= nil then\n         return sub(lb, start_pos, end_pos - 1), end_pos, v\n      end\n   end\n   return nil\nend\n\nlocal Token = require \"helm/repr/token\"\nlocal inbounds = import(\"core/math\", \"inbounds\")\n\nfunction Lex.lua_thor(txtbuf)\n   local toks = {}\n   local lb = tostring(txtbuf)\n   local cursor_index = txtbuf:cursorIndex()\n   local pos = 1\n   while pos <= #lb do\n      local bite, new_pos, tok_t = chomp_token(lb, pos)\n      assert(bite and #bite > 0, \"lua-thor has failed you\")\n      local color = color_map[tok_t] or c.no_color\n      local cfg = { }\n      if inbounds(cursor_index, pos + 1, new_pos) then\n         cfg.cursor_offset = cursor_index - pos\n      end\n      -- Would love to highlight escape sequences in strings,\n      -- but this turns out to be rather difficult...\n      insert(toks, Token(bite, color, cfg))\n      pos = new_pos\n   end\n   return toks\nend\n\n\n\n\n\n\n\nfunction Lex.null(txtbuf)\n   return { Token(tostring(txtbuf), c.no_color) }\nend\n\n\n\nreturn Lex\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/nerf",
hash = "ed13c2db8100d4773b7854bc2f0219531d8eedc76578c18861cd5694da958f2c",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta, \"must have meta in _G\")\n\n\n\nlocal a         = require \"anterm:anterm\"\nlocal Txtbuf    = require \"helm/txtbuf\"\nlocal Rainbuf   = require \"helm/rainbuf\"\nlocal Historian = require \"helm/historian\"\nlocal Lex       = require \"helm/lex\"\n\nlocal concat         = assert(table.concat)\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\n\n\n\n\n\n\nlocal clone    = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal Nerf = clone(EditBase, 2)\nNerf.name = \"nerf\"\nNerf.prompt_char = \"ðŸ‘‰\"\n\n\n\n\n\n\nlocal function _insert(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n      if value == \"/\" then\n         modeS.shift_to = \"search\"\n         return\n      end\n      if value == \"?\" then\n         modeS:openHelp()\n         return\n      end\n   end\n   modeS.txtbuf:insert(value)\nend\n\nNerf.ASCII = _insert\nNerf.UTF8 = _insert\n\n\n\n\n\n\n\nlocal NAV = Nerf.NAV\n\nlocal function _prev(modeS)\n   local linestash\n   if tostring(modeS.txtbuf) ~= \"\"\n      and modeS.hist.cursor > modeS.hist.n then\n      linestash = modeS.txtbuf\n   end\n   local prev_txtbuf, prev_result = modeS.hist:prev()\n   if linestash then\n      modeS.hist:append(linestash)\n   end\n   modeS:setTxtbuf(prev_txtbuf)\n   modeS:setResults(prev_result)\n   return modeS\nend\n\nfunction NAV.UP(modeS, category, value)\n   local inline = modeS.txtbuf:up()\n   if not inline then\n      _prev(modeS)\n   end\n   return modeS\nend\n\nlocal function _advance(modeS)\n   local new_txtbuf, next_result = modeS.hist:next()\n   if not new_txtbuf then\n      local added = modeS.hist:append(modeS.txtbuf)\n      if added then\n         modeS.hist.cursor = modeS.hist.n + 1\n      end\n      new_txtbuf = Txtbuf()\n   end\n   modeS:setTxtbuf(new_txtbuf)\n   modeS:setResults(next_result)\n   return modeS\nend\n\nfunction NAV.DOWN(modeS, category, value)\n   local inline = modeS.txtbuf:down()\n   if not inline then\n      _advance(modeS)\n   end\n\n   return modeS\nend\n\n\n\nfunction NAV.RETURN(modeS, category, value)\n   if modeS.txtbuf:shouldEvaluate() then\n      modeS:eval()\n   else\n      modeS.txtbuf:nl()\n   end\nend\n\nfunction NAV.CTRL_RETURN(modeS, category, value)\n   modeS:eval()\nend\n\nfunction NAV.SHIFT_RETURN(modeS, category, value)\n   modeS.txtbuf:nl()\nend\n\n-- Add aliases for terminals not in CSI u mode\nNerf.CTRL[\"^\\\\\"] = NAV.CTRL_RETURN\nNAV.ALT_RETURN = NAV.SHIFT_RETURN\n\nlocal function _activateCompletion(modeS)\n   if modeS.suggest.active_suggestions then\n      modeS.shift_to = \"complete\"\n      -- #todo seems like this should be able to be handled more centrally\n      modeS.suggest.active_suggestions[1].selected_index = 1\n      modeS.zones.suggest:beTouched()\n      return true\n   else\n      return false\n   end\nend\n\nfunction NAV.SHIFT_DOWN(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.zones.results:scrollDown()\n   end\nend\n\nfunction NAV.SHIFT_UP(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.zones.results:scrollUp()\n   end\nend\n\nfunction NAV.TAB(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.txtbuf:paste(\"   \")\n   end\nend\n\nfunction NAV.SHIFT_TAB(modeS, category, value)\n   -- If we can\'t activate completion, nothing to do really\n   _activateCompletion(modeS)\nend\n\n\n\n\n\n\n\n\n\n\nlocal CTRL = Nerf.CTRL\n\nCTRL [\"^B\"] = NAV.LEFT\nCTRL [\"^F\"] = NAV.RIGHT\nCTRL [\"^N\"] = NAV.DOWN\nCTRL [\"^P\"] = NAV.UP\n\n\n\n\n\n\nfunction Nerf.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.zones.results:scrollUp()\n      elseif value.button == \"MB1\" then\n         modeS.zones.results:scrollDown()\n      end\n   end\nend\n\n\n\n\n\n\nlocal ALT = Nerf.ALT\n\n\n\n\n\n\nALT [\"M-e\"] = function(modeS, category, value)\n   modeS:evalFromCursor()\nend\n\n\n\n\n\n\n\n\nfunction Nerf.onCursorChanged(modeS)\n   modeS.suggest:update(modeS)\n   EditBase.onCursorChanged(modeS)\nend\n\n\n\nreturn Nerf\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/search",
hash = "4f0d42d28b6a028429b8861093e6066eb979caee837f137306ca7997e09a6cd0",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm/raga/edit\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal Txtbuf = require \"helm/txtbuf\"\n\nlocal Search = clone(EditBase, 2)\n\nSearch.name = \"search\"\nSearch.prompt_char = \"â‰ï¸\"\n\n\n\n\n\n\n\n\nfunction Search.onTxtbufChanged(modeS)\n   local searchResult = modeS.hist:search(tostring(modeS.txtbuf))\n   modeS:setResults(searchResult)\nend\n\n\n\n\n\n\n\nfunction Search.NAV.SHIFT_DOWN(modeS, category, value)\n   local search_buf = modeS.hist.last_collection\n   if not search_buf then return end\n   local search_result = search_buf[1]\n   if search_result:selectNext() then\n      if search_result.selected_index >= search_buf.offset + modeS.zones.results:height() then\n        search_buf:scrollDown()\n      end\n      modeS.zones.results:beTouched()\n   end\nend\n\n\n\nfunction Search.NAV.SHIFT_UP(modeS, category, value)\n   local search_buf = modeS.hist.last_collection\n   if not search_buf then return end\n   local search_result = search_buf[1]\n   if search_result:selectPrevious() then\n      if search_result.selected_index < search_buf.offset then\n         search_buf:scrollUp()\n      end\n      modeS.zones.results:beTouched()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nSearch.NAV.UP = Search.NAV.SHIFT_UP\nSearch.NAV.DOWN = Search.NAV.SHIFT_DOWN\n\nlocal function _modeShiftOnDeleteWhenEmpty(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS.shift_to = modeS.raga_default\n      modeS:setResults(\"\")\n   else\n      EditBase(modeS, category, value)\n   end\nend\n\nSearch.NAV.BACKSPACE = _modeShiftOnDeleteWhenEmpty\nSearch.NAV.DELETE    = _modeShiftOnDeleteWhenEmpty\n\n\n\n\n\n\n\nlocal function _acceptAtIndex(modeS, selected_index)\n   local search_result = modeS.hist.last_collection[1]\n   local txtbuf, result\n   if #search_result > 0 then\n      selected_index = selected_index or search_result.selected_index\n      txtbuf, result = modeS.hist:index(search_result.cursors[selected_index])\n   end\n   modeS.shift_to = modeS.raga_default\n   modeS:setTxtbuf(txtbuf or Txtbuf(), result)\n   modeS:setResults(result)\nend\n\nfunction Search.NAV.RETURN(modeS, category, value)\n   _acceptAtIndex(modeS)\nend\n\nlocal function _makeControl(num)\n   return function(modeS, category, value)\n      _acceptAtIndex(modeS, num)\n   end\nend\n\nfor i = 1, 9 do\n   Search.ALT[\"M-\" ..tostring(i)] = _makeControl(i)\nend\n\n\n\n\n\n\nfunction Search.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.raga.NAV.SHIFT_DOWN(modeS, category, value)\n      elseif value.button == \"MB1\" then\n         modeS.raga.NAV.SHIFT_UP(modeS, category, value)\n      end\n   end\nend\n\n\n\nreturn Search\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm",
hash = "b98e0e951445c22697f0f566dda35cf6d02b99657649f4bba2c0416d53e5feed",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n--[[\nprofile = require(\"jit.profile\")\nprofiled = {}\nprofile.start(\"li1\", function(th, samples, vmmode)\n  local d = profile.dumpstack(th, \"pF\", 1)\n  profiled[d] = (profiled[d] or 0) + samples\nend)\n--]]\n\n\n\nif rawget(_G, \"_Bridge\") then\n  _Bridge.helm = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n__G = setmetatable({}, {__index = _G})\n\n\n\n\n\n\n\n\n\nlocal function _helm(_ENV)\n\n\n\n\n\nsetfenv(1, __G)\n\nimport = assert(require \"core/module\" . import)\nmeta = import(\"core/meta\", \"meta\")\ncore = require \"core:core\"\njit.vmdef = require \"helm:helm/vmdef\"\njit.p = require \"helm:helm/ljprof\"\nsql = assert(sql, \"sql must be in _G\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal deepclone = assert(core.deepclone)\n_G_back = deepclone(_G)\n\n\n\n\n\n\n\n\nuv = require \"luv\"\nlocal usecolors\nstdout = \"\"\n\nif uv.guess_handle(1) == \"tty\" then\n  stdout = uv.new_tty(1, false)\n  usecolors = true\nelse\n  stdout = uv.new_pipe(false)\n  uv.pipe_open(utils.stdout, 1)\n  usecolors = false\nend\n\nif not usecolors then\n   ts = tostring\n   -- #todo make this properly black and white ts\nend\n\n\n\n\n\nlocal function write(...)\n   uv.write(stdout, {...})\nend\n\n\n\nlocal concat = assert(table.concat)\n\nfunction print(...)\n  local n = select(\'#\', ...)\n  local arguments = {...}\n  for i = 1, n do\n    arguments[i] = tostring(arguments[i])\n  end\n  uv.write(stdout, concat(arguments, \"\\t\") .. \"\\n\")\nend\n\n\n\n\n\n\nif uv.guess_handle(0) ~= \"tty\" or\n   uv.guess_handle(1) ~= \"tty\" then\n  -- Entry point for other consumers!\n  error \"stdio must be a tty\"\nend\n\nlocal stdin = uv.new_tty(0, true)\n\n\n\n\n\na = require \"anterm:anterm\"\n--watch = require \"watcher\"\n\n\n\n\n\n\n\n-- Get window size and set up an idler to keep it refreshed\n\nlocal MOUSE_MAX = 223\n\nlocal function bind_pane(col, row)\n   local bound_col = col > MOUSE_MAX and MOUSE_MAX or col\n   local bound_row = row > MOUSE_MAX and MOUSE_MAX or row\n   return bound_col, bound_row\nend\n\nlocal max_col, max_row = bind_pane(uv.tty_get_winsize(stdin))\n\n\n\nmodeS = require \"helm/modeselektor\" (max_col, max_row, write)\nlocal insert = assert(table.insert)\nlocal function s_out(msg)\n  insert(modeS.status, msg)\nend\n\n-- make a new \'status\' instance\nlocal s = require \"singletons/status\" (s_out)\n\nlocal timer = uv.new_timer()\nuv.timer_start(timer, 500, 500, function()\n   max_col, max_row = uv.tty_get_winsize(stdin)\n   if max_col ~= modeS.max_col or max_row ~= modeS.max_row then\n      modeS.max_col, modeS.max_row = bind_pane(max_col, max_row)\n      -- Mark all zones as touched since we don\'t know the state of the screen\n      -- (some terminals, iTerm for sure, will attempt to reflow the screen\n      -- themselves and fail miserably)\n      for _, zone in ipairs(modeS.zones) do\n         zone.touched = true\n      end\n      modeS:reflow()\n   end\nend)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal byte, sub, char = assert(string.byte),\n                        assert(string.sub),\n                        assert(string.char)\nlocal m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove\nlocal navigation, is_nav = a.navigation, a.is_nav\n\nlocal function process_escapes(seq)\n   if is_nav(seq) then\n      return modeS(\"NAV\", navigation[seq])\n   elseif is_mouse(seq) then\n      return modeS(\"MOUSE\", m_parse(seq))\n   elseif #seq == 2 and byte(seq, 2) < 128 then\n      -- Meta\n      local key = \"M-\" .. sub(seq,2,2)\n      return modeS(\"ALT\", key)\n   elseif a.is_paste(seq) then\n      return modeS(\"PASTE\", a.parse_paste(seq))\n   else\n      return modeS(\"NYI\", seq)\n   end\nend\n\n-- uv, being an event loop, will sometimes keep reading after\n-- we expect it to stop.\n-- this prevents modeS from being reloaded in such circumstances.\n--\n-- maybe.\n\nlocal _ditch = false\n\nlocal function onseq(err,seq)\n   if _ditch then return nil end\n   if err then error(err) end\n\n   local head = byte(seq)\n   -- ^Q hard coded as quit, for now\n   if head == 17 then\n      _ditch = true\n      modeS.zones.status:replace \'exiting repl, owo... ðŸ²\'\n      modeS:paint()\n      uv.read_stop(stdin)\n      uv.timer_stop(timer)\n      return 0\n   end\n   -- Escape sequences\n   if head == 27 then\n      return process_escapes(seq)\n   end\n   -- Control sequences\n   if navigation[seq] then\n      return modeS(\"NAV\", navigation[seq])\n   elseif head <= 31 then\n      local ctrl = \"^\" .. char(head + 64)\n      return modeS(\"CTRL\", ctrl)\n   end\n   -- Printables--break into codepoints in case of multi-char input sequence\n   -- But first, optimize common case of single ascii printable\n   -- Note that bytes <= 31 and 127 (DEL) will have been taken care of earlier\n   if #seq == 1 and head < 128 then\n      return modeS(\"ASCII\", seq)\n   else\n      local points = Codepoints(seq)\n      for i, pt in ipairs(points) do\n         -- #todo handle decode errors here--right now we\'ll just insert an\n         -- actual Unicode \"replacement character\"\n         modeS(byte(pt) < 128 and \"ASCII\" or \"UTF8\", pt)\n      end\n   end\nend\n\n\n\n\n\n-- Get names for as many values as possible\n-- into the colorizer\n-- Treat package names as existing in the global namespace\n-- rather than having a \"package.loaded.\" prefix\nlocal names = require \"helm/repr/names\"\nnames.loadNames(package.loaded)\nnames.loadNames(_G)\nnames.loadNames(__G)\n\n-- assuming we survived that, set up our repling environment:\n\n-- raw mode\nuv.tty_set_mode(stdin, 2)\n\n-- Enable mouse tracking, save the cursor, switch screens and wipe,\n-- then put the cursor at 1,1.\n-- #todo Cursor save/restore supposedly may not work on all terminals?\n-- Test this and, if necessary, explicitly read and store the cursor position\n-- and manually restore it at the end.\nwrite(a.cursor.stash(),\n      a.alternate_screen(true),\n      a.erase.all(),\n      a.jump(1, 1),\n      a.paste_bracketing(true),\n      a.mouse.track(true)\n)\nuv.read_start(stdin, onseq)\n\n-- paint screen\nmodeS:paint()\n\n-- main loop\nlocal retcode =  uv.run(\'default\')\n\n-- Shut down the database conn:\nlocal conn = modeS.hist.conn\npcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n-- set up an idler to close the conn, so that e.g. busy\n-- exceptions don\'t blow up the hook\nlocal close_idler = uv.new_idle()\nclose_idler:start(function()\n  local success = pcall(conn.close, conn)\n  if not success then\n    return nil\n  else\n    close_idler:stop()\n  end\nend)\n\nretcode = uv.run \'default\'\n\n-- Teardown: Mouse tracking off, restore main screen and cursor\nwrite(a.mouse.track(false),\n      a.paste_bracketing(false),\n      a.alternate_screen(false),\n      a.cursor.pop())\n\n\n\n-- remove any spurious mouse inputs or other stdin stuff\nio.stdin:read \"*a\"\n\n-- Back to normal mode\nuv.tty_reset_mode()\n\nuv.stop()\n\nio.stdout:flush()\n\n-- nil out our extra copy of _G\n_G_back = nil\n\nend -- of _helm\n\n\n\n\n\nreturn _helm\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/historian",
hash = "c97c8f9c0a2e48bd1db851f8bdcfe7ce30dd5eb54995c6ba794e5ccc744576e3",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv      = require \"luv\"\nlocal sql     = assert(sql, \"sql must be in bridge _G\")\n\nlocal Txtbuf  = require \"helm/txtbuf\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal C       = require \"singletons/color\"\nlocal repr    = require \"helm/repr\"\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal reverse = require \"core/table\" . reverse\nlocal meta = require \"core/meta\" . meta\n\nlocal Set = require \"set:set\"\n\n\n\n\nlocal File = require \"fs:fs/file\"\nlocal Dir  = require \"fs:fs/directory\"\n\n\n\n\nlocal Historian = meta {}\nHistorian.HISTORY_LIMIT = 2000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n]]\n\nlocal create_project_table_3 = [[\nCREATE TABLE IF NOT EXISTS project_3 (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\'))\n);\n]]\n\nlocal create_repl_table = [[\nCREATE TABLE IF NOT EXISTS repl (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\nlocal create_repl_table_3 = [[\nCREATE TABLE IF NOT EXISTS repl_3 (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\nlocal create_result_table = [[\nCREATE TABLE IF NOT EXISTS result (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   line_id INTEGER,\n   repr text NOT NULL,\n   value blob,\n   FOREIGN KEY (line_id)\n      REFERENCES repl (line_id)\n      ON DELETE CASCADE\n);\n]]\n\nlocal create_session_table = [[\nCREATE TABLE IF NOT EXISTS session (\nsession_id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT,\nproject INTEGER,\n-- These two are line_ids\nstart INTEGER NOT NULL,\nend INTEGER,\ntest BOOLEAN,\nsha TEXT,\nFOREIGN KEY (project)\n   REFERENCES project (project_id)\n   ON DELETE CASCADE );\n]]\n\n\n\n\nlocal insert_line = [[\nINSERT INTO repl (project, line) VALUES (:project, :line);\n]]\n\nlocal insert_result = [[\nINSERT INTO result (line_id, repr) VALUES (:line_id, :repr);\n]]\n\nlocal insert_project = [[\nINSERT INTO project (directory) VALUES (?);\n]]\n\n\n\n\nlocal get_recent = [[\nSELECT CAST (line_id AS REAL), line FROM repl\n   WHERE project = :project\n   ORDER BY line_id DESC\n   LIMIT :num_lines;\n]]\n\nlocal get_number_of_lines = [[\nSELECT CAST (count(line) AS REAL) from repl\n   WHERE project = ?\n;\n]]\n\nlocal get_project = [[\nSELECT project_id FROM project\n   WHERE directory = %s;\n]]\n\nlocal get_results = [[\nSELECT result.repr\nFROM result\nWHERE result.line_id = :line_id\nORDER BY result.result_id;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal HELM_DB_VERSION = 3\n\nlocal migrations = {function() return true end}\n\n\n\n\n\n\nlocal function migration_2(conn)\n   conn:exec(create_project_table)\n   conn:exec(create_result_table)\n   conn:exec(create_repl_table)\n   conn:exec(create_session_table)\n   return true\nend\n\ninsert(migrations, migration_2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migration_3(conn)\n   conn.pragma.foreign_keys(false)\n   conn:exec \"BEGIN TRANSACTION;\"\n   conn:exec [[\n      UPDATE project\n      SET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n   ]]\n   conn:exec(create_project_table_3)\n   conn:exec [[\n      INSERT INTO project_3 (project_id, directory, time)\n      SELECT project_id, directory, time\n      FROM project;\n   ]]\n   conn:exec \"DROP TABLE project;\"\n   conn:exec [[\n      ALTER TABLE project_3\n      RENAME TO project;\n   ]]\n   conn:exec [[\n      UPDATE repl\n      SET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n   ]]\n   conn:exec(create_repl_table_3)\n   conn:exec [[\n      INSERT INTO repl_3 (line_id, project, line, time)\n      SELECT line_id, project, line, time\n      FROM repl;\n   ]]\n   conn:exec \"DROP TABLE repl;\"\n   conn:exec [[\n      ALTER TABLE repl_3\n      RENAME to repl;\n   ]]\n   conn:exec \"COMMIT;\"\n   conn.pragma.foreign_keys(true)\n   return true\nend\ninsert(migrations, migration_3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- make the /helm directory\n-- use sh to avoid a permissions issue with stale versions of fs\nif not Dir(_Bridge.bridge_home .. \"/helm\"):exists() then\n   local sh = require \"orb:util/sh\"\n   sh(\"mkdir\", \"-p\", _Bridge.bridge_home .. \"/helm\")\nend\n\nlocal old_helm = File (_Bridge.bridge_home .. \"/.helm\")\nif old_helm:exists() then\n   -- move it\n   if File(_Bridge.bridge_home .. \"/.helm-wal\"):exists() then\n      print \"please shut down all helm instances before running migration\"\n      os.exit()\n   end\n   if File(_Bridge.bridge_home .. \"/helm/helm.sqlite\"):exists() then\n      print \"two databases in $BRIDGE_HOME: .helm and helm/helm.sqlite\"\n      print \"probably, the migration has already been performed,\"\n      print \"but an old copy of helm was then used.\"\n      print \"please inspect the databases with sqlite3 and delete the one\"\n      print \"you don\'t want to keep.\"\n      os.exit()\n   end\n   local sh = require \"orb:util/sh\"\n   sh(\"mv \" .. tostring(old_helm) .. \" \"\n      .. _Bridge.bridge_home .. \"/helm/helm.sqlite\")\nend\n\n\n\n\n\n\n\n\n\n\nHistorian.helm_db = _Bridge.bridge_home .. \"/helm/helm.sqlite\"\n\nHistorian.project = uv.cwd()\n\nlocal function has(table, name)\n   for _,v in ipairs(table) do\n      if name == v then\n         return true\n      end\n   end\n   return false\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bound, inbounds = import(\"core:core/math\", \"bound\", \"inbounds\")\nlocal assertfmt = import(\"core:core/string\", \"assertfmt\")\nlocal format = assert(string.format)\n\n\nfunction Historian.load(historian)\n   local conn = sql.open(historian.helm_db, \"rwc\")\n   historian.conn = conn\n   -- Set up bridge tables\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \"wal\"\n   -- check the user_version and perform migrations if necessary.\n   assertfmt(#migrations == HELM_DB_VERSION,\n             \"number of migrations (%d) must equal HELM_DB_VERSION (%d)\",\n             #migrations, HELM_DB_VERSION)\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < HELM_DB_VERSION then\n      for i = user_version, HELM_DB_VERSION do\n         migrations[i](conn)\n      end\n      conn.pragma.user_version(HELM_DB_VERSION)\n   elseif user_version > HELM_DB_VERSION then\n      error(format(\"Error: helm.sqlite is version %d, expected %d\",\n                   user_version, HELM_DB_VERSION))\n      os.exit(HELM_DB_VERSION)\n   end\n   -- Retrieve project id\n   local proj_val, proj_row = sql.pexec(conn,\n                                  sql.format(get_project, historian.project),\n                                  \"i\")\n   if not proj_val then\n      local ins_proj_stmt = conn:prepare(insert_project)\n      ins_proj_stmt : bind(historian.project)\n      proj_val, proj_row = ins_proj_stmt:step()\n      -- retry\n      proj_val, proj_row = sql.pexec(conn,\n                              sql.format(get_project, historian.project),\n                              \"i\")\n      if not proj_val then\n         error \"Could not create project in .bridge\"\n      end\n   end\n   local project_id = proj_val[1][1]\n   historian.project_id = project_id\n   -- Create insert prepared statements\n   historian.insert_line = conn:prepare(insert_line)\n   historian.insert_result = conn:prepare(insert_result)\n   -- Create result retrieval prepared statement\n   historian.get_results = conn:prepare(get_results)\n   -- Retrieve history\n   local number_of_lines = conn:prepare(get_number_of_lines)\n                             :bind(project_id):step()[1]\n   if number_of_lines == 0 then\n      return nil\n   end\n   number_of_lines = bound(number_of_lines, nil, historian.HISTORY_LIMIT)\n   local pop_stmt = conn:prepare(get_recent)\n                      : bindkv { project = project_id,\n                                 num_lines = number_of_lines }\n   historian.cursor = number_of_lines + 1\n   historian.cursor_start = number_of_lines + 1\n   historian.n = number_of_lines\n   local counter = number_of_lines\n   local idler\n   local function load_one()\n      local res = pop_stmt:step()\n      if not res then\n         if idler then idler:stop() end\n         return nil\n      end\n      historian[counter] = Txtbuf(res[2])\n      historian.line_ids[counter] = res[1]\n      -- Results are loaded backwards because that\'s how they\'re accessed\n      counter = counter - 1\n   end\n   -- add one line to ensure we have history on startup\n   load_one()\n   -- idle to populate the rest of the history\n   idler = uv.new_idle()\n   idler:start(load_one)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ninsert(tab, val)\n   tab.n = tab.n + 1\n   tab[tab.n] = val\nend\n\nlocal SOH, STX = \"\\x01\", \"\\x02\"\n\nlocal function dump_token(token, stream)\n   ninsert(stream, SOH)\n   if token.event then\n      ninsert(stream, \"event=\")\n      ninsert(stream, token.event)\n   end\n   if token.wrappable then\n      if token.event then ninsert(stream, \" \") end\n      ninsert(stream, \"wrappable\")\n   end\n   ninsert(stream, STX)\n   ninsert(stream, tostring(token))\n   return stream\nend\n\nlocal tabulate = require \"helm/repr/tabulate\"\n\nfunction Historian.persist(historian, txtbuf, results)\n   local lb = tostring(txtbuf)\n   local have_results = results\n                        and type(results) == \"table\"\n                        and results.n\n   if lb == \"\" then\n      -- A blank line can have no results and is uninteresting.\n      return false\n   end\n   historian.conn:exec(\"SAVEPOINT save_persist\")\n   historian.insert_line:bindkv { project = historian.project_id,\n                                       line    = sql.blob(lb) }\n   local err = historian.insert_line:step()\n   if not err then\n      historian.insert_line:clearbind():reset()\n   else\n      error(err)\n   end\n   local line_id = sql.lastRowId(historian.conn)\n   insert(historian.line_ids, line_id)\n\n   -- If there\'s nothing to persist, release our savepoint\n   -- and don\'t bother starting the idler\n   if not have_results then\n      historian.conn:exec(\"RELEASE save_persist\")\n      return true\n   end\n\n   local results_tostring, results_tabulates = {}, {}\n   -- Make a dummy table to stand in for Composer:window(),\n   -- since we won\'t be making a Composer at all.\n   local dummy_window = { width = 80, remains = 80, color = C.no_color }\n   for i = 1, results.n do\n      results_tabulates[i] = tabulate(results[i], dummy_window, C.no_color)\n      results_tostring[i] = { n = 0 }\n   end\n   local i = 1\n   local persist_idler = uv.new_idle()\n   historian.idlers:insert(persist_idler)\n   persist_idler:start(function()\n      if i <= results.n then\n         local start_token_count = results_tostring[i].n\n         if start_token_count > 15000 then\n            -- bail early\n            results_tostring[i] = concat(results_tostring[i], \"\", 1, results_tostring[i].n)\n            i  = i + 1\n            return nil\n         end\n         while results_tostring[i].n - start_token_count < 100 do\n            local success, token = pcall(results_tabulates[i])\n            if success then\n               if token then\n                  dump_token(token, results_tostring[i])\n               else\n                  results_tostring[i] = concat(results_tostring[i], \"\", 1, results_tostring[i].n)\n                  i = i + 1\n                  -- Stop this execution of the idler now, even if we\n                  -- haven\'t gotten 100 tokens--easier than keeping track\n                  -- across result boundaries\n                  return nil\n               end\n            else\n               error(token)\n            end\n         end\n         return nil\n      end\n      -- now persist\n      for i = 1, results.n do\n         historian.insert_result:bindkv { line_id = line_id,\n                                          repr = results_tostring[i] }\n         err = historian.insert_result:step()\n         if not err then\n            historian.insert_result:clearbind():reset()\n         else\n            error(err)\n         end\n      end\n      historian.conn:exec(\"RELEASE save_persist\")\n      persist_idler:stop()\n      assert(historian.idlers:remove(persist_idler) == true)\n   end)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm/selection_list\"\nlocal fuzz_patt = require \"helm:helm/fuzz_patt\"\n\nfunction Historian.search(historian, frag)\n   if historian.last_collection\n      and historian.last_collection[1].lit_frag == frag then\n      -- don\'t repeat a search\n      return historian.last_collection\n   end\n   if frag == \"\" then\n      return \"\"\n   end\n   local result = SelectionList()\n   result.cursors = {}\n   result.frag = frag\n   result.lit_frag = frag\n   result.best = true\n   result.show_shortcuts = true\n   local function try_search()\n      local patt = fuzz_patt(result.frag)\n      local dup = {}\n      for i = historian.n, 1, -1 do\n         local item_str = tostring(historian[i])\n         if not dup[item_str] and patt:match(item_str) then\n            dup[item_str] = true\n            insert(result, item_str)\n            insert(result.cursors, i)\n         end\n      end\n   end\n   try_search()\n   if #result == 0 then\n      result.best = false\n      result.frag = frag:sub(1, -3) .. frag:sub(-1, -1) .. frag:sub(-2, -2)\n      try_search()\n   end\n   result.selected_index = 1\n   historian.last_collection = Rainbuf {[1] = result, n = 1, live = true}\n   historian.last_collection.made_in = \"historian.search\"\n   return historian.last_collection\nend\n\n\n\n\n\n\n\n\nlocal lines = import(\"core/string\", \"lines\")\nlocal find, match, sub = assert(string.find),\n                         assert(string.match),\n                         assert(string.sub)\nlocal Token = require \"helm/repr/token\"\nlocal function _db_result__repr(result)\n   if sub(result[1], 1, 1) == SOH then\n      -- New format--tokens delimited by SOH/STX\n      local header_position = 1\n      local text_position = 0\n      return function()\n         text_position = find(result[1], STX, header_position + 1)\n         if not text_position then\n            return nil\n         end\n         local metadata = sub(result[1], header_position + 1, text_position - 1)\n         local cfg = {}\n         if find(metadata, \"wrappable\") then cfg.wrappable = true end\n         cfg.event = match(metadata, \"event=(%w+)\")\n         header_position = find(result[1], SOH, text_position + 1)\n         if not header_position then\n            header_position = #result[1] + 1\n         end\n         local text = sub(result[1], text_position + 1, header_position - 1)\n         return Token(text, C.color.greyscale, cfg)\n      end\n   else\n      -- Old format--just a string, which we\'ll break up into lines\n      local line_iter = lines(result[1])\n      return function()\n         local line = line_iter()\n         if line then\n            -- Might as well return a Token in order to attach the color properly,\n            -- rather than just including the color escapes in the string\n            return Token(line, C.color.greyscale, { event = \"repr_line\" })\n         else\n            return nil\n         end\n      end\n   end\nend\n\nlocal _db_result_M = meta {}\n_db_result_M.__repr = _db_result__repr\n\n\nlocal function _resultsFrom(historian, cursor)\n   if historian.result_buffer[cursor] then\n      return historian.result_buffer[cursor]\n   end\n   local line_id = historian.line_ids[cursor]\n   local stmt = historian.get_results\n   stmt:bindkv {line_id = line_id}\n   local results = stmt :resultset \'i\'\n   if results then\n      results = results[1]\n      results.n = #results\n      for i = 1, results.n do\n         -- stick the result in a table to enable repr-ing\n         results[i] = {results[i]}\n         setmetatable(results[i], _db_result_M)\n      end\n   end\n   historian.get_results:reset()\n   -- may as well memoize the database call, while we\'re here\n   historian.result_buffer[line_id] = results\n   return results\nend\n\n\n\n\n\n\n\nfunction Historian.prev(historian)\n   historian.cursor = bound(historian.cursor - 1, 1)\n   local txtbuf = historian[historian.cursor]\n   if txtbuf then\n      txtbuf = txtbuf:clone()\n      txtbuf:startOfText()\n      txtbuf:endOfLine()\n      local result = _resultsFrom(historian, historian.cursor)\n      return txtbuf, result\n   else\n      return Txtbuf(), nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Historian.next(historian)\n   historian.cursor = bound(historian.cursor + 1, nil, historian.n + 1)\n   local txtbuf = historian[historian.cursor]\n   if txtbuf then\n      txtbuf = txtbuf:clone()\n      txtbuf:endOfText()\n      local result = _resultsFrom(historian, historian.cursor)\n      return txtbuf, result\n   else\n      return nil, nil\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.index(historian, cursor)\n   assert(inbounds(cursor, 1, historian.n))\n   local txtbuf = historian[cursor]:clone()\n   txtbuf:endOfText()\n   local result = _resultsFrom(historian, cursor)\n   historian.cursor = cursor\n   return txtbuf, result\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.append(historian, txtbuf, results, success)\n   if tostring(historian[historian.n]) == tostring(txtbuf)\n      or tostring(txtbuf) == \"\" then\n      -- don\'t bother\n      return false\n   end\n   historian[historian.n + 1] = txtbuf\n   historian.n = historian.n + 1\n   if success then\n      historian:persist(txtbuf, results)\n   else\n      historian:persist(txtbuf)\n   end\n   return true\nend\n\n\n\n\nlocal __result_buffer_M = meta {}\nfunction __result_buffer_M.__repr(buf, window, c)\n   return c.alert \"cowardly refusing to print result_buffer to avoid infinite appending\"\nend\n\nlocal function new(helm_db)\n   local historian = meta(Historian)\n   if helm_db then\n      historian.helm_db = helm_db\n   end\n   historian.line_ids = {}\n   historian.cursor = 0\n   historian.cursor_start = 0\n   historian.n = 0\n   historian:load()\n   historian.result_buffer = setmetatable({}, __result_buffer_M)\n   historian.idlers = Set()\n   return historian\nend\nHistorian.idEst = new\n\n\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/zone",
hash = "9b226920ad6a4b8d755e6b6e459b3f74c37ae240ef6c57dbda875eb44e117002",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Txtbuf = require \"helm/txtbuf\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal a = require \"anterm:anterm\"\n\nlocal instanceof = import(\"core/meta\", \"instanceof\")\n\n\n\nlocal Zone = meta {}\nlocal Zoneherd = meta {}\n\n\n\n\n\n\n\n\nfunction Zone.height(zone)\n   return zone.br - zone.tr + 1\nend\n\nfunction Zone.width(zone)\n   return zone.bc - zone.tc + 1\nend\n\n\n\n\n\n\n\n\n\nfunction Zone.overlaps(zone, other_zone)\n   -- The other zone may be uninitialized--treat this as nonoverlapping\n   if not (other_zone.tc and other_zone.tr and\n           other_zone.bc and other_zone.br) then\n      return false\n   end\n   return zone.tc <= other_zone.bc and\n          zone.bc >= other_zone.tc and\n          zone.tr <= other_zone.br and\n          zone.br >= other_zone.tr\nend\n\n\n\n\n\n\n\nfunction Zone.replace(zone, contents)\n   zone.contents = contents or \"\"\n   zone:beTouched()\n   return zone\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bound = import(\"core/math\", \"bound\")\nlocal instanceof = import(\"core/meta\", \"instanceof\")\nfunction Zone.scrollTo(zone, offset, allow_overscroll)\n   if not instanceof(zone.contents, Rainbuf) then\n      return false\n   end\n   -- Try to render the content that will be visible after the scroll\n   zone.contents:composeUpTo(offset + zone:height())\n   local required_lines_visible = allow_overscroll and 1 or zone:height()\n   offset = bound(offset, 0, #zone.contents.lines - required_lines_visible)\n   if offset ~= zone.contents.offset then\n      zone.contents.offset = offset\n      zone:beTouched()\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\nfunction Zone.scrollBy(zone, delta, allow_overscroll)\n   -- Need to check this here even though :scrollTo already does\n   -- because we talk to the Rainbuf to figure out the new offset\n   if not instanceof(zone.contents, Rainbuf) then\n      return false\n   end\n   return zone:scrollTo(zone.contents.offset + delta, allow_overscroll)\nend\n\n\n\n\n\n\n\nfunction Zone.scrollUp(zone)\n   return zone:scrollBy(-1)\nend\nfunction Zone.scrollDown(zone)\n   return zone:scrollBy(1)\nend\n\nfunction Zone.pageUp(zone)\n   return zone:scrollBy(-zone:height())\nend\nfunction Zone.pageDown(zone)\n   return zone:scrollBy(zone:height())\nend\n\nlocal floor = assert(math.floor)\nfunction Zone.halfPageUp(zone)\n   return zone:scrollBy(-floor(zone:height() / 2))\nend\nfunction Zone.halfPageDown(zone)\n   return zone:scrollBy(floor(zone:height() / 2))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zone.scrollToTop(zone)\n   return zone:scrollTo(0)\nend\n\nfunction Zone.scrollToBottom(zone, allow_overscroll)\n   zone.contents:composeAll()\n   -- Choose a definitely out-of-range value,\n   -- which scrollTo will bound appropriately\n   return zone:scrollTo(#zone.contents.lines, allow_overscroll)\nend\n\n\n\n\n\n\n\nfunction Zone.setBounds(zone, tc, tr, bc, br)\n   assert(tc <= bc, \"tc: \" .. tc .. \", bc: \" .. bc)\n   assert(tr <= br, \"tr: \" .. tr .. \", br: \" .. br)\n   if not(zone.tr == tr and\n          zone.tc == tc and\n          zone.br == br and\n          zone.bc == bc) then\n      -- If zone width is changing, clear caches of the contained Rainbuf\n      -- Note that :setBounds() is called to set zone.(tc,bc,tr,br) for the first time,\n      -- so we only check for a change if there are previous values\n      if zone.bc and zone.tc\n         and (bc - tc) ~= (zone.bc - zone.tc)\n         and instanceof(zone.contents, Rainbuf) then\n         zone.contents:clearCaches()\n      end\n      zone.tr = tr\n      zone.tc = tc\n      zone.br = br\n      zone.bc = bc\n      -- #todo technically this is incomplete as we need to care about\n      -- cells we may previously have owned and no longer do, and what zones\n      -- *are* now responsible for them. Doing that properly requires a real\n      -- two-step layout process, though (figure out where everything is going\n      -- to be, *then* put it there and mark things touched), so we\'ll\n      -- hold off for now\n      zone:beTouched()\n   end\n   return zone\nend\n\n\n\n\n\nfunction Zone.setVisibility(zone, new_visibility)\n   if new_visibility ~= zone.visible then\n      zone.visible = new_visibility\n      zone:beTouched()\n   end\n   return zone\nend\n\nfunction Zone.show(zone)\n   return zone:setVisibility(true)\nend\nfunction Zone.hide(zone)\n   return zone:setVisibility(false)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Zone.beTouched(zone)\n   if zone.touched then return end\n   zone.touched = true\n   for _, other_zone in ipairs(zone.zoneherd) do\n      if zone.z ~= other_zone.z and\n         zone.visible == (other_zone.z > zone.z) and\n         zone:overlaps(other_zone) then\n         other_zone.touched = true\n      end\n   end\nend\n\n\n\n\n\nlocal lines = import(\"core/string\", \"lines\")\n\nlocal function _writeLines(write, zone, str)\n   local nl = a.col(zone.tc) .. a.jump.down(1)\n   local pr_row = zone.tr\n   for line in lines(str) do\n       write(line)\n       write(nl)\n       pr_row = pr_row + 1\n       if pr_row > zone.br then\n          break\n       end\n   end\nend\n\n\n\n\n\n\n\n\nlocal instanceof = import(\"core/meta\", \"instanceof\")\n\nlocal function _renderRainbuf(write, zone)\n   if not zone.contents then\n      return nil\n   end\n   assert(instanceof(zone.contents, Rainbuf))\n   local nl = a.col(zone.tc) .. a.jump.down(1)\n   for line in zone.contents:lineGen(zone:height(), zone:width()) do\n      write(line)\n      write(nl)\n   end\nend\n\n\n\n\n\nlocal concat = assert(table.concat)\nlocal c = import(\"singletons/color\", \"color\")\nlocal Token = require \"helm/repr/token\"\n\nlocal function _renderTxtbuf(modeS, zone, write)\n   local tokens = modeS.lex(zone.contents)\n   for i, tok in ipairs(tokens) do\n      -- If suggestions are active and one is highlighted,\n      -- display it in grey instead of what the user has typed so far\n      -- Note this only applies once Tab has been pressed, as until then\n      -- :selectedItem() will be nil\n      if tok.cursor_offset and modeS.suggest.active_suggestions\n         and modeS.suggest.active_suggestions[1]:selectedItem() then\n         tok = Token(modeS.suggest.active_suggestions[1]:selectedItem(), c.base)\n      end\n      tokens[i] = tok:toString(c)\n   end\n   _writeLines(write, zone, concat(tokens))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Zoneherd.addZone(zoneherd, zone)\n   zoneherd[zone.name] = zone\n   zone.zoneherd = zoneherd\n   local insert_index\n   for i, existing in ipairs(zoneherd) do\n      if existing.z > zone.z then\n         insert_index = i\n         break\n      end\n   end\n   if insert_index then\n      insert(zoneherd, insert_index, zone)\n   else\n      insert(zoneherd, zone)\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\nlocal function newZone(name, z, debug_mark)\n   local zone = meta(Zone)\n   zone.name = name\n   zone.debug_mark = debug_mark\n   zone.z = z\n   zone.visible = true\n   zone.touched = false\n   -- zone.contents, aspirationally a rainbuf, is provided later\n   return zone\nend\n\nfunction Zoneherd.newZone(zoneherd, name, z, debug_mark)\n   return zoneherd:addZone(newZone(name, z, debug_mark))\nend\n\n\n\n\n\nlocal function _zoneOffset(modeS)\n   if modeS.max_col <= 80 then\n      return 20\n   elseif modeS.max_col <= 100 then\n      return 30\n   elseif modeS.max_col <= 120 then\n      return 40\n   else\n      return 50\n   end\nend\n\n\n\n\n\nlocal ceil, floor = assert(math.ceil), assert(math.floor)\n\nfunction Zoneherd.reflow(zoneherd, modeS)\n   local right_col = modeS.max_col - _zoneOffset(modeS)\n   local txt_off = modeS:continuationLines()\n   zoneherd.status:setBounds(  1, 1, right_col, 1)\n   zoneherd.stat_col:setBounds(right_col + 1, 1,\n                               modeS.max_col, 1 )\n   zoneherd.prompt:setBounds(  1,\n                               modeS.repl_top,\n                               modeS.l_margin - 1,\n                               modeS.repl_top + txt_off )\n   zoneherd.command:setBounds( modeS.l_margin,\n                               modeS.repl_top,\n                               right_col,\n                               modeS.repl_top + txt_off )\n   zoneherd.results:setBounds( 1,\n                               modeS.repl_top + txt_off + 1,\n                               right_col,\n                               modeS.max_row )\n   zoneherd.suggest:setBounds( right_col + 1,\n                               modeS.repl_top + 1,\n                               modeS.max_col,\n                               modeS.max_row )\n   -- Popup is centered and 2/3 of max width, i.e. from 1/6 to 5/6\n   zoneherd.popup:setBounds(   floor(modeS.max_col / 6),\n                               modeS.repl_top + txt_off + 1,\n                               ceil(modeS.max_col * 5 / 6),\n                               modeS.max_row)\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zoneherd.paint(zoneherd, modeS)\n   local write = zoneherd.write\n   write(a.cursor.hide(), a.clear())\n   for i, zone in ipairs(zoneherd) do\n      if zone.visible and zone.touched then\n         -- erase\n         write(a.erase.box( zone.tc,\n                            zone.tr,\n                            zone.bc,\n                            zone.br ),\n               a.colrow(zone.tc, zone.tr))\n         -- actually render ze contents\n         if type(zone.contents) == \"string\" then\n            _writeLines(write, zone, zone.contents)\n         elseif instanceof(zone.contents, Txtbuf) then\n            _renderTxtbuf(modeS, zone, write)\n         else\n            _renderRainbuf(write, zone)\n         end\n      end\n      zone.touched = false\n   end\n   modeS:placeCursor()\n   write(a.cursor.show())\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\nlocal function new(modeS, writer)\n   local zoneherd = meta(Zoneherd)\n   zoneherd.write = writer\n   -- make Zones\n   -- correct values are provided by reflow\n   zoneherd:newZone(\"status\", 1, \".\")\n   zoneherd:newZone(\"stat_col\", 1, \"!\")\n   zoneherd:newZone(\"prompt\", 1, \">\")\n   zoneherd:newZone(\"command\", 1, \"$\")\n   zoneherd:newZone(\"results\", 1, \"~\")\n   zoneherd:newZone(\"suggest\", 1, \"%\")\n   zoneherd:newZone(\"popup\", 2, \"^\")\n   zoneherd.popup.visible = false\n   zoneherd:reflow(modeS)\n\n   return zoneherd\nend\n\n\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/watcher",
hash = "97c0b3809e6c6b6a00e013dea372feef036b9fcabc66cd1e05421cf6dd52b83c",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n    watcher.dir = dir\n    -- default to a recursive watch\n    if recur == nil then\n        recur = true\n    end\n    local fse = uv.new_fs_event()\n    watcher.fse = fse\n    uv.fs_event_start(fse, dir,{recursive = recur},function (err,fname,status)\n        if(err) then\n            print(\"Error \"..err)\n        else\n            local ev = nil\n            for k,v in pairs(status) do\n                ev = k\n            end\n            if ev == \"change\" then\n               watcher:onchange(fname)\n            elseif ev == \"rename\" then\n               watcher:onrename(fname)\n            else\n               print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n            end\n        end\n    end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/rainbuf",
hash = "62a2b64f8809289a10cfe144583249929c08a7758a6a0ac91011b19c5612c4e3",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal lineGen = import(\"helm/repr\", \"lineGen\")\n\n\n\n\n\n\nlocal Rainbuf = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\nfunction Rainbuf.clearCaches(rainbuf)\n   rainbuf.reprs = nil\n   rainbuf.r_num = nil\n   clear(rainbuf.lines)\nend\n\n\n\n\n\n\n\nlocal lines = import(\"core/string\", \"lines\")\nfunction Rainbuf.initComposition(rainbuf, cols)\n   cols = cols or 80\n   if rainbuf.scrollable then\n      cols = cols - 3\n   end\n   if rainbuf.live then\n      -- this buffer needs a fresh render each time\n      rainbuf:clearCaches()\n   end\n   if not rainbuf.reprs then\n      rainbuf.reprs = {}\n      rainbuf.r_num = 1\n      rainbuf.more = true\n      for i = 1, rainbuf.n do\n         rainbuf.reprs[i] = rainbuf.frozen\n            and lines(rainbuf[i])\n            or lineGen(rainbuf[i], cols)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nfunction Rainbuf.composeOneLine(rainbuf)\n   while true do\n      local repr = rainbuf.reprs[rainbuf.r_num]\n      if not repr then\n         rainbuf.more = false\n         return false\n      end\n      local line = repr()\n      if line then\n         insert(rainbuf.lines, line)\n         return true\n      else\n         rainbuf.r_num = rainbuf.r_num + 1\n      end\n   end\nend\n\n\n\n\n\n\n\n\nfunction Rainbuf.composeUpTo(rainbuf, line_number)\n   while rainbuf.more and #rainbuf.lines < line_number do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf.more\nend\n\n\n\n\n\n\n\nfunction Rainbuf.composeAll(rainbuf)\n   while rainbuf.more do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.lineGen(rainbuf, rows, cols)\n   rainbuf:initComposition(cols)\n   -- state for iterator\n   local cursor = rainbuf.offset\n   local max_row = rainbuf.offset + rows\n   local function _nextLine()\n      -- Off the end\n      if cursor >= max_row then\n         return nil\n      end\n      cursor = cursor + 1\n      rainbuf:composeUpTo(cursor)\n      local prefix = \"\"\n      if rainbuf.scrollable then\n         -- If this is the last line requested, but more are available,\n         -- prepend a continuation marker, otherwise left padding\n         prefix = \"   \"\n         if cursor == max_row and rainbuf.more then\n            prefix = a.red \"...\"\n         end\n      end\n      return rainbuf.lines[cursor] and prefix .. rainbuf.lines[cursor]\n   end\n   return _nextLine\nend\n\n\n\n\n\nlocal function new(res)\n   if type(res) == \"table\" and res.idEst == Rainbuf then\n      return res\n   end\n   local rainbuf = meta(Rainbuf)\n   assert(res.n, \"must have n\")\n   if res then\n      for i = 1, res.n do\n         rainbuf[i] = res[i]\n      end\n      rainbuf.n = res.n\n      rainbuf.frozen = res.frozen\n      rainbuf.live = res.live\n      rainbuf.scrollable = res.scrollable\n   end\n   rainbuf.offset = 0\n   rainbuf.lines = {}\n   return rainbuf\nend\n\nRainbuf.idEst = new\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/fuzz_patt",
hash = "023916c59b6b66f881e6302fe646c26d2c81b1d1e874d8b3919120706c6fb96c",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L        = require \"lpeg\"\nlocal P, match = L.P, L.match\nlocal Codepoints = require \"singletons/codepoints\"\n\nlocal function fuzz_patt(frag)\n   frag = type(frag) == \"string\" and Codepoints(frag) or frag\n   local patt =  (P(1) - P(frag[1]))^0\n   for i = 1 , #frag - 1 do\n      local v = frag[i]\n      patt = patt * (P(v) * (P(1) - P(frag[i + 1]))^0)\n   end\n   patt = patt * P(frag[#frag])\n   return patt\nend\n\nreturn fuzz_patt\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/edit",
hash = "044db75e7c02106a2ab24c95f6bb52fbf46734d81bc8c217abcbe7b0f4408fab",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal RagaBase = require \"helm:helm/raga/base\"\nlocal Txtbuf = require \"helm/txtbuf\"\n\n\n\nlocal EditBase = clone(RagaBase, 2)\n\n\n\n\n\n\n\n\n\nlocal function toTxtbuf(fn)\n   return function(modeS, category, value)\n      return modeS.txtbuf[fn](modeS.txtbuf)\n   end\nend\n\n\n\n\n\n\nlocal function _insert(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n   end\n   modeS.txtbuf:insert(value)\nend\n\nEditBase.ASCII = _insert\nEditBase.UTF8 = _insert\n\nfunction EditBase.PASTE(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n   end\n   modeS.txtbuf:paste(value)\nend\n\n\n\n\n\n\n\nlocal NAV = EditBase.NAV\n\nNAV.LEFT        = toTxtbuf \"left\"\nNAV.RIGHT       = toTxtbuf \"right\"\nNAV.ALT_LEFT    = toTxtbuf \"leftWordAlpha\"\nNAV.ALT_RIGHT   = toTxtbuf \"rightWordAlpha\"\nNAV.HOME        = toTxtbuf \"startOfLine\"\nNAV.END         = toTxtbuf \"endOfLine\"\nNAV.BACKSPACE   = toTxtbuf \"deleteBackward\"\nNAV.DELETE      = toTxtbuf \"deleteForward\"\n\n\n\n\n\n\nlocal CTRL = EditBase.CTRL\n\nCTRL [\"^A\"] = NAV.HOME\nCTRL [\"^E\"] = NAV.END\n\nlocal function clear_txtbuf(modeS, category, value)\n   modeS:setTxtbuf(Txtbuf())\n   modeS:setResults(\"\")\n   modeS.hist.cursor = modeS.hist.n + 1\nend\n\nCTRL [\"^L\"] = clear_txtbuf\n\nCTRL [\"^R\"] = function(modeS, category, value)\n                 modeS:restart()\n              end\n\nCTRL [\"^K\"] = toTxtbuf \"killToEndOfLine\"\nCTRL [\"^U\"] = toTxtbuf \"killToBeginningOfLine\"\nCTRL [\"^T\"] = toTxtbuf \"transposeLetter\"\n\n\n\n\n\n\nEditBase.ALT [\"M-w\"] = NAV.ALT_RIGHT\n\nEditBase.ALT [\"M-b\"] = NAV.ALT_LEFT\n\n\n\nreturn EditBase\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/lua-parser",
hash = "2e0f8b6e61bf46da03ca7b81fbc06f85616b34b49b27e7113436b096da072929",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\n\n\n\n\n\nlocal lua_str = [=[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr _ \",\" _ expr _ (\",\" _ expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t _ (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = reprsymbol\n       / !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nreprsymbol = \"$\" ([1-9] [0-9]*)* (\".\" ([a-z]/[A-Z]))*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]=]\n\n\n\n\n\n\n\n\nlocal Lua = Node : inherit \"lua\"\n\nfunction Lua.__tostring(lua)\n   return lua:span()\nend\n\nlocal lua_metas = { lua = Lua }\n\n\n\nreturn Peg(lua_str) : toGrammar(lua_metas)\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/luapersist",
hash = "871a177fb99970da9dc358475b8fa77be94bcda71786d8232720e7167b6089e4",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--[[ luapersist3.lua  2004-Aug-31 e\n\n  The author disclaims copyright to this source code.  In place of\n  a legal notice, here is a blessing:\n      May you be healthy and well.\n      May you be free of all suffering.\n      May you be happy, giving more than you take.\n\n  Lua Persistent Tables\n  loosely based on the wiki page http://lua-users.org/wiki/PersistentTables\n  uses Lua SQLite 3 (see http://luaforge.net/projects/luasqlite/)\n  handles circular structures\n\n  DB Schema\n  the Lua tables are stored in a single SQL table with five columns\n  TID : Table ID that identifies the Lua table -- string\n  Key : index in the Lua Table -- TID, string, number, or boolean\n  Kyp : the data type of Key\n  Val : value in the Lua Table at index -- TID, string, number, or boolean\n  Vyp : the data type of Val\n\n  A row is created for each Lua Persistent Table to reserve its TID.\n  The Key, Kyp, Val, and Vyp columns are all set to \"_\".\n\n  Both Kyp and Vyp use the following encoding:\n  \"b\" -- boolean (Key/Val = \"t\" or \"f\")\n  \"n\" -- number\n  \"t\" -- TID\n  \"s\" -- string\n  \"e\" -- encoded string (the raw string has embedded NULs)\n   \"_\" -- null\n\n  Caveats\n  1. Strings used for Key and Val may contain embedded \'\\0\' NUL characters;\n     they are stored using sqlite blobs.\n     Strings used for TIDs must not have embedded NULs.\n  2. A table may not be used as a key unless the table is already persistent;\n      tables may always be used as vals.\n  3. Functions, threads, and userdata are not supported as keys or vals.\n  4. Lua Persistent Tables may not have user metatables (they will not be\n     persisted, and they may conflict with Lua Persistent Table events).\n\n  Implementation\n\n  Lua Persistent Tables are represented by an empty Lua Table and a\n  corresponding metatable.\n\n  Lua Persistent Table Metatable events:\n  \"lpt_TID\" -- the TID for this table\n  \"index\" -- handler for unmarshalling Key/Val from the DB\n  \"newindex\" -- handler for marshalling Key/Val to the DB\n  \"lpt_cache\" -- a Lua Table that caches Key/Val pairs\n  \"lpt_db\" -- the Lua Persistent Table database descriptor for this table\'s db\n\n  LuaPersist maintains one global weak table, map, that is used to find\n  Lua Persistent Tables that are already open. This insures that there\n  is at most one version of each Lua Persistent Table in memory.\n]]\n\n-- nb: accidentally corrupted this file (fuck) and am not using it so,\n-- removed all source code -Sam\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/modeselektor",
hash = "37a11e6c8cb62dff6777301b67768fdea9a02ad85b7f476713fcefdd8db6ad35",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta, \"must have meta in _G\")\n\n\n\n\n\n\n\n\n\n\nlocal c = import(\"singletons/color\", \"color\")\nlocal Set = require \"set:set\"\n\nlocal Txtbuf     = require \"helm/txtbuf\"\nlocal Resbuf     = require \"helm/resbuf\" -- Not currently used...\nlocal Rainbuf    = require \"helm/rainbuf\"\nlocal Historian  = require \"helm/historian\"\nlocal Lex        = require \"helm/lex\"\nlocal Zoneherd   = require \"helm/zone\"\nlocal Suggest    = require \"helm/suggest\"\nlocal repr       = require \"helm/repr\"\nlocal lua_parser = require \"helm/lua-parser\"\n\nlocal concat               = assert(table.concat)\nlocal sub, gsub, rep, find = assert(string.sub),\n                             assert(string.gsub),\n                             assert(string.rep),\n                             assert(string.find)\n\nlocal ts = repr.ts_color\n\n\n\n\nlocal ModeS = meta()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeS.REPL_LINE = 2\n\n\n\n\n\n\n\nfunction ModeS.errPrint(modeS, log_stmt)\n   modeS.zones.suggest:replace(log_stmt)\n   modeS:paint()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal STAT_ICON = \"â—‰ \"\n\nlocal function tf(bool)\n  return bool and c[\"true\"](\"t\") or c[\"false\"](\"f\")\nend\n\nlocal function mouse_paint(m)\n   return c.userdata(STAT_ICON)\n      .. a.magenta(m.button) .. \": \"\n      .. tf(m.shift) .. \" \"\n      .. tf(m.meta) .. \" \"\n      .. tf(m.ctrl) .. \" \"\n      .. tf(m.moving) .. \" \"\n      .. tf(m.scrolling) .. \" \"\n      .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)\nend\n\nlocal function mk_paint(fragment, shade)\n   return function(action)\n      return shade(fragment .. action)\n   end\nend\n\nlocal function paste_paint(frag)\n   local result\n   -- #todo handle escaping of special characters in pasted data\n   if #frag < 20 then\n      result = \"PASTE: \" .. frag\n   else\n      result = (\"PASTE(%d): %s...\"):format(#frag, frag:sub(1, 17))\n   end\n   return a.green(STAT_ICON .. result)\nend\n\nlocal icon_map = { MOUSE = mouse_paint,\n                   NAV   = mk_paint(STAT_ICON, a.magenta),\n                   CTRL  = mk_paint(STAT_ICON, a.blue),\n                   ALT   = mk_paint(STAT_ICON, c[\"function\"]),\n                   ASCII = mk_paint(STAT_ICON, a.green),\n                   UTF8  = mk_paint(STAT_ICON, a.green),\n                   PASTE = paste_paint,\n                   NYI   = mk_paint(STAT_ICON .. \"! \", a.red) }\n\nlocal function _make_icon(category, value)\n   return icon_map[category](value)\nend\n\n\n\n\n\n\n\nfunction ModeS.placeCursor(modeS)\n   local col = modeS.zones.command.tc + modeS.txtbuf.cursor.col - 1\n   local row = modeS.zones.command.tr + modeS.txtbuf.cursor.row - 1\n   modeS.write(a.colrow(col, row))\n   return modeS\nend\n\n\n\n\n\n\n\nfunction ModeS.paint(modeS)\n   modeS.zones:paint(modeS)\n   return modeS\nend\n\n\n\n\n\n\nfunction ModeS.reflow(modeS)\n   modeS.zones:reflow(modeS)\n   modeS:paint()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\nModeS.raga_default = \"nerf\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.continuationLines(modeS)\n   return modeS.txtbuf and #modeS.txtbuf.lines - 1 or 0\nend\n\n\n\n\n\n\n\nfunction ModeS.updatePrompt(modeS)\n   local prompt = modeS.raga.prompt_char .. \" \" .. (\"\\n...\"):rep(modeS:continuationLines())\n   modeS.zones.prompt:replace(prompt)\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Nerf      = require \"helm/raga/nerf\"\nlocal Search    = require \"helm/raga/search\"\nlocal Complete  = require \"helm/raga/complete\"\nlocal Page      = require \"helm/raga/page\"\n\nModeS.closet = { nerf =     { raga = Nerf,\n                              lex  = Lex.lua_thor },\n                 search =   { raga = Search,\n                              lex  = Lex.null },\n                 complete = { raga = Complete,\n                              lex  = Lex.lua_thor },\n                 page =     { raga = Page,\n                              lex  = Lex.null } }\n\nfunction ModeS.shiftMode(modeS, raga_name)\n   -- Stash the current lexer associated with the current raga\n   -- Currently we never change the lexer separate from the raga,\n   -- but this will change when we start supporting multiple languages\n   -- Guard against nil raga or lexer during startup\n   if modeS.raga then\n      modeS.raga.onUnshift(modeS)\n      modeS.closet[modeS.raga.name].lex = modeS.lex\n   end\n   -- Switch in the new raga and associated lexer\n   modeS.raga = modeS.closet[raga_name].raga\n   modeS.lex = modeS.closet[raga_name].lex\n   modeS.raga.onShift(modeS)\n   modeS:updatePrompt()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.actOnce(modeS, category, value)\n   local handled = modeS.raga(modeS, category, value)\n   if modeS.shift_to then\n      modeS:shiftMode(modeS.shift_to)\n      modeS.shift_to = nil\n   end\n   if modeS.txtbuf.contents_changed then\n     modeS.raga.onTxtbufChanged(modeS)\n     modeS.txtbuf.contents_changed = false\n   end\n   if modeS.txtbuf.cursor_changed then\n     modeS.raga.onCursorChanged(modeS)\n     modeS.txtbuf.cursor_changed = false\n   end\n   return handled\nend\n\n\n\nfunction ModeS.act(modeS, category, value)\n   local icon = _make_icon(category, value)\n   local handled = false\n   repeat\n      modeS.action_complete = true\n      -- The raga may set action_complete to false to cause the command\n      -- to be re-processed, most likely after a mode-switch\n      local handledThisTime = modeS:actOnce(category, value)\n      handled = handled or handledThisTime\n   until modeS.action_complete == true\n   if not handled then\n      local val_rep = string.format(\"%q\",value):sub(2,-2)\n      icon = _make_icon(\"NYI\", category .. \": \" .. val_rep)\n   end\n\n   -- Replace zones\n   modeS.zones.stat_col:replace(icon)\n   modeS.zones.command:replace(modeS.txtbuf)\n   -- Reflow in case command height has changed. Includes a paint.\n   modeS:updatePrompt():reflow()\n   collectgarbage()\n   return modeS\nend\n\n\n\n\n\nfunction ModeS.__call(modeS, category, value)\n  return modeS:act(category, value)\nend\n\n\n\n\n\n\n\n\nlocal instanceof = import(\"core/meta\", \"instanceof\")\n\nfunction ModeS.setResults(modeS, results)\n   results = results or \"\"\n   if results == \"\" then\n      modeS.zones.results:replace(results)\n      return modeS\n   end\n   if type(results) == \"string\" then\n      results = { results, n = 1, frozen = true }\n   end\n   local rb = Rainbuf(results)\n   rb.scrollable = true\n   modeS.zones.results:replace(rb)\n   return modeS\nend\n\n\n\n\n\n\n\n\nfunction ModeS.setTxtbuf(modeS, txtbuf)\n   modeS.txtbuf = txtbuf\n   modeS.txtbuf.cursor_changed = true\n   modeS.txtbuf.contents_changed = true\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal eval_ENV = {}\nlocal eval_M = {}\nsetmetatable(eval_ENV, eval_M)\n\nlocal function indexer(Env, key)\n   return Env[key]\nend\n\nfunction eval_M.__index(eval_ENV, key)\n   local ok, value = pcall(indexer, _G, key)\n   if ok and value ~= nil then\n      return value\n   end\n   ok, value = pcall(indexer, __G, key)\n   if ok and value ~= nil then\n      return value\n   end\n   return nil\nend\n\nlocal function newindexer(Env, key, value)\n   Env[key] = value\nend\n\nlocal loadNames = import(\"helm/repr/names\", \"loadNames\")\n\nfunction eval_M.__newindex(eval_ENV, key, value)\n   local ok = pcall(newindexer, _G, key, value)\n   if not ok then\n      rawset(_G, key, value)\n   end\n   -- Use loadNames() to get the key added to all_symbols\n   -- Should really divide up responsibility better between\n   -- loadNames() and addName()\n   loadNames{ [key] = value }\nend\n\n\n\nlocal function gatherResults(success, ...)\n  return success, pack(...)\nend\n\n\n\nlocal result_repr_M = meta {}\n\nfunction result_repr_M.__repr(result)\n  local i = 1\n  return function()\n     if i <= #result then\n       i = i + 1\n       return result[i - 1]\n     end\n  end\nend\n\n\n\nlocal insert = assert(table.insert)\nlocal keys = assert(core.keys)\n\nfunction ModeS.__eval(modeS, chunk, headless)\n   if not modeS.original_packages then\n      -- we cache the package.loaded packages here, to preserve\n      -- everything loaded by helm and modeselektor, while letting\n      -- us hot-reload anything \"require\"d at the repl.\n      modeS.original_packages = Set(keys(package.loaded))\n   end\n   if not headless then\n      -- Getting ready to eval, cancel any active autocompletion\n      modeS.suggest:cancel(modeS)\n   end\n   -- check for leading =, old-school style\n   local head = sub(chunk, 1, 1)\n   if head == \"=\" then -- take pity on old-school Lua hackers\n       chunk = \"return \" .. sub(chunk,2)\n   end\n   -- add \"return\" and see if it parses\n   local return_chunk = \"return \" .. chunk\n   local parsed_chunk = lua_parser(return_chunk)\n   if not parsed_chunk:select \"Error\" () then\n      chunk = return_chunk\n   else\n      -- re-parse the chunk\n      parsed_chunk = lua_parser(chunk)\n   end\n   -- #Todo tinker with the chunk, finding $1-type vars\n   if parsed_chunk:select \"Error\" () then\n      -- our parser isn\'t perfect, let\'s see what lua thinks\n      local is_expr = loadstring(return_chunk)\n      if is_expr then\n         -- we have an expression which needs a return, and didn\'t\n         -- detect it:\n         chunk = return_chunk\n         -- otherwise, we\'ll try our luck with the chunk, as-is\n      end\n   end\n   local success, results\n   local f, err = loadstring(chunk, \'REPL\')\n   if f then\n      setfenv(f, eval_ENV)\n      success, results = gatherResults(xpcall(f, debug.traceback))\n      if not success then\n         -- error\n         results.frozen = true\n      end\n   else\n      if err:match \"\'<eof>\'$\" then\n         -- Lua expects some more input\n         return modeS, \'advance\'\n      else\n         -- make the error into the result\n         results = { err,\n                     n = 1,\n                     frozen = true }\n      end\n   end\n   if not headless then\n      modeS.hist:append(modeS.txtbuf, results, success)\n      modeS.hist.cursor = modeS.hist.n + 1\n      if success then\n         modeS.hist.result_buffer[modeS.hist.n] = results\n      end\n      modeS:setResults(results)\n      modeS:setTxtbuf(Txtbuf())\n   end\n\n   return modeS, results\nend\n\nfunction ModeS.eval(modeS)\n   local _, advance = modeS:__eval(tostring(modeS.txtbuf))\n   if advance == \'advance\' then\n      modeS.txtbuf:advance()\n   end\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS.evalFromCursor(modeS)\n   local top = modeS.hist.n\n   local cursor = modeS.hist.cursor\n   for i = cursor, top do\n      modeS.txtbuf = modeS.hist:index(i)\n      modeS:eval()\n   end\nend\n\n\n\n\n\n\n\n\nlocal deepclone = assert(core.deepclone)\n\nfunction ModeS.restart(modeS)\n   modeS.zones.status:replace \"Restarting an repl â†©ï¸\"\n   -- we might want to do this again, so:\n   local _G_backback = deepclone(_G_back)\n   -- package has to be handled separately because it\'s in the registry\n   local _loaded = package.loaded\n   _G = _G_back\n   -- we need the existing __G, not the empty clone, in _G:\n   _G.__G = __G\n   -- and we need the new _G, not the old one, as the index for __G:\n   getmetatable(__G).__index = _G\n   -- and the one-and-only package.loaded\n   _G.package.loaded = _loaded\n   _G_back = _G_backback\n   -- we also need to clear the registry of package.loaded\n   local current_packages = Set(keys(package.loaded))\n   local new_packages = current_packages - modeS.original_packages\n   for pack in pairs(new_packages) do\n      package.loaded[pack] = nil\n   end\n   -- perform rerun\n   -- Replace results:\n   local hist = modeS.hist\n   local top = hist.cursor - 1\n   local session_count = hist.cursor - hist.cursor_start\n   hist.cursor = hist.cursor_start\n   hist.n  = hist.n - session_count\n   hist.conn:exec \"SAVEPOINT restart_session;\"\n   for i = modeS.hist.cursor_start, top do\n      local _, results = modeS:__eval(tostring(hist[i]), true)\n      if results ~= \'advance\' then\n         hist.n = hist.n + 1\n         hist.result_buffer[hist.n] = results\n         hist:persist(hist[i], results)\n      end\n   end\n   hist.cursor = top + 1\n   hist.n = #hist\n   modeS:paint()\n   uv.timer_start(uv.new_timer(), 2000, 0,\n                  function()\n                     modeS.zones.status:replace(modeS.prompt_lines.default)\n                     modeS:paint()\n                  end)\n   local restart_idle = uv.new_idle()\n   restart_idle:start(function()\n      if #hist.idlers > 0 then\n         return nil\n      end\n      hist.conn:exec \"RELEASE restart_session;\"\n      restart_idle:stop()\n   end)\n   return modeS\nend\n\n\n\n\n\n\n\nfunction ModeS.openHelp(modeS)\n   local rb = Rainbuf{ (\"abcde \"):rep(1000), n = 1 }\n   modeS.zones.popup:replace(rb)\n   modeS.shift_to = \"page\"\nend\n\n\n\n\n\n\n\n\nlocal function _status__repr(status_table)\n  return concat(status_table)\nend\n\nlocal _stat_M = meta {}\n_stat_M.__repr = _status__repr\n\nfunction _stat_M.clear(status_table)\n  return setmetatable({}, getmetatable(status_table))\nend\n\n\n\n\n\n\n\nlocal function new(max_col, max_row, writer, db)\n  local modeS = meta(ModeS)\n  modeS.txtbuf = Txtbuf()\n  modeS.hist  = Historian(db)\n  modeS.suggest = Suggest()\n  modeS.status = setmetatable({}, _stat_M)\n  rawset(__G, \"stat\", modeS.status)\n  modeS.max_col = max_col\n  modeS.max_row = max_row\n  modeS.write = writer\n  -- this will be replaced with Zones\n  modeS.l_margin = 4\n  modeS.r_margin = 80\n  modeS.repl_top = ModeS.REPL_LINE\n  modeS.zones = Zoneherd(modeS, writer)\n  modeS.prompt_lines = { default = \"an repl, plz reply uwu ðŸ‘€\" }\n  modeS.zones.status:replace(modeS.prompt_lines.default)\n  -- initial state\n  modeS:shiftMode(modeS.raga_default)\n  modeS.action_complete = true\n  modeS.shift_to = nil\n  return modeS\nend\n\nModeS.idEst = new\n\n\n\nreturn new\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/complete",
hash = "a21ae58181a98fe473e37ace7986c1c2bc9aeb93a2b175723854f699c32cf6e0",
branch = "hang-on-exit",
binary = "\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm/raga/edit\"\n\nlocal Complete = clone(EditBase, 2)\n\nComplete.name = \"complete\"\nComplete.prompt_char = \"ðŸ‘‰\"\n\n\n\n\n\n\nlocal function _quit(modeS)\n   modeS.suggest:cancel(modeS)\n   -- #todo restore last-used raga instead of always returning to default\n   modeS.shift_to = modeS.raga_default\nend\n\nlocal function _accept(modeS)\n   if modeS.suggest.active_suggestions then\n      modeS.suggest:accept(modeS)\n   else\n      modeS.action_complete = false\n   end\n   _quit(modeS)\nend\n\nfunction Complete.PASTE(modeS, category, value)\n   _quit(modeS)\n   modeS.action_complete = false\nend\n\n\n\n\nlocal find = assert(string.find)\nlocal function _insert(modeS, category, value)\n   -- Non-symbol character accepts the completion\n   -- #todo should be consistent with lex.orb definition\n   if find(value, \"[^a-zA-Z0-9_]\") then\n      _accept(modeS, category, value)\n      modeS.action_complete = false\n   else\n      EditBase(modeS, category, value)\n   end\nend\n\nComplete.ASCII = _insert\nComplete.UTF8 = _insert\n\n\n\n\n\nlocal NAV = Complete.NAV\n\nfunction NAV.TAB(modeS, category, value)\n   modeS.suggest.active_suggestions[1]:selectNext()\n   modeS.zones.suggest:beTouched()\nend\nNAV.DOWN = NAV.TAB\nNAV.SHIFT_DOWN = NAV.TAB\n\nfunction NAV.SHIFT_TAB(modeS, category, value)\n   modeS.suggest.active_suggestions[1]:selectPrevious()\n   modeS.zones.suggest:beTouched()\nend\nNAV.UP = NAV.SHIFT_TAB\nNAV.SHIFT_UP = NAV.SHIFT_TAB\n\nNAV.ESC = _quit\nfunction NAV.RIGHT(modeS, category, value)\n   _quit(modeS, category, value)\n   modeS.action_complete = false\nend\n\nNAV.RETURN = _accept\nfunction NAV.LEFT(modeS, category, value)\n   _accept(modeS, category, value)\n   modeS.action_complete = false\nend\n\n\n\n\n\nfunction Complete.onCursorChanged(modeS)\n   modeS.suggest:update(modeS)\n   EditBase.onCursorChanged(modeS)\nend\n\n\n\nreturn Complete\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/aliaser",
hash = "d0a869a8d1bc6142d88346b865898141ff54d9cea5510b5a0491dcad2014ded8",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function aliaser(raga)\n   local function alias(dict)\n      local fn = dict[1]\n      for category, values in pairs(dict) do\n         if category ~= 1 then\n            for _, value in ipairs(values) do\n               raga[category][value] = fn\n            end\n         end\n      end\n   end\n   return alias\nend\n\nreturn aliaser\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/repr/tabulate",
hash = "dc643b6140ca69f9ec85bb39d46d2081eb0ada99fc3e4c44ae12dc95771208b9",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal core_table, core_string = require \"core/table\", require \"core/string\"\nlocal Token = require \"helm/repr/token\"\nlocal nameFor = require \"helm/repr/names\" . nameFor\nlocal C = require \"singletons/color\"\n\nlocal yield, wrap = assert(coroutine.yield), assert(coroutine.wrap)\n\n\n\n\n\n\nlocal SORT_LIMIT = 500  -- This won\'t be necessary #todo remove\n\nlocal function _keysort(a, b)\n   if (type(a) == \"string\" and type(b) == \"string\")\n      or (type(a) == \"number\" and type(b) == \"number\") then\n      return a < b\n   elseif type(a) == \"number\" and type(b) == \"string\" then\n      return false\n   elseif type(a) == \"string\" and type(b) == \"number\" then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasmetamethod = assert(require \"core/meta\" . hasmetamethod)\nlocal collect, lines = assert(core_table.collect), assert(core_string.lines)\nlocal assertfmt = assert(require \"core/fn\" . assertfmt)\n\nlocal function _yieldReprs(tab, window, c)\n   local _repr = hasmetamethod(\"repr\", tab)\n   assert(c, \"must have a value for c\")\n   assert(_repr, \"failed to retrieve repr metamethod\")\n   local repr = _repr(tab, window, c)\n   -- __repr may choose to use yield() directly rather than returning a value\n   if repr == nil then return end\n   if type(repr) == \"string\" then\n      repr = lines(repr)\n   end\n   assertfmt(type(repr) == \"function\",\n      \"Unexpected return type from __repr: \\\n      Expected string, iterator-of-string, or iterator-of-Token, got %s\",\n      type(repr))\n   for line_or_token, len in repr do\n      local token\n      if type(line_or_token) == \"string\" then\n         -- Note that len may be nil, in which case the Token will figure things out for itself\n         token = Token(line_or_token, c.no_color, { event = \"repr_line\", total_disp = len })\n      else\n         token = line_or_token\n      end\n      yield(token)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function yield_name(...) yield(nameFor(...)) end\n\nlocal isarray, table_keys, sort = assert(core_table.isarray),\n                                  assert(core_table.keys),\n                                  assert(table.sort)\n\nlocal function _tabulate(tab, window, c)\n   if type(tab) ~= \"table\"\n      or window.depth > C.depth\n      or window.cycle[tab] then\n      yield_name(tab, c)\n      return nil\n   end\n   -- Check for an __repr metamethod. If present, it replaces the rest of the\n   -- tabulation process for this table\n   if hasmetamethod(\"repr\", tab) and (not rawget(tab, \"__repr\")) then\n      window.depth = window.depth + 1\n      _yieldReprs(tab, window, c)\n      window.depth = window.depth - 1\n      return nil\n   end\n   -- add non-__repr\'ed tables to cycle\n   window.cycle[tab] = true\n\n   -- Okay, we\'re repring the body of a table of some kind\n   -- Check to see if this is an array\n   local is_array = isarray(tab)\n   -- And print an open brace, noting increased depth\n   yield(Token(\"{ \", c.base, { event = is_array and \"array\" or \"map\" }))\n   window.depth = window.depth + 1\n\n   -- if we have a metatable, get it first\n   local _M = getmetatable(tab)\n   if _M then\n      local mt_name_token = nameFor(_M, c, \"metatable\")\n      mt_name_token.event = \"metatable\"\n      if window.cycle[_M] then\n         mt_name_token:insert(1, \"âŸ¨\")\n         mt_name_token:insert(\"âŸ©\")\n         mt_name_token:insert(\" \")\n      end\n      yield(mt_name_token)\n      -- Skip printing the metatable altogether if it\'s going to end up\n      -- represented by its name, since we just printed that.\n      if window.depth < C.depth and not window.cycle[_M] then\n         yield(Token(\" â†’ \", c.base, { event = \"sep\" }))\n         yield(Token(\"âŸ¨\", c.metatable, { event = \"metatable\" }))\n         _tabulate(_M, window, c)\n         yield(Token(\"âŸ© \", c.metatable, { event = \"sep\"}))\n      else\n         yield(Token(\" \", c.no_color, { event = \"sep\" }))\n      end\n   end\n\n   if is_array then\n      for i, val in ipairs(tab) do\n         if i ~= 1 then yield(Token(\", \", c.base, { event = \"sep\" })) end\n         _tabulate(val, window, c)\n      end\n   else\n      local keys = table_keys(tab)\n      if #keys <= SORT_LIMIT then\n         sort(keys, _keysort)\n      end\n      for i, key in ipairs(keys) do\n         if i ~= 1 then yield(Token(\", \", c.base, { event = \"sep\" })) end\n         local val = tab[key]\n         if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then\n            -- legal identifier, display it as a bareword\n            yield_name(key, c, \"field\")\n         else\n            -- arbitrary string or other type, wrap with braces and repr it\n            yield(Token(\"[\", c.base))\n            -- We want names or hashes for any lvalue table\n            yield_name(key, c)\n            yield(Token(\"]\", c.base))\n         end\n         yield(Token(\" = \", c.base))\n         _tabulate(val, window, c)\n      end\n   end\n   yield(Token(\" }\", c.base, { event = \"end\" }))\n   window.depth = window.depth - 1\n   return nil\nend\n\nlocal function tabulate(tab, window, c)\n   return wrap(function()\n      window.depth = 0\n      window.cycle = {}\n      local err_lines\n      local success, result = xpcall(\n         function() return _tabulate(tab, window, c) end,\n         function(err)\n            err_lines = collect(lines, debug.traceback(tostring(err)))\n            err_lines[1] = \"error in __repr: \" .. err_lines[1]\n         end)\n      if err_lines then\n         for _, line in ipairs(err_lines) do\n            yield(Token(line, c.alert, { event = \"repr_line\" }))\n         end\n      end\n   end)\nend\n\nreturn tabulate\n\n",
},
  { 
vc_hash = "b6f7300674d109bf77c89b5a08640d7e9af67f03",
name = "helm/raga/base",
hash = "2afdf81ac56d2356e81c5e12b8ac49eab432373d73fb21e25b0be8382f1b8c56",
branch = "hang-on-exit",
binary = "\n\n\n\n\n\n\nlocal a         = require \"anterm:anterm\"\n\nlocal concat         = assert(table.concat)\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\n\n\n\n\n\n\n\nlocal RagaBase_meta = {}\nlocal RagaBase = setmetatable({}, RagaBase_meta)\n\nfor _, cat in ipairs{\"NAV\", \"CTRL\", \"ALT\", \"ASCII\",\n                     \"UTF8\", \"PASTE\", \"MOUSE\", \"NYI\"} do\n   RagaBase[cat] = {}\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasfield, iscallable = import(\"core/table\", \"hasfield\", \"iscallable\")\n\nfunction RagaBase_meta.__call(raga, modeS, category, value)\n   -- Dispatch on value if possible\n   if hasfield(raga[category], value) then\n      raga[category][value](modeS, category, value)\n   -- Or on category if the whole category is callable\n   elseif iscallable(raga[category]) then\n      raga[category](modeS, category, value)\n   -- Otherwise indicate that we didn\'t know what to do with the input\n   else\n      return false\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onTxtbufChanged(modeS)\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onCursorChanged(modeS)\n   return\nend\n\n\n\n\n\n\n\n\nfunction RagaBase.onShift(modeS)\n   return\nend\n\n\n\n\n\n\n\nfunction RagaBase.onUnshift(modeS)\n   return\nend\n\n\n\nreturn RagaBase\n",
},
} },
{
  project = {
    repo = "",
    repo_alternates = "",
    home = "",
    website = "",
    name = "lash",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "1a6a9986f37d5d95d5390c87549ef08be32f3e1b",
name = "lash",
hash = "280b4eb6946f96902fcff1c6b432632bee7d65733007ff1a985999592d8eb975",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Sh = {}\n\n\n\n\n-- make a safe-escaped, POSIX-compliant literal string,\n-- with the \'quote marks\'\nlocal function sh_str(str)\n    return table.concat {\"\'\", str:gsub(\"\'\", \"\'\\\\\'\'\"), \"\'\"}\nend\n-- borrowed with gratitude from:\n-- https://github.com/zserge/luash/blob/master/sh.lua\n\n-- converts key and it\'s argument to \"-k\" or \"-k=v\" or just \"\"\nlocal function arg(k, a)\n    if not a then return k end\n    if type(a) == \'string\' and #a > 0 then return k .. \'=\' .. sh_str(a) end\n    if type(a) == \'number\' then return k..\'=\'..tostring(a) end\n    if type(a) == \'boolean\' and a == true then return k end\n    error(\'invalid argument type \' .. type(a) .. \" \" .. tostring(a))\nend\n\n-- converts nested tables into a flat list of arguments and concatenated input\nlocal function flatten(t)\n    local result = {args = {}}\n\n    local function f(t)\n        local keys = {}\n        for k = 1, #t do\n            keys[k] = true\n            local v = t[k]\n            if type(v) == \'table\' then\n                f(v)\n            else\n                table.insert(result.args, v)\n            end\n        end\n        for k, v in pairs(t) do\n            if k == \'__input\' then\n                result.input = result.input or \'\'\n                result.input = result.input .. v\n            elseif not keys[k] and k:sub(1, 1) ~= \'_\' then\n                local key = \'-\'..k\n                if #k > 1 then key = \'-\' ..key end\n                table.insert(result.args, arg(key, v))\n            end\n        end\n    end\n\n    f(t)\n    return result\nend\n\n-- returns a function that executes the command with given args and returns its\n-- output, exit status etc\nlocal function command(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n        local p = io.popen(s, \'r\')\n        local output = p:read(\'*a\')\n        local _, exit, status = p:close()\n\n        local t = {\n            __input = output,\n            __exitcode = exit == \'exit\' and status or 127,\n            __signal = exit == \'signal\' and status or 0,\n        }\n        local mt = {\n            __index = function(self, k)\n                return command(k)\n            end,\n            __tostring = function(self)\n                -- return trimmed command output as a string\n                return self.__input:match(\'^%s*(.-)%s*$\')\n            end,\n            __repr = function(self)\n                return string.gmatch(self.__input, \"[^\\n]+\")\n            end\n        }\n        return setmetatable(t, mt)\n    end\nend\n\n-- export command() function\nSh.command = command\n\n\n\n\n\n\n\n\n\nlocal function preview(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n       return s\n    end\nend\n\nSh.preview = preview\n\n\n\n\n\n-- allow to call sh to run shell commands\nlocal Sh_M = {\n    __call = function(_, cmd, ...)\n        return command(cmd, ...)()\n    end,\n    __index = function(_, field)\n        return command(field)\n    end\n}\nsetmetatable(Sh, Sh_M)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.install(_Global)\n    local Global\n    local VER = string.sub( assert( _VERSION ), -4 )\n    if _Global and _Global ~= Sh then\n        Global = _Global\n    elseif VER == \" 5.1\" then\n        Global = getfenv()\n    else\n        Global = _ENV\n    end\n    local G_mt, G_index = nil, nil\n    local at_top = false\n    local our_mt = false\n    while not at_top do\n        local maybe_mt = getmetatable(Global)\n        if not maybe_mt then\n            at_top = true\n        else\n            -- we have a metatable\n            G_mt = maybe_mt\n            -- but is it the ultimate?\n            if G_mt.__index then\n                if type(G_mt.__index) == \"function\" then\n                    at_top = true\n                    G_index = G_mt.__index\n                elseif getmetatable(G_mt.__index) then\n                    at_top = false\n                    Global = G_mt.__index\n                else\n                    at_top = true\n                    G_index = G_mt.__index\n                end\n            else\n                at_top = true\n            end\n        end\n    end\n    -- if _ENV has no metatable, let\'s make one:\n    if not G_mt then\n        our_mt = true\n        G_mt = {}\n    end\n    -- *now* we can monkey-patch the global environment\n    local __index_fn\n    -- three flavors:\n    if not G_index then\n        __index_fn = function(_, cmd)\n                        return command(cmd)\n                     end\n    elseif type(G_index) == \"table\" then\n        __index_fn = function(_, key)\n                        local v = rawget(G_index, key)\n                        if v ~= nil then return v end\n                        return command(key)\n                     end\n    elseif type(G_index) == \"function\" then\n        __index_fn = function(_, key)\n                        local ok, v = pcall(G_index, _, key)\n                        if ok and (v ~= nil) then return v end\n                        return command(key)\n                     end\n    end\n    --- now set the metatable:\n    G_mt.__index = __index_fn\n    setmetatable(Global, G_mt)\n    -- stash the components for later removal\n    -- put them on the metatable to avoid polluting the\n    -- command space\n    Sh_M.__cache = { Global = Global,\n                     our_mt = our_mt,\n                     G_index = G_index,\n                     index_fn = __index_fn }\n    -- return Sh for convenience\n    return Sh\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.remove()\n    if not Sh_M.__cache then\n        -- didn\'t patch the namespace,\n        -- or already removed it\n        return nil\n    end\n    local cache = Sh_M.__cache\n    if cache.our_mt then\n        -- we made the metatable, let\'s remove the whole thing\n        setmetatable(cache.Global, nil)\n    else\n        -- if there was no G_index this will set it to nil\n        -- but only if our index function is still present.\n        local G_mt = getmetatable(cache.Global)\n        if G_mt.__index == cache.index_fn then\n            G_mt.__index = cache.G_index\n        end\n    end\n    -- remove cache\n    Sh_M.__cache = nil\nend\n\n\n\nreturn Sh\n",
},
} },
{
  project = {
    repo = "https://github.com/mnemnion/orb.git",
    repo_alternates = "https://gitlab.com/special-circumstance/orb.git\nhttps://gitlab.com/atman/orb.git\nhttps://gitlab.special-circumstanc.es/bridge-tools/orb.git",
    home = "",
    website = "",
    name = "orb",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "skein/skein",
hash = "c48131e406304a7a3d3d4df0c4cdda83245791578d3b46dd5a51084096431709",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal a = require \"anterm:anterm\"\ns.chatty = true\ns.angry = false\n\n\n\nlocal File = require \"fs:fs/file\"\nlocal Path = require \"fs:fs/path\"\nlocal Doc  = require \"orb:orb/doc\"\nlocal knitter = require \"orb:knit/newknit\" ()\nlocal compiler = require \"orb:compile/compiler\"\nlocal database = require \"orb:compile/newdatabase\"\n\n\n\nlocal Skein = {}\nSkein.__index = Skein\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.load(skein)\n   local ok, text = pcall(skein.source.file.read, skein.source.file)\n   if ok then\n      skein.source.text = text\n   else\n      s:complain(\"fail on load %s: %s\", tostring(skein.source.file), text)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.filter(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.spin(skein)\n    local ok, doc = pcall(Doc, skein.source.text)\n    if not ok then\n       s:complain(\"couldn\'t make doc: %s, %s\", doc, tostring(skein.source.file))\n    end\n    skein.source.doc = doc\n   return skein\nend\n\n\n\n\n\n\n\n\nfunction Skein.format(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\nfunction Skein.knit(skein)\n   local ok, err = pcall(knitter.knit, knitter, skein)\n   if not ok then\n      s:complain(\"failure to knit %s: %s\", tostring(skein.source.file), err)\n   end\n   if not skein.knitted.lua then\n      s:warn(\"no knit document produced from %s\", tostring(skein.source.file))\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.weave(skein)\n   if not skein.woven then\n      skein.woven = {}\n   end\n   local woven = skein.woven\n   woven.md = {}\n   local ok, err = pcall(function()\n      woven.md.text = skein.source.doc:toMarkdown(skein)\n      woven.md.path = skein.source.file.path\n                          :subFor(skein.source_base,\n                                  skein.weave_base .. \"/md\",\n                                  \"md\")\n   end)\n   if not ok then\n      s:complain(\"couldn\'t weave %s: %s\", tostring(skein.source.file), err)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.compile(skein)\n   compiler:compile(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\nlocal commitSkein = assert(database.commitSkein)\n\nfunction Skein.commit(skein, stmts, ids, git_info, now)\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n   assert(now)\n   commitSkein(skein, stmts, ids, git_info, now)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transact(skein, stmts, ids, git_info, now)\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n --  assert(ids.bundle_id == nil)\n   skein.lume.db.begin()\n   commitSkein(skein, stmts, ids, git_info, now)\n   skein.lume.db.commit()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function writeOnChange(scroll, path, dont_write)\n   -- if we don\'t have a path, there\'s nothing to be done\n   -- #todo we should probably take some note of this situation\n   if not path then return end\n   local current = File(path):read()\n   local newest = tostring(scroll)\n   if newest ~= current then\n      s:chat(a.green(\"    - \" .. tostring(path)))\n      if not dont_write then\n         File(path):write(newest)\n      end\n      return true\n   else\n   -- Otherwise do nothing\n      return nil\n   end\nend\n\n\n\nfunction Skein.persist(skein)\n   for _, scroll in pairs(skein.knitted) do\n      writeOnChange(scroll, scroll.path, skein.no_write)\n   end\n   local md = skein.woven.md\n   if md then\n      writeOnChange(md.text, md.path, skein.no_write)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transform(skein)\n   local db = skein.lume.db\n   skein\n     : load()\n     : spin()\n     : knit()\n     : weave()\n     : compile()\n     : transact(db.stmts, db.ids, db.git_info, skein.lume:now())\n     : persist()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(path, lume)\n   local skein = setmetatable({}, Skein)\n   skein.source = {}\n   if not path then\n      error \"Skein must be constructed with a path\"\n   end\n   -- handles: string, Path, or File objects\n   if path.idEst ~= File then\n      path = File(Path(path):absPath())\n   end\n   if lume then\n      skein.lume = lume\n      -- lift info off the lume here\n      skein.project     = lume.project\n      skein.source_base = lume.orb\n      skein.knit_base   = lume.src\n      skein.weave_base  = lume.doc\n      if lume.no_write then\n         skein.no_write = true\n      end\n   end\n   skein.source.file = path\n   return skein\nend\n\nSkein.idEst = new\n\n\n\n\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "walk/deck",
hash = "79abb9b8315019a3f35fd9537b9dbd8c89ecec0ec83d61ffd5974b1e265e82dd",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s   = require \"status:status\" ()\ns.verbose = false\ns.chatty  = true\n\nlocal c   = require \"singletons/color\"\nlocal cAlert = c.color.alert\n\nlocal Dir = require \"fs:fs/directory\"\nlocal Doc = require \"orb:Orbit/doc\"\nlocal Node = require \"espalier/node\"\n\n\n\nlocal Deck = {}\nDeck.__index = Deck\nlocal __Decks = {}\n\n\n\n-- ignore a few critters that can show up\nlocal decIgnore = {\".DS_Store\", \".git\", \".orbback\"}\n\nlocal function ignore(file)\n   local willIgnore = false\n   local basename = file:basename()\n   for _, str in ipairs(decIgnore) do\n      willIgnore = willIgnore or basename == str\n   end\n   -- Goddammit Dropbox\n   willIgnore = willIgnore or (string.find(tostring(file), \"%.%_\") ~= nil)\n   return willIgnore\nend\n\n\n\n\n\n\n\n\n\n\nlocal function spin(deck)\n   local err = {}\n   local dir = deck.dir\n   local codex = deck.codex\n   for _, subdeck in ipairs(deck) do\n      spin(subdeck)\n   end\n   local files = dir:getfiles()\n   for _, file in ipairs(files) do\n      if not ignore(file) then\n         s:verb(\"spinning\" .. tostring(file))\n         local doc = Doc(file:read())\n         if doc.id and doc.id == \"doc\" then\n            deck.docs[file.path.str] = doc\n            codex.docs[file.path.str] = doc\n            codex.files[file.path.str] = file\n         else\n            s:complain(\"no doc\",\n                       tostring(file) .. \" doesn\'t generate a doc\")\n         end\n      end\n   end\n   return deck, err\nend\n\nDeck.spin = spin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new\n\nfunction Deck.case(deck)\n   s:verb(\"dir: \" .. tostring(deck.dir))\n   local dir = deck.dir\n   local codex = deck.codex\n   local basename = dir:basename()\n   assert(dir.idEst == Dir, \"dir not a directory\")\n   local codexRoot = codex.root:basename()\n   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))\n   local subdirs = dir:getsubdirs()\n   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)\n   for i, sub in ipairs(subdirs) do\n      s:verb(\"  - \" .. sub.path.str)\n      deck[i] = new(codex, sub)\n   end\n   local files = dir:getfiles()\n   s:verb(\"  \" .. \"# files: \" .. #files)\n   for i, file in ipairs(files) do\n      if not ignore(file) then\n         local name = file:basename()\n         if #file:extension() > 1 then\n            name = string.sub(name, 1, - #file:extension() - 1)\n         end\n         if name == basename then\n            s:verb(\"  ~ \" .. name)\n            deck.eponym = file\n         end\n      end\n   end\n\n   s:verb(\"#deck is : \" .. #deck)\n   return codex\nend\n\n\n\n\n\nfunction Deck.__tostring(deck)\n   return deck.dir.path.str\nend\n\n\n\nnew = function (codex, dir)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   if __Decks[dir] then\n      return __Decks[dir]\n   end\n   local deck = setmetatable({}, Deck)\n   deck.dir = dir\n   deck.codex = codex\n   deck.docs  = {}\n   deck.srcs  = {}\n   deck.docMds = {}\n   deck.docDots = {}\n   deck.docSvgs = {}\n   -- deck.docHTMLs = {} #todo\n   Deck.case(deck)\n   return deck\nend\n\n\n\n\nDeck.idEst = new\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "spec/doc-spec",
hash = "57e1a84ec484a1474f27de735b37322dc2b3637e77674d7bd0ebd9e15e598269",
branch = "list-subgrammar",
binary = "\n\n\nlocal Dir = require \"fs/directory\"\nlocal Doc = require \"orb:orb/doc\"\n\n\n\nlocal testsDir = Dir \"test\"\n\n\n\nfor file in testsDir:files() do\n   local doc = Doc(file:read())\n   if doc then\n      local nomatch = doc:select \"NOMATCH\" ()\n      if nomatch then\n         io.write\"Unmatched Node:\\n\"\n         for unmatched in doc:select \"NOMATCH\" do\n            io.write(tostring(unmatched:strLine()) .. \"\\n\")\n         end\n      end\n      local incomplete = doc:select \"INCOMPLETE\" ()\n      if incomplete then\n         io.write \"Incomplete Node:\\n\"\n         for uncompleted in doc:select \"INCOMPLETE\" do\n            io.write(tostring(uncompleted:strLine()) .. \"\\n\")\n         end\n      end\n   end\nend\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "util/epeg",
hash = "ad3b469e867092738ddabbf2bad0f0042b4291454118d6f36f7737cb6cfe1d70",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal lpeg = require \"lpeg\"\n\nlocal function makerange(first, second)\n   local patts = {}\n   local patt  = {}\n   if (second) then\n      if (string.len(first) == string.len(second)) then\n         for i = 1, string.len(first) do\n            patts[i] = lpeg.R(string.sub(first,i,i)..string.sub(second,i,i))\n         end\n         patt = patts[1]\n         for i = 2, string.len(first) do\n            patt = patt + patts[i]\n         end\n         return patt\n      else\n         error(\"Ranges must be of equal byte width\")\n         return {}\n      end\n   else\n      return lpeg.R(first)\n   end\nend\n\n\nlocal function num_bytes(str)\n--returns the number of bytes in the next character in str\n   local c = str:byte(1)\n   if c >= 0x00 and c <= 0x7F then\n      return 1\n   elseif c >= 0xC2 and c <= 0xDF then\n      return 2\n   elseif c >= 0xE0 and c <= 0xEF then\n      return 3\n   elseif c >= 0xF0 and c <= 0xF4 then\n      return 4\n   end\nend\n\nlocal function Su (str)\n--[[\n   --convert a \'set\' pattern to uniquely match the characters\n   --in the range.\n   local catch = {}\n   local i = 0\n   for i = 1, #str do\n      catch[i]\n   end\n   --]]\nend\n\nlocal function spanner(first, last, str, root)\n   local vals = {}\n   vals.span = true\n   vals.val = string.sub(str, first, last - 1)\n   vals.first = first\n   vals.last = last - 1\n   if vals.last >= vals.first then\n      return vals\n   end\n   -- If a capture contains nothing, we don\'t want a node for it\n   return nil\nend\n\nlocal function Csp (patt)\n   return lpeg.Cp()\n      * lpeg.Cmt(patt, function() return true end)\n      * lpeg.Cp()\n      * lpeg.Carg(1)\n      * lpeg.Carg(2) / spanner\nend\n\n\n\n\n\nlocal function split (s, sep)\n  sep = lpeg.P(sep)\n  local elem = lpeg.C((1 - sep)^0)\n  local p = lpeg.Ct(elem * (sep * elem)^0)   -- make a table capture\n  return lpeg.match(p, s)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal I = lpeg.Cp()\n\nlocal function  anyP(p)\n     return lpeg.P{ I * p * I + 1 * lpeg.V(1) }\nend\n\n\n\nlocal Ru = makerange\n\n\nreturn { R = Ru,\n      Csp = Csp,\n      anyP = anyP,\n      match = lpeg.match,\n      split = split,\n      spanner = spanner }\n\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/link",
hash = "34e61b8bbacb8362a9a75180ddf27778f5e8fc9d45a650f842353dc182250812",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal m = require \"orb:Orbit/morphemes\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\nlocal s = require \"status:status\" ()\n\nlocal Node = require \"espalier/node\"\n\n\n\n\nlocal Li, li = u.inherit(Node)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Li.toMarkdown(link)\n   local anchor_text = \"\"\n   local url = \"\"\n   if link[1].id == \"anchortext\" then\n      anchor_text = link[1]:toValue()\n   end\n   if link[2].id == \"url\" then\n      url = link[2]:toValue()\n   end\n\n   return \"[\" .. anchor_text .. \"]\"\n         .. \"(\" .. url .. \")\"\nend\n\n\n\n\n\n\nreturn Li\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/commit",
hash = "6d8f6e891b4c1545046c7a4042612122549bfc130d3c1651c97c08862e3b68ec",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\"\ns.verbose = false\nlocal sql = assert(sql, \"must have sql in bridge _G\")\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal uv  = require \"luv\"\nlocal sha = require \"compile/sha2\" . sha3_512\nlocal database = require \"orb:compile/database\"\n\n\n\nlocal commit = {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\nlocal function commitModule(stmt, bytecode, project_id, bundle_id,\n                            version_id, git_info, now)\n   -- get code_id from the hash\n   local code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmt.new_code:bindkv(bytecode):step()\n      stmt.code_id:reset()\n      code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmt.add_module:bindkv(mod):step()\n   for _, st in pairs(stmt) do\n      st:reset()\n   end\nend\n\ncommit.commitModule = commitModule\n\n\n\n\n\n\nlocal sh = require \"orb:util/sh\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction commit.commitCodex(codex)\n   local conn = database.open()\n   local now = tostring(date())\n   -- begin transaction\n   conn:exec \"BEGIN TRANSACTION;\"\n   -- select project_id\n   local project_id = database.project(conn, codex:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, codex:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmt = { code_id = conn:prepare(get_code_id_by_hash),\n                  new_code = conn:prepare(new_code),\n                  add_module = conn:prepare(add_module) }\n   for _, bytecode in pairs(codex.bytecodes) do\n      commitModule(stmt,\n                   bytecode,\n                   project_id,\n                   bundle_id,\n                   version_id,\n                   codex.git_info,\n                   now)\n   end\n   -- commit transaction\n   conn:exec \"COMMIT;\"\n   -- use a pcall because we get a (harmless) error if the table is locked\n   -- by another process:\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   -- set up an idler to close the conn, so that e.g. busy\n   -- exceptions don\'t blow up the hook\n   local close_idler = uv.new_idle()\n   close_idler:start(function()\n      local success = pcall(conn.close, conn)\n      if not success then\n        return nil\n      else\n        close_idler:stop()\n        uv.stop()\n      end\n   end)\n   if not uv.loop_alive() then\n      uv.run \"default\"\n   end\nend\n\n\n\n\nreturn commit\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "tag/tag",
hash = "ec78f8424ea12fa185c804cdf1dea83ddfe32bb18c4c8d73e59a946da0017d67",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal esp = require \"espalier:espalier\"\n\n\n\n\n\n\n\n\nlocal OrbTag = esp.stator()\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "knit/knitters",
hash = "6bb462db812ef5efe8a96694ef2ef33b4ae71acac30364d466b0b3eda5cd7353",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn { lua = require \"orb:knit/lua\" }\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/link",
hash = "6dd1dab1c6f5b7613f0013f83bd455edc7fc97f04720a83beb6894d0532c58d8",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal link_str = [[\n   link         â†  link-head link-text link-close WS*\n                   (link-open link-anchor link-close)? link-close\n\n                /  link-head link-text link-close obelus link-close\n   link-head    â†  \"[[\"\n   link-close   â†  \"]\"\n   link-open    â†  \"[\"\n   link-text    â†  (!\"]\" 1)*\n   link-anchor  â†  (!\"]\" 1)*\n   obelus       â†  (!\"]\" 1)+\n            WS  â†  { \\n}+\n]]\n\n\n\nlocal link_M = Twig :inherit \"link\"\n\n\n\nfunction link_M.toMarkdown(link, skein)\n   local link_text = link:select(\"link_text\")()\n   link_text = link_text and link_text:span() or \"\"\n   local phrase = \"[\"\n   phrase = phrase ..  link_text .. \"]\"\n   local link_anchor = link:select(\"link_anchor\")()\n   link_anchor = link_anchor and link_anchor:span() or \"\"\n   phrase = phrase .. \"(\" ..  link_anchor .. \")\"\n   return phrase\nend\n\n\n\nlocal link_grammar = Peg(link_str, { Twig, link = link_M })\n\n\n\nreturn subGrammar(link_grammar.parse, \"link-nomatch\")\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "spec/spec",
hash = "3c136bfce016e022c0d9b10faaa7da366025ac20d43d766f6c0c8c75f891d53a",
branch = "list-subgrammar",
binary = "\n\n\nlocal walk_spec = require \"orb:spec/walk-spec\"\n\n\n\n\nlocal function Specify()\n   return walk_spec()\nend\n\n\n\n\nreturn Specify\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "walk/walk",
hash = "64881ad90a7ed6ef4d9d8d76af729a8abf6479506196bdfb43ca6dcd4700acde",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal s = require \"status:status\" ()\nlocal a = require \"singletons/anterm\"\ns.chatty = true\n\nlocal pl_mini = require \"orb:util/plmini\"\nlocal pl_mini = require \"orb:util/plmini\"\nlocal read, write, delete = pl_mini.file.read,\n                            pl_mini.file.write,\n                            pl_mini.file.delete\nlocal getfiles = pl_mini.dir.getfiles\nlocal getdirectories = pl_mini.dir.getdirectories\nlocal makepath = pl_mini.dir.makepath\nlocal extension = pl_mini.path.extension\nlocal dirname = pl_mini.path.dirname\nlocal basename = pl_mini.path.basename\nlocal isdir = pl_mini.path.isdir\n\nlocal epeg = require \"orb:util/epeg\"\n\n\n\nlocal Walk = {}\nWalk.Path = require \"fs:fs/path\"\nWalk.Dir  = require \"fs:fs/directory\"\nWalk.File = require \"fs:fs/file\"\nWalk.Codex = require \"orb:walk/codex\"\nWalk.writeOnChange = require \"orb:walk/ops\"\n\n\n\nfunction Walk.strHas(substr, str)\n    return L.match(epeg.anyP(substr), str)\nend\n\nfunction Walk.endsWith(substr, str)\n    return L.match(L.P(string.reverse(substr)),\n        string.reverse(str))\nend\n\n\n\n\n\n\n\nfunction Walk.subLastFor(match, swap, str)\n   local trs, hctam = string.reverse(str), string.reverse(match)\n   local first, last = Walk.strHas(hctam, trs)\n   if last then\n      -- There is some way to do this without reversing the string twice,\n      -- but I can\'t be arsed to find it. ONE BASED INDEXES ARE A MISTAKE\n      return string.reverse(trs:sub(1, first - 1)\n          .. string.reverse(swap) .. trs:sub(last, -1))\n   else\n      s:halt(\"didn\'t find an instance of \" .. match .. \" in string: \" .. str)\n   end\nend\n\n\n\nfunction Walk.writeOnChange(out_file, newest)\n    newest = tostring(newest)\n    out_file = tostring(out_file)\n    local current = read(tostring(out_file))\n    -- If the text has changed, write it\n    if newest ~= current then\n        s:chat(a.green(\"  - \" .. tostring(out_file)))\n        write(out_file, newest)\n        return true\n    -- If the new text is blank, delete the old file\n    elseif current ~= \"\" and newest == \"\" then\n        s:chat(a.red(\"  - \" .. tostring(out_file)))\n        delete(out_file)\n        return false\n    else\n    -- Otherwise do nothing\n\n        return nil\n    end\nend\n\n\n\n\nreturn Walk\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/compile",
hash = "9e37ced0453eac7c2be62423e0e3b7192e89db49d529fe355c25c1b7b5066868",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal commit = require \"orb:compile/commit\"\nlocal database = require \"orb:compile/database\"\nlocal sha512 = require \"orb:compile/sha2\" . sha3_512\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\nlocal function sha(str)\n   return sub(sha512(str),1,64)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _moduleName(path, project)\n   local mod = {}\n   local inMod = false\n   for i, v in ipairs(path) do\n      if v == project then\n         inMod = true\n      end\n      if inMod then\n         if i ~= #path then\n            table.insert(mod, v)\n          else\n             table.insert(mod, path:barename())\n         end\n      end\n   end\n   -- drop the bits of the path we won\'t need\n   --- awful kludge fix\n   local weird_path = table.concat(mod)\n   local good_path = string.gsub(weird_path, \"%.%_\", \"\")\n   local _, cutpoint = string.find(good_path, \"/src/\")\n   local good_path = string.sub(good_path, cutpoint + 1)\n   return good_path\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Compile = {}\nlocal dump = string.dump\nlocal splice = require \"singletons/core\" . splice\n\nlocal function compileDeck(deck)\n   local codex = deck.codex\n   s:verb (\"codex project is \" .. codex.project)\n   local complete, errnum, errs = true, 0, {}\n   deck.bytecodes = deck.bytecodes or {}\n   for _, subdeck in ipairs(deck) do\n      local deck_complete, deck_errnum, deck_errs = compileDeck(subdeck)\n      complete = complete and deck_complete\n      errnum = errnum + deck_errnum\n      splice(errs, nil, deck_errs)\n   end\n   for name, src in pairs(deck.srcs) do\n      local bytecode, err = load (tostring(src),\n                                  \"@\" .. _moduleName(name, codex.project))\n      if bytecode then\n         -- add to srcs\n         local byte_str = tostring(src)\n         local byte_table = {binary = byte_str}\n         byte_table.hash = sha(byte_str)\n         byte_table.name = _moduleName(name, codex.project)\n         codex.bytecodes[name] = byte_table\n         deck.bytecodes[name] = byte_table\n         s:verb(\"compiled: \" .. codex.project .. \":\" .. byte_table.name)\n      else\n         s:chat \"error:\"\n         s:chat(err)\n         complete = false\n         errnum = errnum + 1\n         errs[#errs + 1] = tostring(name)\n      end\n   end\n   return complete, errnum, errs\nend\n\nCompile.compileDeck = compileDeck\n\n\n\n\n\n\nfunction Compile.compileCodex(codex)\n   local complete, errnum, errs = compileDeck(codex.orb)\n   commit.commitCodex(codex)\n   return complete, errnum, errs\nend\n\n\n\nreturn Compile\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/metas/docmetas",
hash = "1751a2cd05ff9629f622613baf239dfaf5181f74359ba3d7d370846de550b3aa",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal DocMetas = {}\n\n\n\n\n\n\n\nlocal Doc_M = Twig:inherit \"doc\"\nDocMetas.doc = Doc_M\n\n\n\nfunction Doc_M.toMarkdown(doc, skein)\n   local phrase = Phrase \"\"\n   for _, block in ipairs(doc) do\n      phrase = phrase .. block:toMarkdown(skein)\n   end\n   return phrase\nend\n\n\n\nlocal Section_M = Twig:inherit \"section\"\nDocMetas.section = Section_M\n\n\n\nfunction Section_M.toMarkdown(section, skein)\n   local phrase = Phrase \"\"\n   for _, block in ipairs(section) do\n      phrase = phrase .. block:toMarkdown(skein)\n   end\n   return phrase\nend\n\n\n\nreturn DocMetas\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "walk/codex",
hash = "de037b5c569810c70fe9d1346e27a023a8a70880f48e9b0f1b50d1fd1739bd90",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pl_mini = require \"orb:util/plmini\"\nlocal write = pl_mini.file.write\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal Dir  = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal Path = require \"fs:fs/path\"\nlocal Deck = require \"orb:walk/deck\"\nlocal ops  = require \"orb:walk/ops\"\nlocal git_info = require \"orb:util/gitinfo\"\n\nlocal knitter = require \"orb:knit/knitter\"\n\nlocal Watcher = require \"helm:helm/watcher\"\n\n\n\n\nlocal Codex = {}\nCodex.__index = Codex\nlocal __Codices = {} -- One codex per directory\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Codex.spin(codex)\n   codex.orb:spin()\nend\n\n\n\n\n\n\nlocal function changer(codex)\n   local function onchange(watcher, fname)\n      local full_name = tostring(codex.orb) .. \"/\" .. fname\n      print (\"changed \" .. full_name)\n      if codex.docs[full_name] and full_name:sub(-4) == \".orb\" then\n         local doc = Doc(codex.files[full_name]:read())\n         local knit_doc = knitter:knit(doc)\n         local knit_name = tostring(codex.src) .. \"/\"\n                           .. fname : sub(1, -5) .. \".lua\"\n         local written = write(knit_name, tostring(knit_doc))\n         print(\"knit_doc is type \" .. type   (knit_doc))\n      else\n         print(\"false\")\n      end\n   end\n\n   return onchange\nend\n\n\nlocal function renamer(codex)\n   local function onrename(watcher, fname)\n      print (\"renamed \" .. fname)\n   end\n\n   return onrename\nend\n\nfunction Codex.serve(codex)\n   codex.server = Watcher { onchange = changer(codex),\n                            onrename = renamer(codex) }\n   codex.server(tostring(codex.orb))\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Codex.gitInfo(codex)\n   codex.git_info = git_info(tostring(codex.root))\n   return codex.git_info\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Codex.projectInfo(codex)\n   local proj = {}\n   proj.name = _Bridge.args.project or codex.project\n   if codex.git_info.is_repo then\n      proj.repo_type = \"git\"\n      proj.repo = codex.git_info.url\n      proj.home = codex.home or \"\"\n      proj.website = codex.website or \"\"\n      local alts = {}\n      for _, repo in ipairs(codex.git_info.remotes) do\n         alts[#alts + 1] = repo[2] ~= proj.repo and repo[2] or nil\n      end\n      proj.repo_alternates = table.concat(alts, \"\\n\")\n   end\n   return proj\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Codex.versionInfo(codex)\n   if not _Bridge.args.version then\n      return { is_versioned = false }\n   end\n   local version = { is_versioned = true }\n   for k,v in pairs(_Bridge.args.version) do\n      version[k] = v\n   end\n   version.edition = _Bridge.args.edition or \"\"\n   version.stage   = _Bridge.args.stage or \"SNAPSHOT\"\n   return version\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function buildCodex(dir, codex)\n   local isCo = false\n   local orbDir, srcDir, libDir = nil, nil, nil\n   local docDir, docMdDir, docDotDir, docSvgDir = nil, nil, nil, nil\n   codex.root = dir\n   local subdirs = dir:getsubdirs()\n\n   for i, sub in ipairs(subdirs) do\n      local name = sub:basename()\n      if name == \"orb\" then\n         s:verb(\"orb: \" .. tostring(sub))\n         orbDir = sub\n         codex.orb = sub\n         -- dumb hack because I mutated this parameter >.<\n         codex.orb_base = sub\n      elseif name == \"src\" then\n         s:verb(\"src: \" .. tostring(sub))\n         srcDir = Dir(sub)\n         codex.src = sub\n      elseif name == \"doc\" then\n         s:verb(\"doc: \" .. tostring(sub))\n         docDir = sub\n         codex.doc = sub\n         local subsubdirs = docDir:getsubdirs()\n         for j, subsub in ipairs(subsubdirs) do\n            local subname = subsub:basename()\n            if subname == \"md\" then\n               s:verb(\"doc/md: \" .. tostring(subsub))\n               docMdDir = subsub\n               codex.docMd = subsub\n            elseif subname == \"dot\" then\n               s:verb(\"doc/dot: \" .. tostring(subsub))\n               docDotDir = subsub\n               codex.docDot = subsub\n            elseif subname == \"svg\" then\n               s:verb(\"doc/svg: \" .. tostring(subsub))\n               docSvgDir = subsub\n               codex.docSvg = subsub\n            end\n         end\n      end\n   end\n\n   if orbDir and srcDir and docDir then\n      codex.codex = true\n   end\n   return codex\nend\n\n\n\n\n\n\n\n\nlocal function new(dir)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   if __Codices[dir] then\n      return __Codices[dir]\n   end\n   local codex = setmetatable({}, Codex)\n   codex = buildCodex(dir, codex)\n   codex.project = dir.path[#dir.path] -- hmmm?\n   if codex.orb then\n      codex.orb = Deck(codex, codex.orb)\n   end\n   codex.git_info = git_info(tostring(dir))\n   codex.docs  = {}\n   codex.files = {}\n   codex.srcs  = {}\n   codex.docMds = {}\n   codex.docSvgs = {}\n   codex.docDots = {}\n   -- codex.docHTMLs = {} #todo\n\n   codex.bytecodes = {}\n   return codex\nend\n\n\n\n\nCodex.idEst = new\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "lume/watcher",
hash = "1cdeb816e3291e03c6bbf1e17f60f93890dbfd57c10eba729ff62895af153a06",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n    watcher.dir = dir\n    -- default to a recursive watch\n    if recur == nil then\n        recur = true\n    end\n    local fse = uv.new_fs_event()\n    watcher.fse = fse\n    uv.fs_event_start(fse, dir, {recursive = recur},\n       function (err,fname,status)\n          if (err) then\n             print(\"Error \"..err)\n          else\n             local ev = nil\n             for k,v in pairs(status) do\n                ev = k\n             end\n             if ev == \"change\" then\n                watcher:onchange(fname)\n             elseif ev == \"rename\" then\n                watcher:onrename(fname)\n             else\n                print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n             end\n          end\n       end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "util/plmini",
hash = "c74e57865486fdde647509ff6190c648334afafd13e41102a08757abc9137e56",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal pl = {}\n\n\n\n\n\n\n\n----------------\n--- Lua 5.1/5.2/5.3 compatibility.\n-- Ensures that `table.pack` and `package.searchpath` are available\n-- for Lua 5.1 and LuaJIT.\n-- The exported function `load` is Lua 5.2 compatible.\n-- `compat.setfenv` and `compat.getfenv` are available for Lua 5.2, although\n-- they are not always guaranteed to work.\n-- @module pl.compat\n\nlocal compat = {}\n\ncompat.lua51 = _VERSION == \'Lua 5.1\'\n\nlocal isJit = (tostring(assert):match(\'builtin\') ~= nil)\nif isJit then\n    -- \'goto\' is a keyword when 52 compatibility is enabled in LuaJit\n    compat.jit52 = not loadstring(\"local goto = 1\")\nend\n\ncompat.dir_separator = _G.package.config:sub(1,1)\ncompat.is_windows = compat.dir_separator == \'\\\\\'\n\n--- execute a shell command.\n-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2\n-- @param cmd a shell command\n-- @return true if successful\n-- @return actual return code\nfunction compat.execute (cmd)\n    local res1,_,res3 = os.execute(cmd)\n    if compat.lua51 and not compat.jit52 then\n        if compat.is_windows then\n            res1 = res1 > 255 and res1 % 256 or res1\n            return res1==0,res1\n        else\n            res1 = res1 > 255 and res1 / 256 or res1\n            return res1==0,res1\n        end\n    else\n        if compat.is_windows then\n            res3 = res3 > 255 and res3 % 256 or res3\n            return res3==0,res3\n        else\n            return not not res1,res3\n        end\n    end\nend\n\n----------------\n-- Load Lua code as a text or binary chunk.\n-- @param ld code string or loader\n-- @param[opt] source name of chunk for errors\n-- @param[opt] mode \'b\', \'t\' or \'bt\'\n-- @param[opt] env environment to load the chunk in\n-- @function compat.load\n\n---------------\n-- Get environment of a function.\n-- With Lua 5.2, may return nil for a function with no global references!\n-- Based on code by [Sergey Rozhenko](http://lua-users.org/lists/lua-l/2010-06/msg00313.html)\n-- @param f a function or a call stack reference\n-- @function compat.getfenv\n\n---------------\n-- Set environment of a function\n-- @param f a function or a call stack reference\n-- @param env a table that becomes the new environment of `f`\n-- @function compat.setfenv\n\nif compat.lua51 then -- define Lua 5.2 style load()\n    if not isJit then -- but LuaJIT\'s load _is_ compatible\n        local lua51_load = load\n        function compat.load(str,src,mode,env)\n            local chunk,err\n            if type(str) == \'string\' then\n                if str:byte(1) == 27 and not (mode or \'bt\'):find \'b\' then\n                    return nil,\"attempt to load a binary chunk\"\n                end\n                chunk,err = loadstring(str,src)\n            else\n                chunk,err = lua51_load(str,src)\n            end\n            if chunk and env then setfenv(chunk,env) end\n            return chunk,err\n        end\n    else\n        compat.load = load\n    end\n    compat.setfenv, compat.getfenv = setfenv, getfenv\nelse\n    compat.load = load\n    -- setfenv/getfenv replacements for Lua 5.2\n    -- by Sergey Rozhenko\n    -- http://lua-users.org/lists/lua-l/2010-06/msg00313.html\n    -- Roberto Ierusalimschy notes that it is possible for getfenv to return nil\n    -- in the case of a function with no globals:\n    -- http://lua-users.org/lists/lua-l/2010-06/msg00315.html\n    function compat.setfenv(f, t)\n        f = (type(f) == \'function\' and f or debug.getinfo(f + 1, \'f\').func)\n        local name\n        local up = 0\n        repeat\n            up = up + 1\n            name = debug.getupvalue(f, up)\n        until name == \'_ENV\' or name == nil\n        if name then\n            debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue\n            debug.setupvalue(f, up, t)\n        end\n        if f ~= 0 then return f end\n    end\n\n    function compat.getfenv(f)\n        local f = f or 0\n        f = (type(f) == \'function\' and f or debug.getinfo(f + 1, \'f\').func)\n        local name, val\n        local up = 0\n        repeat\n            up = up + 1\n            name, val = debug.getupvalue(f, up)\n        until name == \'_ENV\' or name == nil\n        return val\n    end\nend\n\n--- Lua 5.2 Functions Available for 5.1\n-- @section lua52\n\n--- pack an argument list into a table.\n-- @param ... any arguments\n-- @return a table with field n set to the length\n-- @return the length\n-- @function table.pack\n--if not table.pack then\n    function table.pack (...)\n        return {n=select(\'#\',...); ...}\n    end\n--end\n\n------\n-- return the full path where a Lua module name would be matched.\n-- @param mod module name, possibly dotted\n-- @param path a path in the same form as package.path or package.cpath\n-- @see path.package_path\n-- @function package.searchpath\nif not package.searchpath then\n    local sep = package.config:sub(1,1)\n    function package.searchpath (mod,path)\n        mod = mod:gsub(\'%.\',sep)\n        for m in path:gmatch(\'[^;]+\') do\n            local nm = m:gsub(\'?\',mod)\n            local f = io.open(nm,\'r\')\n            if f then f:close(); return nm end\n        end\n    end\nend\n\n\n\n\n\n\n--- Generally useful routines.\n-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.\n--\n-- Dependencies: `pl.compat`\n--\n-- @module pl.utils\nlocal format = string.format\nlocal stdout = io.stdout\nlocal append = table.insert\nlocal unpack = rawget(_G,\'unpack\') or rawget(table,\'unpack\')\n\nlocal utils = {\n    _VERSION = \"1.5.2\",\n    lua51 = compat.lua51,\n    setfenv = compat.setfenv,\n    getfenv = compat.getfenv,\n    load = compat.load,\n    execute = compat.execute,\n    dir_separator = compat.dir_separator,\n    is_windows = compat.is_windows,\n    unpack = unpack\n}\n\n--- end this program gracefully.\n-- @param code The exit code or a message to be printed\n-- @param ... extra arguments for message\'s format\'\n-- @see utils.fprintf\nfunction utils.quit(code,...)\n    if type(code) == \'string\' then\n        utils.fprintf(io.stderr,code,...)\n        code = -1\n    else\n        utils.fprintf(io.stderr,...)\n    end\n    io.stderr:write(\'\\n\')\n    os.exit(code)\nend\n\n--- print an arbitrary number of arguments using a format.\n-- @param fmt The format (see string.format)\n-- @param ... Extra arguments for format\nfunction utils.printf(fmt,...)\n    utils.assert_string(1,fmt)\n    utils.fprintf(stdout,fmt,...)\nend\n\n--- write an arbitrary number of arguments to a file using a format.\n-- @param f File handle to write to.\n-- @param fmt The format (see string.format).\n-- @param ... Extra arguments for format\nfunction utils.fprintf(f,fmt,...)\n    utils.assert_string(2,fmt)\n    f:write(format(fmt,...))\nend\n\nlocal function import_symbol(T,k,v,libname)\n    local key = rawget(T,k)\n    -- warn about collisions!\n    if key and k ~= \'_M\' and k ~= \'_NAME\' and k ~= \'_PACKAGE\' and k ~= \'_VERSION\' then\n        utils.fprintf(io.stderr,\"warning: \'%s.%s\' will not override existing symbol\\n\",libname,k)\n        return\n    end\n    rawset(T,k,v)\nend\n\nlocal function lookup_lib(T,t)\n    for k,v in pairs(T) do\n        if v == t then return k end\n    end\n    return \'?\'\nend\n\nlocal already_imported = {}\n\n--- take a table and \'inject\' it into the local namespace.\n-- @param t The Table\n-- @param T An optional destination table (defaults to callers environment)\nfunction utils.import(t,T)\n    T = T or _G\n    t = t or utils\n    if type(t) == \'string\' then\n        t = require (t)\n    end\n    local libname = lookup_lib(T,t)\n    if already_imported[t] then return end\n    already_imported[t] = libname\n    for k,v in pairs(t) do\n        import_symbol(T,k,v,libname)\n    end\nend\n\nutils.patterns = {\n    FLOAT = \'[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*\',\n    INTEGER = \'[+%-%d]%d*\',\n    IDEN = \'[%a_][%w_]*\',\n    FILE = \'[%a%.\\\\][:%][%w%._%-\\\\]*\'\n}\n\n--- escape any \'magic\' characters in a string\n-- @param s The input string\nfunction utils.escape(s)\n    utils.assert_string(1,s)\n    return (s:gsub(\'[%-%.%+%[%]%(%)%$%^%%%?%*]\',\'%%%1\'))\nend\n\n--- return either of two values, depending on a condition.\n-- @param cond A condition\n-- @param value1 Value returned if cond is true\n-- @param value2 Value returned if cond is false (can be optional)\nfunction utils.choose(cond,value1,value2)\n    if cond then return value1\n    else return value2\n    end\nend\n\nlocal raise\n\n--- return the contents of a file as a string\n-- @param filename The file path\n-- @param is_bin open in binary mode\n-- @return file contents\nfunction utils.readfile(filename,is_bin)\n    local mode = is_bin and \'b\' or \'\'\n    utils.assert_string(1,filename)\n    local f,open_err = io.open(filename,\'r\'..mode)\n    if not f then return utils.raise (open_err) end\n    local res,read_err = f:read(\'*a\')\n    f:close()\n    if not res then\n        -- Errors in io.open have \"filename: \" prefix,\n        -- error in file:read don\'t, add it.\n        return raise (filename..\": \"..read_err)\n    end\n    return res\nend\n\n--- write a string to a file\n-- @param filename The file path\n-- @param str The string\n-- @param is_bin open in binary mode\n-- @return true or nil\n-- @return error message\n-- @raise error if filename or str aren\'t strings\nfunction utils.writefile(filename,str,is_bin)\n    local mode = is_bin and \'b\' or \'\'\n    utils.assert_string(1,filename)\n    utils.assert_string(2,str)\n    local f,err = io.open(filename,\'w\'..mode)\n    if not f then return raise(err) end\n    f:write(str)\n    f:close()\n    return true\nend\n\n--- return the contents of a file as a list of lines\n-- @param filename The file path\n-- @return file contents as a table\n-- @raise errror if filename is not a string\nfunction utils.readlines(filename)\n    utils.assert_string(1,filename)\n    local f,err = io.open(filename,\'r\')\n    if not f then return raise(err) end\n    local res = {}\n    for line in f:lines() do\n        append(res,line)\n    end\n    f:close()\n    return res\nend\n\n--- split a string into a list of strings separated by a delimiter.\n-- @param s The input string\n-- @param re A Lua string pattern; defaults to \'%s+\'\n-- @param plain don\'t use Lua patterns\n-- @param n optional maximum number of splits\n-- @return a list-like table\n-- @raise error if s is not a string\nfunction utils.split(s,re,plain,n)\n    utils.assert_string(1,s)\n    local find,sub,append = string.find, string.sub, table.insert\n    local i1,ls = 1,{}\n    if not re then re = \'%s+\' end\n    if re == \'\' then return {s} end\n    while true do\n        local i2,i3 = find(s,re,i1,plain)\n        if not i2 then\n            local last = sub(s,i1)\n            if last ~= \'\' then append(ls,last) end\n            if #ls == 1 and ls[1] == \'\' then\n                return {}\n            else\n                return ls\n            end\n        end\n        append(ls,sub(s,i1,i2-1))\n        if n and #ls == n then\n            ls[#ls] = sub(s,i1)\n            return ls\n        end\n        i1 = i3+1\n    end\nend\n\n--- split a string into a number of values.\n-- @param s the string\n-- @param re the delimiter, default space\n-- @return n values\n-- @usage first,next = splitv(\'jane:doe\',\':\')\n-- @see split\nfunction utils.splitv (s,re)\n    return unpack(utils.split(s,re))\nend\n\n--- convert an array of values to strings.\n-- @param t a list-like table\n-- @param temp buffer to use, otherwise allocate\n-- @param tostr custom tostring function, called with (value,index).\n-- Otherwise use `tostring`\n-- @return the converted buffer\nfunction utils.array_tostring (t,temp,tostr)\n    temp, tostr = temp or {}, tostr or tostring\n    for i = 1,#t do\n        temp[i] = tostr(t[i],i)\n    end\n    return temp\nend\n\nlocal is_windows = utils.is_windows\n\n--- Quote an argument of a command.\n-- Quotes a single argument of a command to be passed\n-- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.\n-- @string argument the argument.\n-- @return quoted argument.\nfunction utils.quote_arg(argument)\n    if is_windows then\n        if argument == \"\" or argument:find(\'[ \\f\\t\\v]\') then\n            -- Need to quote the argument.\n            -- Quotes need to be escaped with backslashes;\n            -- additionally, backslashes before a quote, escaped or not,\n            -- need to be doubled.\n            -- See documentation for CommandLineToArgvW Windows function.\n            argument = \'\"\' .. argument:gsub([[(\\*)\"]], [[%1%1\\\"]]):gsub([[\\+$]], \"%0%0\") .. \'\"\'\n        end\n\n        -- os.execute() uses system() C function, which on Windows passes command\n        -- to cmd.exe. Escape its special characters.\n        return (argument:gsub(\'[\"^<>!|&%%]\', \"^%0\"))\n    else\n        if argument == \"\" or argument:find(\'[^a-zA-Z0-9_@%+=:,./-]\') then\n            -- To quote arguments on posix-like systems use single quotes.\n            -- To represent an embedded single quote close quoted string (\'),\n            -- add escaped quote (\\\'), open quoted string again (\').\n            argument = \"\'\" .. argument:gsub(\"\'\", [[\'\\\'\']]) .. \"\'\"\n        end\n\n        return argument\n    end\nend\n\n--- execute a shell command and return the output.\n-- This function redirects the output to tempfiles and returns the content of those files.\n-- @param cmd a shell command\n-- @param bin boolean, if true, read output as binary file\n-- @return true if successful\n-- @return actual return code\n-- @return stdout output (string)\n-- @return errout output (string)\nfunction utils.executeex(cmd, bin)\n    local mode\n    local outfile = os.tmpname()\n    local errfile = os.tmpname()\n\n    if is_windows and not outfile:find(\':\') then\n        outfile = os.getenv(\'TEMP\')..outfile\n        errfile = os.getenv(\'TEMP\')..errfile\n    end\n    cmd = cmd .. \" > \" .. utils.quote_arg(outfile) .. \" 2> \" .. utils.quote_arg(errfile)\n\n    local success, retcode = utils.execute(cmd)\n    local outcontent = utils.readfile(outfile, bin)\n    local errcontent = utils.readfile(errfile, bin)\n    os.remove(outfile)\n    os.remove(errfile)\n    return success, retcode, (outcontent or \"\"), (errcontent or \"\")\nend\n\n--- \'memoize\' a function (cache returned value for next call).\n-- This is useful if you have a function which is relatively expensive,\n-- but you don\'t know in advance what values will be required, so\n-- building a table upfront is wasteful/impossible.\n-- @param func a function of at least one argument\n-- @return a function with at least one argument, which is used as the key.\nfunction utils.memoize(func)\n    local cache = {}\n    return function(k)\n        local res = cache[k]\n        if res == nil then\n            res = func(k)\n            cache[k] = res\n        end\n        return res\n    end\nend\n\n\nutils.stdmt = {\n    List = {_name=\'List\'}, Map = {_name=\'Map\'},\n    Set = {_name=\'Set\'}, MultiMap = {_name=\'MultiMap\'}\n}\n\nlocal _function_factories = {}\n\n--- associate a function factory with a type.\n-- A function factory takes an object of the given type and\n-- returns a function for evaluating it\n-- @tab mt metatable\n-- @func fun a callable that returns a function\nfunction utils.add_function_factory (mt,fun)\n    _function_factories[mt] = fun\nend\n\nlocal function _string_lambda(f)\n    local raise = utils.raise\n    if f:find \'^|\' or f:find \'_\' then\n        local args,body = f:match \'|([^|]*)|(.+)\'\n        if f:find \'_\' then\n            args = \'_\'\n            body = f\n        else\n            if not args then return raise \'bad string lambda\' end\n        end\n        local fstr = \'return function(\'..args..\') return \'..body..\' end\'\n        local fn,err = utils.load(fstr)\n        if not fn then return raise(err) end\n        fn = fn()\n        return fn\n    else return raise \'not a string lambda\'\n    end\nend\n\n--- an anonymous function as a string. This string is either of the form\n-- \'|args| expression\' or is a function of one argument, \'_\'\n-- @param lf function as a string\n-- @return a function\n-- @usage string_lambda \'|x|x+1\' (2) == 3\n-- @usage string_lambda \'_+1\' (2) == 3\n-- @function utils.string_lambda\nutils.string_lambda = utils.memoize(_string_lambda)\n\nlocal ops\n\n--- process a function argument.\n-- This is used throughout Penlight and defines what is meant by a function:\n-- Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n-- such as \'>\' or \'#\'. If a function factory has been registered for the type, it will\n-- be called to get the function.\n-- @param idx argument index\n-- @param f a function, operator string, or callable object\n-- @param msg optional error message\n-- @return a callable\n-- @raise if idx is not a number or if f is not callable\nfunction utils.function_arg (idx,f,msg)\n    utils.assert_arg(1,idx,\'number\')\n    local tp = type(f)\n    if tp == \'function\' then return f end  -- no worries!\n    -- ok, a string can correspond to an operator (like \'==\')\n    if tp == \'string\' then\n        if not ops then ops = require \'pl.operator\'.optable end\n        local fn = ops[f]\n        if fn then return fn end\n        local fn, err = utils.string_lambda(f)\n        if not fn then error(err..\': \'..f) end\n        return fn\n    elseif tp == \'table\' or tp == \'userdata\' then\n        local mt = getmetatable(f)\n        if not mt then error(\'not a callable object\',2) end\n        local ff = _function_factories[mt]\n        if not ff then\n            if not mt.__call then error(\'not a callable object\',2) end\n            return f\n        else\n            return ff(f) -- we have a function factory for this type!\n        end\n    end\n    if not msg then msg = \" must be callable\" end\n    if idx > 0 then\n        error(\"argument \"..idx..\": \"..msg,2)\n    else\n        error(msg,2)\n    end\nend\n\n--- bind the first argument of the function to a value.\n-- @param fn a function of at least two values (may be an operator string)\n-- @param p a value\n-- @return a function such that f(x) is fn(p,x)\n-- @raise same as @{function_arg}\n-- @see func.bind1\nfunction utils.bind1 (fn,p)\n    fn = utils.function_arg(1,fn)\n    return function(...) return fn(p,...) end\nend\n\n--- bind the second argument of the function to a value.\n-- @param fn a function of at least two values (may be an operator string)\n-- @param p a value\n-- @return a function such that f(x) is fn(x,p)\n-- @raise same as @{function_arg}\nfunction utils.bind2 (fn,p)\n    fn = utils.function_arg(1,fn)\n    return function(x,...) return fn(x,p,...) end\nend\n\n\n--- assert that the given argument is in fact of the correct type.\n-- @param n argument index\n-- @param val the value\n-- @param tp the type\n-- @param verify an optional verification function\n-- @param msg an optional custom message\n-- @param lev optional stack position for trace, default 2\n-- @raise if the argument n is not the correct type\n-- @usage assert_arg(1,t,\'table\')\n-- @usage assert_arg(n,val,\'string\',path.isdir,\'not a directory\')\nfunction utils.assert_arg (n,val,tp,verify,msg,lev)\n    if type(val) ~= tp then\n        error((\"argument %d expected a \'%s\', got a \'%s\'\"):format(n,tp,type(val)),lev or 2)\n    end\n    if verify and not verify(val) then\n        error((\"argument %d: \'%s\' %s\"):format(n,val,msg),lev or 2)\n    end\nend\n\n--- assert the common case that the argument is a string.\n-- @param n argument index\n-- @param val a value that must be a string\n-- @raise val must be a string\nfunction utils.assert_string (n,val)\n    utils.assert_arg(n,val,\'string\',nil,nil,3)\nend\n\nlocal err_mode = \'default\'\n\n--- control the error strategy used by Penlight.\n-- Controls how <code>utils.raise</code> works; the default is for it\n-- to return nil and the error string, but if the mode is \'error\' then\n-- it will throw an error. If mode is \'quit\' it will immediately terminate\n-- the program.\n-- @param mode - either \'default\', \'quit\'  or \'error\'\n-- @see utils.raise\nfunction utils.on_error (mode)\n    if ({[\'default\'] = 1, [\'quit\'] = 2, [\'error\'] = 3})[mode] then\n      err_mode = mode\n    else\n      -- fail loudly\n      if err_mode == \'default\' then err_mode = \'error\' end\n      utils.raise(\"Bad argument expected string; \'default\', \'quit\', or \'error\'. Got \'\"..tostring(mode)..\"\'\")\n    end\nend\n\n--- used by Penlight functions to return errors.  Its global behaviour is controlled\n-- by <code>utils.on_error</code>\n-- @param err the error string.\n-- @see utils.on_error\nfunction utils.raise (err)\n    if err_mode == \'default\' then return nil,err\n    elseif err_mode == \'quit\' then utils.quit(err)\n    else error(err,2)\n    end\nend\n\n--- is the object of the specified type?.\n-- If the type is a string, then use type, otherwise compare with metatable\n-- @param obj An object to check\n-- @param tp String of what type it should be\nfunction utils.is_type (obj,tp)\n    if type(tp) == \'string\' then return type(obj) == tp end\n    local mt = getmetatable(obj)\n    return tp == mt\nend\n\nraise = utils.raise\n\n--- load a code string or bytecode chunk.\n-- @param code Lua code as a string or bytecode\n-- @param name for source errors\n-- @param mode kind of chunk, \'t\' for text, \'b\' for bytecode, \'bt\' for all (default)\n-- @param env  the environment for the new chunk (default nil)\n-- @return compiled chunk\n-- @return error message (chunk is nil)\n-- @function utils.load\n\n---------------\n-- Get environment of a function.\n-- With Lua 5.2, may return nil for a function with no global references!\n-- Based on code by [Sergey Rozhenko](http://lua-users.org/lists/lua-l/2010-06/msg00313.html)\n-- @param f a function or a call stack reference\n-- @function utils.getfenv\n\n---------------\n-- Set environment of a function\n-- @param f a function or a call stack reference\n-- @param env a table that becomes the new environment of `f`\n-- @function utils.setfenv\n\n--- execute a shell command.\n-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2\n-- @param cmd a shell command\n-- @return true if successful\n-- @return actual return code\n-- @function utils.execute\n\n\n\nlocal file = {}\n\n--- return the contents of a file as a string\n-- @function file.read\n-- @string filename The file path\n-- @return file contents\nfile.read = utils.readfile\n\n--- write a string to a file\n-- @function file.write\n-- @string filename The file path\n-- @string str The string\nfile.write = utils.writefile\n\n\n\n\n\n\n\nlocal _G = _G\nlocal sub = string.sub\nlocal getenv = os.getenv\nlocal tmpnam = os.tmpname\nlocal package = package\nlocal append, concat, remove = table.insert, table.concat, table.remove\nlocal assert_string,raise = utils.assert_string,utils.raise\n\nlocal attrib\nlocal path = {}\n\nlocal lfs = require \"lfs\"\ngetfenv(1).lfs = nil -- lfs is an \'old-school\' module, hence global pollution\nlocal attributes = lfs.attributes\nlocal currentdir = lfs.currentdir\nlocal link_attrib = lfs.symlinkattributes\n\nattrib = attributes\npath.attrib = attrib\npath.link_attrib = link_attrib\n\n--- Lua iterator over the entries of a given directory.\n-- Behaves like `lfs.dir`\npath.dir = lfs.dir\n\n--- Creates a directory.\npath.mkdir = lfs.mkdir\n\n--- Removes a directory.\npath.rmdir = lfs.rmdir\n\n---- Get the working directory.\npath.currentdir = currentdir\n\n--- Changes the working directory.\npath.chdir = lfs.chdir\n\n\n--- is this a directory?\n-- @string P A file path\nfunction path.isdir(P)\n    assert_string(1,P)\n    if P:match(\"\\\\$\") then\n        P = P:sub(1,-2)\n    end\n    return attrib(P,\'mode\') == \'directory\'\nend\n\n--- is this a file?.\n-- @string P A file path\nfunction path.isfile(P)\n    assert_string(1,P)\n    return attrib(P,\'mode\') == \'file\'\nend\n\n-- is this a symbolic link?\n-- @string P A file path\nfunction path.islink(P)\n    assert_string(1,P)\n    if link_attrib then\n        return link_attrib(P,\'mode\')==\'link\'\n    else\n        return false\n    end\nend\n\n--- return size of a file.\n-- @string P A file path\nfunction path.getsize(P)\n    assert_string(1,P)\n    return attrib(P,\'size\')\nend\n\n--- does a path exist?.\n-- @string P A file path\n-- @return the file path if it exists, nil otherwise\nfunction path.exists(P)\n    assert_string(1,P)\n    return attrib(P,\'mode\') ~= nil and P\nend\n\n--- Return the time of last access as the number of seconds since the epoch.\n-- @string P A file path\nfunction path.getatime(P)\n    assert_string(1,P)\n    return attrib(P,\'access\')\nend\n\n--- Return the time of last modification\n-- @string P A file path\nfunction path.getmtime(P)\n    return attrib(P,\'modification\')\nend\n\n---Return the system\'s ctime.\n-- @string P A file path\nfunction path.getctime(P)\n    assert_string(1,P)\n    return path.attrib(P,\'change\')\nend\n\n\nlocal function at(s,i)\n    return sub(s,i,i)\nend\n\npath.is_windows = utils.is_windows\n\nlocal other_sep\n-- !constant sep is the directory separator for this platform.\nif path.is_windows then\n    path.sep = \'\\\\\'; other_sep = \'/\'\n    path.dirsep = \';\'\nelse\n    path.sep = \'/\'\n    path.dirsep = \':\'\nend\nlocal sep,dirsep = path.sep,path.dirsep\n\n--- are we running Windows?\n-- @class field\n-- @name path.is_windows\n\n--- path separator for this platform.\n-- @class field\n-- @name path.sep\n\n--- separator for PATH for this platform\n-- @class field\n-- @name path.dirsep\n\n--- given a path, return the directory part and a file part.\n-- if there\'s no directory part, the first value will be empty\n-- @string P A file path\nfunction path.splitpath(P)\n    assert_string(1,P)\n    local i = #P\n    local ch = at(P,i)\n    while i > 0 and ch ~= sep and ch ~= other_sep do\n        i = i - 1\n        ch = at(P,i)\n    end\n    if i == 0 then\n        return \'\',P\n    else\n        return sub(P,1,i-1), sub(P,i+1)\n    end\nend\n\n--- return an absolute path.\n-- @string P A file path\n-- @string[opt] pwd optional start path to use (default is current dir)\nfunction path.abspath(P,pwd)\n    assert_string(1,P)\n    if pwd then assert_string(2,pwd) end\n    local use_pwd = pwd ~= nil\n    if not use_pwd and not currentdir then return P end\n    P = P:gsub(\'[\\\\/]$\',\'\')\n    pwd = pwd or currentdir()\n    if not path.isabs(P) then\n        P = path.join(pwd,P)\n    elseif path.is_windows and not use_pwd and at(P,2) ~= \':\' and at(P,2) ~= \'\\\\\' then\n        P = pwd:sub(1,2)..P -- attach current drive to path like \'\\\\fred.txt\'\n    end\n    return path.normpath(P)\nend\n\n--- given a path, return the root part and the extension part.\n-- if there\'s no extension part, the second value will be empty\n-- @string P A file path\n-- @treturn string root part\n-- @treturn string extension part (maybe empty)\nfunction path.splitext(P)\n    assert_string(1,P)\n    local i = #P\n    local ch = at(P,i)\n    while i > 0 and ch ~= \'.\' do\n        if ch == sep or ch == other_sep then\n            return P,\'\'\n        end\n        i = i - 1\n        ch = at(P,i)\n    end\n    if i == 0 then\n        return P,\'\'\n    else\n        return sub(P,1,i-1),sub(P,i)\n    end\nend\n\n--- return the directory part of a path\n-- @string P A file path\nfunction path.dirname(P)\n    assert_string(1,P)\n    local p1,p2 = path.splitpath(P)\n    return p1\nend\n\n--- return the file part of a path\n-- @string P A file path\nfunction path.basename(P)\n    assert_string(1,P)\n    local p1,p2 = path.splitpath(P)\n    return p2\nend\n\n--- get the extension part of a path.\n-- @string P A file path\nfunction path.extension(P)\n    assert_string(1,P)\n    local p1,p2 = path.splitext(P)\n    return p2\nend\n\n--- is this an absolute path?.\n-- @string P A file path\nfunction path.isabs(P)\n    assert_string(1,P)\n    if path.is_windows then\n        return at(P,1) == \'/\' or at(P,1)==\'\\\\\' or at(P,2)==\':\'\n    else\n        return at(P,1) == \'/\'\n    end\nend\n\n--- return the path resulting from combining the individual paths.\n-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).\n-- empty elements (except the last) will be ignored.\n-- @string p1 A file path\n-- @string p2 A file path\n-- @string ... more file paths\nfunction path.join(p1,p2,...)\n    assert_string(1,p1)\n    assert_string(2,p2)\n    if select(\'#\',...) > 0 then\n        local p = path.join(p1,p2)\n        local args = {...}\n        for i = 1,#args do\n            assert_string(i,args[i])\n            p = path.join(p,args[i])\n        end\n        return p\n    end\n    if path.isabs(p2) then return p2 end\n    local endc = at(p1,#p1)\n    if endc ~= path.sep and endc ~= other_sep and endc ~= \"\" then\n        p1 = p1..path.sep\n    end\n    return p1..p2\nend\n\n--- normalize the case of a pathname. On Unix, this returns the path unchanged;\n--  for Windows, it converts the path to lowercase, and it also converts forward slashes\n-- to backward slashes.\n-- @string P A file path\nfunction path.normcase(P)\n    assert_string(1,P)\n    if path.is_windows then\n        return (P:lower():gsub(\'/\',\'\\\\\'))\n    else\n        return P\n    end\nend\n\n--- normalize a path name.\n--  A//B, A/./B and A/foo/../B all become A/B.\n-- @string P a file path\nfunction path.normpath(P)\n    assert_string(1,P)\n    -- Split path into anchor and relative path.\n    local anchor = \'\'\n    if path.is_windows then\n        if P:match \'^\\\\\\\\\' then -- UNC\n            anchor = \'\\\\\\\\\'\n            P = P:sub(3)\n        elseif at(P, 1) == \'/\' or at(P, 1) == \'\\\\\' then\n            anchor = \'\\\\\'\n            P = P:sub(2)\n        elseif at(P, 2) == \':\' then\n            anchor = P:sub(1, 2)\n            P = P:sub(3)\n            if at(P, 1) == \'/\' or at(P, 1) == \'\\\\\' then\n                anchor = anchor..\'\\\\\'\n                P = P:sub(2)\n            end\n        end\n        P = P:gsub(\'/\',\'\\\\\')\n    else\n        -- According to POSIX, in path start \'//\' and \'/\' are distinct,\n        -- but \'///+\' is equivalent to \'/\'.\n        if P:match \'^//\' and at(P, 3) ~= \'/\' then\n            anchor = \'//\'\n            P = P:sub(3)\n        elseif at(P, 1) == \'/\' then\n            anchor = \'/\'\n            P = P:match \'^/*(.*)$\'\n        end\n    end\n    local parts = {}\n    for part in P:gmatch(\'[^\'..sep..\']+\') do\n        if part == \'..\' then\n            if #parts ~= 0 and parts[#parts] ~= \'..\' then\n                remove(parts)\n            else\n                append(parts, part)\n            end\n        elseif part ~= \'.\' then\n            append(parts, part)\n        end\n    end\n    P = anchor..concat(parts, sep)\n    if P == \'\' then P = \'.\' end\n    return P\nend\n\nlocal function ATS (P)\n    if at(P,#P) ~= path.sep then\n        P = P..path.sep\n    end\n    return path.normcase(P)\nend\n\n--- relative path from current directory or optional start point\n-- @string P a path\n-- @string[opt] start optional start point (default current directory)\nfunction path.relpath (P,start)\n    assert_string(1,P)\n    if start then assert_string(2,start) end\n    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert\n    P = normcase(path.abspath(P,start))\n    start = start or currentdir()\n    start = normcase(start)\n    local startl, Pl = split(start,sep), split(P,sep)\n    local n = min(#startl,#Pl)\n    if path.is_windows and n > 0 and at(Pl[1],2) == \':\' and Pl[1] ~= startl[1] then\n        return P\n    end\n    local k = n+1 -- default value if this loop doesn\'t bail out!\n    for i = 1,n do\n        if startl[i] ~= Pl[i] then\n            k = i\n            break\n        end\n    end\n    local rell = {}\n    for i = 1, #startl-k+1 do rell[i] = \'..\' end\n    if k <= #Pl then\n        for i = k,#Pl do append(rell,Pl[i]) end\n    end\n    return table.concat(rell,sep)\nend\n\n\n--- Replace a starting \'~\' with the user\'s home directory.\n-- In windows, if HOME isn\'t set, then USERPROFILE is used in preference to\n-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.\n-- @string P A file path\nfunction path.expanduser(P)\n    assert_string(1,P)\n    if at(P,1) == \'~\' then\n        local home = getenv(\'HOME\')\n        if not home then -- has to be Windows\n            home = getenv \'USERPROFILE\' or (getenv \'HOMEDRIVE\' .. getenv \'HOMEPATH\')\n        end\n        return home..sub(P,2)\n    else\n        return P\n    end\nend\n\n\n---Return a suitable full path to a new temporary file name.\n-- unlike os.tmpnam(), it always gives you a writeable path (uses TEMP environment variable on Windows)\nfunction path.tmpname ()\n    local res = tmpnam()\n    -- On Windows if Lua is compiled using MSVC14 os.tmpname\n    -- already returns an absolute path within TEMP env variable directory,\n    -- no need to prepend it.\n    if path.is_windows and not res:find(\':\') then\n        res = getenv(\'TEMP\')..res\n    end\n    return res\nend\n\n--- return the largest common prefix path of two paths.\n-- @string path1 a file path\n-- @string path2 a file path\nfunction path.common_prefix (path1,path2)\n    assert_string(1,path1)\n    assert_string(2,path2)\n    path1, path2 = path.normcase(path1), path.normcase(path2)\n    -- get them in order!\n    if #path1 > #path2 then path2,path1 = path1,path2 end\n    for i = 1,#path1 do\n        local c1 = at(path1,i)\n        if c1 ~= at(path2,i) then\n            local cp = path1:sub(1,i-1)\n            if at(path1,i-1) ~= sep then\n                cp = path.dirname(cp)\n            end\n            return cp\n        end\n    end\n    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end\n    return path1\n    --return \'\'\nend\n\n--- return the full path where a particular Lua module would be found.\n-- Both package.path and package.cpath is searched, so the result may\n-- either be a Lua file or a shared library.\n-- @string mod name of the module\n-- @return on success: path of module, lua or binary\n-- @return on error: nil,error string\nfunction path.package_path(mod)\n    assert_string(1,mod)\n    local res\n    mod = mod:gsub(\'%.\',sep)\n    res = package.searchpath(mod,package.path)\n    if res then return res,true end\n    res = package.searchpath(mod,package.cpath)\n    if res then return res,false end\n    return raise \'cannot find module on path\'\nend\n\n\n\n\n\n--- Provides a reuseable and convenient framework for creating classes in Lua.\n-- Two possible notations:\n--\n--    B = class(A)\n--    class.B(A)\n--\n-- The latter form creates a named class within the current environment. Note\n-- that this implicitly brings in `pl.utils` as a dependency.\n--\n-- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}\n-- @module pl.class\n\nlocal error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =\n    _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type\nlocal compat\n\n-- this trickery is necessary to prevent the inheritance of \'super\' and\n-- the resulting recursive call problems.\nlocal function call_ctor (c,obj,...)\n    -- nice alias for the base class ctor\n    local base = rawget(c,\'_base\')\n    if base then\n        local parent_ctor = rawget(base,\'_init\')\n        while not parent_ctor do\n            base = rawget(base,\'_base\')\n            if not base then break end\n            parent_ctor = rawget(base,\'_init\')\n        end\n        if parent_ctor then\n            rawset(obj,\'super\',function(obj,...)\n                call_ctor(base,obj,...)\n            end)\n        end\n    end\n    local res = c._init(obj,...)\n    rawset(obj,\'super\',nil)\n    return res\nend\n\n--- initializes an __instance__ upon creation.\n-- @function class:_init\n-- @param ... parameters passed to the constructor\n-- @usage local Cat = class()\n-- function Cat:_init(name)\n--   --self:super(name)   -- call the ancestor initializer if needed\n--   self.name = name\n-- end\n--\n-- local pussycat = Cat(\"pussycat\")\n-- print(pussycat.name)  --> pussycat\n\n--- checks whether an __instance__ is derived from some class.\n-- Works the other way around as `class_of`. It has two ways of using;\n-- 1) call with a class to check against, 2) call without params.\n-- @function instance:is_a\n-- @param some_class class to check against, or `nil` to return the class\n-- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then\n-- it returns the class table of the instance\n-- @usage local pussycat = Lion()  -- assuming Lion derives from Cat\n-- if pussycat:is_a(Cat) then\n--   -- it\'s true, it is a Lion, but also a Cat\n-- end\n--\n-- if pussycat:is_a() == Lion then\n--   -- It\'s true\n-- end\nlocal function is_a(self,klass)\n    if klass == nil then\n        -- no class provided, so return the class this instance is derived from\n        return getmetatable(self)\n    end\n    local m = getmetatable(self)\n    if not m then return false end --*can\'t be an object!\n    while m do\n        if m == klass then return true end\n        m = rawget(m,\'_base\')\n    end\n    return false\nend\n\n--- checks whether an __instance__ is derived from some class.\n-- Works the other way around as `is_a`.\n-- @function some_class:class_of\n-- @param some_instance instance to check against\n-- @return `true` if `some_instance` is derived from `some_class`\n-- @usage local pussycat = Lion()  -- assuming Lion derives from Cat\n-- if Cat:class_of(pussycat) then\n--   -- it\'s true\n-- end\nlocal function class_of(klass,obj)\n    if type(klass) ~= \'table\' or not rawget(klass,\'is_a\') then return false end\n    return klass.is_a(obj,klass)\nend\n\n--- cast an object to another class.\n-- It is not clever (or safe!) so use carefully.\n-- @param some_instance the object to be changed\n-- @function some_class:cast\nlocal function cast (klass, obj)\n    return setmetatable(obj,klass)\nend\n\n\nlocal function _class_tostring (obj)\n    local mt = obj._class\n    local name = rawget(mt,\'_name\')\n    setmetatable(obj,nil)\n    local str = tostring(obj)\n    setmetatable(obj,mt)\n    if name then str = name ..str:gsub(\'table\',\'\') end\n    return str\nend\n\nlocal function tupdate(td,ts,dont_override)\n    for k,v in pairs(ts) do\n        if not dont_override or td[k] == nil then\n            td[k] = v\n        end\n    end\nend\n\nlocal function _class(base,c_arg,c)\n    -- the class `c` will be the metatable for all its objects,\n    -- and they will look up their methods in it.\n    local mt = {}   -- a metatable for the class to support __call and _handler\n    -- can define class by passing it a plain table of methods\n    local plain = type(base) == \'table\' and not getmetatable(base)\n    if plain then\n        c = base\n        base = c._base\n    else\n        c = c or {}\n    end\n\n    if type(base) == \'table\' then\n        -- our new class is a shallow copy of the base class!\n        -- but be careful not to wipe out any methods we have been given at this point!\n        tupdate(c,base,plain)\n        c._base = base\n        -- inherit the \'not found\' handler, if present\n        if rawget(c,\'_handler\') then mt.__index = c._handler end\n    elseif base ~= nil then\n        error(\"must derive from a table type\",3)\n    end\n\n    c.__index = c\n    setmetatable(c,mt)\n    if not plain then\n        c._init = nil\n    end\n\n    if base and rawget(base,\'_class_init\') then\n        base._class_init(c,c_arg)\n    end\n\n    -- expose a ctor which can be called by <classname>(<args>)\n    mt.__call = function(class_tbl,...)\n        local obj\n        if rawget(c,\'_create\') then obj = c._create(...) end\n        if not obj then obj = {} end\n        setmetatable(obj,c)\n\n        if rawget(c,\'_init\') then -- explicit constructor\n            local res = call_ctor(c,obj,...)\n            if res then -- _if_ a ctor returns a value, it becomes the object...\n                obj = res\n                setmetatable(obj,c)\n            end\n        elseif base and rawget(base,\'_init\') then -- default constructor\n            -- make sure that any stuff from the base class is initialized!\n            call_ctor(base,obj,...)\n        end\n\n        if base and rawget(base,\'_post_init\') then\n            base._post_init(obj)\n        end\n\n        return obj\n    end\n    -- Call Class.catch to set a handler for methods/properties not found in the class!\n    c.catch = function(self, handler)\n        if type(self) == \"function\" then\n            -- called using . instead of :\n            handler = self\n        end\n        c._handler = handler\n        mt.__index = handler\n    end\n    c.is_a = is_a\n    c.class_of = class_of\n    c.cast = cast\n    c._class = c\n\n    if not rawget(c,\'__tostring\') then\n        c.__tostring = _class_tostring\n    end\n\n    return c\nend\n\n--- create a new class, derived from a given base class.\n-- Supporting two class creation syntaxes:\n-- either `Name = class(base)` or `class.Name(base)`.\n-- The first form returns the class directly and does not set its `_name`.\n-- The second form creates a variable `Name` in the current environment set\n-- to the class, and also sets `_name`.\n-- @function class\n-- @param base optional base class\n-- @param c_arg optional parameter to class constructor\n-- @param c optional table to be used as class\nlocal class\nclass = setmetatable({},{\n    __call = function(fun,...)\n        return _class(...)\n    end,\n    __index = function(tbl,key)\n        if key == \'class\' then\n            io.stderr:write(\'require(\"pl.class\").class is deprecated. Use require(\"pl.class\")\\n\')\n            return class\n        end\n        compat = compat or require \'pl.compat\'\n        local env = compat.getfenv(2)\n        return function(...)\n            local c = _class(...)\n            c._name = key\n            rawset(env,key,c)\n            return c\n        end\n    end\n})\n\nclass.properties = class()\n\nfunction class.properties._class_init(klass)\n    klass.__index = function(t,key)\n        -- normal class lookup!\n        local v = klass[key]\n        if v then return v end\n        -- is it a getter?\n        v = rawget(klass,\'get_\'..key)\n        if v then\n            return v(t)\n        end\n        -- is it a field?\n        return rawget(t,\'_\'..key)\n    end\n    klass.__newindex = function (t,key,value)\n        -- if there\'s a setter, use that, otherwise directly set table\n        local p = \'set_\'..key\n        local setter = klass[p]\n        if setter then\n            setter(t,value)\n        else\n            rawset(t,key,value)\n        end\n    end\nend\n\n\n\n\n\n\n---- Dealing with Detailed Type Information\n\n-- Dependencies `pl.utils`\n-- @module pl.types\n\nlocal types = {}\n\n--- is the object either a function or a callable object?.\n-- @param obj Object to check.\nfunction types.is_callable (obj)\n    return type(obj) == \'function\' or getmetatable(obj) and getmetatable(obj).__call and true\nend\n\n--- is the object of the specified type?.\n-- If the type is a string, then use type, otherwise compare with metatable\n-- @param obj An object to check\n-- @param tp String of what type it should be\n-- @function is_type\ntypes.is_type = utils.is_type\n\nlocal fileMT = getmetatable(io.stdout)\n\n--- a string representation of a type.\n-- For tables with metatables, we assume that the metatable has a `_name`\n-- field. Knows about Lua file objects.\n-- @param obj an object\n-- @return a string like \'number\', \'table\' or \'List\'\nfunction types.type (obj)\n    local t = type(obj)\n    if t == \'table\' or t == \'userdata\' then\n        local mt = getmetatable(obj)\n        if mt == fileMT then\n            return \'file\'\n        elseif mt == nil then\n            return t\n        else\n            return mt._name or \"unknown \"..t\n        end\n    else\n        return t\n    end\nend\n\n--- is this number an integer?\n-- @param x a number\n-- @raise error if x is not a number\nfunction types.is_integer (x)\n    return math.ceil(x)==x\nend\n\n--- Check if the object is \"empty\".\n-- An object is considered empty if it is nil, a table with out any items (key,\n-- value pairs or indexes), or a string with no content (\"\").\n-- @param o The object to check if it is empty.\n-- @param ignore_spaces If the object is a string and this is true the string is\n-- considered empty is it only contains spaces.\n-- @return true if the object is empty, otherwise false.\nfunction types.is_empty(o, ignore_spaces)\n    if o == nil or (type(o) == \"table\" and not next(o)) or (type(o) == \"string\" and (o == \"\" or (ignore_spaces and o:match(\"^%s+$\")))) then\n        return true\n    end\n    return false\nend\n\nlocal function check_meta (val)\n    if type(val) == \'table\' then return true end\n    return getmetatable(val)\nend\n\n--- is an object \'array-like\'?\n-- @param val any value.\nfunction types.is_indexable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__len and mt.__index and true\nend\n\n--- can an object be iterated over with `pairs`?\n-- @param val any value.\nfunction types.is_iterable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__pairs and true\nend\n\n--- can an object accept new key/pair values?\n-- @param val any value.\nfunction types.is_writeable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__newindex and true\nend\n\n-- Strings that should evaluate to true.\nlocal trues = { yes=true, y=true, [\"true\"]=true, t=true, [\"1\"]=true }\n-- Conditions types should evaluate to true.\nlocal true_types = {\n    boolean=function(o, true_strs, check_objs) return o end,\n    string=function(o, true_strs, check_objs)\n        if trues[o:lower()] then\n            return true\n        end\n        -- Check alternative user provided strings.\n        for _,v in ipairs(true_strs or {}) do\n            if type(v) == \"string\" and o == v:lower() then\n                return true\n            end\n        end\n        return false\n    end,\n    number=function(o, true_strs, check_objs) return o ~= 0 end,\n    table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end\n}\n--- Convert to a boolean value.\n-- True values are:\n--\n-- * boolean: true.\n-- * string: \'yes\', \'y\', \'true\', \'t\', \'1\' or additional strings specified by `true_strs`.\n-- * number: Any non-zero value.\n-- * table: Is not empty and `check_objs` is true.\n-- * object: Is not `nil` and `check_objs` is true.\n--\n-- @param o The object to evaluate.\n-- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.\n-- This should be a List of strings. E.g. \"ja\" to support German.\n-- @param[opt] check_objs True if objects should be evaluated. Default is to evaluate objects as true if not nil\n-- or if it is a table and it is not empty.\n-- @return true if the input evaluates to true, otherwise false.\nfunction types.to_bool(o, true_strs, check_objs)\n    local true_func\n    if true_strs then\n        utils.assert_arg(2, true_strs, \"table\")\n    end\n    true_func = true_types[type(o)]\n    if true_func then\n        return true_func(o, true_strs, check_objs)\n    elseif check_objs and o ~= nil then\n        return true\n    end\n    return false\nend\n\n\n\n\n\n--- Extended operations on Lua tables.\n--\n-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}\n--\n-- Dependencies: `pl.utils`, `pl.types`\n-- @module pl.tablex\nlocal getmetatable,setmetatable,require = getmetatable,setmetatable,require\nlocal tsort,append,remove = table.sort,table.insert,table.remove\nlocal min = math.min\nlocal pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring\nlocal function_arg = utils.function_arg\nlocal assert_arg = utils.assert_arg\n\nlocal tablex = {}\n\n-- generally, functions that make copies of tables try to preserve the metatable.\n-- However, when the source has no obvious type, then we attach appropriate metatables\n-- like List, Map, etc to the result.\nlocal function setmeta (res,tbl,pl_class)\n    local mt = getmetatable(tbl) or pl_class and require(\'pl.\' .. pl_class)\n    return mt and setmetatable(res, mt) or res\nend\n\nlocal function makelist(l)\n    return setmetatable(l, require(\'pl.List\'))\nend\n\nlocal function makemap(m)\n    return setmetatable(m, require(\'pl.Map\'))\nend\n\nlocal function complain (idx,msg)\n    error((\'argument %d is not %s\'):format(idx,msg),3)\nend\n\nlocal function assert_arg_indexable (idx,val)\n    if not types.is_indexable(val) then\n        complain(idx,\"indexable\")\n    end\nend\n\nlocal function assert_arg_iterable (idx,val)\n    if not types.is_iterable(val) then\n        complain(idx,\"iterable\")\n    end\nend\n\nlocal function assert_arg_writeable (idx,val)\n    if not types.is_writeable(val) then\n        complain(idx,\"writeable\")\n    end\nend\n\n--- copy a table into another, in-place.\n-- @within Copying\n-- @tab t1 destination table\n-- @tab t2 source (actually any iterable object)\n-- @return first table\nfunction tablex.update (t1,t2)\n    assert_arg_writeable(1,t1)\n    assert_arg_iterable(2,t2)\n    for k,v in pairs(t2) do\n        t1[k] = v\n    end\n    return t1\nend\n\n--- total number of elements in this table.\n-- Note that this is distinct from `#t`, which is the number\n-- of values in the array part; this value will always\n-- be greater or equal. The difference gives the size of\n-- the hash part, for practical purposes. Works for any\n-- object with a __pairs metamethod.\n-- @tab t a table\n-- @return the size\nfunction tablex.size (t)\n    assert_arg_iterable(1,t)\n    local i = 0\n    for k in pairs(t) do i = i + 1 end\n    return i\nend\n\n--- make a shallow copy of a table\n-- @within Copying\n-- @tab t an iterable source\n-- @return new table\nfunction tablex.copy (t)\n    assert_arg_iterable(1,t)\n    local res = {}\n    for k,v in pairs(t) do\n        res[k] = v\n    end\n    return res\nend\n\n--- make a deep copy of a table, recursively copying all the keys and fields.\n-- This will also set the copied table\'s metatable to that of the original.\n-- @within Copying\n-- @tab t A table\n-- @return new table\nfunction tablex.deepcopy(t)\n    if type(t) ~= \'table\' then return t end\n    assert_arg_iterable(1,t)\n    local mt = getmetatable(t)\n    local res = {}\n    for k,v in pairs(t) do\n        if type(v) == \'table\' then\n            v = tablex.deepcopy(v)\n        end\n        res[k] = v\n    end\n    setmetatable(res,mt)\n    return res\nend\n\nlocal abs, deepcompare = math.abs\n\n--- compare two values.\n-- if they are tables, then compare their keys and fields recursively.\n-- @within Comparing\n-- @param t1 A value\n-- @param t2 A value\n-- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)\n-- @number[opt] eps if defined, then used for any number comparisons\n-- @return true or false\nfunction tablex.deepcompare(t1,t2,ignore_mt,eps)\n    local ty1 = type(t1)\n    local ty2 = type(t2)\n    if ty1 ~= ty2 then return false end\n    -- non-table types can be directly compared\n    if ty1 ~= \'table\' then\n        if ty1 == \'number\' and eps then return abs(t1-t2) < eps end\n        return t1 == t2\n    end\n    -- as well as tables which have the metamethod __eq\n    local mt = getmetatable(t1)\n    if not ignore_mt and mt and mt.__eq then return t1 == t2 end\n    for k1 in pairs(t1) do\n        if t2[k1]==nil then return false end\n    end\n    for k2 in pairs(t2) do\n        if t1[k2]==nil then return false end\n    end\n    for k1,v1 in pairs(t1) do\n        local v2 = t2[k1]\n        if not deepcompare(v1,v2,ignore_mt,eps) then return false end\n    end\n\n    return true\nend\n\ndeepcompare = tablex.deepcompare\n\n--- compare two arrays using a predicate.\n-- @within Comparing\n-- @array t1 an array\n-- @array t2 an array\n-- @func cmp A comparison function\nfunction tablex.compare (t1,t2,cmp)\n    assert_arg_indexable(1,t1)\n    assert_arg_indexable(2,t2)\n    if #t1 ~= #t2 then return false end\n    cmp = function_arg(3,cmp)\n    for k = 1,#t1 do\n        if not cmp(t1[k],t2[k]) then return false end\n    end\n    return true\nend\n\n--- compare two list-like tables using an optional predicate, without regard for element order.\n-- @within Comparing\n-- @array t1 a list-like table\n-- @array t2 a list-like table\n-- @param cmp A comparison function (may be nil)\nfunction tablex.compare_no_order (t1,t2,cmp)\n    assert_arg_indexable(1,t1)\n    assert_arg_indexable(2,t2)\n    if cmp then cmp = function_arg(3,cmp) end\n    if #t1 ~= #t2 then return false end\n    local visited = {}\n    for i = 1,#t1 do\n        local val = t1[i]\n        local gotcha\n        for j = 1,#t2 do if not visited[j] then\n            local match\n            if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end\n            if match then\n                gotcha = j\n                break\n            end\n        end end\n        if not gotcha then return false end\n        visited[gotcha] = true\n    end\n    return true\nend\n\n\n--- return the index of a value in a list.\n-- Like string.find, there is an optional index to start searching,\n-- which can be negative.\n-- @within Finding\n-- @array t A list-like table\n-- @param val A value\n-- @int idx index to start; -1 means last element,etc (default 1)\n-- @return index of value or nil if not found\n-- @usage find({10,20,30},20) == 2\n-- @usage find({\'a\',\'b\',\'a\',\'c\'},\'a\',2) == 3\nfunction tablex.find(t,val,idx)\n    assert_arg_indexable(1,t)\n    idx = idx or 1\n    if idx < 0 then idx = #t + idx + 1 end\n    for i = idx,#t do\n        if t[i] == val then return i end\n    end\n    return nil\nend\n\n--- return the index of a value in a list, searching from the end.\n-- Like string.find, there is an optional index to start searching,\n-- which can be negative.\n-- @within Finding\n-- @array t A list-like table\n-- @param val A value\n-- @param idx index to start; -1 means last element,etc (default 1)\n-- @return index of value or nil if not found\n-- @usage rfind({10,10,10},10) == 3\nfunction tablex.rfind(t,val,idx)\n    assert_arg_indexable(1,t)\n    idx = idx or #t\n    if idx < 0 then idx = #t + idx + 1 end\n    for i = idx,1,-1 do\n        if t[i] == val then return i end\n    end\n    return nil\nend\n\n\n--- return the index (or key) of a value in a table using a comparison function.\n-- @within Finding\n-- @tab t A table\n-- @func cmp A comparison function\n-- @param arg an optional second argument to the function\n-- @return index of value, or nil if not found\n-- @return value returned by comparison function\nfunction tablex.find_if(t,cmp,arg)\n    assert_arg_iterable(1,t)\n    cmp = function_arg(2,cmp)\n    for k,v in pairs(t) do\n        local c = cmp(v,arg)\n        if c then return k,c end\n    end\n    return nil\nend\n\n--- return a list of all values in a table indexed by another list.\n-- @tab tbl a table\n-- @array idx an index table (a list of keys)\n-- @return a list-like table\n-- @usage index_by({10,20,30,40},{2,4}) == {20,40}\n-- @usage index_by({one=1,two=2,three=3},{\'one\',\'three\'}) == {1,3}\nfunction tablex.index_by(tbl,idx)\n    assert_arg_indexable(1,tbl)\n    assert_arg_indexable(2,idx)\n    local res = {}\n    for i = 1,#idx do\n        res[i] = tbl[idx[i]]\n    end\n    return setmeta(res,tbl,\'List\')\nend\n\n--- apply a function to all values of a table.\n-- This returns a table of the results.\n-- Any extra arguments are passed to the function.\n-- @within MappingAndFiltering\n-- @func fun A function that takes at least one argument\n-- @tab t A table\n-- @param ... optional arguments\n-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}\nfunction tablex.map(fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t) do\n        res[k] = fun(v,...)\n    end\n    return setmeta(res,t)\nend\n\n--- apply a function to all values of a list.\n-- This returns a table of the results.\n-- Any extra arguments are passed to the function.\n-- @within MappingAndFiltering\n-- @func fun A function that takes at least one argument\n-- @array t a table (applies to array part)\n-- @param ... optional arguments\n-- @return a list-like table\n-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}\nfunction tablex.imap(fun,t,...)\n    assert_arg_indexable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for i = 1,#t do\n        res[i] = fun(t[i],...) or false\n    end\n    return setmeta(res,t,\'List\')\nend\n\n--- apply a named method to values from a table.\n-- @within MappingAndFiltering\n-- @string name the method name\n-- @array t a list-like table\n-- @param ... any extra arguments to the method\nfunction tablex.map_named_method (name,t,...)\n    utils.assert_string(1,name)\n    assert_arg_indexable(2,t)\n    local res = {}\n    for i = 1,#t do\n        local val = t[i]\n        local fun = val[name]\n        res[i] = fun(val,...)\n    end\n    return setmeta(res,t,\'List\')\nend\n\n--- apply a function to all values of a table, in-place.\n-- Any extra arguments are passed to the function.\n-- @func fun A function that takes at least one argument\n-- @tab t a table\n-- @param ... extra arguments\nfunction tablex.transform (fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    for k,v in pairs(t) do\n        t[k] = fun(v,...)\n    end\nend\n\n--- generate a table of all numbers in a range.\n-- This is consistent with a numerical for loop.\n-- @int start  number\n-- @int finish number\n-- @int[opt=1] step  make this negative for start < finish\nfunction tablex.range (start,finish,step)\n    local res\n    step = step or 1\n    if start == finish then\n        res = {start}\n    elseif (start > finish and step > 0) or (finish > start and step < 0) then\n        res = {}\n    else\n        local k = 1\n        res = {}\n        for i=start,finish,step do res[k]=i; k=k+1 end\n    end\n    return makelist(res)\nend\n\n--- apply a function to values from two tables.\n-- @within MappingAndFiltering\n-- @func fun a function of at least two arguments\n-- @tab t1 a table\n-- @tab t2 a table\n-- @param ... extra arguments\n-- @return a table\n-- @usage map2(\'+\',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}\nfunction tablex.map2 (fun,t1,t2,...)\n    assert_arg_iterable(1,t1)\n    assert_arg_iterable(2,t2)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t1) do\n        res[k] = fun(v,t2[k],...)\n    end\n    return setmeta(res,t1,\'List\')\nend\n\n--- apply a function to values from two arrays.\n-- The result will be the length of the shortest array.\n-- @within MappingAndFiltering\n-- @func fun a function of at least two arguments\n-- @array t1 a list-like table\n-- @array t2 a list-like table\n-- @param ... extra arguments\n-- @usage imap2(\'+\',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}\nfunction tablex.imap2 (fun,t1,t2,...)\n    assert_arg_indexable(2,t1)\n    assert_arg_indexable(3,t2)\n    fun = function_arg(1,fun)\n    local res,n = {},math.min(#t1,#t2)\n    for i = 1,n do\n        res[i] = fun(t1[i],t2[i],...)\n    end\n    return res\nend\n\n--- \'reduce\' a list using a binary function.\n-- @func fun a function of two arguments\n-- @array t a list-like table\n-- @array memo optional initial memo value. Defaults to first value in table.\n-- @return the result of the function\n-- @usage reduce(\'+\',{1,2,3,4}) == 10\nfunction tablex.reduce (fun,t,memo)\n    assert_arg_indexable(2,t)\n    fun = function_arg(1,fun)\n    local n = #t\n    if n == 0 then\n        return memo\n    end\n    local res = memo and fun(memo, t[1]) or t[1]\n    for i = 2,n do\n        res = fun(res,t[i])\n    end\n    return res\nend\n\n--- apply a function to all elements of a table.\n-- The arguments to the function will be the value,\n-- the key and _finally_ any extra arguments passed to this function.\n-- Note that the Lua 5.0 function table.foreach passed the _key_ first.\n-- @within Iterating\n-- @tab t a table\n-- @func fun a function with at least one argument\n-- @param ... extra arguments\nfunction tablex.foreach(t,fun,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(2,fun)\n    for k,v in pairs(t) do\n        fun(v,k,...)\n    end\nend\n\n--- apply a function to all elements of a list-like table in order.\n-- The arguments to the function will be the value,\n-- the index and _finally_ any extra arguments passed to this function\n-- @within Iterating\n-- @array t a table\n-- @func fun a function with at least one argument\n-- @param ... optional arguments\nfunction tablex.foreachi(t,fun,...)\n    assert_arg_indexable(1,t)\n    fun = function_arg(2,fun)\n    for i = 1,#t do\n        fun(t[i],i,...)\n    end\nend\n\n--- Apply a function to a number of tables.\n-- A more general version of map\n-- The result is a table containing the result of applying that function to the\n-- ith value of each table. Length of output list is the minimum length of all the lists\n-- @within MappingAndFiltering\n-- @func fun a function of n arguments\n-- @tab ... n tables\n-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}\n-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}\n-- @param fun A function that takes as many arguments as there are tables\nfunction tablex.mapn(fun,...)\n    fun = function_arg(1,fun)\n    local res = {}\n    local lists = {...}\n    local minn = 1e40\n    for i = 1,#lists do\n        minn = min(minn,#(lists[i]))\n    end\n    for i = 1,minn do\n        local args,k = {},1\n        for j = 1,#lists do\n            args[k] = lists[j][i]\n            k = k + 1\n        end\n        res[#res+1] = fun(unpack(args))\n    end\n    return res\nend\n\n--- call the function with the key and value pairs from a table.\n-- The function can return a value and a key (note the order!). If both\n-- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that\n-- key into a table and append into it. If only value is not nil, then it is appended to the result.\n-- @within MappingAndFiltering\n-- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.\n-- @tab t A table\n-- @param ... optional arguments\n-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}\n-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={\'one\',1},two={\'two\',2}}\nfunction tablex.pairmap(fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t) do\n        local rv,rk = fun(k,v,...)\n        if rk then\n            if res[rk] then\n                if type(res[rk]) == \'table\' then\n                    table.insert(res[rk],rv)\n                else\n                    res[rk] = {res[rk], rv}\n                end\n            else\n                res[rk] = rv\n            end\n        else\n            res[#res+1] = rv\n        end\n    end\n    return res\nend\n\nlocal function keys_op(i,v) return i end\n\n--- return all the keys of a table in arbitrary order.\n-- @within Extraction\n--  @tab t A table\nfunction tablex.keys(t)\n    assert_arg_iterable(1,t)\n    return makelist(tablex.pairmap(keys_op,t))\nend\n\nlocal function values_op(i,v) return v end\n\n--- return all the values of the table in arbitrary order\n-- @within Extraction\n--  @tab t A table\nfunction tablex.values(t)\n    assert_arg_iterable(1,t)\n    return makelist(tablex.pairmap(values_op,t))\nend\n\nlocal function index_map_op (i,v) return i,v end\n\n--- create an index map from a list-like table. The original values become keys,\n-- and the associated values are the indices into the original list.\n-- @array t a list-like table\n-- @return a map-like table\nfunction tablex.index_map (t)\n    assert_arg_indexable(1,t)\n    return makemap(tablex.pairmap(index_map_op,t))\nend\n\nlocal function set_op(i,v) return true,v end\n\n--- create a set from a list-like table. A set is a table where the original values\n-- become keys, and the associated values are all true.\n-- @array t a list-like table\n-- @return a set (a map-like table)\nfunction tablex.makeset (t)\n    assert_arg_indexable(1,t)\n    return setmetatable(tablex.pairmap(set_op,t),require(\'pl.Set\'))\nend\n\n--- combine two tables, either as union or intersection. Corresponds to\n-- set operations for sets () but more general. Not particularly\n-- useful for list-like tables.\n-- @within Merging\n-- @tab t1 a table\n-- @tab t2 a table\n-- @bool dup true for a union, false for an intersection.\n-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}\n-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}\n-- @see tablex.index_map\nfunction tablex.merge (t1,t2,dup)\n    assert_arg_iterable(1,t1)\n    assert_arg_iterable(2,t2)\n    local res = {}\n    for k,v in pairs(t1) do\n        if dup or t2[k] then res[k] = v end\n    end\n    if dup then\n      for k,v in pairs(t2) do\n        res[k] = v\n      end\n    end\n    return setmeta(res,t1,\'Map\')\nend\n\n--- the union of two map-like tables.\n-- If there are duplicate keys, the second table wins.\n-- @tab t1 a table\n-- @tab t2 a table\n-- @treturn tab\n-- @see tablex.merge\nfunction tablex.union(t1, t2)\n    return tablex.merge(t1, t2, true)\nend\n\n--- the intersection of two map-like tables.\n-- @tab t1 a table\n-- @tab t2 a table\n-- @treturn tab\n-- @see tablex.merge\nfunction tablex.intersection(t1, t2)\n    return tablex.merge(t1, t2, false)\nend\n\n--- a new table which is the difference of two tables.\n-- With sets (where the values are all true) this is set difference and\n-- symmetric difference depending on the third parameter.\n-- @within Merging\n-- @tab s1 a map-like table or set\n-- @tab s2 a map-like table or set\n-- @bool symm symmetric difference (default false)\n-- @return a map-like table or set\nfunction tablex.difference (s1,s2,symm)\n    assert_arg_iterable(1,s1)\n    assert_arg_iterable(2,s2)\n    local res = {}\n    for k,v in pairs(s1) do\n        if s2[k] == nil then res[k] = v end\n    end\n    if symm then\n        for k,v in pairs(s2) do\n            if s1[k] == nil then res[k] = v end\n        end\n    end\n    return setmeta(res,s1,\'Map\')\nend\n\n--- A table where the key/values are the values and value counts of the table.\n-- @array t a list-like table\n-- @func cmp a function that defines equality (otherwise uses ==)\n-- @return a map-like table\n-- @see seq.count_map\nfunction tablex.count_map (t,cmp)\n    assert_arg_indexable(1,t)\n    local res,mask = {},{}\n    cmp = function_arg(2,cmp or \'==\')\n    local n = #t\n    for i = 1,#t do\n        local v = t[i]\n        if not mask[v] then\n            mask[v] = true\n            -- check this value against all other values\n            res[v] = 1  -- there\'s at least one instance\n            for j = i+1,n do\n                local w = t[j]\n                local ok = cmp(v,w)\n                if ok then\n                    res[v] = res[v] + 1\n                    mask[w] = true\n                end\n            end\n        end\n    end\n    return makemap(res)\nend\n\n--- filter an array\'s values using a predicate function\n-- @within MappingAndFiltering\n-- @array t a list-like table\n-- @func pred a boolean function\n-- @param arg optional argument to be passed as second argument of the predicate\nfunction tablex.filter (t,pred,arg)\n    assert_arg_indexable(1,t)\n    pred = function_arg(2,pred)\n    local res,k = {},1\n    for i = 1,#t do\n        local v = t[i]\n        if pred(v,arg) then\n            res[k] = v\n            k = k + 1\n        end\n    end\n    return setmeta(res,t,\'List\')\nend\n\n--- return a table where each element is a table of the ith values of an arbitrary\n-- number of tables. It is equivalent to a matrix transpose.\n-- @within Merging\n-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}\n-- @array ... arrays to be zipped\nfunction tablex.zip(...)\n    return tablex.mapn(function(...) return {...} end,...)\nend\n\nlocal _copy\nfunction _copy (dest,src,idest,isrc,nsrc,clean_tail)\n    idest = idest or 1\n    isrc = isrc or 1\n    local iend\n    if not nsrc then\n        nsrc = #src\n        iend = #src\n    else\n        iend = isrc + min(nsrc-1,#src-isrc)\n    end\n    if dest == src then -- special case\n        if idest > isrc and iend >= idest then -- overlapping ranges\n            src = tablex.sub(src,isrc,nsrc)\n            isrc = 1; iend = #src\n        end\n    end\n    for i = isrc,iend do\n        dest[idest] = src[i]\n        idest = idest + 1\n    end\n    if clean_tail then\n        tablex.clear(dest,idest)\n    end\n    return dest\nend\n\n--- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.\n-- @within Copying\n-- @array dest a list-like table\n-- @array src a list-like table\n-- @int[opt=1] idest where to start copying values into destination\n-- @int[opt=1] isrc where to start copying values from source\n-- @int[opt=#src] nsrc number of elements to copy from source\nfunction tablex.icopy (dest,src,idest,isrc,nsrc)\n    assert_arg_indexable(1,dest)\n    assert_arg_indexable(2,src)\n    return _copy(dest,src,idest,isrc,nsrc,true)\nend\n\n--- copy an array into another one.\n-- @within Copying\n-- @array dest a list-like table\n-- @array src a list-like table\n-- @int[opt=1] idest where to start copying values into destination\n-- @int[opt=1] isrc where to start copying values from source\n-- @int[opt=#src] nsrc number of elements to copy from source\nfunction tablex.move (dest,src,idest,isrc,nsrc)\n    assert_arg_indexable(1,dest)\n    assert_arg_indexable(2,src)\n    return _copy(dest,src,idest,isrc,nsrc,false)\nend\n\nfunction tablex._normalize_slice(self,first,last)\n  local sz = #self\n  if not first then first=1 end\n  if first<0 then first=sz+first+1 end\n  -- make the range _inclusive_!\n  if not last then last=sz end\n  if last < 0 then last=sz+1+last end\n  return first,last\nend\n\n--- Extract a range from a table, like  \'string.sub\'.\n-- If first or last are negative then they are relative to the end of the list\n-- eg. sub(t,-2) gives last 2 entries in a list, and\n-- sub(t,-4,-2) gives from -4th to -2nd\n-- @within Extraction\n-- @array t a list-like table\n-- @int first An index\n-- @int last An index\n-- @return a new List\nfunction tablex.sub(t,first,last)\n    assert_arg_indexable(1,t)\n    first,last = tablex._normalize_slice(t,first,last)\n    local res={}\n    for i=first,last do append(res,t[i]) end\n    return setmeta(res,t,\'List\')\nend\n\n--- set an array range to a value. If it\'s a function we use the result\n-- of applying it to the indices.\n-- @array t a list-like table\n-- @param val a value\n-- @int[opt=1] i1 start range\n-- @int[opt=#t] i2 end range\nfunction tablex.set (t,val,i1,i2)\n    assert_arg_indexable(1,t)\n    i1,i2 = i1 or 1,i2 or #t\n    if types.is_callable(val) then\n        for i = i1,i2 do\n            t[i] = val(i)\n        end\n    else\n        for i = i1,i2 do\n            t[i] = val\n        end\n    end\nend\n\n--- create a new array of specified size with initial value.\n-- @int n size\n-- @param val initial value (can be `nil`, but don\'t expect `#` to work!)\n-- @return the table\nfunction tablex.new (n,val)\n    local res = {}\n    tablex.set(res,val,1,n)\n    return res\nend\n\n--- clear out the contents of a table.\n-- @array t a list\n-- @param istart optional start position\nfunction tablex.clear(t,istart)\n    istart = istart or 1\n    for i = istart,#t do remove(t) end\nend\n\n--- insert values into a table.\n-- similar to `table.insert` but inserts values from given table `values`,\n-- not the object itself, into table `t` at position `pos`.\n-- @within Copying\n-- @array t the list\n-- @int[opt] position (default is at end)\n-- @array values\nfunction tablex.insertvalues(t, ...)\n    assert_arg(1,t,\'table\')\n    local pos, values\n    if select(\'#\', ...) == 1 then\n        pos,values = #t+1, ...\n    else\n        pos,values = ...\n    end\n    if #values > 0 then\n        for i=#t,pos,-1 do\n            t[i+#values] = t[i]\n        end\n        local offset = 1 - pos\n        for i=pos,pos+#values-1 do\n            t[i] = values[i + offset]\n        end\n    end\n    return t\nend\n\n--- remove a range of values from a table.\n-- End of range may be negative.\n-- @array t a list-like table\n-- @int i1 start index\n-- @int i2 end index\n-- @return the table\nfunction tablex.removevalues (t,i1,i2)\n    assert_arg(1,t,\'table\')\n    i1,i2 = tablex._normalize_slice(t,i1,i2)\n    for i = i1,i2 do\n        remove(t,i1)\n    end\n    return t\nend\n\nlocal _find\n_find = function (t,value,tables)\n    for k,v in pairs(t) do\n        if v == value then return k end\n    end\n    for k,v in pairs(t) do\n        if not tables[v] and type(v) == \'table\' then\n            tables[v] = true\n            local res = _find(v,value,tables)\n            if res then\n                res = tostring(res)\n                if type(k) ~= \'string\' then\n                    return \'[\'..k..\']\'..res\n                else\n                    return k..\'.\'..res\n                end\n            end\n        end\n    end\nend\n\n--- find a value in a table by recursive search.\n-- @within Finding\n-- @tab t the table\n-- @param value the value\n-- @array[opt] exclude any tables to avoid searching\n-- @usage search(_G,math.sin,{package.path}) == \'math.sin\'\n-- @return a fieldspec, e.g. \'a.b\' or \'math.sin\'\nfunction tablex.search (t,value,exclude)\n    assert_arg_iterable(1,t)\n    local tables = {[t]=true}\n    if exclude then\n        for _,v in pairs(exclude) do tables[v] = true end\n    end\n    return _find(t,value,tables)\nend\n\n--- return an iterator to a table sorted by its keys\n-- @within Iterating\n-- @tab t the table\n-- @func f an optional comparison function (f(x,y) is true if x < y)\n-- @usage for k,v in tablex.sort(t) do print(k,v) end\n-- @return an iterator to traverse elements sorted by the keys\nfunction tablex.sort(t,f)\n    local keys = {}\n    for k in pairs(t) do keys[#keys + 1] = k end\n    tsort(keys,f)\n    local i = 0\n    return function()\n        i = i + 1\n        return keys[i], t[keys[i]]\n    end\nend\n\n--- return an iterator to a table sorted by its values\n-- @within Iterating\n-- @tab t the table\n-- @func f an optional comparison function (f(x,y) is true if x < y)\n-- @usage for k,v in tablex.sortv(t) do print(k,v) end\n-- @return an iterator to traverse elements sorted by the values\nfunction tablex.sortv(t,f)\n    f = function_arg(2, f or \'<\')\n    local keys = {}\n    for k in pairs(t) do keys[#keys + 1] = k end\n    tsort(keys,function(x, y) return f(t[x], t[y]) end)\n    local i = 0\n    return function()\n        i = i + 1\n        return keys[i], t[keys[i]]\n    end\nend\n\n--- modifies a table to be read only.\n-- This only offers weak protection. Tables can still be modified with\n-- `table.insert` and `rawset`.\n-- @tab t the table\n-- @return the table read only.\nfunction tablex.readonly(t)\n    local mt = {\n        __index=t,\n        __newindex=function(t, k, v) error(\"Attempt to modify read-only table\", 2) end,\n        __pairs=function() return pairs(t) end,\n        __ipairs=function() return ipairs(t) end,\n        __len=function() return #t end,\n        __metatable=false\n    }\n    return setmetatable({}, mt)\nend\n\n\n\n\n\n--- Python-style list class.\n--\n-- **Please Note**: methods that change the list will return the list.\n-- This is to allow for method chaining, but please note that `ls = ls:sort()`\n-- does not mean that a new copy of the list is made. In-place (mutable) methods\n-- are marked as returning \'the list\' in this documentation.\n--\n-- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}\n--\n-- See <a href=\"http://www.python.org/doc/current/tut/tut.html\">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1\n--\n-- **Note**: The comments before some of the functions are from the Python docs\n-- and contain Python code.\n--\n-- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.\n--\n-- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`\n-- @classmod pl.List\n-- @pragma nostrip\n\nlocal tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort\nlocal setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string\nlocal filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues\nlocal tsub = tablex.sub\n\nlocal array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg\nlocal normalize_slice = tablex._normalize_slice\n\n-- metatable for our list and map objects has already been defined..\nlocal Multimap = utils.stdmt.MultiMap\nlocal List = utils.stdmt.List\n\nlocal iter\n\nclass(nil,nil,List)\n\n-- we want the result to be _covariant_, i.e. t must have type of obj if possible\nlocal function makelist (t,obj)\n    local klass = List\n    if obj then\n        klass = getmetatable(obj)\n    end\n    return setmetatable(t,klass)\nend\n\nlocal function simple_table(t)\n    return type(t) == \'table\' and not getmetatable(t) and #t > 0\nend\n\nfunction List._create (src)\n    if simple_table(src) then return src end\nend\n\nfunction List:_init (src)\n    if self == src then return end -- existing table used as self!\n    if src then\n        for v in iter(src) do\n            tinsert(self,v)\n        end\n    end\nend\n\n--- Create a new list. Can optionally pass a table;\n-- passing another instance of List will cause a copy to be created;\n-- this will return a plain table with an appropriate metatable.\n-- we pass anything which isn\'t a simple table to iterate() to work out\n-- an appropriate iterator\n--  @see List.iterate\n-- @param[opt] t An optional list-like table\n-- @return a new List\n-- @usage ls = List();  ls = List {1,2,3,4}\n-- @function List.new\n\nList.new = List\n\n--- Make a copy of an existing list.\n-- The difference from a plain \'copy constructor\' is that this returns\n-- the actual List subtype.\nfunction List:clone()\n    local ls = makelist({},self)\n    ls:extend(self)\n    return ls\nend\n\n---Add an item to the end of the list.\n-- @param i An item\n-- @return the list\nfunction List:append(i)\n    tinsert(self,i)\n    return self\nend\n\nList.push = tinsert\n\n--- Extend the list by appending all the items in the given list.\n-- equivalent to \'a[len(a):] = L\'.\n-- @tparam List L Another List\n-- @return the list\nfunction List:extend(L)\n    assert_arg(1,L,\'table\')\n    for i = 1,#L do tinsert(self,L[i]) end\n    return self\nend\n\n--- Insert an item at a given position. i is the index of the\n-- element before which to insert.\n-- @int i index of element before whichh to insert\n-- @param x A data item\n-- @return the list\nfunction List:insert(i, x)\n    assert_arg(1,i,\'number\')\n    tinsert(self,i,x)\n    return self\nend\n\n--- Insert an item at the begining of the list.\n-- @param x a data item\n-- @return the list\nfunction List:put (x)\n    return self:insert(1,x)\nend\n\n--- Remove an element given its index.\n-- (equivalent of Python\'s del s[i])\n-- @int i the index\n-- @return the list\nfunction List:remove (i)\n    assert_arg(1,i,\'number\')\n    tremove(self,i)\n    return self\nend\n\n--- Remove the first item from the list whose value is given.\n-- (This is called \'remove\' in Python; renamed to avoid confusion\n-- with table.remove)\n-- Return nil if there is no such item.\n-- @param x A data value\n-- @return the list\nfunction List:remove_value(x)\n    for i=1,#self do\n        if self[i]==x then tremove(self,i) return self end\n    end\n    return self\n end\n\n--- Remove the item at the given position in the list, and return it.\n-- If no index is specified, a:pop() returns the last item in the list.\n-- The item is also removed from the list.\n-- @int[opt] i An index\n-- @return the item\nfunction List:pop(i)\n    if not i then i = #self end\n    assert_arg(1,i,\'number\')\n    return tremove(self,i)\nend\n\nList.get = List.pop\n\n--- Return the index in the list of the first item whose value is given.\n-- Return nil if there is no such item.\n-- @function List:index\n-- @param x A data value\n-- @int[opt=1] idx where to start search\n-- @return the index, or nil if not found.\n\nlocal tfind = tablex.find\nList.index = tfind\n\n--- does this list contain the value?.\n-- @param x A data value\n-- @return true or false\nfunction List:contains(x)\n    return tfind(self,x) and true or false\nend\n\n--- Return the number of times value appears in the list.\n-- @param x A data value\n-- @return number of times x appears\nfunction List:count(x)\n    local cnt=0\n    for i=1,#self do\n        if self[i]==x then cnt=cnt+1 end\n    end\n    return cnt\nend\n\n--- Sort the items of the list, in place.\n-- @func[opt=\'<\'] cmp an optional comparison function\n-- @return the list\nfunction List:sort(cmp)\n    if cmp then cmp = function_arg(1,cmp) end\n    tsort(self,cmp)\n    return self\nend\n\n--- return a sorted copy of this list.\n-- @func[opt=\'<\'] cmp an optional comparison function\n-- @return a new list\nfunction List:sorted(cmp)\n    return List(self):sort(cmp)\nend\n\n--- Reverse the elements of the list, in place.\n-- @return the list\nfunction List:reverse()\n    local t = self\n    local n = #t\n    for i = 1,n/2 do\n        t[i],t[n] = t[n],t[i]\n        n = n - 1\n    end\n    return self\nend\n\n--- return the minimum and the maximum value of the list.\n-- @return minimum value\n-- @return maximum value\nfunction List:minmax()\n    local vmin,vmax = 1e70,-1e70\n    for i = 1,#self do\n        local v = self[i]\n        if v < vmin then vmin = v end\n        if v > vmax then vmax = v end\n    end\n    return vmin,vmax\nend\n\n--- Emulate list slicing.  like  \'list[first:last]\' in Python.\n-- If first or last are negative then they are relative to the end of the list\n-- eg. slice(-2) gives last 2 entries in a list, and\n-- slice(-4,-2) gives from -4th to -2nd\n-- @param first An index\n-- @param last An index\n-- @return a new List\nfunction List:slice(first,last)\n    return tsub(self,first,last)\nend\n\n--- empty the list.\n-- @return the list\nfunction List:clear()\n    for i=1,#self do tremove(self) end\n    return self\nend\n\nlocal eps = 1.0e-10\n\n--- Emulate Python\'s range(x) function.\n-- Include it in List table for tidiness\n-- @int start A number\n-- @int[opt] finish A number greater than start; if absent,\n-- then start is 1 and finish is start\n-- @int[opt=1] incr an increment (may be less than 1)\n-- @return a List from start .. finish\n-- @usage List.range(0,3) == List{0,1,2,3}\n-- @usage List.range(4) = List{1,2,3,4}\n-- @usage List.range(5,1,-1) == List{5,4,3,2,1}\nfunction List.range(start,finish,incr)\n    if not finish then\n        finish = start\n        start = 1\n    end\n    if incr then\n    assert_arg(3,incr,\'number\')\n    if math.ceil(incr) ~= incr then finish = finish + eps end\n    else\n        incr = 1\n    end\n    assert_arg(1,start,\'number\')\n    assert_arg(2,finish,\'number\')\n    local t = List()\n    for i=start,finish,incr do tinsert(t,i) end\n    return t\nend\n\n--- list:len() is the same as #list.\nfunction List:len()\n    return #self\nend\n\n-- Extended operations --\n\n--- Remove a subrange of elements.\n-- equivalent to \'del s[i1:i2]\' in Python.\n-- @int i1 start of range\n-- @int i2 end of range\n-- @return the list\nfunction List:chop(i1,i2)\n    return tremovevalues(self,i1,i2)\nend\n\n--- Insert a sublist into a list\n-- equivalent to \'s[idx:idx] = list\' in Python\n-- @int idx index\n-- @tparam List list list to insert\n-- @return the list\n-- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})\nfunction List:splice(idx,list)\n    assert_arg(1,idx,\'number\')\n    idx = idx - 1\n    local i = 1\n    for v in iter(list) do\n        tinsert(self,i+idx,v)\n        i = i + 1\n    end\n    return self\nend\n\n--- general slice assignment s[i1:i2] = seq.\n-- @int i1  start index\n-- @int i2  end index\n-- @tparam List seq a list\n-- @return the list\nfunction List:slice_assign(i1,i2,seq)\n    assert_arg(1,i1,\'number\')\n    assert_arg(1,i2,\'number\')\n    i1,i2 = normalize_slice(self,i1,i2)\n    if i2 >= i1 then self:chop(i1,i2) end\n    self:splice(i1,seq)\n    return self\nend\n\n--- concatenation operator.\n-- @within metamethods\n-- @tparam List L another List\n-- @return a new list consisting of the list with the elements of the new list appended\nfunction List:__concat(L)\n    assert_arg(1,L,\'table\')\n    local ls = self:clone()\n    ls:extend(L)\n    return ls\nend\n\n--- equality operator ==.  True iff all elements of two lists are equal.\n-- @within metamethods\n-- @tparam List L another List\n-- @return true or false\nfunction List:__eq(L)\n    if #self ~= #L then return false end\n    for i = 1,#self do\n        if self[i] ~= L[i] then return false end\n    end\n    return true\nend\n\n--- join the elements of a list using a delimiter.\n-- This method uses tostring on all elements.\n-- @string[opt=\'\'] delim a delimiter string, can be empty.\n-- @return a string\nfunction List:join (delim)\n    delim = delim or \'\'\n    assert_arg(1,delim,\'string\')\n    return concat(array_tostring(self),delim)\nend\n\n--- join a list of strings. <br>\n-- Uses `table.concat` directly.\n-- @function List:concat\n-- @string[opt=\'\'] delim a delimiter\n-- @return a string\nList.concat = concat\n\nlocal function tostring_q(val)\n    local s = tostring(val)\n    if type(val) == \'string\' then\n        s = \'\"\'..s..\'\"\'\n    end\n    return s\nend\n\n--- how our list should be rendered as a string. Uses join().\n-- @within metamethods\n-- @see List:join\nfunction List:__tostring()\n    return \'{\'..self:join(\',\',tostring_q)..\'}\'\nend\n\n--- call the function on each element of the list.\n-- @func fun a function or callable object\n-- @param ... optional values to pass to function\nfunction List:foreach (fun,...)\n    fun = function_arg(1,fun)\n    for i = 1,#self do\n        fun(self[i],...)\n    end\nend\n\nlocal function lookup_fun (obj,name)\n    local f = obj[name]\n    if not f then error(type(obj)..\" does not have method \"..name,3) end\n    return f\nend\n\n--- call the named method on each element of the list.\n-- @string name the method name\n-- @param ... optional values to pass to function\nfunction List:foreachm (name,...)\n    for i = 1,#self do\n        local obj = self[i]\n        local f = lookup_fun(obj,name)\n        f(obj,...)\n    end\nend\n\n--- create a list of all elements which match a function.\n-- @func fun a boolean function\n-- @param[opt] arg optional argument to be passed as second argument of the predicate\n-- @return a new filtered list.\nfunction List:filter (fun,arg)\n    return makelist(filter(self,fun,arg),self)\nend\n\n--- split a string using a delimiter.\n-- @string s the string\n-- @string[opt] delim the delimiter (default spaces)\n-- @return a List of strings\n-- @see pl.utils.split\nfunction List.split (s,delim)\n    assert_arg(1,s,\'string\')\n    return makelist(split(s,delim))\nend\n\n--- apply a function to all elements.\n-- Any extra arguments will be passed to the function.\n-- @func fun a function of at least one argument\n-- @param ... arbitrary extra arguments.\n-- @return a new list: {f(x) for x in self}\n-- @usage List{\'one\',\'two\'}:map(string.upper) == {\'ONE\',\'TWO\'}\n-- @see pl.tablex.imap\nfunction List:map (fun,...)\n    return makelist(imap(fun,self,...),self)\nend\n\n--- apply a function to all elements, in-place.\n-- Any extra arguments are passed to the function.\n-- @func fun A function that takes at least one argument\n-- @param ... arbitrary extra arguments.\n-- @return the list.\nfunction List:transform (fun,...)\n    transform(fun,self,...)\n    return self\nend\n\n--- apply a function to elements of two lists.\n-- Any extra arguments will be passed to the function\n-- @func fun a function of at least two arguments\n-- @tparam List ls another list\n-- @param ... arbitrary extra arguments.\n-- @return a new list: {f(x,y) for x in self, for x in arg1}\n-- @see pl.tablex.imap2\nfunction List:map2 (fun,ls,...)\n    return makelist(imap2(fun,self,ls,...),self)\nend\n\n--- apply a named method to all elements.\n-- Any extra arguments will be passed to the method.\n-- @string name name of method\n-- @param ... extra arguments\n-- @return a new list of the results\n-- @see pl.seq.mapmethod\nfunction List:mapm (name,...)\n    local res = {}\n    for i = 1,#self do\n      local val = self[i]\n      local fn = lookup_fun(val,name)\n      res[i] = fn(val,...)\n    end\n    return makelist(res,self)\nend\n\nlocal function composite_call (method,f)\n    return function(self,...)\n        return self[method](self,f,...)\n    end\nend\n\nfunction List.default_map_with(T)\n    return function(self,name)\n        local m\n        if T then\n            local f = lookup_fun(T,name)\n            m = composite_call(\'map\',f)\n        else\n            m = composite_call(\'mapn\',name)\n        end\n        getmetatable(self)[name] = m -- and cache..\n        return m\n    end\nend\n\nList.default_map = List.default_map_with\n\n--- \'reduce\' a list using a binary function.\n-- @func fun a function of two arguments\n-- @return result of the function\n-- @see pl.tablex.reduce\nfunction List:reduce (fun)\n    return reduce(fun,self)\nend\n\n--- partition a list using a classifier function.\n-- The function may return nil, but this will be converted to the string key \'<nil>\'.\n-- @func fun a function of at least one argument\n-- @param ... will also be passed to the function\n-- @treturn MultiMap a table where the keys are the returned values, and the values are Lists\n-- of values where the function returned that key.\n-- @see pl.MultiMap\nfunction List:partition (fun,...)\n    fun = function_arg(1,fun)\n    local res = {}\n    for i = 1,#self do\n        local val = self[i]\n        local klass = fun(val,...)\n        if klass == nil then klass = \'<nil>\' end\n        if not res[klass] then res[klass] = List() end\n        res[klass]:append(val)\n    end\n    return setmetatable(res,Multimap)\nend\n\n--- return an iterator over all values.\nfunction List:iter ()\n    return iter(self)\nend\n\n--- Create an iterator over a seqence.\n-- This captures the Python concept of \'sequence\'.\n-- For tables, iterates over all values with integer indices.\n-- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function\n-- @usage for x in iterate {1,10,22,55} do io.write(x,\',\') end ==> 1,10,22,55\n-- @usage for ch in iterate \'help\' do do io.write(ch,\' \') end ==> h e l p\nfunction List.iterate(seq)\n    if type(seq) == \'string\' then\n        local idx = 0\n        local n = #seq\n        local sub = string.sub\n        return function ()\n            idx = idx + 1\n            if idx > n then return nil\n            else\n                return sub(seq,idx,idx)\n            end\n        end\n    elseif type(seq) == \'table\' then\n        local idx = 0\n        local n = #seq\n        return function()\n            idx = idx + 1\n            if idx > n then return nil\n            else\n                return seq[idx]\n            end\n        end\n    elseif type(seq) == \'function\' then\n        return seq\n    elseif type(seq) == \'userdata\' and io.type(seq) == \'file\' then\n        return seq:lines()\n    end\nend\niter = List.iterate\n\n\n\n\n\nlocal is_windows = path.is_windows\nlocal ldir = path.dir\nlocal mkdir = path.mkdir\nlocal rmdir = path.rmdir\nlocal sub = string.sub\nlocal os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable\nlocal remove = os.remove\nlocal append = table.insert\nlocal wrap = coroutine.wrap\nlocal yield = coroutine.yield\nlocal assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise\n\nlocal dir = {}\n\nlocal function makelist(l)\n    return setmetatable(l, List)\nend\n\nlocal function assert_dir (n,val)\n    assert_arg(n,val,\'string\',path.isdir,\'not a directory\',4)\nend\n\nlocal function filemask(mask)\n    mask = utils.escape(path.normcase(mask))\n    return \'^\'..mask:gsub(\'%%%*\',\'.*\'):gsub(\'%%%?\',\'.\')..\'$\'\nend\n\n--- Test whether a file name matches a shell pattern.\n-- Both parameters are case-normalized if operating system is\n-- case-insensitive.\n-- @string filename A file name.\n-- @string pattern A shell pattern. The only special characters are\n-- `\'*\'` and `\'?\'`: `\'*\'` matches any sequence of characters and\n-- `\'?\'` matches any single character.\n-- @treturn bool\n-- @raise dir and mask must be strings\nfunction dir.fnmatch(filename,pattern)\n    assert_string(1,filename)\n    assert_string(2,pattern)\n    return path.normcase(filename):find(filemask(pattern)) ~= nil\nend\n\n--- Return a list of all file names within an array which match a pattern.\n-- @tab filenames An array containing file names.\n-- @string pattern A shell pattern.\n-- @treturn List(string) List of matching file names.\n-- @raise dir and mask must be strings\nfunction dir.filter(filenames,pattern)\n    assert_arg(1,filenames,\'table\')\n    assert_string(2,pattern)\n    local res = {}\n    local mask = filemask(pattern)\n    for i,f in ipairs(filenames) do\n        if path.normcase(f):find(mask) then append(res,f) end\n    end\n    return makelist(res)\nend\n\nlocal function _listfiles(dir,filemode,match)\n    local res = {}\n    local check = utils.choose(filemode,path.isfile,path.isdir)\n    if not dir then dir = \'.\' end\n    for f in ldir(dir) do\n        if f ~= \'.\' and f ~= \'..\' then\n            local p = path.join(dir,f)\n            if check(p) and (not match or match(f)) then\n                append(res,p)\n            end\n        end\n    end\n    return makelist(res)\nend\n\n--- return a list of all files in a directory which match the a shell pattern.\n-- @string dir A directory. If not given, all files in current directory are returned.\n-- @string mask  A shell pattern. If not given, all files are returned.\n-- @treturn {string} list of files\n-- @raise dir and mask must be strings\nfunction dir.getfiles(dir,mask)\n    assert_dir(1,dir)\n    if mask then assert_string(2,mask) end\n    local match\n    if mask then\n        mask = filemask(mask)\n        match = function(f)\n            return path.normcase(f):find(mask)\n        end\n    end\n    return _listfiles(dir,true,match)\nend\n\n--- return a list of all subdirectories of the directory.\n-- @string dir A directory\n-- @treturn {string} a list of directories\n-- @raise dir must be a a valid directory\nfunction dir.getdirectories(dir)\n    assert_dir(1,dir)\n    return _listfiles(dir,false)\nend\n\nlocal alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile\n\nlocal function execute_command(cmd,parms)\n   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end\n   local err = path.is_windows and \' > \' or \' 2> \'\n    cmd = cmd..\' \'..parms..err..utils.quote_arg(cmd_tmpfile)\n    local ret = utils.execute(cmd)\n    if not ret then\n        local err = (utils.readfile(cmd_tmpfile):gsub(\'\\n(.*)\',\'\'))\n        remove(cmd_tmpfile)\n        return false,err\n    else\n        remove(cmd_tmpfile)\n        return true\n    end\nend\n\nlocal function find_ffi_copyfile ()\n    if not ffi_checked then\n        ffi_checked = true\n        local res\n        res,alien = pcall(require,\'alien\')\n        if not res then\n            alien = nil\n            res, ffi = pcall(require,\'ffi\')\n        end\n        if not res then\n            ffi = nil\n            return\n        end\n    else\n        return\n    end\n    if alien then\n        -- register the Win32 CopyFile and MoveFile functions\n        local kernel = alien.load(\'kernel32.dll\')\n        CopyFile = kernel.CopyFileA\n        CopyFile:types{\'string\',\'string\',\'int\',ret=\'int\',abi=\'stdcall\'}\n        MoveFile = kernel.MoveFileA\n        MoveFile:types{\'string\',\'string\',ret=\'int\',abi=\'stdcall\'}\n        GetLastError = kernel.GetLastError\n        GetLastError:types{ret =\'int\', abi=\'stdcall\'}\n    elseif ffi then\n        ffi.cdef [[\n            int CopyFileA(const char *src, const char *dest, int iovr);\n            int MoveFileA(const char *src, const char *dest);\n            int GetLastError();\n        ]]\n        CopyFile = ffi.C.CopyFileA\n        MoveFile = ffi.C.MoveFileA\n        GetLastError = ffi.C.GetLastError\n    end\n    win32_errors = {\n        ERROR_FILE_NOT_FOUND    =         2,\n        ERROR_PATH_NOT_FOUND    =         3,\n        ERROR_ACCESS_DENIED    =          5,\n        ERROR_WRITE_PROTECT    =          19,\n        ERROR_BAD_UNIT         =          20,\n        ERROR_NOT_READY        =          21,\n        ERROR_WRITE_FAULT      =          29,\n        ERROR_READ_FAULT       =          30,\n        ERROR_SHARING_VIOLATION =         32,\n        ERROR_LOCK_VIOLATION    =         33,\n        ERROR_HANDLE_DISK_FULL  =         39,\n        ERROR_BAD_NETPATH       =         53,\n        ERROR_NETWORK_BUSY      =         54,\n        ERROR_DEV_NOT_EXIST     =         55,\n        ERROR_FILE_EXISTS       =         80,\n        ERROR_OPEN_FAILED       =         110,\n        ERROR_INVALID_NAME      =         123,\n        ERROR_BAD_PATHNAME      =         161,\n        ERROR_ALREADY_EXISTS    =         183,\n    }\nend\n\nlocal function two_arguments (f1,f2)\n    return utils.quote_arg(f1)..\' \'..utils.quote_arg(f2)\nend\n\nlocal function file_op (is_copy,src,dest,flag)\n    if flag == 1 and path.exists(dest) then\n        return false,\"cannot overwrite destination\"\n    end\n    if is_windows then\n        -- if we haven\'t tried to load Alien/LuaJIT FFI before, then do so\n        find_ffi_copyfile()\n        -- fallback if there\'s no Alien, just use DOS commands *shudder*\n        -- \'rename\' involves a copy and then deleting the source.\n        if not CopyFile then\n            src = path.normcase(src)\n            dest = path.normcase(dest)\n            local cmd = is_copy and \'copy\' or \'rename\'\n            local res, err = execute_command(\'copy\',two_arguments(src,dest))\n            if not res then return false,err end\n            if not is_copy then\n                return execute_command(\'del\',utils.quote_arg(src))\n            end\n            return true\n        else\n            if path.isdir(dest) then\n                dest = path.join(dest,path.basename(src))\n            end\n            local ret\n            if is_copy then ret = CopyFile(src,dest,flag)\n            else ret = MoveFile(src,dest) end\n            if ret == 0 then\n                local err = GetLastError()\n                for name,value in pairs(win32_errors) do\n                    if value == err then return false,name end\n                end\n                return false,\"Error #\"..err\n            else return true\n            end\n        end\n    else -- for Unix, just use cp for now\n        return execute_command(is_copy and \'cp\' or \'mv\',\n            two_arguments(src,dest))\n    end\nend\n\n--- copy a file.\n-- @string src source file\n-- @string dest destination file or directory\n-- @bool flag true if you want to force the copy (default)\n-- @treturn bool operation succeeded\n-- @raise src and dest must be strings\nfunction dir.copyfile (src,dest,flag)\n    assert_string(1,src)\n    assert_string(2,dest)\n    flag = flag==nil or flag\n    return file_op(true,src,dest,flag and 0 or 1)\nend\n\n--- move a file.\n-- @string src source file\n-- @string dest destination file or directory\n-- @treturn bool operation succeeded\n-- @raise src and dest must be strings\nfunction dir.movefile (src,dest)\n    assert_string(1,src)\n    assert_string(2,dest)\n    return file_op(false,src,dest,0)\nend\n\nlocal function _dirfiles(dir,attrib)\n    local dirs = {}\n    local files = {}\n    for f in ldir(dir) do\n        if f ~= \'.\' and f ~= \'..\' then\n            local p = path.join(dir,f)\n            local mode = attrib(p,\'mode\')\n            if mode==\'directory\' then\n                append(dirs,f)\n            else\n                append(files,f)\n            end\n        end\n    end\n    return makelist(dirs), makelist(files)\nend\n\n\nlocal function _walker(root,bottom_up,attrib)\n    local dirs,files = _dirfiles(root,attrib)\n    if not bottom_up then yield(root,dirs,files) end\n    for i,d in ipairs(dirs) do\n        _walker(root..path.sep..d,bottom_up,attrib)\n    end\n    if bottom_up then yield(root,dirs,files) end\nend\n\n--- return an iterator which walks through a directory tree starting at root.\n-- The iterator returns (root,dirs,files)\n-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)\n-- to get the actual full path)\n-- If bottom_up is false (or not present), then the entries at the current level are returned\n-- before we go deeper. This means that you can modify the returned list of directories before\n-- continuing.\n-- This is a clone of os.walk from the Python libraries.\n-- @string root A starting directory\n-- @bool bottom_up False if we start listing entries immediately.\n-- @bool follow_links follow symbolic links\n-- @return an iterator returning root,dirs,files\n-- @raise root must be a directory\nfunction dir.walk(root,bottom_up,follow_links)\n    assert_dir(1,root)\n    local attrib\n    if path.is_windows or not follow_links then\n        attrib = path.attrib\n    else\n        attrib = path.link_attrib\n    end\n    return wrap(function () _walker(root,bottom_up,attrib) end)\nend\n\n--- remove a whole directory tree.\n-- @string fullpath A directory path\n-- @return true or nil\n-- @return error if failed\n-- @raise fullpath must be a string\nfunction dir.rmtree(fullpath)\n    assert_dir(1,fullpath)\n    if path.islink(fullpath) then return false,\'will not follow symlink\' end\n    for root,dirs,files in dir.walk(fullpath,true) do\n        for i,f in ipairs(files) do\n            local res, err = remove(path.join(root,f))\n            if not res then return nil,err end\n        end\n        local res, err = rmdir(root)\n        if not res then return nil,err end\n    end\n    return true\nend\n\nlocal dirpat\nif path.is_windows then\n    dirpat = \'(.+)\\\\[^\\\\]+$\'\nelse\n    dirpat = \'(.+)/[^/]+$\'\nend\n\nlocal _makepath\nfunction _makepath(p)\n    -- windows root drive case\n    if p:find \'^%a:[\\\\]*$\' then\n        return true\n    end\n   if not path.isdir(p) then\n    local subp = p:match(dirpat)\n    local ok, err = _makepath(subp)\n    if not ok then return nil, err end\n    return mkdir(p)\n   else\n    return true\n   end\nend\n\n--- create a directory path.\n-- This will create subdirectories as necessary!\n-- @string p A directory path\n-- @return true on success, nil + errormsg on failure\n-- @raise failure to create\nfunction dir.makepath (p)\n    assert_string(1,p)\n    return _makepath(path.normcase(path.abspath(p)))\nend\n\n\n--- clone a directory tree. Will always try to create a new directory structure\n-- if necessary.\n-- @string path1 the base path of the source tree\n-- @string path2 the new base path for the destination\n-- @func file_fun an optional function to apply on all files\n-- @bool verbose an optional boolean to control the verbosity of the output.\n--  It can also be a logging function that behaves like print()\n-- @return true, or nil\n-- @return error message, or list of failed directory creations\n-- @return list of failed file operations\n-- @raise path1 and path2 must be strings\n-- @usage clonetree(\'.\',\'../backup\',copyfile)\nfunction dir.clonetree (path1,path2,file_fun,verbose)\n    assert_string(1,path1)\n    assert_string(2,path2)\n    if verbose == true then verbose = print end\n    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join\n    local faildirs,failfiles = {},{}\n    if not isdir(path1) then return raise \'source is not a valid directory\' end\n    path1 = abspath(normcase(path1))\n    path2 = abspath(normcase(path2))\n    if verbose then verbose(\'normalized:\',path1,path2) end\n    -- particularly NB that the new path isn\'t fully contained in the old path\n    if path1 == path2 then return raise \"paths are the same\" end\n    local i1,i2 = path2:find(path1,1,true)\n    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then\n        return raise \'destination is a subdirectory of the source\'\n    end\n    local cp = path.common_prefix (path1,path2)\n    local idx = #cp\n    if idx == 0 then -- no common path, but watch out for Windows paths!\n        if path1:sub(2,2) == \':\' then idx = 3 end\n    end\n    for root,dirs,files in dir.walk(path1) do\n        local opath = path2..root:sub(idx)\n        if verbose then verbose(\'paths:\',opath,root) end\n        if not isdir(opath) then\n            local ret = dir.makepath(opath)\n            if not ret then append(faildirs,opath) end\n            if verbose then verbose(\'creating:\',opath,ret) end\n        end\n        if file_fun then\n            for i,f in ipairs(files) do\n                local p1 = join(root,f)\n                local p2 = join(opath,f)\n                local ret = file_fun(p1,p2)\n                if not ret then append(failfiles,p2) end\n                if verbose then\n                    verbose(\'files:\',p1,p2,ret)\n                end\n            end\n        end\n    end\n    return true,faildirs,failfiles\nend\n\n--- return an iterator over all entries in a directory tree\n-- @string d a directory\n-- @return an iterator giving pathname and mode (true for dir, false otherwise)\n-- @raise d must be a non-empty string\nfunction dir.dirtree( d )\n    assert( d and d ~= \"\", \"directory parameter is missing or empty\" )\n    local exists, isdir = path.exists, path.isdir\n    local sep = path.sep\n\n    local last = sub ( d, -1 )\n    if last == sep or last == \'/\' then\n        d = sub( d, 1, -2 )\n    end\n\n    local function yieldtree( dir )\n        for entry in ldir( dir ) do\n            if entry ~= \".\" and entry ~= \"..\" then\n                entry = dir .. sep .. entry\n                if exists(entry) then  -- Just in case a symlink is broken.\n                    local is_dir = isdir(entry)\n                    yield( entry, is_dir )\n                    if is_dir then\n                        yieldtree( entry )\n                    end\n                end\n            end\n        end\n    end\n\n    return wrap( function() yieldtree( d ) end )\nend\n\n\n--- Recursively returns all the file starting at _path_. It can optionally take a shell pattern and\n-- only returns files that match _shell_pattern_. If a pattern is given it will do a case insensitive search.\n-- @string start_path  A directory. If not given, all files in current directory are returned.\n-- @string shell_pattern A shell pattern. If not given, all files are returned.\n-- @treturn List(string) containing all the files found recursively starting at _path_ and filtered by _shell_pattern_.\n-- @raise start_path must be a directory\nfunction dir.getallfiles( start_path, shell_pattern )\n    assert_dir(1,start_path)\n    shell_pattern = shell_pattern or \"*\"\n\n    local files = {}\n    local normcase = path.normcase\n    for filename, mode in dir.dirtree( start_path ) do\n        if not mode then\n            local mask = filemask( shell_pattern )\n            if normcase(filename):find( mask ) then\n                files[#files + 1] = filename\n            end\n        end\n    end\n\n    return makelist(files)\nend\n\n\n\n\n\n\npl.file  = file\npl.path  = path\npl.utils = utils\npl.dir   = dir\n\nreturn pl\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/richtext",
hash = "72bde8ed23a89433b71a636b17559b4770b59043bf84ddae3fc354bf821731cd",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier/node\"\n\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal L = require \"lpeg\"\n\n\n\n\n\n\n\n\n\n\n\nlocal Lit, lit = u.inherit(Node)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Lit.toMarkdown(literal)\n   return \"``\" .. literal:toValue() .. \"``\"\nend\n\n\n\n\n\nlocal Ita = u.inherit(Node)\n\nfunction Ita.toMarkdown(italic)\n   return \"_\" .. italic:toValue():gsub(\"_\", \"\\\\_\") .. \"_\"\nend\n\n\n\n\n\nlocal Bold = u.inherit(Node)\n\nfunction Bold.toMarkdown(bold)\n   return \"**\" .. bold:toValue():gsub(\"*\", \"\\\\*\") .. \"**\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Interpol = u.inherit(Node)\n\nfunction Interpol.toMarkdown(interpol)\n   return interpol:toValue()\nend\n\n\n\n\n\n\n\nreturn { literal = Lit,\n       italic  = Ita,\n       bold    = Bold,\n       interpolated = Interpol }\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/hashline",
hash = "f1e3cecf355d63a4503c73ee8b5cf4ebc3e3724a894c030e1a16faac6430f714",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal Node = require \"espalier/node\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal Hashtag = require \"orb:Orbit/hashtag\"\n\nlocal H, h = u.inherit(Node)\n\nfunction H.toMarkdown(hashline)\n   return hashline.__VALUE\nend\n\nlocal function new(Hashline, line)\n    local hashline = setmetatable({}, H)\n    hashline.id = \"hashline\"\n    hashline.__VALUE = line\n    hashline[1] = Hashtag(line)\n\n    return hashline\nend\n\n\nreturn u.export(h, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "walk/ops",
hash = "0d318e836910d6891c6781f0009fb4b6ad3baffdf384bd2953c147b2ca3a4725",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\nlocal a = require \"singletons/anterm\"\nlocal s = require \"status:status\" ()\nlocal pl_mini = require \"orb:util/plmini\"\nlocal write = pl_mini.file.write\nlocal delete = pl_mini.file.delete\n\n\n\nlocal function writeOnChange(newest, current, out_file, depth)\n    -- If the text has changed, write it\n    depth = depth or 1\n    if newest ~= current then\n        s:chat(a.green((\"  \"):rep(depth) .. \"  - \" .. out_file))\n        write(out_file, newest)\n        return true\n    -- If the new text is blank, delete the old file\n    elseif current ~= \"\" and newest == \"\" then\n        s:chat(a.red((\"  \"):rep(depth) .. \"  - \" .. out_file))\n        delete(out_file)\n        return false\n    else\n    -- Otherwise do nothing\n\n        return nil\n    end\nend\n\nreturn writeOnChange\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/section",
hash = "34942130a9d901b31761e7721cbc2a9ccabfe0f220fc1148594016cee12b3b30",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal s = require \"status:status\" ()\ns.verbose = true\nlocal status = require \"status:status\" ()\n\nlocal Node = require \"espalier/node\"\n\nlocal Header = require \"orb:Orbit/header\"\nlocal Block = require \"orb:Orbit/block\"\nlocal Codeblock = require \"orb:Orbit/codeblock\"\nlocal m = require \"orb:Orbit/morphemes\"\n\n\n\n\n\n\nlocal Sec = Node:inherit \"section\"\n\n\n\n\n\n\n\nfunction Sec.__tostring(section)\n    return tostring(section[1])\nend\n\n\n\n\n\n\n\n\n\n\nfunction Sec.dotLabel(section)\n    return \"section: \" .. tostring(section.line_first)\n        .. \"-\" .. tostring(section.line_last)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sec.toMarkdown(section)\n    local phrase = \"\"\n    for _, node in ipairs(section) do\n        if node.toMarkdown then\n            phrase = phrase .. node:toMarkdown()\n        else\n            s:error(\"no toMarkdown method in \" .. node.id)\n        end\n    end\n\n    return phrase\nend\n\n\n\n\n\nfunction Sec.check(section)\n    for i, v in ipairs(section) do\n        if (i == 1) then\n            if section.header then\n                assert(v.id == \"header\")\n            end\n        else\n            assert(v.id == \"section\" or v.id == \"block\")\n        end\n    end\n    assert(section.level)\n    assert(section.id == \"section\")\n    assert(section.first, \"no first in \" .. tostring(section))\n    assert(section.last, \"no last in \" .. tostring(section))\n    assert(section.str, \"no str in \" .. tostring(section))\n    assert(section.lines)\n    assert(section.line_first)\n    assert(section.line_last)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sec.addLine(section, line)\n    section.lines[#section.lines + 1] = line\n    return section\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sec.addSection(section, newsection, linum, finish)\n    -- Conclude the current section\n    if linum > 0 then\n        section.line_last = linum - 1\n        assert(type(finish) == \"number\")\n        section.last = finish\n    end\n    if section.level + 1 == newsection.level then\n        section[#section + 1] = newsection\n    else\n        section[#section + 1] = newsection\n    end\n    return section\nend\n\n\n\n\n\n\n\n\nlocal function isTagline(line)\n    return L.match(m.tagline_p, line)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function fwdBlanks(lines, linum)\n    local fwd = 0\n    local index = linum + 1\n    if index > #lines then\n        return 0\n    else\n        for i = index, #lines do\n            if lines[i] == \"\" then\n                fwd = fwd + 1\n            else\n                break\n            end\n        end\n    end\n    return fwd\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sec.block(section)\n    local str = section.str\n    -- There is always a header at [1], though it may be nil\n    -- If there are other Nodes, they are sections and must be appended\n    -- after the blocks.\n    local sub_sections = {}\n    for i = 2, #section do\n        sub_sections[#sub_sections + 1] = section[i]\n        section[i] = nil\n    end\n\n    -- Every section gets at least one block, at [2], which may be empty.\n    local latest = Block(nil, section.line_first, str) -- current block\n    section[2] = latest\n\n    -- State machine for blocking a section\n    local back_blanks = 0\n    -- first set of blank lines in a section belong to the first block\n    local lead_blanks = true\n    -- Track code blocks in own logic\n    local code_block = false\n    -- Tags also\n    local tagging = false\n    for i = 1, #section.lines do\n        local inset = i + section.line_first\n        local l = section.lines[i]\n        if not code_block then\n            if l == \"\" then\n                -- increment back blanks for clinging subsequent lines\n                back_blanks = back_blanks + 1\n                -- blank lines attach to the preceding block\n                latest:addLine(l)\n            else\n                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)\n                if isCodeHeader then\n                    code_block = true\n                    if not tagging then\n                        -- create a new block for the codeblock\n                        latest.line_last = inset - 1\n                        latest = Block(nil, inset, str)\n                        latest[1] = Codeblock(level, l_trim, inset, str)\n                        section[#section + 1] = latest\n                    else\n                        -- preserve existing block and add codeblock\n                        tagging = false\n                        latest[1] = Codeblock(level, l_trim, inset, str)\n                    end\n                elseif isTagline(l) then\n                    tagging = true\n                    -- apply cling rule\n                    local fwd_blanks = fwdBlanks(section.lines, i)\n                    if fwd_blanks > back_blanks then\n                        latest:addLine(l)\n                    else\n                        -- new block\n                        latest.line_last = inset - 1\n                        latest = Block(l, inset, str)\n                        section[#section + 1] = latest\n                        back_blanks = 0\n                    end\n                else\n                    if back_blanks > 0 and lead_blanks == false then\n                        if not tagging then\n                        -- new block\n                            latest.line_last = inset - 1\n                            latest = Block(l, inset, str)\n                            section[#section + 1] = latest\n                            back_blanks = 0\n                        else\n                            latest:addLine(l)\n                            tagging = false\n                        end\n                    else\n                        -- continuing a block\n                        lead_blanks = false\n                        back_blanks = 0\n                        latest:addLine(l)\n                    end\n                end\n            end\n        else\n            -- Collecting a code block\n            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)\n            if (isCodeFoot and level == latest[1].level) then\n                code_block = false\n                latest[1].footer = l_trim\n                latest[1].line_last = inset\n            else\n                latest[1].lines[#latest[1].lines + 1] = l\n            end\n            -- Continue in normal parse mode\n            -- This may add more lines to the code block\n        end\n    end\n    -- Auto-close a code block with no footer.\n    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then\n        latest[1].line_last = #section.lines\n    end\n\n    -- Close last block\n    latest.line_last = section.line_last\n\n    -- Append sections, if any, which follow our blocks\n    for _, v in ipairs(sub_sections) do\n        section[#section + 1] = v\n    end\n    return section\nend\n\n\n\n\n\n\n\n\nfunction Sec.weed(section)\n    for i, v in ipairs(section) do\n        if v.id == \"block\" then\n            if v[1] then\n                section[i] = v[1]\n            end\n        end\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(header, linum, first, last, str)\n    assert(type(first) == \"number\")\n    assert(type(last) == \"number\", \"type of last is \" .. type(last))\n    local section = setmetatable({}, Sec)\n    if type(header) == \"number\" then\n        -- We have a virtual header\n        section[1] = Header(\"\", header, first, last, str)\n        section.header = nil\n        section.level = header\n    else\n        section[1] = header\n        section.header = header\n        section.level = header.level\n    end\n    section.str = str\n    section.first = first\n    section.last = last\n    section.line_first = linum\n    section.line_last = -1\n    section.lines = {}\n    Sec.check(section)\n    return section\nend\n\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/handleline",
hash = "622f68eca48de7130251ec4fda5bc5854b3ef8d51f19d43d51e17156324460e3",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal Node = require \"espalier/node\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal Handle = require \"orb:Orbit/handle\"\n\nlocal H, h = u.inherit(Node)\n\nfunction H.toMarkdown(handleline)\n   return handleline.__VALUE\nend\n\nlocal function new(Handleline, line)\n    local handleline = setmetatable({}, H)\n    handleline.__VALUE = line\n    handleline.id = \"handleline\"\n    handleline[1] = Handle(line)\n\n    return handleline\nend\n\n\nreturn u.export(h, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/doc",
hash = "d42231a4fee55b89ef8e5480b768bb2c29b72860b09e8b33eb6b2f3bf92f2b53",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\n\nlocal Node = require \"espalier/node\"\nlocal Section = require \"orb:Orbit/section\"\nlocal own = require \"orb:Orbit/own\"\n\n\n\n\n\nlocal D = Node : inherit \"doc\"\n\nD.__tostring = function (doc)\n    local phrase = \"\"\n    for _,v in ipairs(doc) do\n        local repr = tostring(v)\n        if repr ~= \"\" and repr ~= \"\\n\" then\n            phrase = phrase .. repr .. \"\\n\"\n        end\n    end\n\n    return phrase\nend\n\nstring.lines = string.lines or function() end\n\nfunction D.__repr(doc)\n    return string.lines(doc:toString())\nend\n\nD.__index = D\n\nD.own = own\n\nfunction D.dotLabel(doc)\n    return \"doc - \" .. tostring(doc.linum)\nend\n\nfunction D.toMarkdown(doc)\n    local phrase = \"\"\n    for _, node in ipairs(doc) do\n        if node.toMarkdown then\n            phrase = phrase .. node:toMarkdown()\n        else\n            s:error(\"no toMarkdown method for \" .. node.id)\n        end\n    end\n    return phrase\nend\n\n\n\n\n\n\n\nlocal d = {}\n\n\nfunction D.parentOf(doc, level)\n    local i = #doc.levels\n    local parent = doc\n    while i > 0 do\n        local prev_sec = doc.levels[i]\n        if prev_sec.level < level then\n            -- found the parent\n            parent = prev_sec\n            i = 0\n        else\n            -- keep looking\n            i = i - 1\n        end\n    end\n    return parent\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction D.addSection(doc, section, linum, finish)\n    assert(section.id == \"section\", \"type of putative section is \" .. section.id)\n    assert(section.first, \"no first in section at line \" .. tostring(linum))\n    assert(type(finish) == \"number\", \"finish is of type \" .. type(finish))\n    if not doc.latest then\n        doc[1] =  section\n    else\n        if linum > 0 then\n            doc.latest.line_last = linum - 1\n            doc.latest.last = finish\n        end\n        local atLevel = doc.latest.level\n        if atLevel < section.level then\n            -- add the section under the latest section\n            doc.latest:addSection(section, linum, finish)\n        else\n            local parent = doc:parentOf(section.level)\n            if parent.id == \"doc\" then\n                if section.level == 1 and doc.latest.level == 1 then\n                    doc[#doc + 1] = section\n                else\n                    doc.latest:addSection(section, linum, finish)\n                end\n            else\n                parent:addSection(section, linum, finish)\n            end\n        end\n    end\n    doc.latest = section\n    doc.levels[#doc.levels + 1] = section\n    return doc\nend\n\n\nfunction D.addLine(doc, line, linum, finish)\n    if doc.latest then\n        doc.latest:addLine(line)\n        doc.latest.last = finish\n    else\n        -- a virtual zero block\n        doc[1] = Section(0, linum, 1, #line, doc.str)\n        doc.latest = doc[1]\n        doc.latest:addLine(line)\n        doc.latest.last = finish\n    end\n\n    return doc\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(str)\n    local doc = setmetatable({}, D)\n    doc.str = str\n    doc.first = 1\n    doc.last = #str\n    doc.latest = nil\n    doc.lines = {}\n    doc.levels = {}\n    -- for now lets set root to \'false\'\n    doc.root = false\n    return doc:own(str)\nend\n\nD.idEst = new\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/newdatabase",
hash = "dfce5b3ad1432e1b6b80e1627d74b592c2d6cafc407230b0aeb0aabaf178faa0",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal s = require \"status:status\"\ns.verbose = false\n\nlocal unwrapKey, toRow = assert(sql.unwrapKey), assert(sql.toRow)\n\n\n\n\n\n\nlocal database = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project = [[\nSELECT * FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal latest_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = ?\nORDER BY major DESC, minor DESC, patch DESC\nLIMIT 1\n;\n]]\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = :project\nAND version.major = :major\nAND version.minor = :minor\nAND version.patch = :patch\nAND version.edition = :edition\nAND version.stage = :stage\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, stage, project, major, minor, patch)\nVALUES (:edition, :stage, :project, :major, :minor, :patch)\n;\n]]\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal function _updateProjectInfo(conn, db_project, codex_project)\n   -- determine if we need to do an update\n   local update = false\n   for k, v in pairs(codex_project) do\n      if db_project[k] ~= v then\n         update = true\n      end\n   end\n   if update then\n      local stmt = conn:prepare(update_project)\n      stmt:bindkv(codex_project):step()\n   end\nend\n\n\n\nfunction database.project(conn, codex_info)\n   local db_info = conn:prepare(get_project):bind(codex_info.name):resultset()\n   db_info = toRow(db_info) or {}\n   local project_id = db_info.project_id\n   if project_id then\n      s:verb(\"project_id is \" .. project_id)\n      -- update information if there are any changes\n      _updateProjectInfo(conn, db_info, codex_info)\n   else\n      conn:prepare(new_project):bindkv(codex_info):step()\n      project_id = conn:prepare(get_project):bind(codex_info.name):step()\n      if not project_id then\n         error (\"failed to create project \" .. codex.project)\n      else\n         project_id = project_id[1]\n      end\n   end\n   return project_id\nend\n\n\n\n\n\n\nfunction database.version(conn, version_info, project_id)\n   local version_id\n   if not version_info.is_versioned then\n      version_id = conn:prepare(latest_version):bind(project_id):step()\n      if not version_id then\n         conn : prepare(new_version_snapshot) : bindkv\n              { edition = \"\",\n                project = project_id }\n              : step()\n         version_id = conn:prepare(latest_version):bind(project_id):step()\n         if not version_id then\n            error \"didn\'t make a SNAPSHOT\"\n         else\n            version_id = version_id[1]\n         end\n      else\n         version_id = version_id[1]\n      end\n   else\n      version_info.project = project_id\n      conn:prepare(new_version):bindkv(version_info):step()\n      version_id = conn:prepare(get_version):bindkv(version_info):step()\n      if not version_id then\n         error \"failed to create version\"\n      end\n      version_id = version_id[1]\n   end\n   s:verb(\"version_id is \" .. version_id)\n   return version_id\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\n\nfunction database.commitSkein(skein, stmts, ids, git_info, now)\n   local bytecode = skein.compiled and skein.compiled.lua\n   if not bytecode or bytecode.err then\n      local err = bytecode and bytecode.err\n      if err then\n        s:complain(\"attempt to commit erroneous bytecode data: %s, %s\",\n               tostring(skein.source.file), err)\n        return nil, err\n      end\n      -- missing bytecode means the Doc didn\'t create a knitted.lua, which\n      -- is normal\n      return nil\n   end\n   local project_id, version_id, bundle_id = ids.project_id,\n                                             ids.version_id,\n                                             ids.bundle_id\n   -- get code_id from the hash\n   local code_id = unwrapKey(stmts.code_id:bindkv(bytecode):resultset(\'i\'))\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmts.new_code:bindkv(bytecode):step()\n      stmts.code_id:reset()\n      code_id = unwrapKey(stmts.code_id:bindkv(bytecode):resultset(\'i\'))\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmts.add_module:bindkv(mod):step()\n   for _, st in pairs(stmts) do\n      st:clearbind():reset()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction database.commitBundle(lume)\n   local conn = lume.conn or s:halt(\"no database conn on the Lume\")\n   local now = lume:now()\n   -- select project_id\n   local project_id = database.project(conn, lume:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, lume:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmts = { code_id = conn:prepare(get_code_id_by_hash),\n                   new_code = conn:prepare(new_code),\n                   add_module = conn:prepare(add_module) }\n   -- wrap ids\n   local ids = { project_id = project_id,\n                 version_id = version_id,\n                 bundle_id  = bundle_id }\n   return stmts, ids, now\nend\n\n\n\n\nreturn database\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "knit/knitter",
hash = "dbb7440b3b603258ff8556a842eac34d2b1e86e5bbf4ad9acc9dbbcc9b4f4b9e",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal u = {}\n\n-- A helper function which takes an optional metatable,\n-- returning a meta-ed table and a table meta-ed from\n-- that.\n-- The former can be filled with methods and the latter\n-- made into a constructor with __call, as well as a\n-- convenient place to put library functions which aren\'t\n-- methods/self calls.\n--\n-- - meta: a base metatable\n--\n-- - returns:\n--   - The class metatable\n--   - Constructor and library table\n--\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n-- Function to export modules\n--\n-- The first argument of util.inherit being filled with methods,\n-- the second argument is passed to util.export as =mod=, along\n-- with a function =constructor= which will serve to create a\n-- new instance.\n--\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal Phrase = require \"singletons/phrase\"\n\nlocal K, k = u.inherit()\nK.it = require \"singletons/check\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction K.knit(knitter, doc)\n    local phrase = Phrase()\n    local linum = 0\n    for cb in doc:select(\"codeblock\") do\n        cb:check()\n        if cb.lang == \"lua\" then\n           -- Pad code with blank lines to line up errors\n           local pad_count = cb.line_first - linum\n\n           local pad = (\"\\n\"):rep(pad_count)\n           -- cat codeblock value\n           phrase = phrase .. pad .. cb.val\n\n           -- update linum\n           linum = cb.line_last - 1\n        else\n          -- other languages\n        end\n    end\n\n    return phrase, \".lua\"\nend\n\nlocal function new(Knitter, lang)\n    local knitter = setmetatable({}, K)\n    knitter.lang = lang or \"lua\"\n    return knitter\nend\n\nreturn u.export(k, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "knit/lua",
hash = "ca4c8cf3319d67aa09f25a9ed19eb5cb0e87c24427bbc746daf02ae94ad06349",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\nlocal lua_knit = {}\n\n\n\n\n\n\n\n\n\nlua_knit.code_type = \"lua\"\n\n\n\n\n\n\n\n\n\nfunction lua_knit.pred(codeblock)\n   local should_knit = false\n   for tag in codeblock:select \"hashtag\" do\n      if tag:span() == \"#asLua\" then\n         should_knit = true\n      end\n   end\n\n   return should_knit\nend\n\n\n\n\n\n\n\n\n\n\nfunction lua_knit.knit(codeblock, scroll, skein)\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 1 do\n      scroll:add \"\"\n   end\n   scroll:add(codebody)\n   -- add an extra line and skip 2, to get a newline at EOF\n   scroll:add \"\"\n   scroll.line_count = line_end + 2\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, gsub = assert(string.format),\n                           assert(string.find),\n                           assert(string.gsub)\n\nfunction lua_knit.pred_knit(codeblock, scroll, skein)\n   local name = codeblock:select \"name\"()\n   local header = \"\"\n   if name then\n      -- stringify and drop \"#\"\n      name = name:select \"handle\"() :span() :sub(2)\n      -- normalize - to _\n      name = gsub(name, \"%-\", \"_\")\n      -- two forms: =local name= or (=name.field=, name[field])\n      if not find(name, \"%.\") or find(name, \"%[\") then\n         header = \"local \"\n      end\n   else\n      local linum = codeblock :select \"code_start\"() :linePos()\n      error (format(\"an #asLua block must have a name, line: %d\", linum))\n   end\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 2 do\n      scroll:add \"\"\n   end\n\n   header = header .. name .. \" = [[\"\n   scroll:add(header)\n   scroll:add(codebody)\n   scroll:add(\"]]\")\n   scroll.line_count = line_end + 2\n   -- #todo search for ==\"]\" \"=\"* \"]\"== in code_body span and add more = if\n   -- needful\nend\n\n\n\nreturn lua_knit\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/compiler",
hash = "02dc6c2263eaaf7d4b3a653cbd890387783d4bbe52267d2acdc793bdb40fc837",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compiler, compilers = {}, {}\ncompiler.compilers = compilers\n\n\n\n\n\n\nlocal sha512 = require \"orb:compile/sha2\" . sha3_512\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\nlocal function sha(str)\n   return sub(sha512(str),1,64)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _moduleName(path, project)\n   local mod = {}\n   local inMod = false\n   for i, v in ipairs(path) do\n      if v == project then\n         inMod = true\n      end\n      if inMod then\n         if i ~= #path then\n            table.insert(mod, v)\n          else\n             table.insert(mod, path:barename())\n         end\n      end\n   end\n   -- drop the bits of the path we won\'t need\n   --- awful kludge fix\n   local weird_path = table.concat(mod)\n   local good_path = string.gsub(weird_path, \"%.%_\", \"\")\n   local _, cutpoint = string.find(good_path, \"/src/\")\n   local good_path = string.sub(good_path, cutpoint + 1)\n   return good_path\nend\n\n\n\n\n\n\n\n\nfunction compilers.lua(skein)\n   local project = skein.lume.project\n   skein.compiled = skein.compiled or {}\n   local compiled = skein.compiled\n   local path = skein.knitted.lua.path\n   local src = skein.knitted.lua\n   local mod_name = _moduleName(path, project)\n   local bytecode, err = load (tostring(src), \"@\" .. mod_name)\n   if bytecode then\n      -- add to srcs\n      local byte_str = tostring(src) -- #todo: parse and strip\n      local byte_table = {binary = byte_str}\n      byte_table.hash = sha(byte_str)\n      byte_table.name = mod_name\n      byte_table.err = false\n      compiled.lua = byte_table\n      s:verb(\"compiled: \" .. project .. \":\" .. byte_table.name)\n   else\n      s:chat \"error:\"\n      s:chat(err)\n      compiled.lua = { err = err }\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction compiler.compile(compiler, skein)\n   for extension, scroll in pairs(skein.knitted) do\n      if compiler.compilers[extension] then\n         compiler.compilers[extension](skein)\n      end\n   end\nend\n\n\n\nreturn compiler\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/codeblock",
hash = "d4d69054e0057953d795ee287eb91d9e089790e8a38ffcc2b44ea09e11736ed6",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal Node = require \"espalier/node\"\n\nlocal m = require \"orb:Orbit/morphemes\"\n\nlocal CB = setmetatable({}, Node)\nCB.id = \"codeblock\"\n\nCB.__index = CB\n\nCB.__tostring = function() return \"codeblock\" end\n\n\n\n\n\n\nfunction CB.toValue(codeblock)\n    codeblock.val = \"\"\n    for _,v in ipairs(codeblock.lines) do\n        codeblock.val = codeblock.val .. v .. \"\\n\"\n    end\n\n    return codeblock.val\nend\n\nfunction CB.toMarkdown(codeblock)\n  -- hardcode lua\n  local lang = codeblock.lang or \"orbdefault\"\n  return \"```\" .. lang .. \"\\n\"\n         .. codeblock:toValue() .. \"```\\n\"\nend\n\nfunction CB.dotLabel(codeblock)\n    return \"code block \" .. tostring(codeblock.line_first)\n        .. \"-\" .. tostring(codeblock.line_last)\nend\n\nlocal cb = {}\n\n\n\n\n\nfunction CB.check(codeblock)\n  assert(codeblock.line_first)\n  assert(codeblock.line_last)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cb.matchHead(str)\n    if str ~= \"\" and L.match(m.codestart, str) then\n        local trimmed = str:sub(L.match(m.WS * m.hax, str))\n        local level = L.match(m.zaps, trimmed) - 1\n        local bareline = trimmed:sub(L.match(m.zaps, trimmed))\n        return true, level, bareline\n    else\n        return false, 0, \"\"\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cb.matchFoot(str)\n    if str ~= \"\" and L.match(m.codefinish, str) then\n        local trimmed = str:sub(L.match(m.WS * m.hax    , str))\n        local level = L.match(m.fass, trimmed) - 1\n        local bareline = trimmed:sub(L.match(m.fass, trimmed))\n        return true, level, bareline\n    else\n        return false, 0, \"\"\n    end\nend\n\n\n\n\n\nlocal function new(Codeblock, level, headline, linum)\n    local codeblock = setmetatable({}, CB)\n    codeblock.level = level\n    codeblock.header = headline\n    codeblock.lang = L.match(L.C(m.symbol), headline) or \"\"\n    codeblock.footer = \"\"\n    codeblock.line_first = linum\n    codeblock.lines = {}\n\n    return codeblock\nend\n\n\ncb.__call = new\ncb.__index = cb\n\nreturn setmetatable({}, cb)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb",
hash = "de60a83b2ca3aab45fa3fa358da06490aac0e07fe9016a1003670a28f36061ae",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\ncore = require \"core:core\"\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal Orb = {}\n\n\n\n\n\n\ns.verbose = true\n\n\n\n\n\n\n\n\n\n\n\nlocal knit   = require \"orb:knit\"\nlocal weave  = require \"orb:weave/weave\"\nlocal compile = require \"orb:compile\"\n\nlocal Codex = require \"orb:walk/codex\"\nlocal Spec    = require \"orb:spec/spec\"\nOrb.knit, Orb.weave = knit, weave\nOrb.compile, Orb.spec = compile, Spec\n\n\n\n\n\n\n\n\n\nlocal Path  = require \"fs:fs/path\"\nlocal Dir   = require \"fs:fs/directory\"\nlocal File  = require \"fs:fs/file\"\n\nOrb.dir = Dir\nOrb.path = Path\nOrb.file = File\nOrb.codex = Codex\n\nlocal check = require \"singletons/check\"\n\n\n\n\n\n\n\n\n\nlocal sh = require \"orb:util/sh\"\n\nlocal dot_sh = sh.command(\'dot\', \'-Tsvg\')\n\n\n\n\n\n\n\n\n\nlocal Lume = require \"orb:lume/lume\"\nOrb.lume = Lume\n\n\n\n\n\n\n\n\nlocal function _runner(pwd)\n    local orb = {}\n    -- The codex to be bound\n    local rootCodex = Codex(Dir(pwd))\n\n    orb.knit   = knit\n    orb.weave  = weave\n    local own = require \"orb:Orbit/own\"\n    -- do the things\n    rootCodex:spin()\n    knit.knitCodex(rootCodex)\n    local complete, errnum, errs = compile.compileCodex(rootCodex)\n    if not complete then\n        s:verb (\"errors in compilation: \" .. errnum)\n        for i, err in ipairs(errs) do\n            s:verb(\"failed: \" .. err)\n        end\n    else\n        s:verb \"compiled successfully\"\n    end\n    weave:weaveCodex(rootCodex)\nend\n\nOrb.run = _runner\n\ncore = nil\n\nreturn Orb\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/header",
hash = "d76144a7b35603b231a3462bc226f83ee47f17b152f545a6648b6123f8180453",
branch = "list-subgrammar",
binary = "\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Header_M = require \"orb:orb/metas/headermetas\"\n\n\n\nlocal header_str = [[\n        header  â†  WS? level (head-line / -1)\n         WS     â†  \" \"+\n         level  â†  \"*\"+\n     head-line  â†  (\" \" 1*)\n]]\n\n\n\nlocal addall = assert(require \"core:core/table\" . addall)\nlocal head_M = {Twig}\naddall(head_M, Header_M)\nlocal header_grammar = Peg(header_str, head_M)\n\n\n\n\nreturn subGrammar(header_grammar.parse, \"header-nomatch\")\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/fragments",
hash = "d2ea135c575a98a4d6ef7ef54055856945f3646bd17f53a643a06cbf99afc089",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\nlocal fragments = {}\n\n\n\n\n\n\n\n\n\n\nlocal gap_str = [[\n    `gap`  <-  { \\n([)]} / \"{\" / \"}\" / -1\n]]\nfragments.gap = gap_str\n\n\n\n\n\n\nlocal hashtag_h_str = [[\n\n   `hashtag_h`  â†  \"#\" (!gap 1)+\n]] .. gap_str\n\nlocal hashtag_str = [[\n\n   hashtag  â†  hashtag_h\n]] .. hashtag_h_str\n\nfragments.hashtag = hashtag_str\nfragments.hashtag_h = hashtag_h_str\n\n\n\n\n\n\nlocal handle_h_str = [[\n\n  `handle_h`  â† \"@\" (!gap 1)+\n]] .. gap_str\n\nlocal handle_str = [[\n\n   handle  â†  handle_h\n]] .. handle_h_str\n\nfragments.handle = handle_str\nfragments.handle_h = handle_h_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal symbol_str = [[\n\n   `symbol`  <-  (([a-z]/[A-Z]) ([a-z]/[A-Z]/[0-9]/\"-\"/\"_\")*)\n]]\nfragments.symbol = symbol_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal term_str = [[\n\n   `t` = { \\n.,:;?!)(][\\\"} / -1\n]]\nfragments.t = term_str\n\n\n\n\n\n\n\n\n\n\n\nlocal utf8_str = [[\n   `utf8`  â†  [\\x00-\\x7f]\n           /  [\\xc2-\\xdf] [\\x80-\\xbf]\n           /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n           /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\nfragments.utf8 = utf8_str\n\n\n\nreturn fragments\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/database",
hash = "2fbd88142da365ed666d80d4adf62c0a6d0d57e9d6d6e308237b6d49c41e71d0",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal s = require \"status:status\"\ns.verbose = false\n\nlocal unwrapKey, toRow = sql.unwrapKey, sql.toRow\n\n\n\nlocal database = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY,\n   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,\n   repo STRING,\n   repo_type STRING DEFAULT \'git\',\n   repo_alternates STRING,\n   home STRING,\n   website STRING\n);\n]]\n\n\n\n\n\n\nlocal create_version_table = [[\nCREATE TABLE IF NOT EXISTS version (\n   version_id INTEGER PRIMARY KEY,\n   stage STRING DEFAULT \'SNAPSHOT\' COLLATE NOCASE,\n   edition STRING default \'\',\n   special STRING DEFAULT \'no\' COLLATE NOCASE,\n   major INTEGER DEFAULT 0,\n   minor INTEGER DEFAULT 0,\n   patch INTEGER DEFAULT 0,\n   project INTEGER NOT NULL,\n   UNIQUE (project, stage, edition, special, major, minor, patch)\n      ON CONFLICT IGNORE,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\n\n\nlocal create_bundle_table = [[\nCREATE TABLE IF NOT EXISTS bundle (\n   bundle_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n);\n]]\n\n\n\n\n\n\nlocal create_code_table = [[\nCREATE TABLE IF NOT EXISTS code (\n   code_id INTEGER PRIMARY KEY,\n   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,\n   binary BLOB NOT NULL\n);\n]]\n\n\n\n\n\n\nlocal create_module_table = [[\nCREATE TABLE IF NOT EXISTS module (\n   module_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   name STRING NOT NULL,\n   type STRING DEFAULT \'luaJIT-2.1-bytecode\',\n   branch STRING,\n   vc_hash STRING,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   bundle INTEGER,\n   code INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE RESTRICT\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n   FOREIGN KEY (bundle)\n      REFERENCES bundle (bundle_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (code)\n      REFERENCES code (code_id)\n);\n]]\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\n\n\nlocal get_project = [[\nSELECT * FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal latest_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = ?\nORDER BY major DESC, minor DESC, patch DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = :project\nAND version.major = :major\nAND version.minor = :minor\nAND version.patch = :patch\nAND version.edition = :edition\nAND version.stage = :stage\n;\n]]\n\n\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, stage, project, major, minor, patch)\nVALUES (:edition, :stage, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _module_path()\n   local home_dir = os.getenv \"HOME\"\n   local bridge_modules = os.getenv \"BRIDGE_MODULES\"\n   if bridge_modules then\n      return bridge_modules\n   end\n   local bridge_home = os.getenv \"BRIDGE_HOME\"\n   if bridge_home then\n      return bridge_home .. \"/bridge.modules\"\n   end\n   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"\n   if xdg_data_home then\n      Dir(xdg_data_home .. \"/bridge/\") : mkdir()\n      return xdg_data_home .. \"/bridge/bridge.modules\"\n   end\n   -- build the whole shebang from scratch, just in case;\n   -- =mkdir= runs =exists= as the first command so this is\n   -- harmless\n   Dir(home_dir .. \"/.local\") : mkdir()\n   Dir(home_dir .. \"/.local/share\") : mkdir()\n   Dir(home_dir .. \"/.local/share/bridge/\") : mkdir()\n   bridge_modules = home_dir .. \"/.local/share/bridge/bridge.modules\"\n   -- error out if we haven\'t made the directory\n   local bridge_dir = Dir(home_dir .. \"/.local/share/bridge/\")\n   if not bridge_dir:exists() then\n      error (\"Could not create ~/.local/share/bridge/,\" ..\n            \"consider defining $BRIDGE_MODULES\")\n   end\n   return bridge_modules\nend\n\ndatabase.module_path = _module_path\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\nlocal function _updateProjectInfo(conn, db_project, codex_project)\n   -- determine if we need to do an update\n   local update = false\n   for k, v in pairs(codex_project) do\n      if db_project[k] ~= v then\n         update = true\n      end\n   end\n   if update then\n      local stmt = conn:prepare(update_project)\n      stmt:bindkv(codex_project):step()\n   end\nend\n\n\n\nlocal toRow = assert(sql.toRow)\n\nfunction database.project(conn, codex_info)\n   local db_info = conn:prepare(get_project):bind(codex_info.name):resultset()\n   db_info = toRow(db_info) or {}\n   local project_id = db_info.project_id\n   if project_id then\n      s:verb(\"project_id is \" .. project_id)\n      -- update information if there are any changes\n      _updateProjectInfo(conn, db_info, codex_info)\n   else\n      conn:prepare(new_project):bindkv(codex_info):step()\n      project_id = conn:prepare(get_project):bind(codex_info.name):step()\n      if not project_id then\n         error (\"failed to create project \" .. codex.project)\n      else\n         project_id = project_id[1]\n      end\n   end\n   return project_id\nend\n\n\n\n\n\n\nfunction database.version(conn, version_info, project_id)\n   local version_id\n   if not version_info.is_versioned then\n      version_id = conn:prepare(latest_version):bind(project_id):step()\n      if not version_id then\n         conn : prepare(new_version_snapshot) : bindkv\n              { edition = \"\",\n                project = project_id }\n              : step()\n         version_id = conn:prepare(latest_version):bind(project_id):step()\n         if not version_id then\n            error \"didn\'t make a SNAPSHOT\"\n         else\n            version_id = version_id[1]\n         end\n      else\n         version_id = version_id[1]\n      end\n   else\n      version_info.project = project_id\n      conn:prepare(new_version):bindkv(version_info):step()\n      version_id = conn:prepare(get_version):bindkv(version_info):step()\n      if not version_id then\n         error \"failed to create version\"\n      end\n      version_id = version_id[1]\n   end\n   s:verb(\"version_id is \" .. version_id)\n   return version_id\nend\n\n\n\n\n\n\n\n\nfunction database.open()\n   local mod_path = _module_path()\n   local new = not (File(mod_path) : exists())\n   if new then\n      s:verb\"creating new bridge.modules\"\n   end\n   local conn = sql.open(mod_path)\n   --conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \"wal\"\n   if new then\n      conn:exec(create_version_table)\n      conn:exec(create_project_table)\n      conn:exec(create_code_table)\n      conn:exec(create_module_table)\n      conn:exec(create_bundle_table)\n   end\n   return conn\nend\n\n\n\n\nreturn database\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/prose",
hash = "2999664b5e222d18d967ada51e3f3771ed29fbcf6d181ff5f8616f7ccdf3e586",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal Peg = require \"espalier:peg\"\nlocal Set = require \"set:set\"\nlocal core = require \"core:core\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal fragments = require \"orb:orb/fragments\"\n\nlocal ProseMetas = require \"orb:orb/metas/prosemetas\"\n\n\n\nlocal prose_str = [[\n               prose  â†  ( escape\n                          / link\n                          / italic\n                          / bold\n                          / strike\n                          / literal\n                          / verbatim\n                          / underline\n                          / raw )+\n\n              escape  â†  \"\\\\\" {*/~_=`][}\n                link  â†  \"[[\" (!\"]\" 1)+ \"]\" WS*  (\"[\" (!\"]\" 1)+ \"]\")* \"]\"\n                      /  \"[[\" (!\"]\" 1)+ \"]\" (!(WS /\"]\") 1)* \"]\"\n\n                bold  â†   bold-start bold-body bold-end\n        `bold-start`  â†  \"*\"+@bold-c !WS\n          `bold-end`  â†  \"*\"+@(bold-c)\n         `bold-body`  â†  ( WS+ (!non-bold !bold-end fill)+\n                          / WS* non-bold\n                          / (!non-bold !bold-end fill)+ )+\n         `non-bold`   â†  italic / strike / underline / literal / verbatim\n\n              italic  â†  italic-start italic-body italic-end\n      `italic-start`  â†  \"/\"+@italic-c !WS\n        `italic-end`  â†  \"/\"+@(italic-c)\n       `italic-body`  â†  ( WS+ (!non-italic !italic-end fill)+\n                          / WS* non-italic\n                          / (!non-italic !italic-end fill)+ )+\n       `non-italic`   â†  bold / strike / underline / literal / verbatim\n\n              strike  â†  strike-start strike-body strike-end\n      `strike-start`  â†  \"~\"+@strike-c !WS\n        `strike-end`  â†  \"~\"+@(strike-c)\n       `strike-body`  â†  ( WS+ (!non-strike !strike-end fill)+\n                                / WS* non-strike\n                                / (!non-strike !strike-end fill)+ )+\n        `non-strike`  â†  bold / italic / underline / literal / verbatim\n\n           underline  â†  underline-start underline-body underline-end\n   `underline-start`  â†  \"_\"+@underline-c !WS\n     `underline-end`  â†  \"_\"+@(underline-c)\n    `underline-body`  â†  ( WS+ (!non-underline !underline-end fill)+\n                             / WS* non-underline\n                             / (!non-underline !underline-end fill)+ )+\n     `non-underline`  â†  bold / italic / strike / literal / verbatim\n\n            literal  â†  literal-start literal-body literal-end\n    `literal-start`  â†  \"=\"+@literal-c\n      `literal-end`  â†  \"=\"+@(literal-c)\n     `literal-body`  â†  (!literal-end 1)+\n\n     verbatim  â†  verbatim-start verbatim-body verbatim-end\n    `verbatim-start`  â†  (\"`\" \"`\"+)@verbatim-c\n      `verbatim-end`  â†  (\"`\" \"`\"+)@(verbatim-c)\n     `verbatim-body`  â†  (!verbatim-end 1)+\n\n              `fill`  â†  !WS 1\n                WS    â†  (\" \" / \"\\n\")\n              `raw`   â†  ( !bold\n                            !italic\n                            !strike\n                            !literal\n                            !verbatim\n                            !underline\n                            !escape\n                            !link (word / punct / WS) )+\n              word  â†  (!t 1)+\n             punct  â†  {\\n.,:;?!)(][\\\"}+\n]] .. fragments.t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bounds = { bold      = \"*\",\n                 italic    = \"/\",\n                 literal   = \"=\",\n                 verbatim  = \"`\",\n                 underline = \"_\",\n                 strike    = \"~\" }\nlocal bookends = Set(core.keys(bounds))\n\n\n\nlocal byte = assert(string.byte)\nlocal insert = assert(table.insert)\n\nlocal function _makeBooks(bound, str, first, last)\n   local count = 0\n   while true do\n      if byte(str, first + count + 1) ~= bound then\n         break\n      end\n      -- may as well prevent infinite work on malformed input...\n      if first + count + 1 > last then break end\n      count = count + 1\n   end\n   local head = setmetatable({ first = first,\n                               last  = first + count,\n                               str   = str,\n                               id    = \"bound\" }, Twig)\n   local tail = setmetatable({ first = last - count,\n                               last  = last,\n                               str   = str,\n                               id    = \"bound\" }, Twig)\n   return head, tail, count\nend\n\n\nlocal function _fillGen(bookended)\n   local bound = byte(bounds[bookended.id])\n   local str, first, last = bookended.str, bookended.first, bookended.last\n   if #bookended == 0 then\n      local head, tail, count = _makeBooks(bound, str, first, last)\n      local body = setmetatable({ first = first + count + 1,\n                                  last  = last - count - 1,\n                                  str   = str,\n                                  id    = \"body\" }, Twig)\n      insert(bookended, head)\n      insert(bookended, body)\n      insert(bookended, tail)\n   else\n      local head, tail, count = _makeBooks(bound, str, first, last)\n      -- temporary array to hold the new collection\n      local new_order = {head}\n      local next_first = head.last + 1\n      -- test and capture first text\n      if next_first ~= bookended[1].first then\n      insert(new_order, setmetatable({ first = next_first,\n                                       last  = bookended[1].first - 1,\n                                       str   = str,\n                                       id    = \"word\" }, Twig))\n      end\n      -- test and capture interspersed text\n      for i = 2, #bookended do\n         insert(new_order, bookended[i - 1])\n         if not (bookended[i - 1].last + 1 == bookended[i].first) then\n            local inter = setmetatable({ first = bookended[i - 1].last + 1,\n                                         last  = bookended[i].first - 1,\n                                         str   = str,\n                                         id    = \"word\" }, Twig)\n            insert(new_order, inter)\n         end\n      end\n      insert(new_order, bookended[#bookended])\n      -- test and capture end text\n      if bookended[#bookended].last ~= bookended.last then\n         local hip = setmetatable({ first = bookended[#bookended].last + 1,\n                                    last  = bookended.last - count - 1,\n                                    str   = str,\n                                    id    = \"word\" }, Twig)\n         insert(new_order, hip)\n      end\n      for i, node in ipairs(new_order) do\n         bookended[i] = node\n      end\n      insert(bookended, tail)\n   end\nend\n\n\n\nlocal function _prosePost(prose)\n   for node in prose:walk() do\n     if bookends[node.id] then\n        _fillGen(node)\n     end\n   end\n   return prose\nend\n\n\n\n\n\nlocal proseMetas = { Twig,\n                      WS   =  require \"orb:orb/metas/ws\",\n                      link =  require \"orb:orb/link\"  }\n\ncore.addall(proseMetas, require \"orb:orb/metas/prosemetas\")\n\nlocal prose_grammar = Peg(prose_str, proseMetas, nil, _prosePost).parse\n\n\n\n\n\n\n\n\n\nlocal function prose_fn(t)\n   local match = prose_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t. last then\n         -- label the match according to the rule\n         match.id = t.id or \"prose\"\n         return match\n       else\n         match.id = t.id .. \"-INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   t.id = \"prose-nomatch\"\n   return setmetatable(t, Node)\nend\n\n\n\nreturn prose_fn\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/table",
hash = "3070d82a7a35f4847978218dd77cf990c36214940e3039e45da61fa32a20f23b",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig      = require \"orb:orb/metas/twig\"\n\n\n\nlocal table_str = [[\n      table  â†  WS* handle* WS* row+\n        row  â†  WS* pipe cell (!table-end pipe cell)* table-end\n       cell  â†  (!table-end !pipe 1)+\n       pipe  â†  \"|\"\n`table-end`  â†  (pipe / hline / double-row)* row-end\n      hline  â†  \"~\"\n double-row  â†  \"\\\\\"\n         WS  â†  \" \"+\n    row-end  â†  \"\\n\"+ / -1\n\n]] .. fragments.handle .. fragments.symbol\n\n\n\nlocal table_grammar = Peg(table_str, {Twig})\n\n\n\nreturn subGrammar(table_grammar, nil, \"table-nomatch\")\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/header",
hash = "9672f95693993270c58957d784279e429a3a885d2d738544d8cf10dd34f34e98",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal Node = require \"espalier/node\"\n\nlocal m = require \"orb:Orbit/morphemes\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal H = setmetatable({}, { __index = Node })\nH.id = \"header\"\nH.__index = H\n\nH.__tostring = function(header)\n    return \"Lvl \" .. tostring(header.level) .. \" ^: \"\n           .. tostring(header.line)\nend\n\nfunction H.dotLabel(header)\n    return tostring(header.level) .. \" : \" .. header.line\nend\n\nfunction H.toMarkdown(header)\n    local haxen = \"\"\n    if header.level > 0 then\n        haxen = (\"#\"):rep(header.level)\n    end\n    return haxen .. \" \" .. header.line\nend\n\n\n\n\n\n\nlocal h = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction h.match(str)\n    if str ~= \"\" and L.match(m.header, str) then\n        local trimmed = str:sub(L.match(m.WS, str))\n        local level = L.match(m.tars, trimmed) - 1\n        local bareline = trimmed:sub(L.match(m.tars * m.WS, trimmed))\n        return true, level, bareline\n    else\n        return false, 0, \"\"\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(Header, line, level, first, last, str)\n    local header = setmetatable({}, H)\n    header.line = line\n    header.level = level\n    header.first = first\n    header.last = last\n    header.str = str\n    return header\nend\n\nfunction H.howdy()\n    io.write(\"Why hello!\\n\")\nend\n\n\nh.__call = new\nh.__index = h\n\nreturn setmetatable({}, h)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "knit/newknit",
hash = "9cad1070d966c89bfe0672ab9421ee2c7e0e5e3f0e8d54410a7bcf34e171884d",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Scroll = require \"scroll:scroll\"\nlocal Set = require \"set:set\"\n\nlocal knitters = require \"orb:knit/knitters\"\n\nlocal core = require \"core:core\"\n\n\n\nlocal Knitter = {}\nKnitter.__index = Knitter\n\n\n\nlocal insert = assert(table.insert)\n\n\nfunction Knitter.knit(knitter, skein)\n   local doc = skein.source.doc\n   local knitted\n   if skein.knitted then\n      knitted = skein.knitted\n   else\n      knitted = {}\n      skein.knitted = knitted\n   end\n   -- specialize the knitter collection and create scrolls for each type\n   local knit_set = Set()\n   for code_type in doc :select \'code_type\' do\n      knit_set:insert(knitters[code_type:span()])\n   end\n   for knitter, _ in pairs(knit_set) do\n      local scroll = Scroll()\n      knitted[knitter.code_type] = scroll\n      -- #todo this is awkward, find a better way to do this\n      scroll.line_count = 1\n      scroll.path = skein.source.file.path\n                       :subFor(skein.source_base,\n                               skein.knit_base,\n                               knitter.code_type)\n   end\n   for codeblock in doc :select \'codeblock\' do\n      -- retrieve line numbers\n      local code_type = codeblock:select \'code_type\'() :span()\n      for knitter in pairs(knit_set) do\n         if knitter.code_type == code_type then\n            knitter.knit(codeblock, knitted[code_type], skein)\n         end\n         if knitter.pred(codeblock) then\n            knitter.pred_knit(codeblock, knitted[knitter.code_type], skein)\n         end\n      end\n   end\n   -- clean up unused scrolls\n   for code_type, scroll in pairs(knitted) do\n      if #scroll == 0 then\n         knitted[code_type] = nil\n      end\n   end\nend\n\n\n\nlocal function new()\n   local knitter = setmetatable({}, Knitter)\n\n   return knitter\nend\n\nKnitter.idEst = new\n\n\n\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "util/gitinfo",
hash = "c2d9acc41a3b025a514929379ea94a8fab275f460c109b0013c2f93dbcfe5485",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal core = require \"singletons/core\"\nlocal sh = require \"orb:util/sh\"\nlocal pl = require \"orb:util/plmini\"\nlocal isdir = assert(pl.path.isdir)\nlocal lines = assert(core.lines)\nlocal insert = assert(table.insert)\n\nlocal function gitInfo(path)\n   local git_info = {}\n   if isdir(path..\"/.git\") then\n      local git = sh.command (\"cd \" .. path .. \" && git\")\n      git_info.is_repo = true\n      local branches = tostring(git \"branch\")\n      for branch in lines(branches) do\n         if branch:sub(1,1) == \"*\" then\n            git_info.branch = branch:sub(3)\n         end\n      end\n      local remotes = tostring(git \"remote\")\n      if remotes then\n         git_info.remotes = {}\n         for remote in lines(remotes) do\n            local url = tostring(git(\"remote\", \"get-url\", remote))\n            if remote == \"origin\" then\n               git_info.url = url\n            end\n            insert(git_info.remotes, {remote, url})\n         end\n         if not git_info.url then\n            git_info.url = git_info.remotes[1] and git_info.remotes[1][2]\n         end\n      end\n      git_info.commit_hash = tostring(git(\"rev-parse\", \"HEAD\"))\n   else\n      git_info.is_repo = false\n   end\n   return git_info\nend\n\nreturn gitInfo\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/handle",
hash = "6a10e69530ef2a971111ddc7f8db35728c03ee4e7f6922f55d303e7a3de514c7",
branch = "list-subgrammar",
binary = "\n\n\n\nlocal L = require \"lpeg\"\n\nlocal Node = require \"espalier/node\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal m = require \"orb:Orbit/morphemes\"\n\nlocal H, h = u.inherit(Node)\n\nfunction h.matchHandle(line)\n    local handlen = L.match(L.C(m.handle), line)\n    if handlen then\n        return handlen\n\n    else\n        return \"\"\n        --u.freeze(\"h.matchHandle fails to match a handle\")\n    end\nend\n\nlocal function new(Handle, line)\n    local handle = setmetatable({}, H)\n    handle.id = \"handle\"\n    handle.val = h.matchHandle(line):sub(2, -1)\n    return handle\nend\n\nreturn u.export(h, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/own",
hash = "3adaee3095e155e9fa59e211075c34aae7bfee730f50e111329296bd73d4047a",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal epeg = require \"espalier/elpatt\"\n\nlocal Csp = epeg.Csp\n\nlocal a = require \"singletons/anterm\"\n\nlocal Node = require \"espalier/node\"\n\nlocal m = require \"orb:Orbit/morphemes\"\n\nlocal Header = require \"orb:Orbit/header\"\nlocal Section = require \"orb:Orbit/section\"\nlocal Block = require \"orb:Orbit/block\"\nlocal Codeblock = require \"orb:Orbit/codeblock\"\n\nlocal blue = tostring(a.blue)\nlocal red = tostring(a.red)\nlocal dim = tostring(a.dim)\nlocal green = tostring(a.green)\nlocal cl   = tostring(a.clear)\n\n\n\n\n\n\n\n\n\n\nlocal function lead_whitespace(str)\n    local lead_ws = L.match(m.WS, str)\n    if lead_ws > 1 then\n        --  io.write(green..(\"%\"):rep(lead_ws - 1)..cl)\n        return lead_ws, str:sub(lead_ws)\n    else\n        return 0, str\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function splitLines(str)\n   local t = {}\n   local function helper(line)\n      table.insert(t, line)\n      return \"\"\n   end\n   helper((str:gsub(\"(.-)\\r?\\n\", helper)))\n   return t\nend\n\nlocal function own(doc, str)\n    local linum = 1\n    local doc_level = 0\n    local start = 1\n    local doclines = splitLines(str)\n    local num_lines = #doclines\n    -- Track code blocks separately to avoid `* A` type collisions in code\n    local code_block = false\n    for _, line in ipairs(doclines) do\n        -- tab and return filtration\n        local l, err = line:gsub(\"\\t\", \"  \"):gsub(\"\\r\", \"\")\n        local finish = start + #l\n        -- We should always have a string but..\n        if l then\n            if not code_block then\n                local indent, l_trim = lead_whitespace(l)\n                local code_head = Codeblock.matchHead(l)\n                if code_head then\n                    code_block = true\n                end\n                local isHeader, level, bareline = Header.match(l_trim)\n\n                if isHeader then\n                    local header = Header(bareline, level, start, finish, str)\n\n                    -- make new block and append to doc\n                    doc:addSection(Section(header, linum, start, finish, doc.str),\n                                      linum, start)\n\n                else\n                    doc:addLine(l, linum, finish)\n                end\n            else\n                -- code block logic, including restarts\n                --\n                -- NOTE that this will choke on unmatched code headers,\n                -- which I intend to fix. But it\'s fiddly.\n                local code_foot = Codeblock.matchFoot(l)\n                if code_foot then\n                    code_block = false\n                end\n                doc:addLine(l, linum, finish)\n            end\n        elseif err then\n            freeze(\"HUH?\")\n        end\n        linum = linum + 1\n        start = finish\n        -- advance by one to account for line-final newline\n        if linum < num_lines then start = start + 1 end\n    end\n\n    doc.latest.line_last = linum - 1\n    doc.latest.last = start\n\n    for sec in doc:select \"section\" do\n        sec:check()\n        sec:block()\n    end\n    for block in doc:select \"block\" do\n        block:toValue()\n        block:parseProse()\n    end\n    for sec in doc:select \"section\" do\n        sec:weed()\n    end\n    for cbs in doc:select \"codeblock\" do\n        cbs:toValue()\n    end\n    doc.linum = linum - 1\n    return doc\nend\n\nreturn own\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/metas/prosemetas",
hash = "162fa246aa073086052e515e0542f7373e9f580cec3b0bc10940bee851047db2",
branch = "list-subgrammar",
binary = "\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal function bookmaker(icon)\n   return function(bookended, skein)\n      local phrase = Phrase(icon)\n      for i = 2, #bookended - 1 do\n         phrase = phrase .. bookended[i]:toMarkdown(skein)\n      end\n      return phrase .. icon\n   end\nend\n\n\n\nlocal bold_M = Twig:inherit \"bold\"\nbold_M.toMarkdown = bookmaker \"**\"\n\n\n\nlocal italic_M = Twig:inherit \"italic\"\nitalic_M.toMarkdown = bookmaker \"*\"\n\n\n\n\n\n\n\nlocal literal_M = Twig:inherit \"literal\"\n\nlocal find, rep = assert(string.find), assert(string.rep)\n\nfunction literal_M.toMarkdown(literal)\n   local span = literal :select \"body\"() :span()\n   local head, tail = find(span, \"%`+\")\n   if not head then\n      return \"`\" .. span .. \"`\"\n   else\n      local ticks = rep(\"`\", tail + 2 - head)\n      return ticks .. span .. ticks\n   end\nend\n\n\n\nlocal strike_M = Twig:inherit \"strike\"\nstrike_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal underline_M = Twig:inherit \"underline\"\nunderline_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal verbatim_M = Twig:inherit \"verbatim\"\nverbatim_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal Prose_M = { bold = bold_M,\n                  italic = italic_M,\n                  literal = literal_M,\n                  strike = strike_M,\n                  underline = underline_M,\n                  verbatim = verbatim_M, }\n\n\n\n\nreturn Prose_M\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "weave/weave",
hash = "f0748968e40ca5d9d4ecfba61b84d0cea83fae2e5bea594d292f8bf3aaf61abe",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal pl_mini = require \"orb:util/plmini\"\nlocal getfiles = pl_mini.dir.getfiles\nlocal makepath = pl_mini.dir.makepath\nlocal getdirectories = pl_mini.dir.getdirectories\nlocal extension = pl_mini.path.extension\nlocal dirname = pl_mini.path.dirname\nlocal basename = pl_mini.path.basename\nlocal read = pl_mini.file.read\nlocal write = pl_mini.file.write\nlocal isdir = pl_mini.path.isdir\n\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal a = require \"singletons/anterm\"\n\nlocal m = require \"orb:Orbit/morphemes\"\nlocal walk = require \"orb:walk/walk\"\nlocal strHas = walk.strHas\nlocal endsWith = walk.endsWith\nlocal subLastFor = walk.subLastFor\nlocal writeOnChange = walk.writeOnChange\nlocal Path = require \"fs:fs/path\"\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal epeg = require \"orb:util/epeg\"\n\nlocal Doc = require \"orb:Orbit/doc\"\n\nlocal W, w = u.inherit()\n\n\n\nfunction W.weaveMd(weaver, doc)\n  return doc:toMarkdown()\nend\n\n\n\n\n\n\n\n\n\n\nlocal popen = io.popen\nlocal function dotToSvg(dotted, out_file)\n    local success, svg_file = pcall (popen,\n                          \"dot -Tsvg \" .. tostring(out_file), \"r\")\n    if success then\n        return svg_file:read(\"*a\")\n    else\n        -- #todo start using %d and format!\n        s:complain(\"dotError\", \"dot failed with \" .. success)\n    end\nend\n\n\n\n\n\n\n\nlocal function weaveDeck(weaver, deck)\n    local dir = deck.dir\n    local codex = deck.codex\n    local orbDir = codex.orb\n    local docMdDir = codex.docMd\n    s:verb (\"weaving \" .. tostring(deck.dir))\n    s:verb (\"into \" .. tostring(docMdDir))\n    for i, sub in ipairs(deck) do\n        weaveDeck(weaver, sub)\n    end\n    for name, doc in pairs(deck.docs) do\n        local woven = weaver:weaveMd(doc)\n        if woven then\n            -- add to docMds\n            local docMdPath = Path(name):subFor(orbDir, docMdDir, \".md\")\n            s:verb(\"wove: \" .. name)\n            s:verb(\"into:    \" .. tostring(docMdPath))\n            deck.docMds[docMdPath] = woven\n            codex.docMds[docMdPath] = woven\n        end\n\n    end\n    return deck.docMds\nend\n\nW.weaveDeck = weaveDeck\n\n\n\nfunction W.weaveCodex(weaver, codex)\n   print \"weaving CODEX\"\n   local orb = codex.orb\n   weaveDeck(weaver, orb)\n   for name, docMd in pairs(codex.docMds) do\n      walk.writeOnChange(name, docMd)\n   end\nend\n\n\n\nlocal function new(Weaver, doc)\n    local weaver = setmetatable({}, W)\n\n\n    return weaver\nend\n\n\n\nreturn W\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/structure",
hash = "7d02cd8df0b55ee0bc344db22b16dda33e2f836630c5d49a5f25255b830eb101",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier/node\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal Hashline = require \"orb:Orbit/hashline\"\nlocal Handleline = require \"orb:Orbit/handleline\"\n\n\n\n\n\nlocal S, s = u.inherit(Node)\n\nfunction S.dotLabel(structure)\n    -- This is a shim and will break.\n    if structure.temp_id then\n        return structure.temp_id\n    else\n        return \"structure\"\n    end\nend\n\nfunction S.toMarkdown(structure)\n    if structure[1] and structure[1].toMarkdown then\n        return structure[1]:toMarkdown()\n    else\n        return structure.__VALUE\n    end\nend\n\nfunction S.toValue(structure)\n    return structure.__VALUE\nend\n\n\n\n\n\n\nlocal function new(Structure, line, line_id, str)\n    local structure = setmetatable({}, S)\n    structure.__VALUE = line\n    structure.id = \"structure\"\n    if line_id == \"hashline\" then\n        structure[1] = Hashline(line)\n    elseif line_id == \"handleline\" then\n        structure[1] = Handleline(line)\n    end\n    structure.str = str\n    return structure\nend\n\n\nreturn u.export(s, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "compile/sha2",
hash = "04a74f71596146a5f850155b8c94ec62417deafad90accb0c9f754b5e8ffaaf9",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n--------------------------------------------------------------------------------------------------------------------------\n-- sha2.lua\n--------------------------------------------------------------------------------------------------------------------------\n-- VERSION: 8 (2019-09-03)\n-- AUTHOR:  Egor Skriptunoff\n-- LICENSE: MIT (the same license as Lua itself)\n--\n--\n-- DESCRIPTION:\n--    This module contains functions to calculate SHA digest:\n--       MD5, SHA-1,\n--       SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,\n--       SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,\n--       HMAC\n--    Written in pure Lua.\n--    Compatible with:\n--       Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).\n--    Main feature of this module: it was heavily optimized for speed.\n--    For every Lua version the module contains particular implementation branch to get benefits from version-specific features.\n--       - branch for Lua 5.1 (emulating bitwise operators using look-up table)\n--       - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"\n--       - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)\n--       - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT\n--       - branch for LuaJIT without FFI library (useful in a sandboxed environment)\n--       - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)\n--       - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)\n--       - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n--\n--\n-- USAGE:\n--    Input data should be provided as a binary string: either as a whole string or as a sequence of substrings (chunk-by-chunk loading, total length < 9*10^15 bytes).\n--    Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.\n--    Simplest usage example:\n--       local sha = require(\"sha2\")\n--       local your_hash = sha.sha256(\"your string\")\n--    See file \"sha2_test.lua\" for more examples.\n--\n--\n-- CHANGELOG:\n--  version     date      description\n--  -------  ----------   -----------\n--     8     2019-09-03   SHA3 functions added\n--     7     2019-03-17   Added functions to convert to/from base64\n--     6     2018-11-12   HMAC added\n--     5     2018-11-10   SHA-1 added\n--     4     2018-11-03   MD5 added\n--     3     2018-11-02   Bug fixed: incorrect hashing of long (2 GByte) data streams on Lua 5.3/5.4 built with \"int32\" integers\n--     2     2018-10-07   Decreased module loading time in Lua 5.1 implementation branch (thanks to Peter Melnichenko for giving a hint)\n--     1     2018-10-06   First release (only SHA-2 functions)\n-----------------------------------------------------------------------------\n\nlocal print_debug_messages = false  -- set to true to view some messages about your system\'s abilities and implementation branch chosen for your system\n\nlocal unpack, table_concat, byte, char, string_rep, sub, gsub, gmatch, string_format, floor, ceil, math_min, math_max, tonumber, type =\n   table.unpack or unpack, table.concat, string.byte, string.char, string.rep, string.sub, string.gsub, string.gmatch, string.format, math.floor, math.ceil, math.min, math.max, tonumber, type\n\n\n--------------------------------------------------------------------------------\n-- EXAMINING YOUR SYSTEM\n--------------------------------------------------------------------------------\n\nlocal function get_precision(one)\n   -- \"one\" must be either float 1.0 or integer 1\n   -- returns bits_precision, is_integer\n   -- This function works correctly with all floating point datatypes (including non-IEEE-754)\n   local k, n, m, prev_n = 0, one, one\n   while true do\n      k, prev_n, n, m = k + 1, n, n + n + 1, m + m + k % 2\n      if k > 256 or n - (n - 1) ~= 1 or m - (m - 1) ~= 1 or n == m then\n         return k, false   -- floating point datatype\n      elseif n == prev_n then\n         return k, true    -- integer datatype\n      end\n   end\nend\n\n-- Make sure Lua has \"double\" numbers\nlocal x = 2/3\nlocal Lua_has_double = x * 5 > 3 and x * 4 < 3 and get_precision(1.0) >= 53\nassert(Lua_has_double, \"at least 53-bit floating point numbers are required\")\n\n-- Q:\n--    SHA2 was designed for FPU-less machines.\n--    So, why floating point numbers are needed for this module?\n-- A:\n--    53-bit \"double\" numbers are useful to calculate \"magic numbers\" used in SHA.\n--    I prefer to write 50 LOC \"magic numbers calculator\" instead of storing more than 200 constants explicitly in this source file.\n\nlocal int_prec, Lua_has_integers = get_precision(1)\nlocal Lua_has_int64 = Lua_has_integers and int_prec == 64\nlocal Lua_has_int32 = Lua_has_integers and int_prec == 32\nassert(Lua_has_int64 or Lua_has_int32 or not Lua_has_integers, \"Lua integers must be either 32-bit or 64-bit\")\n\n-- Q:\n--    Does it mean that almost all non-standard configurations are not supported?\n-- A:\n--    Yes.  Sorry, too many problems to support all possible Lua numbers configurations.\n--       Lua 5.1/5.2    with \"int32\"               will not work.\n--       Lua 5.1/5.2    with \"int64\"               will not work.\n--       Lua 5.1/5.2    with \"int128\"              will not work.\n--       Lua 5.1/5.2    with \"float\"               will not work.\n--       Lua 5.1/5.2    with \"double\"              is OK.          (default config for Lua 5.1, Lua 5.2, LuaJIT)\n--       Lua 5.3/5.4    with \"int32\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int64\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int128\" + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int32\"  + \"double\"   is OK.          (config used by Fengari)\n--       Lua 5.3/5.4    with \"int64\"  + \"double\"   is OK.          (default config for Lua 5.3, Lua 5.4)\n--       Lua 5.3/5.4    with \"int128\" + \"double\"   will not work.\n--   Using floating point numbers better than \"double\" instead of \"double\" is OK (non-IEEE-754 floating point implementation are allowed).\n--   Using \"int128\" instead of \"int64\" is not OK: \"int128\" would require different branch of implementation for optimized SHA512.\n\n-- Check for LuaJIT and 32-bit bitwise libraries\nlocal is_LuaJIT = ({false, [1] = true})[1] and (type(jit) ~= \"table\" or jit.version_num >= 20000)  -- LuaJIT 1.x.x is treated as vanilla Lua 5.1\nlocal is_LuaJIT_21  -- LuaJIT 2.1+\nlocal LuaJIT_arch\nlocal ffi           -- LuaJIT FFI library (as a table)\nlocal b             -- 32-bit bitwise library (as a table)\nlocal library_name\n\nif is_LuaJIT then\n   -- Assuming \"bit\" library is always available on LuaJIT\n   b = require\"bit\"\n   library_name = \"bit\"\n   -- \"ffi\" is intentionally disabled on some systems for safety reason\n   local LuaJIT_has_FFI, result = pcall(require, \"ffi\")\n   if LuaJIT_has_FFI then\n      ffi = result\n   end\n   is_LuaJIT_21 = not not loadstring\"b=0b0\"\n   LuaJIT_arch = type(jit) == \"table\" and jit.arch or ffi and ffi.arch or nil\nelse\n   -- For vanilla Lua, \"bit\"/\"bit32\" libraries are searched in global namespace only.  No attempt is made to load a library if it\'s not loaded yet.\n   for _, libname in ipairs(_VERSION == \"Lua 5.2\" and {\"bit32\", \"bit\"} or {\"bit\", \"bit32\"}) do\n      if type(_G[libname]) == \"table\" and _G[libname].bxor then\n         b = _G[libname]\n         library_name = libname\n         break\n      end\n   end\nend\n\n--------------------------------------------------------------------------------\n-- You can disable here some of your system\'s abilities (for testing purposes)\n--------------------------------------------------------------------------------\n-- is_LuaJIT = nil\n-- is_LuaJIT_21 = nil\n-- ffi = nil\n-- Lua_has_int32 = nil\n-- Lua_has_int64 = nil\n-- b, library_name = nil\n--------------------------------------------------------------------------------\n\nif print_debug_messages then\n   -- Printing list of abilities of your system\n   print(\"Abilities:\")\n   print(\"   Lua version:               \"..(is_LuaJIT and \"LuaJIT \"..(is_LuaJIT_21 and \"2.1 \" or \"2.0 \")..(LuaJIT_arch or \"\")..(ffi and \" with FFI\" or \" without FFI\") or _VERSION))\n   print(\"   Integer bitwise operators: \"..(Lua_has_int64 and \"int64\" or Lua_has_int32 and \"int32\" or \"no\"))\n   print(\"   32-bit bitwise library:    \"..(library_name or \"not found\"))\nend\n\n-- Selecting the most suitable implementation for given set of abilities\nlocal method, branch\nif is_LuaJIT and ffi then\n   method = \"Using \'ffi\' library of LuaJIT\"\n   branch = \"FFI\"\nelseif is_LuaJIT then\n   method = \"Using special code for FFI-less LuaJIT\"\n   branch = \"LJ\"\nelseif Lua_has_int64 then\n   method = \"Using native int64 bitwise operators\"\n   branch = \"INT64\"\nelseif Lua_has_int32 then\n   method = \"Using native int32 bitwise operators\"\n   branch = \"INT32\"\nelseif library_name then   -- when bitwise library is available (Lua 5.2 with native library \"bit32\" or Lua 5.1 with external library \"bit\")\n   method = \"Using \'\"..library_name..\"\' library\"\n   branch = \"LIB32\"\nelse\n   method = \"Emulating bitwise operators using look-up table\"\n   branch = \"EMUL\"\nend\n\nif print_debug_messages then\n   -- Printing the implementation selected to be used on your system\n   print(\"Implementation selected:\")\n   print(\"   \"..method)\nend\n\n\n--------------------------------------------------------------------------------\n-- BASIC 32-BIT BITWISE FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal AND, OR, XOR, SHL, SHR, ROL, ROR, NOT, NORM, HEX, XOR_BYTE\n-- Only low 32 bits of function arguments matter, high bits are ignored\n-- The result of all functions (except HEX) is an integer inside \"correct range\":\n--    for \"bit\" library:    (-2^31)..(2^31-1)\n--    for \"bit32\" library:        0..(2^32-1)\n\nif branch == \"FFI\" or branch == \"LJ\" or branch == \"LIB32\" then\n\n   -- Your system has 32-bit bitwise library (either \"bit\" or \"bit32\")\n\n   AND  = b.band                -- 2 arguments\n   OR   = b.bor                 -- 2 arguments\n   XOR  = b.bxor                -- 2..5 arguments\n   SHL  = b.lshift              -- second argument is integer 0..31\n   SHR  = b.rshift              -- second argument is integer 0..31\n   ROL  = b.rol or b.lrotate    -- second argument is integer 0..31\n   ROR  = b.ror or b.rrotate    -- second argument is integer 0..31\n   NOT  = b.bnot                -- only for LuaJIT\n   NORM = b.tobit               -- only for LuaJIT\n   HEX  = b.tohex               -- returns string of 8 lowercase hexadecimal digits\n   assert(AND and OR and XOR and SHL and SHR and ROL and ROR and NOT, \"Library \'\"..library_name..\"\' is incomplete\")\n   XOR_BYTE = XOR               -- XOR of two bytes (0..255)\n\nelseif branch == \"EMUL\" then\n\n   -- Emulating 32-bit bitwise operations using 53-bit floating point arithmetic\n\n   function SHL(x, n)\n      return (x * 2^n) % 2^32\n   end\n\n   function SHR(x, n)\n      -- return (x % 2^32 - x % 2^n) / 2^n\n      x = x % 2^32 / 2^n\n      return x - x % 1\n   end\n\n   function ROL(x, n)\n      x = x % 2^32 * 2^n\n      local r = x % 2^32\n      return r + (x - r) / 2^32\n   end\n\n   function ROR(x, n)\n      x = x % 2^32 / 2^n\n      local r = x % 1\n      return r * 2^32 + (x - r)\n   end\n\n   local AND_of_two_bytes = {[0] = 0}  -- look-up table (256*256 entries)\n   local idx = 0\n   for y = 0, 127 * 256, 256 do\n      for x = y, y + 127 do\n         x = AND_of_two_bytes[x] * 2\n         AND_of_two_bytes[idx] = x\n         AND_of_two_bytes[idx + 1] = x\n         AND_of_two_bytes[idx + 256] = x\n         AND_of_two_bytes[idx + 257] = x + 1\n         idx = idx + 2\n      end\n      idx = idx + 256\n   end\n\n   local function and_or_xor(x, y, operation)\n      -- operation: nil = AND, 1 = OR, 2 = XOR\n      local x0 = x % 2^32\n      local y0 = y % 2^32\n      local rx = x0 % 256\n      local ry = y0 % 256\n      local res = AND_of_two_bytes[rx + ry * 256]\n      x = x0 - rx\n      y = (y0 - ry) / 256\n      rx = x % 65536\n      ry = y % 256\n      res = res + AND_of_two_bytes[rx + ry] * 256\n      x = (x - rx) / 256\n      y = (y - ry) / 256\n      rx = x % 65536 + y % 256\n      res = res + AND_of_two_bytes[rx] * 65536\n      res = res + AND_of_two_bytes[(x + y - rx) / 256] * 16777216\n      if operation then\n         res = x0 + y0 - operation * res\n      end\n      return res\n   end\n\n   function AND(x, y)\n      return and_or_xor(x, y)\n   end\n\n   function OR(x, y)\n      return and_or_xor(x, y, 1)\n   end\n\n   function XOR(x, y, z, t, u)          -- 2..5 arguments\n      if z then\n         if t then\n            if u then\n               t = and_or_xor(t, u, 2)\n            end\n            z = and_or_xor(z, t, 2)\n         end\n         y = and_or_xor(y, z, 2)\n      end\n      return and_or_xor(x, y, 2)\n   end\n\n   function XOR_BYTE(x, y)\n      return x + y - 2 * AND_of_two_bytes[x + y * 256]\n   end\n\nend\n\nHEX = HEX or\n   function (x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x % 4294967296)\n   end\n\nlocal function XOR32A5(x)\n   return XOR(x, 0xA5A5A5A5) % 4294967296\nend\n\nlocal function create_array_of_lanes()\n   return {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\n\n--------------------------------------------------------------------------------\n-- CREATING OPTIMIZED INNER LOOP\n--------------------------------------------------------------------------------\n\n-- Inner loop functions\nlocal sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n\n-- Arrays of SHA2 \"magic numbers\" (in \"INT64\" and \"FFI\" branches \"*_lo\" arrays contain 64-bit values)\nlocal sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}\nlocal sha2_H_ext256 = {[224] = {}, [256] = sha2_H_hi}\nlocal sha2_H_ext512_lo, sha2_H_ext512_hi = {[384] = {}, [512] = sha2_H_lo}, {[384] = {}, [512] = sha2_H_hi}\nlocal md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}\nlocal md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}\nlocal HEX64, XOR64A5, lanes_index_base  -- defined only for branches that internally use 64-bit integers: \"INT64\" and \"FFI\"\nlocal common_W = {}    -- temporary table shared between all calculations (to avoid creating new temporary table every time)\nlocal K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0\n\nlocal function build_keccak_format(elem)\n   local keccak_format = {}\n   for _, size in ipairs{1, 9, 13, 17, 18, 21} do\n      keccak_format[size] = \"<\"..string_rep(elem, size)\n   end\n   return keccak_format\nend\n\n\nif branch == \"FFI\" then\n\n\n   -- SHA256 implementation for \"LuaJIT with FFI\" branch\n\n   local common_W_FFI_int32 = ffi.new\"int32_t[80]\"   -- 64 is enough for SHA256, but 80 is needed for SHA-1\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 63 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16] )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 0, 63, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j] + K[j+1] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+1] + K[j+2] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+2] + K[j+3] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+3] + K[j+4] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+4] + K[j+5] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+5] + K[j+6] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+6] + K[j+7] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+7] + K[j+8] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local common_W_FFI_int64 = ffi.new\"int64_t[80]\"\n   local int64 = ffi.typeof\"int64_t\"\n   local int32 = ffi.typeof\"int32_t\"\n   local uint32 = ffi.typeof\"uint32_t\"\n\n   hi_factor = int64(2^32)\n\n   if is_LuaJIT_21 then   -- LuaJIT 2.1 supports bitwise 64-bit operations\n\n      local AND64, OR64, XOR64, NOT64, SHL64, SHR64, ROL64, ROR64  -- introducing synonyms for better code readability\n          = AND,   OR,   XOR,   NOT,   SHL,   SHR,   ROL,   ROR\n      HEX64 = HEX\n\n\n      -- SHA3 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local lanes_arr64 = ffi.typeof\"int64_t[30]\"  -- 25 + 5 for temporary usage\n      -- lanes array is indexed from 0\n      lanes_index_base = 0\n      hi_factor_keccak = int64(2^32)\n\n      function create_array_of_lanes()\n         return lanes_arr64()\n      end\n\n      function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = SHR(block_size_in_bytes, 3)\n         for pos = offs, offs + size - 1, block_size_in_bytes do\n            for j = 0, qwords_qty - 1 do\n               pos = pos + 8\n               local h, g, f, e, d, c, b, a = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               lanes[j] = XOR64(lanes[j], OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))))\n            end\n            for round_idx = 1, 24 do\n               for j = 0, 4 do\n                  lanes[25 + j] = XOR64(lanes[j], lanes[j+5], lanes[j+10], lanes[j+15], lanes[j+20])\n               end\n               local D = XOR64(lanes[25], ROL64(lanes[27], 1))\n               lanes[1], lanes[6], lanes[11], lanes[16] = ROL64(XOR64(D, lanes[6]), 44), ROL64(XOR64(D, lanes[16]), 45), ROL64(XOR64(D, lanes[1]), 1), ROL64(XOR64(D, lanes[11]), 10)\n               lanes[21] = ROL64(XOR64(D, lanes[21]), 2)\n               D = XOR64(lanes[26], ROL64(lanes[28], 1))\n               lanes[2], lanes[7], lanes[12], lanes[22] = ROL64(XOR64(D, lanes[12]), 43), ROL64(XOR64(D, lanes[22]), 61), ROL64(XOR64(D, lanes[7]), 6), ROL64(XOR64(D, lanes[2]), 62)\n               lanes[17] = ROL64(XOR64(D, lanes[17]), 15)\n               D = XOR64(lanes[27], ROL64(lanes[29], 1))\n               lanes[3], lanes[8], lanes[18], lanes[23] = ROL64(XOR64(D, lanes[18]), 21), ROL64(XOR64(D, lanes[3]), 28), ROL64(XOR64(D, lanes[23]), 56), ROL64(XOR64(D, lanes[8]), 55)\n               lanes[13] = ROL64(XOR64(D, lanes[13]), 25)\n               D = XOR64(lanes[28], ROL64(lanes[25], 1))\n               lanes[4], lanes[14], lanes[19], lanes[24] = ROL64(XOR64(D, lanes[24]), 14), ROL64(XOR64(D, lanes[19]), 8), ROL64(XOR64(D, lanes[4]), 27), ROL64(XOR64(D, lanes[14]), 39)\n               lanes[9] = ROL64(XOR64(D, lanes[9]), 20)\n               D = XOR64(lanes[29], ROL64(lanes[26], 1))\n               lanes[5], lanes[10], lanes[15], lanes[20] = ROL64(XOR64(D, lanes[10]), 3), ROL64(XOR64(D, lanes[20]), 18), ROL64(XOR64(D, lanes[5]), 36), ROL64(XOR64(D, lanes[15]), 41)\n               lanes[0] = XOR64(D, lanes[0])\n               lanes[0], lanes[1], lanes[2], lanes[3], lanes[4] = XOR64(lanes[0], AND64(NOT64(lanes[1]), lanes[2]), RC[round_idx]), XOR64(lanes[1], AND64(NOT64(lanes[2]), lanes[3])), XOR64(lanes[2], AND64(NOT64(lanes[3]), lanes[4])), XOR64(lanes[3], AND64(NOT64(lanes[4]), lanes[0])), XOR64(lanes[4], AND64(NOT64(lanes[0]), lanes[1]))\n               lanes[5], lanes[6], lanes[7], lanes[8], lanes[9] = XOR64(lanes[8], AND64(NOT64(lanes[9]), lanes[5])), XOR64(lanes[9], AND64(NOT64(lanes[5]), lanes[6])), XOR64(lanes[5], AND64(NOT64(lanes[6]), lanes[7])), XOR64(lanes[6], AND64(NOT64(lanes[7]), lanes[8])), XOR64(lanes[7], AND64(NOT64(lanes[8]), lanes[9]))\n               lanes[10], lanes[11], lanes[12], lanes[13], lanes[14] = XOR64(lanes[11], AND64(NOT64(lanes[12]), lanes[13])), XOR64(lanes[12], AND64(NOT64(lanes[13]), lanes[14])), XOR64(lanes[13], AND64(NOT64(lanes[14]), lanes[10])), XOR64(lanes[14], AND64(NOT64(lanes[10]), lanes[11])), XOR64(lanes[10], AND64(NOT64(lanes[11]), lanes[12]))\n               lanes[15], lanes[16], lanes[17], lanes[18], lanes[19] = XOR64(lanes[19], AND64(NOT64(lanes[15]), lanes[16])), XOR64(lanes[15], AND64(NOT64(lanes[16]), lanes[17])), XOR64(lanes[16], AND64(NOT64(lanes[17]), lanes[18])), XOR64(lanes[17], AND64(NOT64(lanes[18]), lanes[19])), XOR64(lanes[18], AND64(NOT64(lanes[19]), lanes[15]))\n               lanes[20], lanes[21], lanes[22], lanes[23], lanes[24] = XOR64(lanes[22], AND64(NOT64(lanes[23]), lanes[24])), XOR64(lanes[23], AND64(NOT64(lanes[24]), lanes[20])), XOR64(lanes[24], AND64(NOT64(lanes[20]), lanes[21])), XOR64(lanes[20], AND64(NOT64(lanes[21]), lanes[22])), XOR64(lanes[21], AND64(NOT64(lanes[22]), lanes[23]))\n            end\n         end\n      end\n\n\n      -- SHA512 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local A5_long = 0xA5A5A5A5 * int64(2^32 + 1)  -- It\'s impossible to use constant 0xA5A5A5A5A5A5A5A5LL because it will raise syntax error on other Lua versions\n\n      function XOR64A5(long)\n         return XOR64(long, A5_long)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h))))\n            end\n            for j = 16, 79 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7)) + XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6)) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   else  -- LuaJIT 2.0 doesn\'t support 64-bit bitwise operations\n\n\n      -- SHA512 implementation for \"LuaJIT 2.0 + FFI\" branch\n\n      local union64 = ffi.typeof\"union{int64_t i64; struct{int32_t lo, hi;} i32;}\"\n      do  -- make sure the struct is endianness-compatible\n         local u = union64(1)\n         if u.i32.lo < u.i32.hi then\n            union64 = ffi.typeof\"union{int64_t i64; struct{int32_t hi, lo;} i32;}\"\n         end\n      end\n      local unions64 = ffi.typeof(\"$[?]\", union64)\n      local U = unions64(3)   -- this array of unions is used for fast splitting int64 into int32_high and int32_low\n\n      -- \"xorrific\" 64-bit functions :-)\n      -- int64 input is splitted into two int32 parts, some bitwise 32-bit operations are performed, finally the result is converted to int64\n      -- these functions are needed because bit.* functions in LuaJIT 2.0 don\'t work with int64_t\n\n      local function XORROR64_1(a)\n         -- return XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7))\n         U[0].i64 = a\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n         local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n         return t_hi * int64(2^32) + uint32(int32(t_lo))\n      end\n\n      local function XORROR64_2(b)\n         -- return XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6))\n         U[0].i64 = b\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n         local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_3(e)\n         -- return XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23))\n         U[0].i64 = e\n         local e_lo, e_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n         local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_6(a)\n         -- return XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30))\n         U[0].i64 = a\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n         local u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_4(e, f, g)\n         -- return XOR64(g, AND64(e, XOR64(f, g)))\n         U[0].i64 = f\n         U[1].i64 = g\n         U[2].i64 = e\n         local f_lo, f_hi = U[0].i32.lo, U[0].i32.hi\n         local g_lo, g_hi = U[1].i32.lo, U[1].i32.hi\n         local e_lo, e_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n         local result_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      local function XORROR64_5(a, b, c)\n         -- return XOR64(AND64(XOR64(a, b), c), AND64(a, b))\n         U[0].i64 = a\n         U[1].i64 = b\n         U[2].i64 = c\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local b_lo, b_hi = U[1].i32.lo, U[1].i32.hi\n         local c_lo, c_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(AND(XOR(a_lo, b_lo), c_lo), AND(a_lo, b_lo))\n         local result_hi = XOR(AND(XOR(a_hi, b_hi), c_hi), AND(a_hi, b_hi))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      function XOR64A5(long)\n         -- return XOR64(long, 0xA5A5A5A5A5A5A5A5)\n         U[0].i64 = long\n         local lo32, hi32 = U[0].i32.lo, U[0].i32.hi\n         lo32 = XOR(lo32, 0xA5A5A5A5)\n         hi32 = XOR(hi32, 0xA5A5A5A5)\n         return hi32 * int64(2^32) + uint32(int32(lo32))\n      end\n\n      function HEX64(long)\n         U[0].i64 = long\n         return HEX(U[0].i32.hi)..HEX(U[0].i32.lo)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32) + uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))\n            end\n            for j = 16, 79 do\n               W[j] = XORROR64_1(W[j-15]) + XORROR64_2(W[j-2]) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT with FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 0, 15, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+4] + W[j+3] + a), 22) + b)\n         end\n         for j = 16, 31, 4 do\n            local g = 5*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g + 1, 15)] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 6, 15)] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g - 5, 15)] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+4] + W[AND(g    , 15)] + a), 20) + b)\n         end\n         for j = 32, 47, 4 do\n            local g = 3*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 5, 15)] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 8, 15)] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 5, 15)] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+4] + W[AND(g - 2, 15)] + a), 23) + b)\n         end\n         for j = 48, 63, 4 do\n            local g = 7*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15)] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15)] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15)] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+4] + W[AND(g + 5, 15)] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT with FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W_FFI_int32\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 79 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 0, 19, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 20, 39, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 40, 59, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 60, 79, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\n-- SHA3 implementation for \"LuaJIT 2.0 + FFI\" and \"LuaJIT without FFI\" branches\n\nif branch == \"FFI\" and not is_LuaJIT_21 or branch == \"LJ\" then\n\n   if branch == \"FFI\" then\n      local lanes_arr32 = ffi.typeof\"int32_t[31]\"  -- 25 + 5 + 1 (due to 1-based indexing)\n\n      function create_array_of_lanes()\n         return lanes_arr32()\n      end\n\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = SHR(block_size_in_bytes, 3)\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n         end\n         for round_idx = 1, 24 do\n            for j = 1, 5 do\n               lanes_lo[25 + j] = XOR(lanes_lo[j], lanes_lo[j + 5], lanes_lo[j + 10], lanes_lo[j + 15], lanes_lo[j + 20])\n            end\n            for j = 1, 5 do\n               lanes_hi[25 + j] = XOR(lanes_hi[j], lanes_hi[j + 5], lanes_hi[j + 10], lanes_hi[j + 15], lanes_hi[j + 20])\n            end\n            local D_lo = XOR(lanes_lo[26], SHL(lanes_lo[28], 1), SHR(lanes_hi[28], 31))\n            local D_hi = XOR(lanes_hi[26], SHL(lanes_hi[28], 1), SHR(lanes_lo[28], 31))\n            lanes_lo[2], lanes_hi[2], lanes_lo[7], lanes_hi[7], lanes_lo[12], lanes_hi[12], lanes_lo[17], lanes_hi[17] = XOR(SHR(XOR(D_lo, lanes_lo[7]), 20), SHL(XOR(D_hi, lanes_hi[7]), 12)), XOR(SHR(XOR(D_hi, lanes_hi[7]), 20), SHL(XOR(D_lo, lanes_lo[7]), 12)), XOR(SHR(XOR(D_lo, lanes_lo[17]), 19), SHL(XOR(D_hi, lanes_hi[17]), 13)), XOR(SHR(XOR(D_hi, lanes_hi[17]), 19), SHL(XOR(D_lo, lanes_lo[17]), 13)), XOR(SHL(XOR(D_lo, lanes_lo[2]), 1), SHR(XOR(D_hi, lanes_hi[2]), 31)), XOR(SHL(XOR(D_hi, lanes_hi[2]), 1), SHR(XOR(D_lo, lanes_lo[2]), 31)), XOR(SHL(XOR(D_lo, lanes_lo[12]), 10), SHR(XOR(D_hi, lanes_hi[12]), 22)), XOR(SHL(XOR(D_hi, lanes_hi[12]), 10), SHR(XOR(D_lo, lanes_lo[12]), 22))\n            local L, H = XOR(D_lo, lanes_lo[22]), XOR(D_hi, lanes_hi[22])\n            lanes_lo[22], lanes_hi[22] = XOR(SHL(L, 2), SHR(H, 30)), XOR(SHL(H, 2), SHR(L, 30))\n            D_lo = XOR(lanes_lo[27], SHL(lanes_lo[29], 1), SHR(lanes_hi[29], 31))\n            D_hi = XOR(lanes_hi[27], SHL(lanes_hi[29], 1), SHR(lanes_lo[29], 31))\n            lanes_lo[3], lanes_hi[3], lanes_lo[8], lanes_hi[8], lanes_lo[13], lanes_hi[13], lanes_lo[23], lanes_hi[23] = XOR(SHR(XOR(D_lo, lanes_lo[13]), 21), SHL(XOR(D_hi, lanes_hi[13]), 11)), XOR(SHR(XOR(D_hi, lanes_hi[13]), 21), SHL(XOR(D_lo, lanes_lo[13]), 11)), XOR(SHR(XOR(D_lo, lanes_lo[23]), 3), SHL(XOR(D_hi, lanes_hi[23]), 29)), XOR(SHR(XOR(D_hi, lanes_hi[23]), 3), SHL(XOR(D_lo, lanes_lo[23]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[8]), 6), SHR(XOR(D_hi, lanes_hi[8]), 26)), XOR(SHL(XOR(D_hi, lanes_hi[8]), 6), SHR(XOR(D_lo, lanes_lo[8]), 26)), XOR(SHR(XOR(D_lo, lanes_lo[3]), 2), SHL(XOR(D_hi, lanes_hi[3]), 30)), XOR(SHR(XOR(D_hi, lanes_hi[3]), 2), SHL(XOR(D_lo, lanes_lo[3]), 30))\n            L, H = XOR(D_lo, lanes_lo[18]), XOR(D_hi, lanes_hi[18])\n            lanes_lo[18], lanes_hi[18] = XOR(SHL(L, 15), SHR(H, 17)), XOR(SHL(H, 15), SHR(L, 17))\n            D_lo = XOR(lanes_lo[28], SHL(lanes_lo[30], 1), SHR(lanes_hi[30], 31))\n            D_hi = XOR(lanes_hi[28], SHL(lanes_hi[30], 1), SHR(lanes_lo[30], 31))\n            lanes_lo[4], lanes_hi[4], lanes_lo[9], lanes_hi[9], lanes_lo[19], lanes_hi[19], lanes_lo[24], lanes_hi[24] = XOR(SHL(XOR(D_lo, lanes_lo[19]), 21), SHR(XOR(D_hi, lanes_hi[19]), 11)), XOR(SHL(XOR(D_hi, lanes_hi[19]), 21), SHR(XOR(D_lo, lanes_lo[19]), 11)), XOR(SHL(XOR(D_lo, lanes_lo[4]), 28), SHR(XOR(D_hi, lanes_hi[4]), 4)), XOR(SHL(XOR(D_hi, lanes_hi[4]), 28), SHR(XOR(D_lo, lanes_lo[4]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[24]), 8), SHL(XOR(D_hi, lanes_hi[24]), 24)), XOR(SHR(XOR(D_hi, lanes_hi[24]), 8), SHL(XOR(D_lo, lanes_lo[24]), 24)), XOR(SHR(XOR(D_lo, lanes_lo[9]), 9), SHL(XOR(D_hi, lanes_hi[9]), 23)), XOR(SHR(XOR(D_hi, lanes_hi[9]), 9), SHL(XOR(D_lo, lanes_lo[9]), 23))\n            L, H = XOR(D_lo, lanes_lo[14]), XOR(D_hi, lanes_hi[14])\n            lanes_lo[14], lanes_hi[14] = XOR(SHL(L, 25), SHR(H, 7)), XOR(SHL(H, 25), SHR(L, 7))\n            D_lo = XOR(lanes_lo[29], SHL(lanes_lo[26], 1), SHR(lanes_hi[26], 31))\n            D_hi = XOR(lanes_hi[29], SHL(lanes_hi[26], 1), SHR(lanes_lo[26], 31))\n            lanes_lo[5], lanes_hi[5], lanes_lo[15], lanes_hi[15], lanes_lo[20], lanes_hi[20], lanes_lo[25], lanes_hi[25] = XOR(SHL(XOR(D_lo, lanes_lo[25]), 14), SHR(XOR(D_hi, lanes_hi[25]), 18)), XOR(SHL(XOR(D_hi, lanes_hi[25]), 14), SHR(XOR(D_lo, lanes_lo[25]), 18)), XOR(SHL(XOR(D_lo, lanes_lo[20]), 8), SHR(XOR(D_hi, lanes_hi[20]), 24)), XOR(SHL(XOR(D_hi, lanes_hi[20]), 8), SHR(XOR(D_lo, lanes_lo[20]), 24)), XOR(SHL(XOR(D_lo, lanes_lo[5]), 27), SHR(XOR(D_hi, lanes_hi[5]), 5)), XOR(SHL(XOR(D_hi, lanes_hi[5]), 27), SHR(XOR(D_lo, lanes_lo[5]), 5)), XOR(SHR(XOR(D_lo, lanes_lo[15]), 25), SHL(XOR(D_hi, lanes_hi[15]), 7)), XOR(SHR(XOR(D_hi, lanes_hi[15]), 25), SHL(XOR(D_lo, lanes_lo[15]), 7))\n            L, H = XOR(D_lo, lanes_lo[10]), XOR(D_hi, lanes_hi[10])\n            lanes_lo[10], lanes_hi[10] = XOR(SHL(L, 20), SHR(H, 12)), XOR(SHL(H, 20), SHR(L, 12))\n            D_lo = XOR(lanes_lo[30], SHL(lanes_lo[27], 1), SHR(lanes_hi[27], 31))\n            D_hi = XOR(lanes_hi[30], SHL(lanes_hi[27], 1), SHR(lanes_lo[27], 31))\n            lanes_lo[6], lanes_hi[6], lanes_lo[11], lanes_hi[11], lanes_lo[16], lanes_hi[16], lanes_lo[21], lanes_hi[21] = XOR(SHL(XOR(D_lo, lanes_lo[11]), 3), SHR(XOR(D_hi, lanes_hi[11]), 29)), XOR(SHL(XOR(D_hi, lanes_hi[11]), 3), SHR(XOR(D_lo, lanes_lo[11]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[21]), 18), SHR(XOR(D_hi, lanes_hi[21]), 14)), XOR(SHL(XOR(D_hi, lanes_hi[21]), 18), SHR(XOR(D_lo, lanes_lo[21]), 14)), XOR(SHR(XOR(D_lo, lanes_lo[6]), 28), SHL(XOR(D_hi, lanes_hi[6]), 4)), XOR(SHR(XOR(D_hi, lanes_hi[6]), 28), SHL(XOR(D_lo, lanes_lo[6]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[16]), 23), SHL(XOR(D_hi, lanes_hi[16]), 9)), XOR(SHR(XOR(D_hi, lanes_hi[16]), 23), SHL(XOR(D_lo, lanes_lo[16]), 9))\n            lanes_lo[1], lanes_hi[1] = XOR(D_lo, lanes_lo[1]), XOR(D_hi, lanes_hi[1])\n            lanes_lo[1], lanes_lo[2], lanes_lo[3], lanes_lo[4], lanes_lo[5] = XOR(lanes_lo[1], AND(NOT(lanes_lo[2]), lanes_lo[3]), RC_lo[round_idx]), XOR(lanes_lo[2], AND(NOT(lanes_lo[3]), lanes_lo[4])), XOR(lanes_lo[3], AND(NOT(lanes_lo[4]), lanes_lo[5])), XOR(lanes_lo[4], AND(NOT(lanes_lo[5]), lanes_lo[1])), XOR(lanes_lo[5], AND(NOT(lanes_lo[1]), lanes_lo[2]))\n            lanes_lo[6], lanes_lo[7], lanes_lo[8], lanes_lo[9], lanes_lo[10] = XOR(lanes_lo[9], AND(NOT(lanes_lo[10]), lanes_lo[6])), XOR(lanes_lo[10], AND(NOT(lanes_lo[6]), lanes_lo[7])), XOR(lanes_lo[6], AND(NOT(lanes_lo[7]), lanes_lo[8])), XOR(lanes_lo[7], AND(NOT(lanes_lo[8]), lanes_lo[9])), XOR(lanes_lo[8], AND(NOT(lanes_lo[9]), lanes_lo[10]))\n            lanes_lo[11], lanes_lo[12], lanes_lo[13], lanes_lo[14], lanes_lo[15] = XOR(lanes_lo[12], AND(NOT(lanes_lo[13]), lanes_lo[14])), XOR(lanes_lo[13], AND(NOT(lanes_lo[14]), lanes_lo[15])), XOR(lanes_lo[14], AND(NOT(lanes_lo[15]), lanes_lo[11])), XOR(lanes_lo[15], AND(NOT(lanes_lo[11]), lanes_lo[12])), XOR(lanes_lo[11], AND(NOT(lanes_lo[12]), lanes_lo[13]))\n            lanes_lo[16], lanes_lo[17], lanes_lo[18], lanes_lo[19], lanes_lo[20] = XOR(lanes_lo[20], AND(NOT(lanes_lo[16]), lanes_lo[17])), XOR(lanes_lo[16], AND(NOT(lanes_lo[17]), lanes_lo[18])), XOR(lanes_lo[17], AND(NOT(lanes_lo[18]), lanes_lo[19])), XOR(lanes_lo[18], AND(NOT(lanes_lo[19]), lanes_lo[20])), XOR(lanes_lo[19], AND(NOT(lanes_lo[20]), lanes_lo[16]))\n            lanes_lo[21], lanes_lo[22], lanes_lo[23], lanes_lo[24], lanes_lo[25] = XOR(lanes_lo[23], AND(NOT(lanes_lo[24]), lanes_lo[25])), XOR(lanes_lo[24], AND(NOT(lanes_lo[25]), lanes_lo[21])), XOR(lanes_lo[25], AND(NOT(lanes_lo[21]), lanes_lo[22])), XOR(lanes_lo[21], AND(NOT(lanes_lo[22]), lanes_lo[23])), XOR(lanes_lo[22], AND(NOT(lanes_lo[23]), lanes_lo[24]))\n            lanes_hi[1], lanes_hi[2], lanes_hi[3], lanes_hi[4], lanes_hi[5] = XOR(lanes_hi[1], AND(NOT(lanes_hi[2]), lanes_hi[3]), RC_hi[round_idx]), XOR(lanes_hi[2], AND(NOT(lanes_hi[3]), lanes_hi[4])), XOR(lanes_hi[3], AND(NOT(lanes_hi[4]), lanes_hi[5])), XOR(lanes_hi[4], AND(NOT(lanes_hi[5]), lanes_hi[1])), XOR(lanes_hi[5], AND(NOT(lanes_hi[1]), lanes_hi[2]))\n            lanes_hi[6], lanes_hi[7], lanes_hi[8], lanes_hi[9], lanes_hi[10] = XOR(lanes_hi[9], AND(NOT(lanes_hi[10]), lanes_hi[6])), XOR(lanes_hi[10], AND(NOT(lanes_hi[6]), lanes_hi[7])), XOR(lanes_hi[6], AND(NOT(lanes_hi[7]), lanes_hi[8])), XOR(lanes_hi[7], AND(NOT(lanes_hi[8]), lanes_hi[9])), XOR(lanes_hi[8], AND(NOT(lanes_hi[9]), lanes_hi[10]))\n            lanes_hi[11], lanes_hi[12], lanes_hi[13], lanes_hi[14], lanes_hi[15] = XOR(lanes_hi[12], AND(NOT(lanes_hi[13]), lanes_hi[14])), XOR(lanes_hi[13], AND(NOT(lanes_hi[14]), lanes_hi[15])), XOR(lanes_hi[14], AND(NOT(lanes_hi[15]), lanes_hi[11])), XOR(lanes_hi[15], AND(NOT(lanes_hi[11]), lanes_hi[12])), XOR(lanes_hi[11], AND(NOT(lanes_hi[12]), lanes_hi[13]))\n            lanes_hi[16], lanes_hi[17], lanes_hi[18], lanes_hi[19], lanes_hi[20] = XOR(lanes_hi[20], AND(NOT(lanes_hi[16]), lanes_hi[17])), XOR(lanes_hi[16], AND(NOT(lanes_hi[17]), lanes_hi[18])), XOR(lanes_hi[17], AND(NOT(lanes_hi[18]), lanes_hi[19])), XOR(lanes_hi[18], AND(NOT(lanes_hi[19]), lanes_hi[20])), XOR(lanes_hi[19], AND(NOT(lanes_hi[20]), lanes_hi[16]))\n            lanes_hi[21], lanes_hi[22], lanes_hi[23], lanes_hi[24], lanes_hi[25] = XOR(lanes_hi[23], AND(NOT(lanes_hi[24]), lanes_hi[25])), XOR(lanes_hi[24], AND(NOT(lanes_hi[25]), lanes_hi[21])), XOR(lanes_hi[25], AND(NOT(lanes_hi[21]), lanes_hi[22])), XOR(lanes_hi[21], AND(NOT(lanes_hi[22]), lanes_hi[23])), XOR(lanes_hi[22], AND(NOT(lanes_hi[23]), lanes_hi[24]))\n         end\n      end\n   end\n\nend\n\n\nif branch == \"LJ\" then\n\n\n   -- SHA256 implementation for \"LuaJIT without FFI\" branch\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) ) + NORM( W[j-7] + W[j-16] ) )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 1, 64, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j] + W[j] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+1] + W[j+1] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+2] + W[j+2] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+3] + W[j+3] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+4] + W[j+4] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+5] + W[j+5] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+6] + W[j+6] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+7] + W[j+7] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local function ADD64_4(a_lo, a_hi, b_lo, b_hi, c_lo, c_hi, d_lo, d_hi)\n      local sum_lo = a_lo % 2^32 + b_lo % 2^32 + c_lo % 2^32 + d_lo % 2^32\n      local sum_hi = a_hi + b_hi + c_hi + d_hi\n      local result_lo = NORM( sum_lo )\n      local result_hi = NORM( sum_hi + floor(sum_lo / 2^32) )\n      return result_lo, result_hi\n   end\n\n   if LuaJIT_arch == \"x86\" then  -- Special trick is required to avoid \"PHI shuffling too complex\" on x86 platform\n\n\n      -- SHA512 implementation for \"LuaJIT x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            local zero = 0\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               zero = zero + zero  -- this thick is needed to avoid \"PHI shuffling too complex\" due to PHIs overlap\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = OR(zero, g_lo), OR(zero, g_hi), OR(zero, f_lo), OR(zero, f_hi), OR(zero, e_lo), OR(zero, e_hi)\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = OR(zero, c_lo), OR(zero, c_hi), OR(zero, b_lo), OR(zero, b_hi), OR(zero, a_lo), OR(zero, a_hi)\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + t_lo % 2^32 + u_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + t_hi + u_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   else  -- all platforms except x86\n\n\n      -- SHA512 implementation for \"LuaJIT non-x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = g_lo, g_hi, f_lo, f_hi, e_lo, e_hi\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = c_lo, c_hi, b_lo, b_hi, a_lo, a_hi\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + u_lo % 2^32 + t_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + u_hi + t_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT without FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 1, 16, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j  ] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+3] + a), 22) + b)\n         end\n         for j = 17, 32, 4 do\n            local g = 5*j-4\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j  ] + W[AND(g     , 15) + 1] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g +  5, 15) + 1] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 10, 15) + 1] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g -  1, 15) + 1] + a), 20) + b)\n         end\n         for j = 33, 48, 4 do\n            local g = 3*j+2\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j  ] + W[AND(g    , 15) + 1] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 3, 15) + 1] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 6, 15) + 1] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 7, 15) + 1] + a), 23) + b)\n         end\n         for j = 49, 64, 4 do\n            local g = j*7\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j  ] + W[AND(g - 7, 15) + 1] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15) + 1] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15) + 1] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15) + 1] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT without FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 1, 20, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 21, 40, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 41, 60, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 61, 80, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\nif branch == \"INT64\" then\n\n\n   -- implementation for Lua 5.3/5.4\n\n   hi_factor = 4294967296\n   hi_factor_keccak = 4294967296\n   lanes_index_base = 1\n\n   HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo = ...\n      local string_format, string_unpack = string.format, string.unpack\n\n      local function HEX64(x)\n         return string_format(\"%016x\", x)\n      end\n\n      local function XOR64A5(x)\n         return x ~ 0xa5a5a5a5a5a5a5a5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 64 do\n               local a = W[j-15]\n               a = a<<32 | a\n               local b = W[j-2]\n               b = b<<32 | b\n               W[j] = (a>>7 ~ a>>18 ~ a>>35) + (b>>17 ~ b>>19 ~ b>>42) + W[j-7] + W[j-16] & (1<<32)-1\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               e = e<<32 | e & (1<<32)-1\n               local z = (e>>6 ~ e>>11 ~ e>>25) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = a<<32 | a & (1<<32)-1\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a>>13 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W, sha2_K_lo\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-15]\n               local b = W[j-2]\n               W[j] = (a >> 1 ~ a >> 7 ~ a >> 8 ~ a << 56 ~ a << 63) + (b >> 6 ~ b >> 19 ~ b >> 61 ~ b << 3 ~ b << 45) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 80 do\n               local z = (e >> 14 ~ e >> 18 ~ e >> 41 ~ e << 23 ~ e << 46 ~ e << 50) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a >> 28 ~ a >> 34 ~ a >> 39 ~ a << 25 ~ a << 30 ~ a << 36)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = (a<<32 | a) << 1 >> 32\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i8 = build_keccak_format(\"i8\")\n\n      local function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i8[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local qwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes[j] = lanes[j] ~ qwords_from_message[j]\n            end\n            local L01, L02, L03, L04, L05, L06, L07, L08, L09, L10, L11, L12, L13, L14, L15, L16, L17, L18, L19, L20, L21, L22, L23, L24, L25 =\n               lanes[1], lanes[2], lanes[3], lanes[4], lanes[5], lanes[6], lanes[7], lanes[8], lanes[9], lanes[10], lanes[11], lanes[12], lanes[13],\n               lanes[14], lanes[15], lanes[16], lanes[17], lanes[18], lanes[19], lanes[20], lanes[21], lanes[22], lanes[23], lanes[24], lanes[25]\n            for round_idx = 1, 24 do\n               local C1 = L01 ~ L06 ~ L11 ~ L16 ~ L21\n               local C2 = L02 ~ L07 ~ L12 ~ L17 ~ L22\n               local C3 = L03 ~ L08 ~ L13 ~ L18 ~ L23\n               local C4 = L04 ~ L09 ~ L14 ~ L19 ~ L24\n               local C5 = L05 ~ L10 ~ L15 ~ L20 ~ L25\n               local D = C1 ~ C3<<1 ~ C3>>63\n               local T0 = D ~ L02\n               local T1 = D ~ L07\n               local T2 = D ~ L12\n               local T3 = D ~ L17\n               local T4 = D ~ L22\n               L02 = T1<<44 ~ T1>>20\n               L07 = T3<<45 ~ T3>>19\n               L12 = T0<<1 ~ T0>>63\n               L17 = T2<<10 ~ T2>>54\n               L22 = T4<<2 ~ T4>>62\n               D = C2 ~ C4<<1 ~ C4>>63\n               T0 = D ~ L03\n               T1 = D ~ L08\n               T2 = D ~ L13\n               T3 = D ~ L18\n               T4 = D ~ L23\n               L03 = T2<<43 ~ T2>>21\n               L08 = T4<<61 ~ T4>>3\n               L13 = T1<<6 ~ T1>>58\n               L18 = T3<<15 ~ T3>>49\n               L23 = T0<<62 ~ T0>>2\n               D = C3 ~ C5<<1 ~ C5>>63\n               T0 = D ~ L04\n               T1 = D ~ L09\n               T2 = D ~ L14\n               T3 = D ~ L19\n               T4 = D ~ L24\n               L04 = T3<<21 ~ T3>>43\n               L09 = T0<<28 ~ T0>>36\n               L14 = T2<<25 ~ T2>>39\n               L19 = T4<<56 ~ T4>>8\n               L24 = T1<<55 ~ T1>>9\n               D = C4 ~ C1<<1 ~ C1>>63\n               T0 = D ~ L05\n               T1 = D ~ L10\n               T2 = D ~ L15\n               T3 = D ~ L20\n               T4 = D ~ L25\n               L05 = T4<<14 ~ T4>>50\n               L10 = T1<<20 ~ T1>>44\n               L15 = T3<<8 ~ T3>>56\n               L20 = T0<<27 ~ T0>>37\n               L25 = T2<<39 ~ T2>>25\n               D = C5 ~ C2<<1 ~ C2>>63\n               T1 = D ~ L06\n               T2 = D ~ L11\n               T3 = D ~ L16\n               T4 = D ~ L21\n               L06 = T2<<3 ~ T2>>61\n               L11 = T4<<18 ~ T4>>46\n               L16 = T1<<36 ~ T1>>28\n               L21 = T3<<41 ~ T3>>23\n               L01 = D ~ L01\n               L01, L02, L03, L04, L05 = L01 ~ ~L02 & L03, L02 ~ ~L03 & L04, L03 ~ ~L04 & L05, L04 ~ ~L05 & L01, L05 ~ ~L01 & L02\n               L06, L07, L08, L09, L10 = L09 ~ ~L10 & L06, L10 ~ ~L06 & L07, L06 ~ ~L07 & L08, L07 ~ ~L08 & L09, L08 ~ ~L09 & L10\n               L11, L12, L13, L14, L15 = L12 ~ ~L13 & L14, L13 ~ ~L14 & L15, L14 ~ ~L15 & L11, L15 ~ ~L11 & L12, L11 ~ ~L12 & L13\n               L16, L17, L18, L19, L20 = L20 ~ ~L16 & L17, L16 ~ ~L17 & L18, L17 ~ ~L18 & L19, L18 ~ ~L19 & L20, L19 ~ ~L20 & L16\n               L21, L22, L23, L24, L25 = L23 ~ ~L24 & L25, L24 ~ ~L25 & L21, L25 ~ ~L21 & L22, L21 ~ ~L22 & L23, L22 ~ ~L23 & L24\n               L01 = L01 ~ RC[round_idx]\n            end\n            lanes[1]  = L01\n            lanes[2]  = L02\n            lanes[3]  = L03\n            lanes[4]  = L04\n            lanes[5]  = L05\n            lanes[6]  = L06\n            lanes[7]  = L07\n            lanes[8]  = L08\n            lanes[9]  = L09\n            lanes[10] = L10\n            lanes[11] = L11\n            lanes[12] = L12\n            lanes[13] = L13\n            lanes[14] = L14\n            lanes[15] = L15\n            lanes[16] = L16\n            lanes[17] = L17\n            lanes[18] = L18\n            lanes[19] = L19\n            lanes[20] = L20\n            lanes[21] = L21\n            lanes[22] = L22\n            lanes[23] = L23\n            lanes[24] = L24\n            lanes[25] = L25\n         end\n      end\n\n      return HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo)\n\nend\n\n\nif branch == \"INT32\" then\n\n\n   -- implementation for Lua 5.3/5.4 having non-standard numbers config \"int32\"+\"double\" (built with LUA_INT_TYPE=LUA_INT_INT)\n\n   K_lo_modulo = 2^32\n\n   function HEX(x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x)\n   end\n\n   XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi = ...\n      local string_unpack, floor = string.unpack, math.floor\n\n      local function XOR32A5(x)\n         return x ~ 0xA5A5A5A5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 64 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = (a>>7 ~ a<<25 ~ a<<14 ~ a>>18 ~ a>>3) + (b<<15 ~ b>>17 ~ b<<13 ~ b>>19 ~ b>>10) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               local z = (e>>6 ~ e<<26 ~ e>>11 ~ e<<21 ~ e>>25 ~ e<<7) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a<<30 ~ a>>13 ~ a<<19 ~ a<<10 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local floor, W, K_lo, K_hi = floor, common_W, sha2_K_lo, sha2_K_hi\n         local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n         local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16],\n               W[17], W[18], W[19], W[20], W[21], W[22], W[23], W[24], W[25], W[26], W[27], W[28], W[29], W[30], W[31], W[32] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n               local tmp =\n                  (a_lo>>1 ~ a_hi<<31 ~ a_lo>>8 ~ a_hi<<24 ~ a_lo>>7 ~ a_hi<<25) % 2^32\n                  + (b_lo>>19 ~ b_hi<<13 ~ b_lo<<3 ~ b_hi>>29 ~ b_lo>>6 ~ b_hi<<26) % 2^32\n                  + W[jj-14] % 2^32 + W[jj-32] % 2^32\n               W[jj-1] =\n                  (a_hi>>1 ~ a_lo<<31 ~ a_hi>>8 ~ a_lo<<24 ~ a_hi>>7)\n                  + (b_hi>>19 ~ b_lo<<13 ~ b_hi<<3 ~ b_lo>>29 ~ b_hi>>6)\n                  + W[jj-15] + W[jj-33] + floor(tmp / 2^32)\n               W[jj] = 0|((tmp + 2^31) % 2^32 - 2^31)\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n            for j = 1, 80 do\n               local jj = 2*j\n               local z_lo = (e_lo>>14 ~ e_hi<<18 ~ e_lo>>18 ~ e_hi<<14 ~ e_lo<<23 ~ e_hi>>9) % 2^32 + (g_lo ~ e_lo & (f_lo ~ g_lo)) % 2^32 + h_lo % 2^32 + K_lo[j] + W[jj] % 2^32\n               local z_hi = (e_hi>>14 ~ e_lo<<18 ~ e_hi>>18 ~ e_lo<<14 ~ e_hi<<23 ~ e_lo>>9) + (g_hi ~ e_hi & (f_hi ~ g_hi)) + h_hi + K_hi[j] + W[jj-1] + floor(z_lo / 2^32)\n               z_lo = z_lo % 2^32\n               h_lo = g_lo\n               h_hi = g_hi\n               g_lo = f_lo\n               g_hi = f_hi\n               f_lo = e_lo\n               f_hi = e_hi\n               e_lo = z_lo + d_lo % 2^32\n               e_hi = z_hi + d_hi + floor(e_lo / 2^32)\n               e_lo = 0|((e_lo + 2^31) % 2^32 - 2^31)\n               d_lo = c_lo\n               d_hi = c_hi\n               c_lo = b_lo\n               c_hi = b_hi\n               b_lo = a_lo\n               b_hi = a_hi\n               z_lo = z_lo + (d_lo & c_lo ~ b_lo & (d_lo ~ c_lo)) % 2^32 + (b_lo>>28 ~ b_hi<<4 ~ b_lo<<30 ~ b_hi>>2 ~ b_lo<<25 ~ b_hi>>7) % 2^32\n               a_hi = z_hi + (d_hi & c_hi ~ b_hi & (d_hi ~ c_hi)) + (b_hi>>28 ~ b_lo<<4 ~ b_hi<<30 ~ b_lo>>2 ~ b_hi<<25 ~ b_lo>>7) + floor(z_lo / 2^32)\n               a_lo = 0|((z_lo + 2^31) % 2^32 - 2^31)\n            end\n            a_lo = h1_lo % 2^32 + a_lo % 2^32\n            h1_hi = h1_hi + a_hi + floor(a_lo / 2^32)\n            h1_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h2_lo % 2^32 + b_lo % 2^32\n            h2_hi = h2_hi + b_hi + floor(a_lo / 2^32)\n            h2_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h3_lo % 2^32 + c_lo % 2^32\n            h3_hi = h3_hi + c_hi + floor(a_lo / 2^32)\n            h3_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h4_lo % 2^32 + d_lo % 2^32\n            h4_hi = h4_hi + d_hi + floor(a_lo / 2^32)\n            h4_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h5_lo % 2^32 + e_lo % 2^32\n            h5_hi = h5_hi + e_hi + floor(a_lo / 2^32)\n            h5_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h6_lo % 2^32 + f_lo % 2^32\n            h6_hi = h6_hi + f_hi + floor(a_lo / 2^32)\n            h6_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h7_lo % 2^32 + g_lo % 2^32\n            h7_hi = h7_hi + g_hi + floor(a_lo / 2^32)\n            h7_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h8_lo % 2^32 + h_lo % 2^32\n            h8_hi = h8_hi + h_hi + floor(a_lo / 2^32)\n            h8_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n         end\n         H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = a << 1 ~ a >> 31\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = (a << 5 ~ a >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = (a << 5 ~ a >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i4i4 = build_keccak_format(\"i4i4\")\n\n      local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i4i4[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local dwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes_lo[j] = lanes_lo[j] ~ dwords_from_message[2*j-1]\n               lanes_hi[j] = lanes_hi[j] ~ dwords_from_message[2*j]\n            end\n            local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n               L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n               L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n               lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n               lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n               lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n               lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n               lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n            for round_idx = 1, 24 do\n               local C1_lo = L01_lo ~ L06_lo ~ L11_lo ~ L16_lo ~ L21_lo\n               local C1_hi = L01_hi ~ L06_hi ~ L11_hi ~ L16_hi ~ L21_hi\n               local C2_lo = L02_lo ~ L07_lo ~ L12_lo ~ L17_lo ~ L22_lo\n               local C2_hi = L02_hi ~ L07_hi ~ L12_hi ~ L17_hi ~ L22_hi\n               local C3_lo = L03_lo ~ L08_lo ~ L13_lo ~ L18_lo ~ L23_lo\n               local C3_hi = L03_hi ~ L08_hi ~ L13_hi ~ L18_hi ~ L23_hi\n               local C4_lo = L04_lo ~ L09_lo ~ L14_lo ~ L19_lo ~ L24_lo\n               local C4_hi = L04_hi ~ L09_hi ~ L14_hi ~ L19_hi ~ L24_hi\n               local C5_lo = L05_lo ~ L10_lo ~ L15_lo ~ L20_lo ~ L25_lo\n               local C5_hi = L05_hi ~ L10_hi ~ L15_hi ~ L20_hi ~ L25_hi\n               local D_lo = C1_lo ~ C3_lo<<1 ~ C3_hi>>31\n               local D_hi = C1_hi ~ C3_hi<<1 ~ C3_lo>>31\n               local T0_lo = D_lo ~ L02_lo\n               local T0_hi = D_hi ~ L02_hi\n               local T1_lo = D_lo ~ L07_lo\n               local T1_hi = D_hi ~ L07_hi\n               local T2_lo = D_lo ~ L12_lo\n               local T2_hi = D_hi ~ L12_hi\n               local T3_lo = D_lo ~ L17_lo\n               local T3_hi = D_hi ~ L17_hi\n               local T4_lo = D_lo ~ L22_lo\n               local T4_hi = D_hi ~ L22_hi\n               L02_lo = T1_lo>>20 ~ T1_hi<<12\n               L02_hi = T1_hi>>20 ~ T1_lo<<12\n               L07_lo = T3_lo>>19 ~ T3_hi<<13\n               L07_hi = T3_hi>>19 ~ T3_lo<<13\n               L12_lo = T0_lo<<1 ~ T0_hi>>31\n               L12_hi = T0_hi<<1 ~ T0_lo>>31\n               L17_lo = T2_lo<<10 ~ T2_hi>>22\n               L17_hi = T2_hi<<10 ~ T2_lo>>22\n               L22_lo = T4_lo<<2 ~ T4_hi>>30\n               L22_hi = T4_hi<<2 ~ T4_lo>>30\n               D_lo = C2_lo ~ C4_lo<<1 ~ C4_hi>>31\n               D_hi = C2_hi ~ C4_hi<<1 ~ C4_lo>>31\n               T0_lo = D_lo ~ L03_lo\n               T0_hi = D_hi ~ L03_hi\n               T1_lo = D_lo ~ L08_lo\n               T1_hi = D_hi ~ L08_hi\n               T2_lo = D_lo ~ L13_lo\n               T2_hi = D_hi ~ L13_hi\n               T3_lo = D_lo ~ L18_lo\n               T3_hi = D_hi ~ L18_hi\n               T4_lo = D_lo ~ L23_lo\n               T4_hi = D_hi ~ L23_hi\n               L03_lo = T2_lo>>21 ~ T2_hi<<11\n               L03_hi = T2_hi>>21 ~ T2_lo<<11\n               L08_lo = T4_lo>>3 ~ T4_hi<<29\n               L08_hi = T4_hi>>3 ~ T4_lo<<29\n               L13_lo = T1_lo<<6 ~ T1_hi>>26\n               L13_hi = T1_hi<<6 ~ T1_lo>>26\n               L18_lo = T3_lo<<15 ~ T3_hi>>17\n               L18_hi = T3_hi<<15 ~ T3_lo>>17\n               L23_lo = T0_lo>>2 ~ T0_hi<<30\n               L23_hi = T0_hi>>2 ~ T0_lo<<30\n               D_lo = C3_lo ~ C5_lo<<1 ~ C5_hi>>31\n               D_hi = C3_hi ~ C5_hi<<1 ~ C5_lo>>31\n               T0_lo = D_lo ~ L04_lo\n               T0_hi = D_hi ~ L04_hi\n               T1_lo = D_lo ~ L09_lo\n               T1_hi = D_hi ~ L09_hi\n               T2_lo = D_lo ~ L14_lo\n               T2_hi = D_hi ~ L14_hi\n               T3_lo = D_lo ~ L19_lo\n               T3_hi = D_hi ~ L19_hi\n               T4_lo = D_lo ~ L24_lo\n               T4_hi = D_hi ~ L24_hi\n               L04_lo = T3_lo<<21 ~ T3_hi>>11\n               L04_hi = T3_hi<<21 ~ T3_lo>>11\n               L09_lo = T0_lo<<28 ~ T0_hi>>4\n               L09_hi = T0_hi<<28 ~ T0_lo>>4\n               L14_lo = T2_lo<<25 ~ T2_hi>>7\n               L14_hi = T2_hi<<25 ~ T2_lo>>7\n               L19_lo = T4_lo>>8 ~ T4_hi<<24\n               L19_hi = T4_hi>>8 ~ T4_lo<<24\n               L24_lo = T1_lo>>9 ~ T1_hi<<23\n               L24_hi = T1_hi>>9 ~ T1_lo<<23\n               D_lo = C4_lo ~ C1_lo<<1 ~ C1_hi>>31\n               D_hi = C4_hi ~ C1_hi<<1 ~ C1_lo>>31\n               T0_lo = D_lo ~ L05_lo\n               T0_hi = D_hi ~ L05_hi\n               T1_lo = D_lo ~ L10_lo\n               T1_hi = D_hi ~ L10_hi\n               T2_lo = D_lo ~ L15_lo\n               T2_hi = D_hi ~ L15_hi\n               T3_lo = D_lo ~ L20_lo\n               T3_hi = D_hi ~ L20_hi\n               T4_lo = D_lo ~ L25_lo\n               T4_hi = D_hi ~ L25_hi\n               L05_lo = T4_lo<<14 ~ T4_hi>>18\n               L05_hi = T4_hi<<14 ~ T4_lo>>18\n               L10_lo = T1_lo<<20 ~ T1_hi>>12\n               L10_hi = T1_hi<<20 ~ T1_lo>>12\n               L15_lo = T3_lo<<8 ~ T3_hi>>24\n               L15_hi = T3_hi<<8 ~ T3_lo>>24\n               L20_lo = T0_lo<<27 ~ T0_hi>>5\n               L20_hi = T0_hi<<27 ~ T0_lo>>5\n               L25_lo = T2_lo>>25 ~ T2_hi<<7\n               L25_hi = T2_hi>>25 ~ T2_lo<<7\n               D_lo = C5_lo ~ C2_lo<<1 ~ C2_hi>>31\n               D_hi = C5_hi ~ C2_hi<<1 ~ C2_lo>>31\n               T1_lo = D_lo ~ L06_lo\n               T1_hi = D_hi ~ L06_hi\n               T2_lo = D_lo ~ L11_lo\n               T2_hi = D_hi ~ L11_hi\n               T3_lo = D_lo ~ L16_lo\n               T3_hi = D_hi ~ L16_hi\n               T4_lo = D_lo ~ L21_lo\n               T4_hi = D_hi ~ L21_hi\n               L06_lo = T2_lo<<3 ~ T2_hi>>29\n               L06_hi = T2_hi<<3 ~ T2_lo>>29\n               L11_lo = T4_lo<<18 ~ T4_hi>>14\n               L11_hi = T4_hi<<18 ~ T4_lo>>14\n               L16_lo = T1_lo>>28 ~ T1_hi<<4\n               L16_hi = T1_hi>>28 ~ T1_lo<<4\n               L21_lo = T3_lo>>23 ~ T3_hi<<9\n               L21_hi = T3_hi>>23 ~ T3_lo<<9\n               L01_lo = D_lo ~ L01_lo\n               L01_hi = D_hi ~ L01_hi\n               L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = L01_lo ~ ~L02_lo & L03_lo, L02_lo ~ ~L03_lo & L04_lo, L03_lo ~ ~L04_lo & L05_lo, L04_lo ~ ~L05_lo & L01_lo, L05_lo ~ ~L01_lo & L02_lo\n               L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = L01_hi ~ ~L02_hi & L03_hi, L02_hi ~ ~L03_hi & L04_hi, L03_hi ~ ~L04_hi & L05_hi, L04_hi ~ ~L05_hi & L01_hi, L05_hi ~ ~L01_hi & L02_hi\n               L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = L09_lo ~ ~L10_lo & L06_lo, L10_lo ~ ~L06_lo & L07_lo, L06_lo ~ ~L07_lo & L08_lo, L07_lo ~ ~L08_lo & L09_lo, L08_lo ~ ~L09_lo & L10_lo\n               L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = L09_hi ~ ~L10_hi & L06_hi, L10_hi ~ ~L06_hi & L07_hi, L06_hi ~ ~L07_hi & L08_hi, L07_hi ~ ~L08_hi & L09_hi, L08_hi ~ ~L09_hi & L10_hi\n               L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = L12_lo ~ ~L13_lo & L14_lo, L13_lo ~ ~L14_lo & L15_lo, L14_lo ~ ~L15_lo & L11_lo, L15_lo ~ ~L11_lo & L12_lo, L11_lo ~ ~L12_lo & L13_lo\n               L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = L12_hi ~ ~L13_hi & L14_hi, L13_hi ~ ~L14_hi & L15_hi, L14_hi ~ ~L15_hi & L11_hi, L15_hi ~ ~L11_hi & L12_hi, L11_hi ~ ~L12_hi & L13_hi\n               L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = L20_lo ~ ~L16_lo & L17_lo, L16_lo ~ ~L17_lo & L18_lo, L17_lo ~ ~L18_lo & L19_lo, L18_lo ~ ~L19_lo & L20_lo, L19_lo ~ ~L20_lo & L16_lo\n               L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = L20_hi ~ ~L16_hi & L17_hi, L16_hi ~ ~L17_hi & L18_hi, L17_hi ~ ~L18_hi & L19_hi, L18_hi ~ ~L19_hi & L20_hi, L19_hi ~ ~L20_hi & L16_hi\n               L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = L23_lo ~ ~L24_lo & L25_lo, L24_lo ~ ~L25_lo & L21_lo, L25_lo ~ ~L21_lo & L22_lo, L21_lo ~ ~L22_lo & L23_lo, L22_lo ~ ~L23_lo & L24_lo\n               L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = L23_hi ~ ~L24_hi & L25_hi, L24_hi ~ ~L25_hi & L21_hi, L25_hi ~ ~L21_hi & L22_hi, L21_hi ~ ~L22_hi & L23_hi, L22_hi ~ ~L23_hi & L24_hi\n               L01_lo = L01_lo ~ RC_lo[round_idx]\n               L01_hi = L01_hi ~ RC_hi[round_idx]\n            end\n            lanes_lo[1]  = L01_lo\n            lanes_hi[1]  = L01_hi\n            lanes_lo[2]  = L02_lo\n            lanes_hi[2]  = L02_hi\n            lanes_lo[3]  = L03_lo\n            lanes_hi[3]  = L03_hi\n            lanes_lo[4]  = L04_lo\n            lanes_hi[4]  = L04_hi\n            lanes_lo[5]  = L05_lo\n            lanes_hi[5]  = L05_hi\n            lanes_lo[6]  = L06_lo\n            lanes_hi[6]  = L06_hi\n            lanes_lo[7]  = L07_lo\n            lanes_hi[7]  = L07_hi\n            lanes_lo[8]  = L08_lo\n            lanes_hi[8]  = L08_hi\n            lanes_lo[9]  = L09_lo\n            lanes_hi[9]  = L09_hi\n            lanes_lo[10] = L10_lo\n            lanes_hi[10] = L10_hi\n            lanes_lo[11] = L11_lo\n            lanes_hi[11] = L11_hi\n            lanes_lo[12] = L12_lo\n            lanes_hi[12] = L12_hi\n            lanes_lo[13] = L13_lo\n            lanes_hi[13] = L13_hi\n            lanes_lo[14] = L14_lo\n            lanes_hi[14] = L14_hi\n            lanes_lo[15] = L15_lo\n            lanes_hi[15] = L15_hi\n            lanes_lo[16] = L16_lo\n            lanes_hi[16] = L16_hi\n            lanes_lo[17] = L17_lo\n            lanes_hi[17] = L17_hi\n            lanes_lo[18] = L18_lo\n            lanes_hi[18] = L18_hi\n            lanes_lo[19] = L19_lo\n            lanes_hi[19] = L19_hi\n            lanes_lo[20] = L20_lo\n            lanes_hi[20] = L20_hi\n            lanes_lo[21] = L21_lo\n            lanes_hi[21] = L21_hi\n            lanes_lo[22] = L22_lo\n            lanes_hi[22] = L22_hi\n            lanes_lo[23] = L23_lo\n            lanes_hi[23] = L23_hi\n            lanes_lo[24] = L24_lo\n            lanes_hi[24] = L24_hi\n            lanes_lo[25] = L25_lo\n            lanes_hi[25] = L25_hi\n         end\n      end\n\n      return XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi)\n\nend\n\n\nif branch == \"LIB32\" or branch == \"EMUL\" then\n\n\n   -- implementation for Lua 5.1/5.2 (with or without bitwise library available)\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16]\n         end\n         local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n         for j = 1, 64 do\n            local z = XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + AND(e, f) + AND(-1-e, g) + h + K[j] + W[j]\n            h = g\n            g = f\n            f = e\n            e = z + d\n            d = c\n            c = b\n            b = a\n            a = z + AND(d, c) + AND(a, XOR(d, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10))\n         end\n         h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296\n         h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n   end\n\n   function sha512_feed_128(H_lo, H_hi, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 128\n      -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n      local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n      local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n      local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n      for pos = offs, offs + size - 1, 128 do\n         for j = 1, 16*2 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for jj = 17*2, 80*2, 2 do\n            local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n            local tmp1 = XOR(SHR(a_lo, 1) + SHL(a_hi, 31), SHR(a_lo, 8) + SHL(a_hi, 24), SHR(a_lo, 7) + SHL(a_hi, 25)) % 4294967296 + XOR(SHR(b_lo, 19) + SHL(b_hi, 13), SHL(b_lo, 3) + SHR(b_hi, 29), SHR(b_lo, 6) + SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]\n            local tmp2 = tmp1 % 4294967296\n            W[jj-1] = XOR(SHR(a_hi, 1) + SHL(a_lo, 31), SHR(a_hi, 8) + SHL(a_lo, 24), SHR(a_hi, 7)) + XOR(SHR(b_hi, 19) + SHL(b_lo, 13), SHL(b_hi, 3) + SHR(b_lo, 29), SHR(b_hi, 6)) + W[jj-15] + W[jj-33] + (tmp1 - tmp2) / 4294967296\n            W[jj] = tmp2\n         end\n         local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n         for j = 1, 80 do\n            local jj = 2*j\n            local tmp1 = XOR(SHR(e_lo, 14) + SHL(e_hi, 18), SHR(e_lo, 18) + SHL(e_hi, 14), SHL(e_lo, 23) + SHR(e_hi, 9)) % 4294967296 + (AND(e_lo, f_lo) + AND(-1-e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]\n            local z_lo = tmp1 % 4294967296\n            local z_hi = XOR(SHR(e_hi, 14) + SHL(e_lo, 18), SHR(e_hi, 18) + SHL(e_lo, 14), SHL(e_hi, 23) + SHR(e_lo, 9)) + AND(e_hi, f_hi) + AND(-1-e_hi, g_hi) + h_hi + K_hi[j] + W[jj-1] + (tmp1 - z_lo) / 4294967296\n            h_lo = g_lo\n            h_hi = g_hi\n            g_lo = f_lo\n            g_hi = f_hi\n            f_lo = e_lo\n            f_hi = e_hi\n            tmp1 = z_lo + d_lo\n            e_lo = tmp1 % 4294967296\n            e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296\n            d_lo = c_lo\n            d_hi = c_hi\n            c_lo = b_lo\n            c_hi = b_hi\n            b_lo = a_lo\n            b_hi = a_hi\n            tmp1 = z_lo + (AND(d_lo, c_lo) + AND(b_lo, XOR(d_lo, c_lo))) % 4294967296 + XOR(SHR(b_lo, 28) + SHL(b_hi, 4), SHL(b_lo, 30) + SHR(b_hi, 2), SHL(b_lo, 25) + SHR(b_hi, 7)) % 4294967296\n            a_lo = tmp1 % 4294967296\n            a_hi = z_hi + (AND(d_hi, c_hi) + AND(b_hi, XOR(d_hi, c_hi))) + XOR(SHR(b_hi, 28) + SHL(b_lo, 4), SHL(b_hi, 30) + SHR(b_lo, 2), SHL(b_hi, 25) + SHR(b_lo, 7)) + (tmp1 - a_lo) / 4294967296\n         end\n         a_lo = h1_lo + a_lo\n         h1_lo = a_lo % 4294967296\n         h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296\n         a_lo = h2_lo + b_lo\n         h2_lo = a_lo % 4294967296\n         h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296\n         a_lo = h3_lo + c_lo\n         h3_lo = a_lo % 4294967296\n         h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296\n         a_lo = h4_lo + d_lo\n         h4_lo = a_lo % 4294967296\n         h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296\n         a_lo = h5_lo + e_lo\n         h5_lo = a_lo % 4294967296\n         h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296\n         a_lo = h6_lo + f_lo\n         h6_lo = a_lo % 4294967296\n         h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296\n         a_lo = h7_lo + g_lo\n         h7_lo = a_lo % 4294967296\n         h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296\n         a_lo = h8_lo + h_lo\n         h8_lo = a_lo % 4294967296\n         h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296\n      end\n      H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n      H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n   end\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n      local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((d * 256 + c) * 256 + b) * 256 + a\n         end\n         local a, b, c, d = h1, h2, h3, h4\n         local s = 32-7\n         for j = 1, 16 do\n            local F = ROR(AND(b, c) + AND(-1-b, d) + a + K[j] + W[j], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-5\n         for j = 17, 32 do\n            local F = ROR(AND(d, b) + AND(-1-d, c) + a + K[j] + W[(5*j-4) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-4\n         for j = 33, 48 do\n            local F = ROR(XOR(XOR(b, c), d) + a + K[j] + W[(3*j+2) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-6\n         for j = 49, 64 do\n            local F = ROR(XOR(c, OR(b, -1-d)) + a + K[j] + W[(j*7-7) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n      end\n      H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n   end\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = h1, h2, h3, h4, h5\n         for j = 1, 20 do\n            local z = ROL(a, 5) + AND(b, c) + AND(-1-b, d) + 0x5A827999 + W[j] + e        -- constant = floor(2^30 * sqrt(2))\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 21, 40 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0x6ED9EBA1 + W[j] + e                    -- 2^30 * sqrt(3)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 41, 60 do\n            local z = ROL(a, 5) + AND(d, c) + AND(b, XOR(d, c)) + 0x8F1BBCDC + W[j] + e   -- 2^30 * sqrt(5)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 61, 80 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0xCA62C1D6 + W[j] + e                    -- 2^30 * sqrt(10)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n         h5 = (e + h5) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- This is an example of a Lua function having 79 local variables :-)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = block_size_in_bytes / 8\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)\n         end\n         local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n            L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n            L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n            lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n            lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n            lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n            lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n            lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n         for round_idx = 1, 24 do\n            local C1_lo = XOR(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)\n            local C1_hi = XOR(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)\n            local C2_lo = XOR(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)\n            local C2_hi = XOR(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)\n            local C3_lo = XOR(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)\n            local C3_hi = XOR(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)\n            local C4_lo = XOR(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)\n            local C4_hi = XOR(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)\n            local C5_lo = XOR(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)\n            local C5_hi = XOR(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)\n            local D_lo = XOR(C1_lo, C3_lo * 2 + (C3_hi % 2^32 - C3_hi % 2^31) / 2^31)\n            local D_hi = XOR(C1_hi, C3_hi * 2 + (C3_lo % 2^32 - C3_lo % 2^31) / 2^31)\n            local T0_lo = XOR(D_lo, L02_lo)\n            local T0_hi = XOR(D_hi, L02_hi)\n            local T1_lo = XOR(D_lo, L07_lo)\n            local T1_hi = XOR(D_hi, L07_hi)\n            local T2_lo = XOR(D_lo, L12_lo)\n            local T2_hi = XOR(D_hi, L12_hi)\n            local T3_lo = XOR(D_lo, L17_lo)\n            local T3_hi = XOR(D_hi, L17_hi)\n            local T4_lo = XOR(D_lo, L22_lo)\n            local T4_hi = XOR(D_hi, L22_hi)\n            L02_lo = (T1_lo % 2^32 - T1_lo % 2^20) / 2^20 + T1_hi * 2^12\n            L02_hi = (T1_hi % 2^32 - T1_hi % 2^20) / 2^20 + T1_lo * 2^12\n            L07_lo = (T3_lo % 2^32 - T3_lo % 2^19) / 2^19 + T3_hi * 2^13\n            L07_hi = (T3_hi % 2^32 - T3_hi % 2^19) / 2^19 + T3_lo * 2^13\n            L12_lo = T0_lo * 2 + (T0_hi % 2^32 - T0_hi % 2^31) / 2^31\n            L12_hi = T0_hi * 2 + (T0_lo % 2^32 - T0_lo % 2^31) / 2^31\n            L17_lo = T2_lo * 2^10 + (T2_hi % 2^32 - T2_hi % 2^22) / 2^22\n            L17_hi = T2_hi * 2^10 + (T2_lo % 2^32 - T2_lo % 2^22) / 2^22\n            L22_lo = T4_lo * 2^2 + (T4_hi % 2^32 - T4_hi % 2^30) / 2^30\n            L22_hi = T4_hi * 2^2 + (T4_lo % 2^32 - T4_lo % 2^30) / 2^30\n            D_lo = XOR(C2_lo, C4_lo * 2 + (C4_hi % 2^32 - C4_hi % 2^31) / 2^31)\n            D_hi = XOR(C2_hi, C4_hi * 2 + (C4_lo % 2^32 - C4_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L03_lo)\n            T0_hi = XOR(D_hi, L03_hi)\n            T1_lo = XOR(D_lo, L08_lo)\n            T1_hi = XOR(D_hi, L08_hi)\n            T2_lo = XOR(D_lo, L13_lo)\n            T2_hi = XOR(D_hi, L13_hi)\n            T3_lo = XOR(D_lo, L18_lo)\n            T3_hi = XOR(D_hi, L18_hi)\n            T4_lo = XOR(D_lo, L23_lo)\n            T4_hi = XOR(D_hi, L23_hi)\n            L03_lo = (T2_lo % 2^32 - T2_lo % 2^21) / 2^21 + T2_hi * 2^11\n            L03_hi = (T2_hi % 2^32 - T2_hi % 2^21) / 2^21 + T2_lo * 2^11\n            L08_lo = (T4_lo % 2^32 - T4_lo % 2^3) / 2^3 + T4_hi * 2^29 % 2^32\n            L08_hi = (T4_hi % 2^32 - T4_hi % 2^3) / 2^3 + T4_lo * 2^29 % 2^32\n            L13_lo = T1_lo * 2^6 + (T1_hi % 2^32 - T1_hi % 2^26) / 2^26\n            L13_hi = T1_hi * 2^6 + (T1_lo % 2^32 - T1_lo % 2^26) / 2^26\n            L18_lo = T3_lo * 2^15 + (T3_hi % 2^32 - T3_hi % 2^17) / 2^17\n            L18_hi = T3_hi * 2^15 + (T3_lo % 2^32 - T3_lo % 2^17) / 2^17\n            L23_lo = (T0_lo % 2^32 - T0_lo % 2^2) / 2^2 + T0_hi * 2^30 % 2^32\n            L23_hi = (T0_hi % 2^32 - T0_hi % 2^2) / 2^2 + T0_lo * 2^30 % 2^32\n            D_lo = XOR(C3_lo, C5_lo * 2 + (C5_hi % 2^32 - C5_hi % 2^31) / 2^31)\n            D_hi = XOR(C3_hi, C5_hi * 2 + (C5_lo % 2^32 - C5_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L04_lo)\n            T0_hi = XOR(D_hi, L04_hi)\n            T1_lo = XOR(D_lo, L09_lo)\n            T1_hi = XOR(D_hi, L09_hi)\n            T2_lo = XOR(D_lo, L14_lo)\n            T2_hi = XOR(D_hi, L14_hi)\n            T3_lo = XOR(D_lo, L19_lo)\n            T3_hi = XOR(D_hi, L19_hi)\n            T4_lo = XOR(D_lo, L24_lo)\n            T4_hi = XOR(D_hi, L24_hi)\n            L04_lo = T3_lo * 2^21 % 2^32 + (T3_hi % 2^32 - T3_hi % 2^11) / 2^11\n            L04_hi = T3_hi * 2^21 % 2^32 + (T3_lo % 2^32 - T3_lo % 2^11) / 2^11\n            L09_lo = T0_lo * 2^28 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^4) / 2^4\n            L09_hi = T0_hi * 2^28 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^4) / 2^4\n            L14_lo = T2_lo * 2^25 % 2^32 + (T2_hi % 2^32 - T2_hi % 2^7) / 2^7\n            L14_hi = T2_hi * 2^25 % 2^32 + (T2_lo % 2^32 - T2_lo % 2^7) / 2^7\n            L19_lo = (T4_lo % 2^32 - T4_lo % 2^8) / 2^8 + T4_hi * 2^24 % 2^32\n            L19_hi = (T4_hi % 2^32 - T4_hi % 2^8) / 2^8 + T4_lo * 2^24 % 2^32\n            L24_lo = (T1_lo % 2^32 - T1_lo % 2^9) / 2^9 + T1_hi * 2^23 % 2^32\n            L24_hi = (T1_hi % 2^32 - T1_hi % 2^9) / 2^9 + T1_lo * 2^23 % 2^32\n            D_lo = XOR(C4_lo, C1_lo * 2 + (C1_hi % 2^32 - C1_hi % 2^31) / 2^31)\n            D_hi = XOR(C4_hi, C1_hi * 2 + (C1_lo % 2^32 - C1_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L05_lo)\n            T0_hi = XOR(D_hi, L05_hi)\n            T1_lo = XOR(D_lo, L10_lo)\n            T1_hi = XOR(D_hi, L10_hi)\n            T2_lo = XOR(D_lo, L15_lo)\n            T2_hi = XOR(D_hi, L15_hi)\n            T3_lo = XOR(D_lo, L20_lo)\n            T3_hi = XOR(D_hi, L20_hi)\n            T4_lo = XOR(D_lo, L25_lo)\n            T4_hi = XOR(D_hi, L25_hi)\n            L05_lo = T4_lo * 2^14 + (T4_hi % 2^32 - T4_hi % 2^18) / 2^18\n            L05_hi = T4_hi * 2^14 + (T4_lo % 2^32 - T4_lo % 2^18) / 2^18\n            L10_lo = T1_lo * 2^20 % 2^32 + (T1_hi % 2^32 - T1_hi % 2^12) / 2^12\n            L10_hi = T1_hi * 2^20 % 2^32 + (T1_lo % 2^32 - T1_lo % 2^12) / 2^12\n            L15_lo = T3_lo * 2^8 + (T3_hi % 2^32 - T3_hi % 2^24) / 2^24\n            L15_hi = T3_hi * 2^8 + (T3_lo % 2^32 - T3_lo % 2^24) / 2^24\n            L20_lo = T0_lo * 2^27 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^5) / 2^5\n            L20_hi = T0_hi * 2^27 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^5) / 2^5\n            L25_lo = (T2_lo % 2^32 - T2_lo % 2^25) / 2^25 + T2_hi * 2^7\n            L25_hi = (T2_hi % 2^32 - T2_hi % 2^25) / 2^25 + T2_lo * 2^7\n            D_lo = XOR(C5_lo, C2_lo * 2 + (C2_hi % 2^32 - C2_hi % 2^31) / 2^31)\n            D_hi = XOR(C5_hi, C2_hi * 2 + (C2_lo % 2^32 - C2_lo % 2^31) / 2^31)\n            T1_lo = XOR(D_lo, L06_lo)\n            T1_hi = XOR(D_hi, L06_hi)\n            T2_lo = XOR(D_lo, L11_lo)\n            T2_hi = XOR(D_hi, L11_hi)\n            T3_lo = XOR(D_lo, L16_lo)\n            T3_hi = XOR(D_hi, L16_hi)\n            T4_lo = XOR(D_lo, L21_lo)\n            T4_hi = XOR(D_hi, L21_hi)\n            L06_lo = T2_lo * 2^3 + (T2_hi % 2^32 - T2_hi % 2^29) / 2^29\n            L06_hi = T2_hi * 2^3 + (T2_lo % 2^32 - T2_lo % 2^29) / 2^29\n            L11_lo = T4_lo * 2^18 + (T4_hi % 2^32 - T4_hi % 2^14) / 2^14\n            L11_hi = T4_hi * 2^18 + (T4_lo % 2^32 - T4_lo % 2^14) / 2^14\n            L16_lo = (T1_lo % 2^32 - T1_lo % 2^28) / 2^28 + T1_hi * 2^4\n            L16_hi = (T1_hi % 2^32 - T1_hi % 2^28) / 2^28 + T1_lo * 2^4\n            L21_lo = (T3_lo % 2^32 - T3_lo % 2^23) / 2^23 + T3_hi * 2^9\n            L21_hi = (T3_hi % 2^32 - T3_hi % 2^23) / 2^23 + T3_lo * 2^9\n            L01_lo = XOR(D_lo, L01_lo)\n            L01_hi = XOR(D_hi, L01_hi)\n            L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = XOR(L01_lo, AND(-1-L02_lo, L03_lo)), XOR(L02_lo, AND(-1-L03_lo, L04_lo)), XOR(L03_lo, AND(-1-L04_lo, L05_lo)), XOR(L04_lo, AND(-1-L05_lo, L01_lo)), XOR(L05_lo, AND(-1-L01_lo, L02_lo))\n            L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = XOR(L01_hi, AND(-1-L02_hi, L03_hi)), XOR(L02_hi, AND(-1-L03_hi, L04_hi)), XOR(L03_hi, AND(-1-L04_hi, L05_hi)), XOR(L04_hi, AND(-1-L05_hi, L01_hi)), XOR(L05_hi, AND(-1-L01_hi, L02_hi))\n            L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = XOR(L09_lo, AND(-1-L10_lo, L06_lo)), XOR(L10_lo, AND(-1-L06_lo, L07_lo)), XOR(L06_lo, AND(-1-L07_lo, L08_lo)), XOR(L07_lo, AND(-1-L08_lo, L09_lo)), XOR(L08_lo, AND(-1-L09_lo, L10_lo))\n            L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = XOR(L09_hi, AND(-1-L10_hi, L06_hi)), XOR(L10_hi, AND(-1-L06_hi, L07_hi)), XOR(L06_hi, AND(-1-L07_hi, L08_hi)), XOR(L07_hi, AND(-1-L08_hi, L09_hi)), XOR(L08_hi, AND(-1-L09_hi, L10_hi))\n            L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = XOR(L12_lo, AND(-1-L13_lo, L14_lo)), XOR(L13_lo, AND(-1-L14_lo, L15_lo)), XOR(L14_lo, AND(-1-L15_lo, L11_lo)), XOR(L15_lo, AND(-1-L11_lo, L12_lo)), XOR(L11_lo, AND(-1-L12_lo, L13_lo))\n            L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = XOR(L12_hi, AND(-1-L13_hi, L14_hi)), XOR(L13_hi, AND(-1-L14_hi, L15_hi)), XOR(L14_hi, AND(-1-L15_hi, L11_hi)), XOR(L15_hi, AND(-1-L11_hi, L12_hi)), XOR(L11_hi, AND(-1-L12_hi, L13_hi))\n            L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = XOR(L20_lo, AND(-1-L16_lo, L17_lo)), XOR(L16_lo, AND(-1-L17_lo, L18_lo)), XOR(L17_lo, AND(-1-L18_lo, L19_lo)), XOR(L18_lo, AND(-1-L19_lo, L20_lo)), XOR(L19_lo, AND(-1-L20_lo, L16_lo))\n            L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = XOR(L20_hi, AND(-1-L16_hi, L17_hi)), XOR(L16_hi, AND(-1-L17_hi, L18_hi)), XOR(L17_hi, AND(-1-L18_hi, L19_hi)), XOR(L18_hi, AND(-1-L19_hi, L20_hi)), XOR(L19_hi, AND(-1-L20_hi, L16_hi))\n            L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = XOR(L23_lo, AND(-1-L24_lo, L25_lo)), XOR(L24_lo, AND(-1-L25_lo, L21_lo)), XOR(L25_lo, AND(-1-L21_lo, L22_lo)), XOR(L21_lo, AND(-1-L22_lo, L23_lo)), XOR(L22_lo, AND(-1-L23_lo, L24_lo))\n            L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = XOR(L23_hi, AND(-1-L24_hi, L25_hi)), XOR(L24_hi, AND(-1-L25_hi, L21_hi)), XOR(L25_hi, AND(-1-L21_hi, L22_hi)), XOR(L21_hi, AND(-1-L22_hi, L23_hi)), XOR(L22_hi, AND(-1-L23_hi, L24_hi))\n            L01_lo = XOR(L01_lo, RC_lo[round_idx])\n            L01_hi = L01_hi + RC_hi[round_idx]      -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR\n         end\n         lanes_lo[1]  = L01_lo\n         lanes_hi[1]  = L01_hi\n         lanes_lo[2]  = L02_lo\n         lanes_hi[2]  = L02_hi\n         lanes_lo[3]  = L03_lo\n         lanes_hi[3]  = L03_hi\n         lanes_lo[4]  = L04_lo\n         lanes_hi[4]  = L04_hi\n         lanes_lo[5]  = L05_lo\n         lanes_hi[5]  = L05_hi\n         lanes_lo[6]  = L06_lo\n         lanes_hi[6]  = L06_hi\n         lanes_lo[7]  = L07_lo\n         lanes_hi[7]  = L07_hi\n         lanes_lo[8]  = L08_lo\n         lanes_hi[8]  = L08_hi\n         lanes_lo[9]  = L09_lo\n         lanes_hi[9]  = L09_hi\n         lanes_lo[10] = L10_lo\n         lanes_hi[10] = L10_hi\n         lanes_lo[11] = L11_lo\n         lanes_hi[11] = L11_hi\n         lanes_lo[12] = L12_lo\n         lanes_hi[12] = L12_hi\n         lanes_lo[13] = L13_lo\n         lanes_hi[13] = L13_hi\n         lanes_lo[14] = L14_lo\n         lanes_hi[14] = L14_hi\n         lanes_lo[15] = L15_lo\n         lanes_hi[15] = L15_hi\n         lanes_lo[16] = L16_lo\n         lanes_hi[16] = L16_hi\n         lanes_lo[17] = L17_lo\n         lanes_hi[17] = L17_hi\n         lanes_lo[18] = L18_lo\n         lanes_hi[18] = L18_hi\n         lanes_lo[19] = L19_lo\n         lanes_hi[19] = L19_hi\n         lanes_lo[20] = L20_lo\n         lanes_hi[20] = L20_hi\n         lanes_lo[21] = L21_lo\n         lanes_hi[21] = L21_hi\n         lanes_lo[22] = L22_lo\n         lanes_hi[22] = L22_hi\n         lanes_lo[23] = L23_lo\n         lanes_hi[23] = L23_hi\n         lanes_lo[24] = L24_lo\n         lanes_hi[24] = L24_hi\n         lanes_lo[25] = L25_lo\n         lanes_hi[25] = L25_hi\n      end\n   end\n\nend\n\n\n--------------------------------------------------------------------------------\n-- MAGIC NUMBERS CALCULATOR\n--------------------------------------------------------------------------------\n-- Q:\n--    Is 53-bit \"double\" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?\n-- A:\n--    Yes, 53-bit \"double\" arithmetic is enough.\n--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton\'s method.\n\ndo\n   local function mul(src1, src2, factor, result_length)\n      -- src1, src2 - long integers (arrays of digits in base 2^24)\n      -- factor - small integer\n      -- returns long integer result (src1 * src2 * factor) and its floating point approximation\n      local result, carry, value, weight = {}, 0.0, 0.0, 1.0\n      for j = 1, result_length do\n         for k = math_max(1, j + 1 - #src2), math_min(j, #src1) do\n            carry = carry + factor * src1[k] * src2[j + 1 - k]  -- \"int32\" is not enough for multiplication result, that\'s why \"factor\" must be of type \"double\"\n         end\n         local digit = carry % 2^24\n         result[j] = floor(digit)\n         carry = (carry - digit) / 2^24\n         value = value + digit * weight\n         weight = weight * 2^24\n      end\n      return result, value\n   end\n\n   local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo\n   repeat\n      p = p + step[p % 6]\n      local d = 1\n      repeat\n         d = d + step[d % 6]\n         if d*d > p then -- next prime number is found\n            local root = p^(1/3)\n            local R = root * 2^40\n            R = mul({R - R % 1}, one, 1.0, 2)\n            local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)\n            local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n            local lo = R[1] % 256 * 16777216 + floor(delta * (2^-56 / 3) * root / p)\n            if idx < 16 then\n               root = p^(1/2)\n               R = root * 2^40\n               R = mul({R - R % 1}, one, 1.0, 2)\n               _, delta = mul(R, R, -1.0, 2)\n               local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n               local lo = R[1] % 256 * 16777216 + floor(delta * 2^-17 / root)\n               local idx = idx % 8 + 1\n               sha2_H_ext256[224][idx] = lo\n               sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor\n               if idx > 7 then\n                  sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]\n               end\n            end\n            idx = idx + 1\n            sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor\n            break\n         end\n      until p % d == 0\n   until idx > 79\nend\n\n-- Calculating IVs for SHA512/224 and SHA512/256\nfor width = 224, 256, 32 do\n   local H_lo, H_hi = {}\n   if XOR64A5 then\n      for j = 1, 8 do\n         H_lo[j] = XOR64A5(sha2_H_lo[j])\n      end\n   else\n      H_hi = {}\n      for j = 1, 8 do\n         H_lo[j] = XOR32A5(sha2_H_lo[j])\n         H_hi[j] = XOR32A5(sha2_H_hi[j])\n      end\n   end\n   sha512_feed_128(H_lo, H_hi, \"SHA-512/\"..tostring(width)..\"\\128\"..string_rep(\"\\0\", 115)..\"\\88\", 0, 128)\n   sha2_H_ext512_lo[width] = H_lo\n   sha2_H_ext512_hi[width] = H_hi\nend\n\n-- Constants for MD5\ndo\n   local sin, abs, modf = math.sin, math.abs, math.modf\n   for idx = 1, 64 do\n      -- we can\'t use formula floor(abs(sin(idx))*2^32) because its result may be beyond integer range on Lua built with 32-bit integers\n      local hi, lo = modf(abs(sin(idx)) * 2^16)\n      md5_K[idx] = hi * 65536 + floor(lo * 2^16)\n   end\nend\n\n-- Constants for SHA3\ndo\n   local sh_reg = 29\n   local function next_bit()\n      local r = sh_reg % 2\n      sh_reg = XOR_BYTE((sh_reg - r) / 2, 142 * r)\n      return r\n   end\n   for idx = 1, 24 do\n      local lo, m = 0\n      for _ = 1, 6 do\n         m = m and m * m * 2 or 1\n         lo = lo + next_bit() * m\n      end\n      local hi = next_bit() * m\n      sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak\n   end\nend\n\n\n--------------------------------------------------------------------------------\n-- MAIN FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal function sha256ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(sha2_H_ext256[width])}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha256_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha256_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process 2^53 bytes of data by using this Lua script :-)\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha256_feed_64(H, final_blocks, 0, #final_blocks)\n            local max_reg = width / 32\n            for j = 1, max_reg do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H, \"\", 1, max_reg)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA256 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha512ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local length, tail, H_lo, H_hi = 0.0, \"\", {unpack(sha2_H_ext512_lo[width])}, not HEX64 and {unpack(sha2_H_ext512_hi[width])}\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 128 then\n               offs = 128 - #tail\n               sha512_feed_128(H_lo, H_hi, tail..sub(message_part, 1, offs), 0, 128)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 128\n            sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-17-length) % 128 + 9)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-17 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move floating point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)\n            local max_reg = ceil(width / 64)\n            if HEX64 then\n               for j = 1, max_reg do\n                  H_lo[j] = HEX64(H_lo[j])\n               end\n            else\n               for j = 1, max_reg do\n                  H_lo[j] = HEX(H_hi[j])..HEX(H_lo[j])\n               end\n               H_hi = nil\n            end\n            H_lo = sub(table_concat(H_lo, \"\", 1, max_reg), 1, width / 4)\n         end\n         return H_lo\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA512 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function md5(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H, 1, 4)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               md5_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            md5_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64)}\n            tail = nil\n            length = length * 8  -- convert \"byte-counter\" to \"bit-counter\"\n            for j = 4, 11 do\n               local low_byte = length % 256\n               final_blocks[j] = char(low_byte)\n               length = (length - low_byte) / 256\n            end\n            final_blocks = table_concat(final_blocks)\n            md5_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 4 do\n               H[j] = HEX(H[j])\n            end\n            H = gsub(table_concat(H), \"(..)(..)(..)(..)\", \"%4%3%2%1\")\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the MD5 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha1(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha1_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha1_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha1_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 5 do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA-1 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)\n   -- \"block_size_in_bytes\" is multiple of 8\n   if type(digest_size_in_bytes) ~= \"number\" then\n      -- arguments in SHAKE are swapped:\n      --    NIST FIPS 202 defines SHAKE(message,num_bits)\n      --    this module   defines SHAKE(num_bytes,message)\n      -- it\'s easy to forget about this swap, hence the check\n      error(\"Argument \'digest_size_in_bytes\' must be a number\", 2)\n   end\n\n   -- Create an instance (private objects for current calculation)\n   local tail, lanes_lo, lanes_hi = \"\", create_array_of_lanes(), hi_factor_keccak == 0 and create_array_of_lanes()\n   local result\n\n--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),\n--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)\n--~     initialize the state S to a string of b 0 bits.\n--~     absorb the input into the state: For each block Pi,\n--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,\n--~         XOR that with S and\n--~         apply the block permutation f to the result, yielding a new state S\n--~     initialize Z to be the empty string\n--~     while the length of Z is less than d:\n--~         append the first r bits of S to Z\n--~         if Z is still less than d bits long, apply f to S, yielding a new state S.\n--~     truncate Z to d bits\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= block_size_in_bytes then\n               offs = block_size_in_bytes - #tail\n               keccak_feed(lanes_lo, lanes_hi, tail..sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % block_size_in_bytes\n            keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            -- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1\n            local gap_start = is_SHAKE and 31 or 6\n            tail = tail..(#tail + 1 == block_size_in_bytes and char(gap_start + 128) or char(gap_start)..string_rep(\"\\0\", (-2 - #tail) % block_size_in_bytes)..\"\\128\")\n            keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)\n            tail = nil\n\n            local lanes_used = 0\n            local total_lanes = floor(block_size_in_bytes / 8)\n            local qwords = {}\n\n            local function get_next_qwords_of_digest(qwords_qty)\n               -- returns not more than \'qwords_qty\' qwords (\'qwords_qty\' might be non-integer)\n               -- doesn\'t go across keccak-buffer boundary\n               -- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords\n               if lanes_used >= total_lanes then\n                  keccak_feed(lanes_lo, lanes_hi, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 0, 8, 8)\n                  lanes_used = 0\n               end\n               qwords_qty = floor(math_min(qwords_qty, total_lanes - lanes_used))\n               if hi_factor_keccak ~= 0 then\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])\n                  end\n               else\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX(lanes_hi[lanes_used + j])..HEX(lanes_lo[lanes_used + j])\n                  end\n               end\n               lanes_used = lanes_used + qwords_qty\n               return\n                  gsub(table_concat(qwords, \"\", 1, qwords_qty), \"(..)(..)(..)(..)(..)(..)(..)(..)\", \"%8%7%6%5%4%3%2%1\"),\n                  qwords_qty * 8\n            end\n\n            local parts = {}      -- digest parts\n            local last_part, last_part_size = \"\", 0\n\n            local function get_next_part_of_digest(bytes_needed)\n               -- returns \'bytes_needed\' bytes, for arbitrary integer \'bytes_needed\'\n               bytes_needed = bytes_needed or 1\n               if bytes_needed <= last_part_size then\n                  last_part_size = last_part_size - bytes_needed\n                  local part_size_in_nibbles = bytes_needed * 2\n                  local result = sub(last_part, 1, part_size_in_nibbles)\n                  last_part = sub(last_part, part_size_in_nibbles + 1)\n                  return result\n               end\n               local parts_qty = 0\n               if last_part_size > 0 then\n                  parts_qty = 1\n                  parts[parts_qty] = last_part\n                  bytes_needed = bytes_needed - last_part_size\n               end\n               -- repeats until the length is enough\n               while bytes_needed >= 8 do\n                  local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = next_part\n                  bytes_needed = bytes_needed - next_part_size\n               end\n               if bytes_needed > 0 then\n                  last_part, last_part_size = get_next_qwords_of_digest(1)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = get_next_part_of_digest(bytes_needed)\n               else\n                  last_part, last_part_size = \"\", 0\n               end\n               return table_concat(parts, \"\", 1, parts_qty)\n            end\n\n            if digest_size_in_bytes < 0 then\n               result = get_next_part_of_digest\n            else\n               result = get_next_part_of_digest(digest_size_in_bytes)\n            end\n\n         end\n         return result\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA3 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal hex2bin, bin2base64, base642bin\ndo\n\n   function hex2bin(hex_string)\n      return (gsub(hex_string, \"%x%x\",\n         function (hh)\n            return char(tonumber(hh, 16))\n         end\n      ))\n   end\n\n   local base64_symbols = {\n      [\'+\'] = 62, [\'-\'] = 62,  [62] = \'+\',\n      [\'/\'] = 63, [\'_\'] = 63,  [63] = \'/\',\n      [\'=\'] = -1, [\'.\'] = -1,  [-1] = \'=\'\n   }\n   local symbol_index = 0\n   for j, pair in ipairs{\'AZ\', \'az\', \'09\'} do\n      for ascii = byte(pair), byte(pair, 2) do\n         local ch = char(ascii)\n         base64_symbols[ch] = symbol_index\n         base64_symbols[symbol_index] = ch\n         symbol_index = symbol_index + 1\n      end\n   end\n\n   function bin2base64(binary_string)\n      local result = {}\n      for pos = 1, #binary_string, 3 do\n         local c1, c2, c3, c4 = byte(sub(binary_string, pos, pos + 2)..\'\\0\', 1, -1)\n         result[#result + 1] =\n            base64_symbols[floor(c1 / 4)]\n            ..base64_symbols[c1 % 4 * 16 + floor(c2 / 16)]\n            ..base64_symbols[c3 and c2 % 16 * 4 + floor(c3 / 64) or -1]\n            ..base64_symbols[c4 and c3 % 64 or -1]\n      end\n      return table_concat(result)\n   end\n\n   function base642bin(base64_string)\n      local result, chars_qty = {}, 3\n      for pos, ch in gmatch(gsub(base64_string, \'%s+\', \'\'), \'()(.)\') do\n         local code = base64_symbols[ch]\n         if code < 0 then\n            chars_qty = chars_qty - 1\n            code = 0\n         end\n         local idx = pos % 4\n         if idx > 0 then\n            result[-idx] = code\n         else\n            local c1 = result[-1] * 4 + floor(result[-2] / 16)\n            local c2 = (result[-2] % 16) * 16 + floor(result[-3] / 4)\n            local c3 = (result[-3] % 4) * 64 + code\n            result[#result + 1] = sub(char(c1, c2, c3), 1, chars_qty)\n         end\n      end\n      return table_concat(result)\n   end\n\nend\n\n\nlocal block_size_for_HMAC  -- this table will be initialized at the end of the module\n\nlocal function pad_and_xor(str, result_length, byte_for_xor)\n   return gsub(str, \".\",\n      function(c)\n         return char(XOR_BYTE(byte(c), byte_for_xor))\n      end\n   )..string_rep(char(byte_for_xor), result_length - #str)\nend\n\nlocal function hmac(hash_func, key, message)\n\n   -- Create an instance (private objects for current calculation)\n   local block_size = block_size_for_HMAC[hash_func]\n   if not block_size then\n      error(\"Unknown hash function\", 2)\n   end\n   if #key > block_size then\n      key = hex2bin(hash_func(key))\n   end\n   local append = hash_func()(pad_and_xor(key, block_size, 0x36))\n   local result\n\n   local function partial(message_part)\n      if not message_part then\n         result = result or hash_func(pad_and_xor(key, block_size, 0x5C)..hex2bin(append()))\n         return result\n      elseif result then\n         error(\"Adding more chunks is not allowed after receiving the result\", 2)\n      else\n         append(message_part)\n         return partial\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the HMAC of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading of a message\n      -- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal sha = {\n   md5        = md5,                                                                                                                   -- MD5\n   sha1       = sha1,                                                                                                                  -- SHA-1\n   -- SHA2 hash functions:\n   sha224     = function (message)                       return sha256ext(224, message)                                           end, -- SHA-224\n   sha256     = function (message)                       return sha256ext(256, message)                                           end, -- SHA-256\n   sha512_224 = function (message)                       return sha512ext(224, message)                                           end, -- SHA-512/224\n   sha512_256 = function (message)                       return sha512ext(256, message)                                           end, -- SHA-512/256\n   sha384     = function (message)                       return sha512ext(384, message)                                           end, -- SHA-384\n   sha512     = function (message)                       return sha512ext(512, message)                                           end, -- SHA-512\n   -- SHA3 hash functions:\n   sha3_224   = function (message)                       return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)             end, -- SHA3-224\n   sha3_256   = function (message)                       return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)             end, -- SHA3-256\n   sha3_384   = function (message)                       return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)             end, -- SHA3-384\n   sha3_512   = function (message)                       return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)             end, -- SHA3-512\n   shake128   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message) end, -- SHAKE128\n   shake256   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message) end, -- SHAKE256\n   -- misc utilities:\n   hmac       = hmac,       -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*\n   hex2bin    = hex2bin,    -- converts hexadecimal representation to binary string\n   base642bin = base642bin, -- converts base64 representation to binary string\n   bin2base64 = bin2base64, -- converts binary string to base64 representation\n}\n\n\nblock_size_for_HMAC = {\n   [sha.md5]        = 64,\n   [sha.sha1]       = 64,\n   [sha.sha224]     = 64,\n   [sha.sha256]     = 64,\n   [sha.sha512_224] = 128,\n   [sha.sha512_256] = 128,\n   [sha.sha384]     = 128,\n   [sha.sha512]     = 128,\n   [sha.sha3_224]   = (1600 - 2 * 224) / 8,\n   [sha.sha3_256]   = (1600 - 2 * 256) / 8,\n   [sha.sha3_384]   = (1600 - 2 * 384) / 8,\n   [sha.sha3_512]   = (1600 - 2 * 512) / 8,\n}\n\n\nreturn sha\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "knit/knit",
hash = "f970f1c39a6d5c0efb2404104c3208320bfecd290c3ce2cd8e1eb0894ef5ff48",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal s = require \"status:status\" ()\nlocal a = require \"singletons/anterm\"\ns.chatty = true\ns.verbose = false\n\nlocal pl_mini = require \"orb:util/plmini\"\nlocal read, write, delete = pl_mini.file.read,\n                            pl_mini.file.write,\n                            pl_mini.file.delete\n\n\nlocal knitter = require \"orb:knit/knitter\"\n\nlocal Dir = require \"fs:fs/directory\"\nlocal Path = require \"fs:fs/path\"\nlocal File = require \"fs:fs/file\"\nlocal walk = require \"orb:walk/walk\"\n\nlocal Doc = require \"orb:Orbit/doc\"\n\n\n\n\n\n\n\n\n\n\n\nlocal function knitDeck(deck)\n    local dir = deck.dir\n    local codex = deck.codex\n    local orbDir = codex.orb\n    local srcDir = codex.src\n    -- #todo load .deck file here\n    for i, sub in ipairs(deck) do\n        knitDeck(sub)\n    end\n    for name, doc in pairs(deck.docs) do\n        local knitted, ext = knitter:knit(doc)\n        if knitted then\n            -- add to srcs\n            local srcpath = Path(name):subFor(orbDir, srcDir, ext)\n            s:verb(\"knitted: \" .. name)\n            s:verb(\"into:    \" .. tostring(srcpath))\n            deck.srcs[srcpath] = knitted\n            codex.srcs[srcpath] = knitted\n            walk.writeOnChange(srcpath, knitted)\n        end\n\n    end\n    return deck.srcs\nend\n\nlocal function knitCodex(codex)\n    local orb = codex.orb\n    local src = codex.src\n    s:chat(\"knitting orb directory: \" .. tostring(orb))\n    s:chat(\"into src directory: \" .. tostring(src))\n    knitDeck(orb)\nend\nknitter.knitCodex = knitCodex\n\n\nreturn knitter\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "lume/deck",
hash = "ebb0960fd4619cc4036922932d1da0759b777dfd0b74e4f43a098bb56cdf11ef",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\nlocal s   = require \"status:status\" ()\ns.verbose = false\ns.chatty  = true\n\nlocal Dir = require \"fs:fs/directory\"\n\n\n\nlocal new;\n\nlocal Deck = {}\nDeck.__index = Deck\nlocal __Decks = setmetatable({}, { __mode = \"kv\" })\n\n\n\n-- ignore a few critters that can show up\nlocal decIgnore = {\".DS_Store\", \".git\"}\n\nlocal function ignore(file)\n   local willIgnore = false\n   local basename = file:basename()\n   for _, str in ipairs(decIgnore) do\n      willIgnore = willIgnore or basename == str\n   end\n   -- Goddammit Dropbox\n   willIgnore = willIgnore or (string.find(tostring(file), \"%.%_\") ~= nil)\n   return willIgnore\nend\n\n\n\n\n\n\n\n\n\nlocal new\n\nlocal function case(deck)\n   s:verb(\"dir: \" .. tostring(deck.dir))\n   local dir = deck.dir\n   local lume = deck.lume\n   local basename = dir:basename()\n   assert(dir.idEst == Dir, \"dir not a directory\")\n   local lumeRoot = lume.root:basename()\n   s:verb(\"root: \" .. tostring(lume.root) .. \" base: \" ..tostring(lumeRoot))\n   local subdirs = dir:getsubdirs()\n   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)\n   for i, sub in ipairs(subdirs) do\n      s:verb(\"  - \" .. sub.path.str)\n      deck[i] = new(lume, sub)\n   end\n   local files = dir:getfiles()\n   s:verb(\"  \" .. \"# files: \" .. #files)\n   for i, file in ipairs(files) do\n      if not ignore(file) then\n         lume.shuttle:push(file)\n         --[[not using eponyms, if it doesn\'t come up, delete this\n         local name = file:basename()\n         if #file:extension() > 1 then\n            name = string.sub(name, 1, - #file:extension() - 1)\n         end\n         if name == basename then\n            s:verb(\"  ~ \" .. name)\n            deck.eponym = file\n         end\n         --]]\n      end\n   end\n\n   s:verb(\"#deck is : \" .. #deck)\n   return lume\nend\n\nDeck.case = case\n\n\n\nnew = function (lume, dir)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   s:verb(\"directory: %s\", tostring(dir))\n   if __Decks[dir] then\n      return __Decks[dir]\n   end\n   local deck = setmetatable({}, Deck)\n   deck.dir = dir\n   deck.lume = lume\n   deck.files  = {}\n   case(deck)\n   return deck\nend\n\n\n\n\nDeck.idEst = new\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/codeblock",
hash = "7a84c0a14624db41c0977eea601e533c5f3352bccd2218b7fe29403a1aeb302e",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal code_str = [[\n    codeblock  â†  code-start code-body  code-end\n   code-start  â†  start-mark code-type? (WS name)* rest* NL\n   start-mark  â†  \"#\" \"!\"+\n           NL  â†  \"\\n\"\n           WS  â†  \" \"+\n    code-body  â†  (!code-end 1)+\n     code-end  â†  end-mark code-type? execute* (!\"\\n\" 1)* line-end\n               /  -1\n     end-mark  â†  \"#\" \"/\"+\n    code-type  â†  symbol\n    line-end   â†  (\"\\n\\n\" \"\\n\"* / \"\\n\")* (-1)\n         name  â†  handle\n      execute  â†  \"(\" \" \"* \")\"\n       `rest`  â†  (handle / hashtag / raw)+\n         raw   â†  (!handle !hashtag !\"\\n\" 1)+\n]] .. fragments.symbol .. fragments.handle .. fragments.hashtag\n\n\n\nlocal Code_M = Twig :inherit \"codeblock\"\n\n\n\nfunction Code_M.toMarkdown(codeblock, skein)\n   local phrase = Phrase \"```\"\n   phrase = phrase .. codeblock :select \"code_type\"() :span() .. \"\\n\"\n   phrase = phrase .. codeblock :select \"code_body\"() :span()\n   local code_end = codeblock :select \"code_end\"()\n   local line_end\n   if not code_end[1] then\n      line_end = \"\\n\"\n      -- might be a missing newline\n      if not tostring(phrase):sub(-1) == \"\\n\" then\n         phrase = phrase .. \"\\n\"\n      end\n   else\n      line_end = code_end :select \"line_end\"() :span()\n   end\n   return phrase .. \"```\" .. line_end\nend\n\n\n\nlocal code_peg = Peg(code_str, { Twig, codeblock = Code_M })\n\n\n\n\n\nreturn subGrammar(code_peg.parse, nil, \"code-nomatch\")\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/list-line",
hash = "2a2247721ec4f46e701ae39f857d71d7de698a54af3fe938d573ae97e93780ba",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Peg = require \"espalier:espalier/peg\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal prose = require \"orb:orb/prose\"\nlocal anterm = require \"anterm:anterm\"\n\n\n\nlocal listline_str = [[\n     list-line  â†  depth number* sep WS\n                   (cookie / radio)*\n                   (key colon text / text) cookie* list-end\n         depth  â†  \" \"*\n        number  â†  [0-9]+\n           sep  â†  \"-\" / \".\"\n        cookie  â†  \"[\" (!\"]\" 1)+ \"]\"\n         radio  â†  \"(\" 1 \")\" ; this should be one utf-8 character\n           key  â†  (!\":\" 1)+\n         colon  â†  \":\" &(ws (!ws 1))\n          text  â†  ((!cookie 1)* \"[\" (!\"]\" 1)+ \"]\" (!list-end !cookie 1)+)+\n                /  (!cookie !list-end 1)+\n            WS  â†  ws\n          `ws`  â†  { \\n}+\n      list-end  â†  \"\\n\"* -1\n]]\n\n\n\n\n\n\n\nlocal Sep = Twig:inherit \'sep\'\n\nfunction Sep.toMarkdown(sep)\n   return sep:span()\nend\n\n\n\n\n\n\nlocal Cookie = Twig:inherit \'cookie\'\nCookie.toMarkdown = Sep.toMarkdown\n\n\n\n\n\n\nlocal listline_Meta = { Twig,\n                        text = prose,\n                        sep = Sep,\n                        cookie = Cookie }\nlocal listline_grammar = Peg(listline_str, listline_Meta).parse\n\n\n\n\n\n\n\n\nlocal Listline = Twig:inherit \"list_line\"\n\n\nlocal super_strExtra = Twig . strExtra\n\nfunction Listline.strExtra(list_line)\n   local phrase = super_strExtra(list_line)\n   return phrase .. anterm.magenta(tostring(list_line.indent))\nend\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nfunction Listline.toMarkdown(list_line)\n   local phrase = \"\"\n   for _, node in ipairs(list_line) do\n      phrase = phrase .. node:toMarkdown()\n   end\n   local level_space = \"\\n\" .. (\" \"):rep(list_line.indent + 2)\n   return gsub(tostring(phrase), \'\\n[ ]+\', level_space)\nend\n\n\n\n\nlocal function listline_fn(t)\n   local match = listline_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t. last then\n         -- label the match according to the rule\n         match.id = t.id or \"list_line\"\n         match.indent = match:select\"sep\"().last - match.first + 2\n         return setmetatable(match, Listline)\n       else\n         match.id = t.id .. \"_INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   t.id = \"listline_nomatch\"\n   return setmetatable(t, Twig)\nend\n\n\n\n\n\nreturn listline_fn\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/block",
hash = "14d56fe96805e9dc7b810c5792b997d8f3dc2ed35256ef6890811433791a1bc5",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal Node = require \"espalier/node\"\nlocal Codeblock = require \"orb:Orbit/codeblock\"\nlocal Structure = require \"orb:Orbit/structure\"\nlocal Prose = require \"orb:Orbit/prose\"\n\nlocal s = require \"status:status\" ()\n\nlocal m = require \"orb:Orbit/morphemes\"\n\n\n\n\n\n\nlocal B = setmetatable({}, { __index = Node })\nB.__index = B\n\nB.__tostring = function(block)\n    return \"Block\"\nend\n\nfunction B.addLine(block, line)\n    if L.match(m.tagline_hash_p, line) then\n        block[#block + 1] = Structure(line, \"hashline\", block.str)\n    elseif L.match(m.tagline_handle_p, line) then\n        block[#block + 1] = Structure(line, \"handleline\", block.str)\n        -- Eventually Blocks won\'t have lines, meantime:\n    else\n        block.lines[#block.lines + 1] = line\n    end\n\n    return block\nend\n\n\n\n\n\n\nfunction B.parseProse(block)\n    if block[1] then\n        if block[1].id == \"codeblock\" then\n            return \"\"\n        end\n    else\n        block[1] = Prose(block)\n        block.lines = nil\n        return block[1]\n    end\nend\n\n\n\n\n\n\n\n\nfunction B.toString(block)\n    local phrase = \"\"\n    if type(block.lines) == \"table\" then\n        for _,v in ipairs(block.lines) do\n            phrase = phrase .. v .. \"\\n\"\n        end\n    end\n    return phrase\nend\n\nfunction B.toValue(block)\n    block.val = block:toString()\n    return block.val\nend\n\nfunction B.toMarkdown(block)\n    if block[1] and (block[1].id == \"codeblock\"\n      or block[1].id == \"prose\") then\n        return block[1]:toMarkdown()\n    else\n        return block:toString()\n    end\nend\n\nfunction B.dotLabel(block)\n    return \"block \" .. tostring(block.line_first)\n        .. \"-\" .. tostring(block.line_last)\nend\n\n\n\n\n\n\nlocal b = {}\n\nlocal function new(Block, lines, linum, str)\n    local block = setmetatable({}, B)\n    block.lines = {}\n    block.line_first = linum\n    if (lines) then\n        if type(lines) == \"string\" then\n            block:addLine(lines)\n        elseif type(lines) == \"table\" then\n            for _, l in ipairs(lines) do\n                block:addLine(l)\n            end\n        else\n            freeze(\"Error: in block.new type of `lines` is \" .. type(lines))\n        end\n    end\n\n    block.id = \"block\"\n    return block\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function structureOrProse(line)\n    if L.match(m.tagline_p, line) then\n        return true, \"tagline\"\n    elseif L.match(m.listline_p, line) then\n        return true, \"listline\"\n    elseif L.match(m.tableline_p, line) then\n        return true, \"tableline\"\n    end\n    return false, \"\"\nend\n\nb[\"__call\"] = new\nb[\"__index\"] = b\n\nreturn setmetatable({}, b)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "spec/walk-spec",
hash = "7f5599a87a5be935c9a570b1e726a1b4cbbcf23d148ac5b99042582989972dc3",
branch = "list-subgrammar",
binary = "\n\n\n\nlocal Path = require \"fs:fs/path\"\nlocal Dir  = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\n\nlocal Spec = {}\n\nSpec.folder = \"walk\"\nSpec.it = require \"singletons/check\"\n\nfunction Spec.path()\n   local a = Path \"/kore/build\"\n   local b = a .. \"/codex.orb\"\n   local c = a .. \"/orb\"\n   local d = Path \"/kore/build/orb\"\n   local a1, b1\n   -- new way\n   b, b1 = b: it \"file-path\"\n      : must \"have some fields\"\n         : have \"str\"\n         : equalTo \"/kore/build/codex.orb\"\n         : ofLen(#b.str)\n      : must (\"return the requested directory path\")\n         : have \"idEst\"\n         : equalTo(Path)\n         : have \"parentDir\"\n         : calling ()\n         : gives (Path \"/kore/build\")\n         : feels()\n      : must()\n         : have \"filename\"\n         : equalTo \"codex.orb\"\n         : fin()()\n\n   c = c : it \"equals-d\"\n         : must ()\n             : equal(d)\n             : fin()()\n   d = d : it \"with-relpath\"\n         : must ()\n            : have \"relPath\"\n            : calling (Path \"/core\")\n            : gives (Path \"build/orb\")\n            : fin()\n\n   a, a1 = a: it \"a well-behaved Path\"\n              : mustnt ()\n                 : have \"brack\"\n                 : have \"broil\"\n              : shouldnt()\n                 : have \"badAttitude\"\n                 : fin()()\nend\n\n\n\nfunction Spec.dir()\n   local a = Dir \"/usr/\"\n          : it (\"the /usr/ directory\")\n             : has (\"exists\")\n             : calling()\n             : gives(true)\n             : has \"idEst\"\n             : equalTo (Dir)\n             : calledWith(\"attributes\")\n             : has \"attr\"\n             : whichHas \"ino\"\n             : fin()\n\n   local b = Dir \"/imaginary-in-almost-any-conceivable-case\"\n          : it(\"imaginary directory\")\n              : has \"exists\"\n              : calling()\n              : should()\n              : give (false)\n              : fin()\n\n   local c = Dir \"/usr/tmp\"\n          : it \"swap-directory\"\n          : must \"have basename tmp\"\n            : has \"basename\"\n            : calling()\n            : gives \"tmp\"\n          : must \"swap /usr for /tmp\"\n            : have \"swapDirFor\"\n            : calling(\"/usr\", \"/tmp\")\n            : gives(Dir \"/tmp/tmp\")\n            : fin()\n\nend\n\n\n\n\nfunction Spec.file()\n   local a = File \"/orb/orb.orb\"\n        : it \"orb-file\"\n        : must \"have path\"\n          : have \"path\"\n          : equalTo(Path \"/orb/orb.orb\")\n          : passedTo(tostring)\n          : gives(\"/orb/orb.orb\")\n        : must \"give extension \'orb\'\"\n          : calledWith \"extension\"\n          : gives \".orb\"\n          : fin()\n   local b = File \"/bin/sh\"\n       : it(\"shell\")\n         : has \"exists\"\n         : calling ()\n         : gives (true)\n         : calledWith \"extension\"\n         : gives \"\"\n         : calledWith \"basename\"\n         : gives \"sh\"\n         : fin()\nend\n\n\n\nreturn function()\n          Spec.path()\n          Spec.dir()\n          Spec.file()\n          return Spec:it():allReports()\n       end\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/orbital/tag-engine",
hash = "305c5900a44e55bfc036adcc633de32c2321dc660a654906ea595c34c4e5bc73",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal TagEngine = require \"stator\" ()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_code_table = [[\nCREATE TABLE IF NOT EXISTS code (\n   code_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,\n   binary BLOB NOT NULL\n);\n]]\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "concordance/concordance",
hash = "5a22285894ef0f61b02b162eb6d5043a356438b3e8b608b2fd6f74139c905d5e",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint (\n   codepoint_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   codevalue NOT NULL,\n   utf INTEGER default 1,\n   category STRING NOT NULL DEFAULT \'utf\',\n   version STRING NOT NULL DEFAULT \'official\',\n   destription STRING NOT NULL,\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint_in (\n   codepoint_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   document UNIQUE, NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   codepoint INTEGER NOT NULL,\n   doc INTEGER NOT NULL,\n   document INTEGER NOT NULL,\n   FOREIGN KEY codepoint\n      REFERENCES codepoint (codepoint_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word (\n   word_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word STRING UNIQUE NOT NULL ON CONFLICT DO NOTHING,\n   -- JSON array of codepoint_ids\n   spelling BLOB NOT NULL ON CONFLICT DO NOTHING,\n   thesaurus INTEGER,\n   FOREIGN KEY thesaurus\n      REFERENCES thesaurus (thesaurus_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word_in (\n   word_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word_repr STRING NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   word INTEGER,\n   doc INTEGER,\n   document INTEGER,\n   FOREIGN KEY word\n      REFERENCES word (word_id),\n   FOREIGN KEY doc\n      REFERENCE doc (doc_id)\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/hashtag",
hash = "b91b5f358c21682cbc596fbd8e5a4299781248917e366ad5b7e2bba9afe8f9b7",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal Node = require \"espalier/node\"\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\nlocal m = require \"orb:Orbit/morphemes\"\n\nlocal H, h = u.inherit(Node)\n\nfunction h.matchHashtag(line)\n    local hashlen = L.match(L.C(m.hashtag), line)\n    if hashlen then\n        return hashlen\n    else\n        return \"\"\n        -- This is what it /should/ do, but\n        -- u.freeze(\"Hashtag constructor did not match m.hashtag rule on:  \" .. line)\n    end\nend\n\nlocal function new(Hashtag, line)\n    local hashtag = setmetatable({}, H)\n    hashtag.id = \"hashtag\"\n    hashtag.val = h.matchHashtag(line):sub(2, -1)\n\n    return hashtag\nend\n\nreturn u.export(h, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/list",
hash = "73b760902bcee14a89177d3ce8490b30143988774e3e340365795c8296a04bb3",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\nlocal subgrammar = require \"espalier:espalier/subgrammar\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal list_str = [[\n     list\n]]\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/metas/headermetas",
hash = "6c27c348e555e5b010c93f4bb06e5d2426994b0ec5623b1461ac92e07df19357",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal Phrase = require \"singletons:singletons/phrase\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal Header_M = {}\n\n\n\nlocal Header = Twig:inherit \"header\"\nHeader_M.header = Header\n\n\n\n\n\nfunction Header.toMarkdown(header, skein)\n   local phrase = Phrase ((\"#\"):rep(header:select(\"level\")():len()))\n   local head_line = header :select \"head_line\"()\n   if head_line then\n      return phrase .. head_line :toMarkdown(skein)\n   else\n      return phrase\n   end\nend\n\n\n\nreturn Header_M\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "lume/lume",
hash = "b2d379527f8140046142858b0ba4e7af193652d4fd33f54bdbe4c927eebac292",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal sql = assert(sql)\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal git_info = require \"orb:util/gitinfo\"\nlocal Skein = require \"orb:skein/skein\"\nlocal Deck = require \"orb:lume/deck\"\nlocal Watcher = require \"orb:lume/watcher\"\n-- #todo replace this with /database after new toolchain lands\nlocal database = require \"orb:compile/newdatabase\"\n\nlocal Dir  = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal Path = require \"fs:fs/path\"\nlocal Deque = require \"deque:deque\"\nlocal Set = require \"set:set\"\n\n\n\n\n\n\nlocal Lume = {}\nLume.__index = Lume\n\n\n\n\n\n\nlocal _Lumes = setmetatable({}, { __mode = \"kv\" })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Net = {}\n\n\n\nfunction Net.__index(net, ref)\n   -- resolve reference\n   -- make Skein\n   -- net carries a reference to parent lume:\n   s:verb(\"initial load of \" .. tostring(ref))\n   local skein = Skein(ref, net.lume)\n   -- cache result\n   rawset(net, ref, skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.run(lume, watch)\n   -- determine if we\'re already in an event loop\n   local on_loop = uv.loop_alive()\n   local launcher = uv.new_idle()\n   launcher:start(function()\n      lume:bundle()\n      if watch then\n         -- watcher goes here\n      end\n      launcher:stop()\n   end)\n\n   if not on_loop then\n      print \"running loop\"\n      uv.run \'default\'\n   end\n   -- if there are remaining (hence broken) coroutines, run the skein again,\n   -- to try and catch the error:\n   for _, skein in pairs(lume.ondeck) do\n      s:verb(\"retry on %s\", tostring(skein.source.file))\n      local ok, err = xpcall(skein:transform(), debug.traceback)\n      if not ok then\n         s:warn(err)\n      end\n   end\n   s:verb(\"end run\")\n   return lume\nend\n\n\n\n\n\n\n\n\n\nlocal function changer(lume)\n   return function (watcher, fname)\n      local full_name = tostring(lume.orb) .. \"/\" .. fname\n      print (\"changed to \" .. full_name)\n      local skein = lume.net[File(full_name)]\n      skein:transform()\n      print (\"processed \" .. full_name)\n   end\nend\n\nlocal function renamer(lume)\n   local function onrename(watcher, fname)\n      print (\"renamed \" .. fname)\n   end\n\n   return onrename\nend\n\nfunction Lume.serve(lume)\n   s:chat(\"listening for file changes in orb/\")\n   s:chat(\"^C to exit\")\n   local on_loop = uv.loop_alive()\n   lume.server = Watcher { onchange = changer(lume),\n                            onrename = renamer(lume) }\n   lume.server(tostring(lume.orb))\n   if not on_loop then\n      uv.run \'default\'\n   end\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, resume, running, yield = assert(coroutine.create),\n                                       assert(coroutine.resume),\n                                       assert(coroutine.running),\n                                       assert(coroutine.yield)\n\nlocal function _loader(skein, lume, path)\n   s:verb(\"begin read of %s\", path)\n   local co = running()\n   lume.ondeck[co] = skein\n   skein :load() :spin() :knit() :weave() :compile()\n   s:verb(\"processed: %s\", path)\n   lume.count = lume.count - 1\n   lume.ondeck[co] = nil\n   lume.rack:insert(co)\n   local stmts, ids, git_info, now = yield()\n   skein:commit(stmts, ids, git_info, now)\n   yield()\n   skein:persist()\nend\n\nfunction Lume.bundle(lume)\n   lume.count = 0\n   -- #todo this is, ideally, temporary; we need it while things can still\n   -- break.\n   lume.ondeck = {}\n   repeat\n      local skein = lume.net[lume.shuttle:pop()]\n      local path = tostring(skein.source.file)\n      s:verb(\"loaded skein: %s\", path)\n      lume.count = lume.count + 1\n      resume(create(_loader), skein, lume, path)\n   until lume.shuttle:is_empty()\n   s:verb(\"cleared shuttle\")\n   lume:persist()\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal commitBundle, commitSkein = assert(database.commitBundle),\n                                  assert(database.commitSkein)\n\nfunction Lume.persist(lume)\n   local transactor, persistor = uv.new_idle(), uv.new_idle()\n   local transacting = true\n   local check, report = 0, 1\n\n   transactor:start(function()\n      -- watch for next phase\n      check = check + 1\n      if check == report then\n         s:verb(\"lume.count: %d\", lume.count)\n         report = report * 2\n      end\n      if check > 512 then\n         s:warn(\"bailing. lume.count: %d\", lume.count)\n         lume.count = 0\n      end\n      if lume.count > 0 then return end\n      -- report failed coroutines\n      for _, skein in pairs(lume.ondeck) do\n         s:verb(\"failed to process: %s\", tostring(skein.source.file))\n      end\n      -- set up transaction\n      local conn = lume.conn\n      local stmts, ids, now = commitBundle(lume)\n      local git_info = lume:gitInfo()\n      -- cache db info for later commits\n      lume.db = { stmts    = stmts,\n                  ids      = ids,\n                  git_info = git_info,\n                  now      = now }\n      -- make closures for transaction so we can reuse them\n      lume.db.begin = function() conn:exec [[BEGIN TRANSACTION;]] end\n      lume.db.commit = function() conn:exec [[COMMIT;]] end\n      s:chat(\"writing artifacts to database\")\n      lume.db.begin()\n      for co in pairs(lume.rack) do\n         if coroutine.status(co) ~= \'dead\' then\n            local ok, err = resume(co, stmts, ids, git_info, now)\n            if not ok then\n               error (\"coroutine broke during commit: \" .. err)\n               conn:exec \"ROLLBACK;\"\n               transacting = false\n               persistor:stop()\n               transactor:stop()\n            end\n         end\n      end\n      -- commit transaction\n      lume.db.commit()\n      -- checkpoint\n      -- use a pcall because we get a (harmless) error if the table is locked\n      -- by another process:\n      pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n      -- clean up db cache\n      lume.db.ids.bundle_id = nil\n      lume.db.now = nil\n      -- end transactor, signal persistor to act\n      transacting = false\n      transactor:stop()\n   end)\n   -- persist changed files to disk\n   persistor:start(function()\n      if transacting then return end\n      for co in pairs(lume.rack) do\n         local ok, err = resume(co)\n         if not ok then\n            error (\"coroutine broke during file write: \" .. err)\n            persistor:stop()\n         end\n      end\n      -- GC the coroutines, now that we\'re done with them\n      table.clear(lume.rack)\n      persistor:stop()\n   end)\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sh = require \"lash:lash\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction Lume.now(lume)\n   return tostring(date())\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.gitInfo(lume)\n   lume.git_info = git_info(tostring(lume.root))\n   return lume.git_info\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.projectInfo(lume)\n   local proj = {}\n   proj.name = _Bridge.args.project or lume.project\n   if lume.git_info.is_repo then\n      proj.repo_type = \"git\"\n      proj.repo = lume.git_info.url\n      proj.home = lume.home or \"\"\n      proj.website = lume.website or \"\"\n      local alts = {}\n      for _, repo in ipairs(lume.git_info.remotes) do\n         alts[#alts + 1] = repo[2] ~= proj.repo and repo[2] or nil\n      end\n      proj.repo_alternates = table.concat(alts, \"\\n\")\n   end\n   return proj\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.versionInfo(lume)\n   if not _Bridge.args.version then\n      return { is_versioned = false }\n   end\n   local version = { is_versioned = true }\n   for k,v in pairs(_Bridge.args.version) do\n      version[k] = v\n   end\n   version.edition = _Bridge.args.edition or \"\"\n   version.stage   = _Bridge.args.stage or \"SNAPSHOT\"\n   return version\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _findSubdirs(lume, dir)\n   local isCo = false\n   local orbDir, srcDir, libDir = nil, nil, nil\n   local docDir, docMdDir, docDotDir, docSvgDir = nil, nil, nil, nil\n   lume.root = dir\n   local subdirs = dir:getsubdirs()\n\n   for i, sub in ipairs(subdirs) do\n      local name = sub:basename()\n      if name == \"orb\" then\n         s:verb(\"orb: \" .. tostring(sub))\n         orbDir = sub\n         lume.orb = sub\n      elseif name == \"src\" then\n         s:verb(\"src: \" .. tostring(sub))\n         srcDir = Dir(sub)\n         lume.src = sub\n      elseif name == \"doc\" then\n         s:verb(\"doc: \" .. tostring(sub))\n         docDir = sub\n         lume.doc = sub\n         local subsubdirs = docDir:getsubdirs()\n         for j, subsub in ipairs(subsubdirs) do\n            local subname = subsub:basename()\n            if subname == \"md\" then\n               s:verb(\"doc/md: \" .. tostring(subsub))\n               docMdDir = subsub\n               lume.docMd = subsub\n            elseif subname == \"dot\" then\n               s:verb(\"doc/dot: \" .. tostring(subsub))\n               docDotDir = subsub\n               lume.docDot = subsub\n            elseif subname == \"svg\" then\n               s:verb(\"doc/svg: \" .. tostring(subsub))\n               docSvgDir = subsub\n               lume.docSvg = subsub\n            end\n         end\n      end\n   end\n\n   return (orbDir and srcDir and docDir)\nend\n\n\n\nlocal function new(dir, db_conn, no_write)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   if _Lumes[dir] then\n      return _Lumes[dir]\n   end\n   local lume = setmetatable({}, Lume)\n   lume.conn = db_conn and _Bridge.new_modules_db(db_conn)\n                       or _Bridge.modules_conn\n                       or error \"no database\"\n   lume.no_write = no_write\n   lume.shuttle = Deque()\n   lume.rack = Set()\n   lume.pedantic = _Bridge.args.pedantic and true or false\n   lume.well_formed = _findSubdirs(lume, dir)\n   if lume.well_formed then\n      lume.deck = Deck(lume, lume.orb)\n   else\n      -- this will probably break currently, but the end goal of\n      -- this architecture is to try and do something more sensible\n      -- than that.\n      s:warn(\"root codex %s is not well formed\", tostring(lume.orb))\n   end\n   lume.project = dir.path[#dir.path]\n   lume.git_info = git_info(tostring(dir))\n   lume.net = setmetatable({}, Net)\n   lume.net.lume = lume\n   _Lumes[dir] = lume\n   return lume\nend\n\nLume.idEst = new\n\n\n\nreturn new\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "util/sh",
hash = "280b4eb6946f96902fcff1c6b432632bee7d65733007ff1a985999592d8eb975",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Sh = {}\n\n\n\n\n-- make a safe-escaped, POSIX-compliant literal string,\n-- with the \'quote marks\'\nlocal function sh_str(str)\n    return table.concat {\"\'\", str:gsub(\"\'\", \"\'\\\\\'\'\"), \"\'\"}\nend\n-- borrowed with gratitude from:\n-- https://github.com/zserge/luash/blob/master/sh.lua\n\n-- converts key and it\'s argument to \"-k\" or \"-k=v\" or just \"\"\nlocal function arg(k, a)\n    if not a then return k end\n    if type(a) == \'string\' and #a > 0 then return k .. \'=\' .. sh_str(a) end\n    if type(a) == \'number\' then return k..\'=\'..tostring(a) end\n    if type(a) == \'boolean\' and a == true then return k end\n    error(\'invalid argument type \' .. type(a) .. \" \" .. tostring(a))\nend\n\n-- converts nested tables into a flat list of arguments and concatenated input\nlocal function flatten(t)\n    local result = {args = {}}\n\n    local function f(t)\n        local keys = {}\n        for k = 1, #t do\n            keys[k] = true\n            local v = t[k]\n            if type(v) == \'table\' then\n                f(v)\n            else\n                table.insert(result.args, v)\n            end\n        end\n        for k, v in pairs(t) do\n            if k == \'__input\' then\n                result.input = result.input or \'\'\n                result.input = result.input .. v\n            elseif not keys[k] and k:sub(1, 1) ~= \'_\' then\n                local key = \'-\'..k\n                if #k > 1 then key = \'-\' ..key end\n                table.insert(result.args, arg(key, v))\n            end\n        end\n    end\n\n    f(t)\n    return result\nend\n\n-- returns a function that executes the command with given args and returns its\n-- output, exit status etc\nlocal function command(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n        local p = io.popen(s, \'r\')\n        local output = p:read(\'*a\')\n        local _, exit, status = p:close()\n\n        local t = {\n            __input = output,\n            __exitcode = exit == \'exit\' and status or 127,\n            __signal = exit == \'signal\' and status or 0,\n        }\n        local mt = {\n            __index = function(self, k)\n                return command(k)\n            end,\n            __tostring = function(self)\n                -- return trimmed command output as a string\n                return self.__input:match(\'^%s*(.-)%s*$\')\n            end,\n            __repr = function(self)\n                return string.gmatch(self.__input, \"[^\\n]+\")\n            end\n        }\n        return setmetatable(t, mt)\n    end\nend\n\n-- export command() function\nSh.command = command\n\n\n\n\n\n\n\n\n\nlocal function preview(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n       return s\n    end\nend\n\nSh.preview = preview\n\n\n\n\n\n-- allow to call sh to run shell commands\nlocal Sh_M = {\n    __call = function(_, cmd, ...)\n        return command(cmd, ...)()\n    end,\n    __index = function(_, field)\n        return command(field)\n    end\n}\nsetmetatable(Sh, Sh_M)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.install(_Global)\n    local Global\n    local VER = string.sub( assert( _VERSION ), -4 )\n    if _Global and _Global ~= Sh then\n        Global = _Global\n    elseif VER == \" 5.1\" then\n        Global = getfenv()\n    else\n        Global = _ENV\n    end\n    local G_mt, G_index = nil, nil\n    local at_top = false\n    local our_mt = false\n    while not at_top do\n        local maybe_mt = getmetatable(Global)\n        if not maybe_mt then\n            at_top = true\n        else\n            -- we have a metatable\n            G_mt = maybe_mt\n            -- but is it the ultimate?\n            if G_mt.__index then\n                if type(G_mt.__index) == \"function\" then\n                    at_top = true\n                    G_index = G_mt.__index\n                elseif getmetatable(G_mt.__index) then\n                    at_top = false\n                    Global = G_mt.__index\n                else\n                    at_top = true\n                    G_index = G_mt.__index\n                end\n            else\n                at_top = true\n            end\n        end\n    end\n    -- if _ENV has no metatable, let\'s make one:\n    if not G_mt then\n        our_mt = true\n        G_mt = {}\n    end\n    -- *now* we can monkey-patch the global environment\n    local __index_fn\n    -- three flavors:\n    if not G_index then\n        __index_fn = function(_, cmd)\n                        return command(cmd)\n                     end\n    elseif type(G_index) == \"table\" then\n        __index_fn = function(_, key)\n                        local v = rawget(G_index, key)\n                        if v ~= nil then return v end\n                        return command(key)\n                     end\n    elseif type(G_index) == \"function\" then\n        __index_fn = function(_, key)\n                        local ok, v = pcall(G_index, _, key)\n                        if ok and (v ~= nil) then return v end\n                        return command(key)\n                     end\n    end\n    --- now set the metatable:\n    G_mt.__index = __index_fn\n    setmetatable(Global, G_mt)\n    -- stash the components for later removal\n    -- put them on the metatable to avoid polluting the\n    -- command space\n    Sh_M.__cache = { Global = Global,\n                     our_mt = our_mt,\n                     G_index = G_index,\n                     index_fn = __index_fn }\n    -- return Sh for convenience\n    return Sh\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.remove()\n    if not Sh_M.__cache then\n        -- didn\'t patch the namespace,\n        -- or already removed it\n        return nil\n    end\n    local cache = Sh_M.__cache\n    if cache.our_mt then\n        -- we made the metatable, let\'s remove the whole thing\n        setmetatable(cache.Global, nil)\n    else\n        -- if there was no G_index this will set it to nil\n        -- but only if our index function is still present.\n        local G_mt = getmetatable(cache.Global)\n        if G_mt.__index == cache.index_fn then\n            G_mt.__index = cache.G_index\n        end\n    end\n    -- remove cache\n    Sh_M.__cache = nil\nend\n\n\n\nreturn Sh\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/metas/twig",
hash = "e5a0f446f6b8ee97130657b73b3b4e1df14def6959fd4c757983b3a9327e000d",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal a = require \"anterm:anterm\"\nlocal Set = require \"set:set\"\nlocal Codepoints = require \"singletons:singletons/codepoints\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\n\n\n\n\n\n\nlocal Twig = {}\n\nfor k,v in next, Node do\n   Twig[k] = v\nend\n\nTwig.__index = Twig\nTwig.id = \"twig\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _select = Node.select\n\nfunction Twig.select(twig, pred)\n   if type(pred) == \"function\" then\n      return _select(twig, pred)\n   end\n   local memo\n   twig.__memo = twig.__memo or {}\n   if twig.__memo[pred] then\n      memo = twig.__memo[pred]\n   else\n      memo = {}\n      for result in _select(twig, pred) do\n         memo[#memo + 1] = result\n      end\n      twig.__memo[pred] = memo\n   end\n   local cursor = 0\n   return function()\n      cursor = cursor + 1\n      if cursor > #memo then\n         return nil\n      end\n      return memo[cursor]\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal md_special = Set {\"\\\\\", \"`\", \"*\", \"_\", \"{\", \"}\", \"[\", \"]\", \"(\", \")\",\n                        \"#\", \"+\", \"-\", \".\", \"!\"}\n\nfunction Twig.toMarkdown(twig, skein)\n   if #twig == 0 then\n      local points = Codepoints(twig:span())\n      for i , point in ipairs(points) do\n         if md_special[point] then\n            points[i] = \"\\\\\" .. point\n         end\n      end\n      return tostring(points)\n   else\n      local phrase = Phrase \"\"\n      for _, sub_twig in ipairs(twig) do\n         phrase = phrase .. sub_twig:toMarkdown(skein)\n      end\n      return phrase\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _escapeHtml(span)\n   -- stub\n   return span\nend\n\nfunction Twig.toHtml(twig, skein)\n   local phrase = \'<span class=\"\' .. twig.id .. Phrase \'\">\'\n   if #twig == 0 then\n      phrase = phrase .. _escapeHtml(twig:span())\n   else\n      for _, sub_twig in ipairs(twig) do\n         phrase = phrase .. sub_twig:toHtml(skein)\n      end\n   end\n   return phrase .. \"</span>\"\nend\n\n\n\nreturn Twig\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/morphemes",
hash = "cd3a563ae1a3a6af0c6ac374ef463b5592e16ff98173b455f3f9e4264059bae2",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\nlocal lpeg = require \"lpeg\"\nlocal epeg = require \"orb:util/epeg\"\n\nlocal match = lpeg.match -- match a pattern against a string\nlocal P = lpeg.P -- match a string literally\nlocal S = lpeg.S  -- match anything in a set\nlocal R = epeg.R  -- match anything in a range\nlocal B = lpeg.B  -- match iff the pattern precedes the use of B\nlocal C = lpeg.C  -- captures a match\nlocal Csp = epeg.Csp -- captures start and end position of match\nlocal Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)\nlocal Cb = lpeg.Cb -- Mysterious! TODO make not mysterious\nlocal Cmt = lpeg.Cmt -- match-time capture\nlocal Ct = lpeg.Ct -- a table with all captures from the pattern\nlocal V = lpeg.V -- create a variable within a grammar\n\n\n\n\n\nlocal m = {}\n\n\n\n\n\n\n\n\nm.letter = R\"AZ\" + R\"az\"\n\nm.digit = R\"09\"\n\nm.number = m.digit^1 -- We will improve this\n\nm._ = P\" \"\n\nm.WS = P\" \"^0\n\nm.NL = P\"\\n\"\n\nm.__TAB__ = P\"\\t\" -- First thing we do is eliminate these\n\n\n\n\n\n\n\n\n\n\n\n\n\nm.tar  = P\"*\"\nm.tars = m.tar^1\nm.hax  = P\"#\"\nm.pat  = P\"@\"\nm.hep  = P\"-\"\nm.cab  = P\"_\"\nm.bar  = P\"|\"\nm.sig  = P\"~\"\nm.fas  = P\"/\"\nm.fass = m.fas^1\nm.wut  = P\"?\"\nm.zap  = P\"!\"\nm.zaps = m.zap^1\nm.dot  = P\".\"\nm.col  = P\":\"\nm.sem  = P\";\"\nm.sel  = P\"[\"\nm.ser  = P\"]\"\nm.pal  = P\"(\"\nm.par  = P\")\"\nm.kel  = P\"{\"\nm.ker  = P\"}\"\nm.gal  = P\"<\"\nm.gar  = P\">\"\n\n\n\n\n\nm.punctuation = m.zap + m.wut + m.dot + m.col + m.sem\n\n\n\n\n\nm.symbol = m.letter * (m.letter + m.digit + m.hep + m.zap + m.wut)^0\n\nm.hashtag = m.hax * m.symbol\nm.handle = m.pat * m.symbol\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nm.tagline_hash_p = #(m.WS * m.hax - (m.hax * m._))\nm.tagline_handle_p = #(m.WS * m.pat - (m.pat * m._))\nm.tagline_p = m.tagline_hash_p + m.tagline_hash_p\n\n\n\n\n\n\n\n\n\nm.listline_base_p = #(m.WS * m.hep * m._)\nm.listline_num_p = #(m.WS * m.digit^1 * m.dot)\nm.listline_p = m.listline_base_p + m.listline_num_p\n\n\n\n\n\n\n\n\n\n\n\n\n\nm.tableline_p = #(m.WS * m.bar)\n\nm.codestart_p = #(m.WS * m.hax * m.zaps)\nm.codefinish_p = #(m.WS * m.hax * m.fass)\n\nm.codestart = m.WS * m.hax * m.zaps * P(1)^1\nm.codefinish = m.WS * m.hax * m.fass * P(1)^1\n\nm.header = m.WS * m.tars * m._ * P(1)^1\n\n\n\n\n\n\n\n\n\n\n\n-- This is definitely not right at all\nm.url = (m.letter + m.dot + m.fass)\n      * (m.symbol + m.hax + m.digit + m.cab\n         + m.sig + m.dot + m.fas + m.col\n         + m.pal + m.par + m.wut)^0 - m.ser\n\nm.prose = (m.symbol + m._)^1 -- Or this\nm.anchor_text = m.prose - m.ser -- accurate\n\n\n\n\n\n\nm.url_link = m.sel * m.url * m.ser\nm.anchor_link = m.sel * m.anchor_text * m.ser\nm.link =  (m.sel * m.anchor_link * m.url_link * m.ser)\n       +  (m.sel * m.url_link * m.ser)\n\n\n\n\nreturn m\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/doc",
hash = "208908463176a3ab9d9579e6d794e46503eea391fbd3091ed69476ccf4a777dc",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg   = require \"espalier:peg\"\nlocal table = require \"core:core/table\"\n\n\n\nlocal Twig      = require \"orb:orb/metas/twig\"\nlocal Header    = require \"orb:orb/header\"\nlocal Codeblock = require \"orb:orb/codeblock\"\nlocal Table     = require \"orb:orb/table\"\nlocal Prose     = require \"orb:orb/prose\"\nlocal Listline  = require \"orb:orb/list-line\"\nlocal fragments = require \"orb:orb/fragments\"\n\n\n\nlocal Doc_str = [[\n            doc  â†  (first-section / section) section*\n`first-section`  â†  blocks\n\n        section  â†  header line-end blocks*\n         header  â†  \" \"* \"*\"+ \" \" (!\"\\n\" 1)*\n                 /   \" \"* \"*\"+ &\"\\n\"\n\n       `blocks`  â†  block (block-sep* block)* block-sep*\n        `block`  â†  structure\n                 /  paragraph\n    `structure`  â†  codeblock\n                 /  blockquote\n                 /  table\n                 /  list\n                 /  handle-line\n                 /  hashtag-line\n                 /  link-line\n                 /  drawer\n   block-sep   â†  \"\\n\\n\" \"\\n\"*\n\n     codeblock   â†  code-start (!code-end 1)* code-end\n   `code-start`  â†  \"#\" (\"!\"+)@codelevel code-type@code_c (!\"\\n\" 1)* \"\\n\"\n     `code-end`  â†  \"\\n\" \"#\" (\"/\"+)@(#codelevel) code-type@(code_c)\n                     (!\"\\n\" 1)* line-end\n                 /  -1\n    `code-type`  â†  symbol?\n\n     blockquote  â†  block-line+ line-end\n     block-line  â†  \" \"* \"> \" (!\"\\n\" 1)* (!\"\\n\\n\" \"\\n\")?\n\n          table  â†  table-head table-line*\n   `table-head`  â†  (\" \"* handle_h* \" \"*)@table_c\n                    \"|\" (!\"\\n\" 1)* (\"\\n\" / -1)\n   `table-line`  â†  (\" \"*)@(#table_c) \"|\" (!line-end 1)* line-end\n\n           list  â†  (list-line / numlist-line)+\n      list-line  â†  (\"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>list_c) !\"- \"\n                    (!line-end 1)* line-end)*\n                 /  (\" \"+ \"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>=list_c) !\"- \" (!line-end 1)* line-end)*\n   numlist-line  â†  list-num@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n                 /  (\" \"+ list-num)@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>=numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n     `list-num`  â†  [0-9]+ \". \"\n\n    handle-line  â†  handle (!line-end 1)* line-end\n\n   hashtag-line  â†  hashtag (!line-end 1)* line-end\n\n      link-line  â†  link-open obelus link-close link line-end\n      link-open  â†  \"[\"\n         obelus  â†  (!\"]\" 1)+\n     link-close  â†  \"]: \"\n           link  â†  (!line-end 1)*\n\n\n         drawer  â†  drawer-top line-end\n                    ((structure \"\\n\"* / (!drawer-bottom prose-line)+)+\n                    / &drawer-bottom)\n                    drawer-bottom\n   `drawer-top`  â†  \" \"* \":[\" (!\"\\n\" !\"]:\" 1)*@drawer_c \"]:\" &\"\\n\"\n`drawer-bottom`  â†  \" \"* \":/[\" (!\"\\n\" !\"]:\" 1)*@(drawer_c) \"]:\" line-end\n\n      paragraph  â†  (!header !structure par-line (!\"\\n\\n\" \"\\n\")?)+\n     `par-line`  â†  (!\"\\n\" 1)+\n    prose-line   â†  (!\"\\n\" 1)* \"\\n\"\n       line-end  â†  (block-sep / \"\\n\" / -1)\n]] .. fragments.symbol .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\n\n\n\n\nlocal compact = assert(table.compact)\n\nlocal function _parent(levels, section)\n   local top = #levels\n   if top == 0 then\n      return section\n   end\n   local level = section :select \"level\"() :len()\n   for i = top, 1, -1 do\n      local p_level = levels[i] :select \"level\"() :len()\n      if p_level < level then\n         return levels[i]\n      end\n   end\n   return section\nend\n\nlocal function post(doc)\n   local levels = {}\n   local top = #doc\n   for i = 1, top do\n      local section = doc[i]\n      if section:select \"section\" () then\n         local parent = _parent(levels, section)\n         if parent ~= section then\n            -- add to section\n            parent[#parent + 1] = section\n            doc[i] = nil\n            -- adjust .last fields\n            parent.last = section.last\n            local under\n            repeat\n               under = parent\n               parent = _parent(levels, under)\n               parent.last = section.last\n            until parent == under\n            -- remove from doc\n         end\n         levels[#levels + 1] = section\n      end\n   end\n   compact(doc, top)\n   return doc\nend\n\n\n\n\n\n\n\n\nlocal DocMetas = { Twig,\n                   header       = Header,\n                   codeblock    = Codeblock,\n                   table        = Table,\n                   paragraph    = Prose,\n                   list_line    = Listline,\n                   numlist_line = Listline, }\n\n\n\nlocal addall = assert(table.addall)\n\naddall(DocMetas, require \"orb:orb/metas/docmetas\")\n\n\n\nreturn Peg(Doc_str, DocMetas, nil, post)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "Orbit/prose",
hash = "1bf958b11d149442cc5ec17c28db316d6d641632f1d5dab65a5249e6960f5f4a",
branch = "list-subgrammar",
binary = "\n\n\n\n\nlocal L = require \"lpeg\"\n\nlocal u = {}\nfunction u.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\nfunction u.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\nlocal s = require \"status:status\" ()\nlocal epeg = require \"orb:util/epeg\"\nlocal Csp = epeg.Csp\nlocal Node = require \"espalier/node\"\n\nlocal m = require \"orb:Orbit/morphemes\"\nlocal Link = require \"orb:Orbit/link\"\nlocal Richtext = require \"orb:Orbit/richtext\"\nlocal Grammar = require \"espalier/grammar\"\n\n\nlocal Pr, pr = u.inherit(Node)\nPr.id = \"prose\"\n\n\n\ns.chatty = false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function equal_strings(s, i, a, b)\n   -- Returns true if a and b are equal.\n   -- s and i are not used, provided because expected by Cb.\n   return a == b\nend\n\nlocal function bookends(sigil)\n  local Cg, C, P, Cmt, Cb = L.Cg, L.C, L.P, L.Cmt, L.Cb\n   -- Returns a pair of patterns, _open and _close,\n   -- which will match a brace of sigil.\n   -- sigil must be a string.\n   local _open = Cg(C(P(sigil)^1), sigil .. \"_init\")\n   local _close =  Cmt(C(P(sigil)^1) * Cb(sigil .. \"_init\"), equal_strings)\n   return _open, _close\nend\n\nlocal bold_open, bold_close     =  bookends(\"*\")\nlocal italic_open, italic_close =  bookends(\"/\")\nlocal under_open, under_close   =  bookends(\"_\")\nlocal strike_open, strike_close =  bookends(\"-\")\nlocal lit_open, lit_close       =  bookends(\"=\")\nlocal inter_open, inter_close   =  bookends(\"`\")\n\n\n\nfunction Pr.toMarkdown(prose)\n   local phrase = \"\"\n   for _, node in ipairs(prose) do\n      if node.toMarkdown then\n        phrase = phrase .. node:toMarkdown()\n      elseif node.id == \"raw\" then\n         phrase = phrase  .. node:toValue()\n      end\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal punct = m.punctuation\n\nlocal function prose_gm(_ENV)\n   START \"prose\"\n\n   SUPPRESS (\"anchorboxed\", \"urlboxed\", \"richtext\",\n             \"literalwrap\", \"boldwrap\", \"italicwrap\", \"interpolwrap\")\n\n   prose = (V\"link\" + (V\"prespace\" * V\"richtext\") + V\"raw\")^1\n\n   link = m.sel * m.WS * V\"anchorboxed\" * (m._ + m.NL)^0 * V\"urlboxed\" * m.ser\n   anchorboxed = m.sel * m.WS * V\"anchortext\" * m.ser\n   urlboxed = m.sel * m.WS * V\"url\" * m.WS * m.ser\n   anchortext = m.anchor_text\n   url = m.url\n\n   richtext =  (V\"literalwrap\"\n            +  V\"boldwrap\"\n            +  V\"italicwrap\"\n            +  V\"interpolwrap\") * #(m.WS + m.punctuation)\n   literalwrap = lit_open * V\"literal\" * lit_close\n   literal = (P(1) - lit_close)^1 -- These are not even close to correct\n   boldwrap = bold_open * V\"bold\" * bold_close\n   bold = (P(1) - bold_close)^1\n   italicwrap = italic_open * V\"italic\" * italic_close\n   italic = (P(1) - italic_close)^1\n   interpolwrap = inter_open * V\"interpolated\" * inter_close\n   interpolated = (P(1) - inter_close)^1 -- This may even be true\n\n   -- This is the catch bucket.\n   raw = (P(1) - (V\"link\" + (V\"prespace\" * V\"richtext\")))^1\n\n   -- This is another one.\n   prespace = m._ + m.NL\nend\n\nlocal function proseBuild(prose, str)\n   return setmetatable(prose, {__index = Pr})\nend\n\nlocal proseMetas = { prose = proseBuild,\n                     -- prespace = proseBuild,\n                     link  = Link }\n\nfor k, v in pairs(Richtext) do\n  proseMetas[k] = v\nend\n\nlocal parse = Grammar(prose_gm, proseMetas)\n\n\n\n\n\n\n\n\n\n\nlocal function new(Prose, block)\n    local phrase = \"\\n\"\n    for _,l in ipairs(block.lines) do\n      phrase = phrase .. l .. \"\\n\"\n    end\n    local prose = parse(phrase)\n    return prose\nend\n\n\n\nreturn u.export(pr, new)\n",
},
  { 
vc_hash = "85fe0c2a4eb9530a4fbdf918d7a0765be25a13e7",
name = "orb/metas/ws",
hash = "4a73aa94a932f50835e07319b34b2f6851c5381cc4524536b62692237bedd33d",
branch = "list-subgrammar",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal WS = Twig:inherit \"WS\"\n\n\n\nfunction WS.strLine()\n   return \"\"\nend\n\n\n\nreturn WS\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/pylon",
    repo_alternates = "",
    home = "",
    website = "",
    name = "pylon",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "afterward",
hash = "9c6cb24336f699d57044c8366e04437092ca8f35baa154dbb2654aaeaf7f096a",
branch = "trunk",
binary = "\n\n\n\n\n\n\ndo\n   if _Bridge.modules_conn then\n      _Bridge.modules_conn:pclose()\n   end\n\n   if _Bridge.bootstrap_conn then\n      _Bridge.bootstrap_conn:pclose()\n   end\nend\n",
},
  { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "modules",
hash = "afd4e5aa422f74dc20addf5c06414055b110e3d1148dd581fffe3a5663146f8e",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\nlocal new_modules = false\n\n\n\n\n\n\n\n\n\n\n\n\nlocal stmts = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nstmts.create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY,\n   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,\n   repo STRING,\n   repo_type STRING DEFAULT \'git\',\n   repo_alternates STRING,\n   home STRING,\n   website STRING\n);\n]]\n\n\n\n\nstmts.create_version_table = [[\nCREATE TABLE IF NOT EXISTS version (\n   version_id INTEGER PRIMARY KEY,\n   stage STRING DEFAULT \'SNAPSHOT\' COLLATE NOCASE,\n   edition STRING default \'\',\n   special STRING DEFAULT \'no\' COLLATE NOCASE,\n   major INTEGER DEFAULT 0,\n   minor INTEGER DEFAULT 0,\n   patch INTEGER DEFAULT 0,\n   project INTEGER NOT NULL,\n   UNIQUE (project, stage, edition, special, major, minor, patch)\n      ON CONFLICT IGNORE,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\nstmts.create_bundle_table = [[\nCREATE TABLE IF NOT EXISTS bundle (\n   bundle_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n);\n]]\n\n\n\n\nstmts.create_code_table = [[\nCREATE TABLE IF NOT EXISTS code (\n   code_id INTEGER PRIMARY KEY,\n   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,\n   binary BLOB NOT NULL\n);\n]]\n\n\n\n\nstmts.create_module_table = [[\nCREATE TABLE IF NOT EXISTS module (\n   module_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   name STRING NOT NULL,\n   type STRING DEFAULT \'luaJIT-2.1-bytecode\',\n   branch STRING,\n   vc_hash STRING,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   bundle INTEGER,\n   code INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE RESTRICT\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n   FOREIGN KEY (bundle)\n      REFERENCES bundle (bundle_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (code)\n      REFERENCES code (code_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new_modules_db(conn_home)\n   local yes, conn;\n   if type(conn_home) == \'string\' then\n      yes, conn = pcall(sql.open, conn_home, \'rwc\')\n      if not yes then\n         error(\"Could not create \" .. conn_home\n               .. \", consider creating the directory or setting\"\n               .. \" $BRIDGE_MODULES.\")\n      end\n   end\n   if conn then\n      conn:exec(stmts.create_project_table)\n      conn:exec(stmts.create_version_table)\n      conn:exec(stmts.create_bundle_table)\n      conn:exec(stmts.create_code_table)\n      conn:exec(stmts.create_module_table)\n   end\n\n   return conn\nend\n\n_Bridge.new_modules_db = new_modules_db\n\nif not _Bridge.modules_conn then\n   _Bridge.modules_conn = new_modules_db(_Bridge.bridge_modules_home)\n   new_modules = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n_Bridge.import = import\n\n\n\n\n\n\n\n\nif new_modules then\n   print \"importing modules bundle\"\n   import(\"all_modules.bundle\")\nend\n\n\n\n\n\n\nend\n",
},
  { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "sql",
hash = "260bfcc5eeec6f15531be32b3af7c2d802b384b22d6d3ad3857ae38c6a5d3bdc",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sqlayer = {}\ndo\n   local ffi  = require \"ffi\"\n   local bit  = require \"bit\"\n\n\n\n\n\n\n\n   local insert = table.insert\n\n   -- CREDIT: Steve Dovan snippet.\n   local function split(s, re)\n     local i1, ls = 1, { }\n     if not re then re = \'%s+\' end\n     if re == \'\' then return { s } end\n     while true do\n       local i2, i3 = s:find(re, i1)\n       if not i2 then\n         local last = s:sub(i1)\n         if last ~= \'\' then insert(ls, last) end\n         if #ls == 1 and ls[1] == \'\' then\n           return  { }\n         else\n           return ls\n         end\n       end\n       insert(ls, s:sub(i1, i2 - 1))\n       i1 = i3 + 1\n     end\n   end\n\n   local function trim(s)\n     return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n   end\n\n   local function err(code, msg)\n     error(\"ljsqlite3[\"..code..\"] \"..msg .. \"\\n\" .. debug.traceback())\n   end\n\n\n\n\n\n\n\n\n\n\n   -- Codes -----------------------------------------------------------------------\n   local sqlconstants = {} -- SQLITE_* and OPEN_* declarations.\n   local codes = {\n     [0] = \"OK\", \"ERROR\", \"INTERNAL\", \"PERM\", \"ABORT\", \"BUSY\", \"LOCKED\", \"NOMEM\",\n     \"READONLY\", \"INTERRUPT\", \"IOERR\", \"CORRUPT\", \"NOTFOUND\", \"FULL\", \"CANTOPEN\",\n     \"PROTOCOL\", \"EMPTY\", \"SCHEMA\", \"TOOBIG\", \"CONSTRAINT\", \"MISMATCH\", \"MISUSE\",\n     \"NOLFS\", \"AUTH\", \"FORMAT\", \"RANGE\", \"NOTADB\", [100] = \"ROW\", [101] = \"DONE\"\n   } -- From 0 to 26.\n\n   do\n     local types = { \"INTEGER\", \"FLOAT\", \"TEXT\", \"BLOB\", \"NULL\" } -- From 1 to 5.\n\n     local opens = {\n       READONLY =        0x00000001;\n       READWRITE =       0x00000002;\n       CREATE =          0x00000004;\n       DELETEONCLOSE =   0x00000008;\n       EXCLUSIVE =       0x00000010;\n       AUTOPROXY =       0x00000020;\n       URI =             0x00000040;\n       MAIN_DB =         0x00000100;\n       TEMP_DB =         0x00000200;\n       TRANSIENT_DB =    0x00000400;\n       MAIN_JOURNAL =    0x00000800;\n       TEMP_JOURNAL =    0x00001000;\n       SUBJOURNAL =      0x00002000;\n       MASTER_JOURNAL =  0x00004000;\n       NOMUTEX =         0x00008000;\n       FULLMUTEX =       0x00010000;\n       SHAREDCACHE =     0x00020000;\n       PRIVATECACHE =    0x00040000;\n       WAL =             0x00080000;\n     }\n\n     local t = sqlconstants\n     local pre = \"static const int32_t SQLITE_\"\n     for i=0,26    do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n     for i=100,101 do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n     for i=1,5     do t[#t+1] = pre..types[i]..\"=\"..i..\";\\n\" end\n     pre = pre..\"OPEN_\"\n     for k,v in pairs(opens) do\n       t[#t+1] = pre..k..\"=\"..bit.tobit(v)..\";\\n\"\n     end\n   end\n\n   -- Cdef ------------------------------------------------------------------------\n   -- SQLITE_*, OPEN_*\n\n   ffi.cdef(table.concat(sqlconstants))\n\n   -- sqlite3*, ljsqlite3_*\n   ffi.cdef[[\n   // Typedefs.\n   typedef struct sqlite3 sqlite3;\n   typedef struct sqlite3_stmt sqlite3_stmt;\n   typedef void (*sqlite3_destructor_type)(void*);\n   typedef struct sqlite3_context sqlite3_context;\n   typedef struct Mem sqlite3_value;\n\n   // Get informative error message.\n   const char *sqlite3_errmsg(sqlite3*);\n\n   // Connection.\n   int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags,\n     const char *zVfs);\n   int sqlite3_close(sqlite3*);\n   int sqlite3_busy_timeout(sqlite3*, int ms);\n\n   // Statement.\n   int sqlite3_prepare_v2(sqlite3 *conn, const char *zSql, int nByte,\n     sqlite3_stmt **ppStmt, const char **pzTail);\n   int sqlite3_step(sqlite3_stmt*);\n   int sqlite3_reset(sqlite3_stmt *pStmt);\n   int sqlite3_finalize(sqlite3_stmt *pStmt);\n\n   // Extra functions for SELECT.\n   int sqlite3_column_count(sqlite3_stmt *pStmt);\n   const char *sqlite3_column_name(sqlite3_stmt*, int N);\n   int sqlite3_column_type(sqlite3_stmt*, int iCol);\n\n   // Get value from SELECT.\n   int64_t sqlite3_column_int64(sqlite3_stmt*, int iCol);\n   double sqlite3_column_double(sqlite3_stmt*, int iCol);\n   int sqlite3_column_bytes(sqlite3_stmt*, int iCol);\n   const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\n   const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\n\n   // Set value in bind.\n   int sqlite3_bind_int64(sqlite3_stmt*, int, int64_t);\n   int sqlite3_bind_double(sqlite3_stmt*, int, double);\n   int sqlite3_bind_null(sqlite3_stmt*, int);\n   int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));\n   int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\n\n   int sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *name);\n\n   // Clear bindings.\n   int sqlite3_clear_bindings(sqlite3_stmt*);\n\n   // Get value in callbacks.\n   int sqlite3_value_type(sqlite3_value*);\n   int64_t sqlite3_value_int64(sqlite3_value*);\n   double sqlite3_value_double(sqlite3_value*);\n   int sqlite3_value_bytes(sqlite3_value*);\n   const unsigned char *sqlite3_value_text(sqlite3_value*); //Not used.\n   const void *sqlite3_value_blob(sqlite3_value*);\n\n   // Set value in callbacks.\n   void sqlite3_result_error(sqlite3_context*, const char*, int);\n   void sqlite3_result_int64(sqlite3_context*, int64_t);\n   void sqlite3_result_double(sqlite3_context*, double);\n   void sqlite3_result_null(sqlite3_context*);\n   void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\n   void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\n\n   // Persistency of data in callbacks (here just a pointer for tagging).\n   void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\n\n   // Typedefs for callbacks.\n   typedef void (*ljsqlite3_cbstep)(sqlite3_context*,int,sqlite3_value**);\n   typedef void (*ljsqlite3_cbfinal)(sqlite3_context*);\n\n   // Register callbacks.\n   int sqlite3_create_function(\n     sqlite3 *conn,\n     const char *zFunctionName,\n     int nArg,\n     int eTextRep,\n     void *pApp,\n     void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n     void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n     void (*xFinal)(sqlite3_context*)\n   );\n   ]]\n\n   ---------------------------------------------------------------------------\n\n   local transient = ffi.cast(\"sqlite3_destructor_type\", -1)\n   local int64_ct = ffi.typeof(\"int64_t\")\n\n   local blob_mt = {} -- For tagging only.\n\n   local function blob(str)\n     return setmetatable({ str }, blob_mt)\n   end\n\n   local connstmt = {} -- Statements for a conn.\n   local conncb = {} -- Callbacks for a conn.\n   local aggregatestate = {} -- Aggregate states.\n\n   local stmt_step\n\n   local stmt_mt, stmt_ct = {}\n   stmt_mt.__index = stmt_mt\n\n   local conn_mt, conn_ct = {}\n   conn_mt.__index = conn_mt\n\n   -- Checks ----------------------------------------------------------------------\n\n   -- Helper function to get error msg and code from sqlite.\n   local function codemsg(pconn, code)\n     return codes[code]:lower(), ffi.string(ffi.C.sqlite3_errmsg(pconn))\n   end\n\n   -- Throw error for a given connection.\n   local function E_conn(pconn, code)\n     local code, msg = codemsg(pconn, code)\n     err(code, msg)\n   end\n\n   -- Test code is OK or throw error for a given connection.\n   local function T_okcode(pconn, code)\n     if code ~= ffi.C.SQLITE_OK then\n       E_conn(pconn, code)\n     end\n   end\n\n   local function T_open(x)\n     if x._closed then\n       err(\"misuse\", \"object is closed\")\n     end\n   end\n\n   -- Getters / Setters to minimize code duplication ------------------------------\n   local sql_get_code = [=[\n   return function(stmt_or_value <opt_i>)\n     local t = ffi.C.sqlite3_<variant>_type(stmt_or_value <opt_i>)\n     if t == ffi.C.SQLITE_INTEGER then\n       return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>)\n     elseif t == ffi.C.SQLITE_FLOAT then\n       return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>)\n     elseif t == ffi.C.SQLITE_TEXT then\n       local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n       return ffi.string(ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>), nb)\n     elseif t == ffi.C.SQLITE_BLOB then\n       local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n       return ffi.string(ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>), nb)\n     elseif t == ffi.C.SQLITE_NULL then\n       return nil\n     else\n       err(\"constraint\", \"unexpected SQLite3 type\")\n     end\n   end\n   ]=]\n\n   local sql_set_code = [=[\n   return function(stmt_or_value, v <opt_i>)\n     local t = type(v)\n     if t == \"table\" then\n        --  Convert on a __todb metamethod\n        local t_M = getmetatable(v)\n        local method = t_M and t_M.__todb\n        if method then\n           v = method(v)\n           t = \"string\"\n        end\n     end\n     if ffi.istype(int64_ct, v) then\n       return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>, v)\n     elseif t == \"number\" then\n       return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, v)\n     elseif t == \"string\" then\n       return ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>, v, #v,\n         transient)\n     elseif t == \"table\" and getmetatable(v) == blob_mt then\n       v = v[1]\n       return ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>, v, #v,\n         transient)\n     elseif t == \"boolean\" then\n       local bool_num = v and 1 or 0\n       return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, bool_num)\n     elseif t == \"nil\" then\n       return ffi.C.sqlite3_<variant>_null(stmt_or_value <opt_i>)\n     else\n       err(\"constraint\", \"unexpected Lua type \" .. t)\n     end\n   end\n   ]=]\n\n   -- Environment for setters/getters.\n   local sql_env = {\n     sql          = sql,\n     transient    = transient,\n     ffi          = ffi,\n     int64_ct     = int64_ct,\n     blob_mt      = blob_mt,\n     getmetatable = getmetatable,\n     err          = err,\n     type         = type,\n     tostring     = tostring\n   }\n\n   local function sql_format(s, variant, index)\n     return s:gsub(\"<variant>\", variant):gsub(\"<opt_i>\", index)\n   end\n\n   local function loadcode(s, env)\n     local ret = assert(loadstring(s))\n     if env then setfenv(ret, env) end\n     return ret()\n   end\n\n   -- Must always be called from *:_* function due to error level 4.\n   local get_column = loadcode(sql_format(sql_get_code, \"column\", \",i\"),   sql_env)\n   local get_value  = loadcode(sql_format(sql_get_code, \"value\" , \"  \"),   sql_env)\n   local set_column = loadcode(sql_format(sql_set_code, \"bind\"  , \",i\"),   sql_env)\n   local set_value  = loadcode(sql_format(sql_set_code, \"result\", \"  \"),   sql_env)\n\n   -- Connection ------------------------------------------------------------------\n   local open_modes = {\n     ro = ffi.C.SQLITE_OPEN_READONLY,\n     rw = ffi.C.SQLITE_OPEN_READWRITE,\n     rwc = bit.bor(ffi.C.SQLITE_OPEN_READWRITE, ffi.C.SQLITE_OPEN_CREATE)\n   }\n\n   local function open(str, mode)\n     mode = mode or \"rwc\"\n     mode = open_modes[mode]\n     if not mode then\n       err(\"constraint\", \"argument #2 to open must be ro, rw, or rwc\")\n     end\n     local aptr = ffi.new(\"sqlite3*[1]\")\n     -- Usually aptr is set even if error code, so conn always needs to be closed.\n     local code = ffi.C.sqlite3_open_v2(str, aptr, mode, nil)\n     local conn = conn_ct(aptr[0], false)\n     -- Must create this anyway due to conn:close() function.\n     connstmt[conn] = setmetatable({}, { __mode = \"k\" })\n     conncb[conn] = { scalar = {}, step = {}, final = {} }\n     if code ~= ffi.C.SQLITE_OK then\n       local code, msg = codemsg(conn._ptr, code) -- Before closing!\n       conn:close() -- Free resources, should not fail here in this case!\n       err(code, msg)\n     end\n     return conn\n   end\n\n   function conn_mt:close() T_open(self)\n      -- Close all stmt linked to conn.\n     for k,_ in pairs(connstmt[self]) do if not k._closed then k:close() end end\n      -- Close all callbacks linked to conn.\n     for _,v in pairs(conncb[self].scalar) do v:free() end\n     for _,v in pairs(conncb[self].step)   do v:free() end\n     for _,v in pairs(conncb[self].final)  do v:free() end\n     local code = ffi.C.sqlite3_close(self._ptr)\n     T_okcode(self._ptr, code)\n     connstmt[self] = nil -- Table connstmt is not weak, need to clear manually.\n     conncb[self] = nil\n     self._closed = true -- Set only if close succeded.\n   end\n\n   function conn_mt:__gc()\n     if not self._closed then self:close() end\n   end\n\n   function conn_mt:prepare(stmtstr) T_open(self)\n     local aptr = ffi.new(\"sqlite3_stmt*[1]\")\n     -- If error code aptr NULL, so no need to close anything.\n     local code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n     T_okcode(self._ptr, code)\n     local stmt = stmt_ct(aptr[0], false, self._ptr, code)\n     connstmt[self][stmt] = true\n     return stmt\n   end\n\n   -- Connection exec, __call, rowexec --------------------------------------------\n   function conn_mt:exec(commands, get) T_open(self)\n     get = get or \'ihk\'\n     local cmd1 = split(commands, \";\")\n     local res, n\n     for i=1,#cmd1 do\n       local cmd = trim(cmd1[i])\n       if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         res, n = stmt:resultset(get)\n         stmt:close()\n       end\n     end\n     return res, n -- Only last record is returned.\n   end\n\n   function conn_mt:rowexec(command) T_open(self)\n     local stmt = self:prepare(command)\n     local res = stmt:_step()\n     if stmt:_step() then\n       err(\"misuse\", \"multiple records returned, 1 expected\")\n     end\n     stmt:close()\n     if res then\n       return unpack(res)\n     else\n       return nil\n     end\n   end\n\n   function conn_mt:__call(commands, out) T_open(self)\n     out = out or print\n     local cmd1 = split(commands, \";\")\n     for c=1,#cmd1 do\n       local cmd = trim(cmd1[c])\n       if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         local ret, n = stmt:resultset()\n         if ret then -- All the results get handled, not only last one.\n           out(unpack(ret[0])) -- Headers are printed.\n           for i=1,n do\n             local o = {}\n             for j=1,#ret[0] do\n               local v = ret[j][i]\n               if type(v) == \"nil\" then v = \"\" end -- Empty strings for NULLs.\n               o[#o+1] = tostring(v)\n             end\n             out(unpack(o))\n           end\n         end\n         stmt:close()\n       end\n     end\n   end\n\n   -- Callbacks -------------------------------------------------------------------\n   -- Update (one of) callbacks registry for sqlite functions.\n   local function updatecb(self, where, name, f)\n     local cbs = conncb[self][where]\n     if cbs[name] then -- Callback already present, free old one.\n       cbs[name]:free()\n     end\n     cbs[name] = f -- Could be nil and that\'s fine.\n   end\n\n   -- Return manually casted callback that sqlite expects, scalar.\n   local function scalarcb(name, f)\n     local values = {} -- Conversion buffer.\n     local function sqlf(context, nvalues, pvalues)\n       -- Indexing 0,N-1.\n       for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n       -- Throw error via sqlite function if necessary.\n       local ok, result = pcall(f, unpack(values, 1, nvalues))\n       if not ok then\n         local msg = \"Lua registered scalar function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n       else\n         set_value(context, result)\n       end\n     end\n     return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\n   end\n\n   -- Return the state for aggregate case (created via initstate()). We use the ptr\n   -- returned from aggregate_context() for tagging only, all the state data is\n   -- handled from Lua side.\n   local function getstate(context, initstate, size)\n     -- Only pointer address relevant for indexing, size irrelevant.\n     local ptr = ffi.C.sqlite3_aggregate_context(context, size)\n     local pid = tonumber(ffi.cast(\"intptr_t\",ptr))\n     local state = aggregatestate[pid]\n     if type(state) == \"nil\" then\n       state = initstate()\n       aggregatestate[pid] = state\n     end\n     return state, pid\n   end\n\n   -- Return manually casted callback that sqlite expects, stepper for aggregate.\n   local function stepcb(name, f, initstate)\n     local values = {} -- Conversion buffer.\n     local function sqlf(context, nvalues, pvalues)\n       -- Indexing 0,N-1.\n       for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n       local state = getstate(context, initstate, 1)\n       -- Throw error via sqlite function if necessary.\n       local ok, result = pcall(f, state, unpack(values, 1, nvalues))\n       if not ok then\n         local msg = \"Lua registered step function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n       end\n     end\n     return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\n   end\n\n   -- Return manually casted callback that sqlite expects, finalizer for aggregate.\n   local function finalcb(name, f, initstate)\n     local function sqlf(context)\n       local state, pid = getstate(context, initstate, 0)\n       aggregatestate[pid] = nil -- Clear the state.\n       local ok, result = pcall(f, state)\n       -- Throw error via sqlite function if necessary.\n       if not ok then\n         local msg = \"Lua registered final function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n       else\n         set_value(context, result)\n       end\n     end\n     return ffi.cast(\"ljsqlite3_cbfinal\", sqlf)\n   end\n\n   function conn_mt:setscalar(name, f) T_open(self)\n     jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n     local cbf = f and scalarcb(name, f) or nil\n     local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n       cbf, nil, nil) -- If cbf nil this clears the function is sqlite.\n     T_okcode(self._ptr, code)\n     updatecb(self, \"scalar\", name, cbf) -- Update and clear old.\n   end\n\n   function conn_mt:setaggregate(name, initstate, step, final) T_open(self)\n     jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n     local cbs = step  and stepcb (name, step,  initstate) or nil\n     local cbf = final and finalcb(name, final, initstate) or nil\n     local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n       nil, cbs, cbf) -- If cbs, cbf nil this clears the function is sqlite.\n     T_okcode(self._ptr, code)\n     updatecb(self, \"step\", name, cbs) -- Update and clear old.\n     updatecb(self, \"final\", name, cbf) -- Update and clear old.\n   end\n\n   conn_ct = ffi.metatype(\"struct { sqlite3* _ptr; bool _closed; }\", conn_mt)\n\n   -- Statement -------------------------------------------------------------------\n   function stmt_mt:reset() T_open(self)\n     -- Ignore possible error code, it would be repetition of error raised during\n     -- most recent evaluation of statement which would have been raised already.\n     ffi.C.sqlite3_reset(self._ptr)\n     self._code = ffi.C.SQLITE_OK -- Always succeds.\n     return self\n   end\n\n   function stmt_mt:close() T_open(self)\n     -- Ignore possible error code, it would be repetition of error raised during\n     -- most recent evaluation of statement which would have been raised already.\n     ffi.C.sqlite3_finalize(self._ptr)\n     self._code = ffi.C.SQLITE_OK -- Always succeds.\n     self._closed = true -- Must be called exaclty once.\n   end\n\n   function stmt_mt:__gc()\n     if not self._closed then self:close() end\n   end\n\n   -- Statement step, resultset ---------------------------------------------------\n   function stmt_mt:_ncol()\n     return ffi.C.sqlite3_column_count(self._ptr)\n   end\n\n   function stmt_mt:_header(h)\n     for i=1,self:_ncol() do -- Here indexing 0,N-1.\n       h[i] = ffi.string(ffi.C.sqlite3_column_name(self._ptr, i - 1))\n     end\n   end\n\n   stmt_step = function(self, row, header)\n     -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n     if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n     self._code = ffi.C.sqlite3_step(self._ptr)\n     if self._code == ffi.C.SQLITE_ROW then\n       -- All the sql.* functions called never errors here.\n       row = row or {}\n       for i=1,self:_ncol() do\n         row[i] = get_column(self._ptr, i - 1)\n       end\n       if header then self:_header(header) end\n       return row, header\n     elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now.\n       return nil\n     else -- If code not DONE or ROW then it\'s error.\n       E_conn(self._conn, self._code)\n     end\n   end\n   stmt_mt._step = stmt_step\n\n   function stmt_mt:step(row, header) T_open(self)\n     return self:_step(row, header)\n   end\n\n\n   -- iterator for rows\n   function stmt_mt:rows() T_open(self)\n     return function()\n       local row = self:step()\n       if row then\n         return row\n       else\n         self:clearbind():reset()\n         return nil\n       end\n     end\n   end\n\n   function stmt_mt:resultset(get, maxrecords) T_open(self)\n     get = get or \"k\"\n     maxrecords = maxrecords or math.huge\n     if maxrecords < 1 then\n       err(\"constraint\", \"argument #2 to resultset must be >= 1\")\n     end\n     local hash, hasi, hask = get:find(\"h\"), get:find(\"i\"), get:find(\"k\")\n     local r, h = self:_step({}, {})\n     if not r then return nil, 0 end -- No records case.\n     -- First record, o is a temporary table used to get records.\n     local o = hash and { [0] = h } or {}\n     for i=1,#h do o[i] = { r[i] } end\n     -- Other records.\n     local n = 1\n     while n < maxrecords and self:_step(r) do\n       n = n + 1\n       for i=1,#h do o[i][n] = r[i] end\n     end\n\n     local out = { [0] = o[0] } -- Eventually copy colnames.\n     if hasi then -- Use numeric indexes.\n       for i=1,#h do out[i] = o[i] end\n     end\n     if hask then -- Use colnames indexes.\n       for i=1,#h do out[h[i]] = o[i] end\n     end\n     return out, n\n   end\n\n   -- Statement bind --------------------------------------------------------------\n   function stmt_mt:_bind1(i, v)\n     local code = set_column(self._ptr, v, i) -- Here indexing 1,N.\n     T_okcode(self._conn, code)\n     return self\n   end\n\n   function stmt_mt:bind1(i, v) T_open(self)\n     return self:_bind1(i, v)\n   end\n\n   function stmt_mt:bind(...) T_open(self)\n     for i=1,select(\"#\", ...) do self:_bind1(i, select(i, ...)) end\n     return self\n   end\n\n   -- note: after some thought, I\'ve decided to let this method only handle string\n   -- values.  It would be possible to bind against numeric indices as well, but this\n   -- would do the wrong thing if given a table with the correct named keys as well as\n   -- indexed values.\n   --\n   -- Worse, it would *unpredictably* do the wrong thing, since stmts silently accept\n   -- rebinding, and `pairs` offers no ordering guarantees.\n   --\n\n   function stmt_mt:bindkv(t, pre) T_open(self)\n     pre = pre or \":\"\n     for k,v in pairs(t) do\n       if type(k) == \"string\" then\n         local param = ffi.C.sqlite3_bind_parameter_index(self._ptr, pre..k)\n         if param ~= 0 then\n           self:_bind1(param, v)\n         end\n       end\n     end\n     return self\n   end\n\n   function stmt_mt:clearbind() T_open(self)\n     local code = ffi.C.sqlite3_clear_bindings(self._ptr)\n     T_okcode(self._conn, code)\n     return self\n   end\n\n   stmt_ct = ffi.metatype([[struct {\n     sqlite3_stmt* _ptr;\n     bool          _closed;\n     sqlite3*      _conn;\n     int32_t       _code;\n   }]], stmt_mt)\n\n\n\n   sqlayer.open = open\n   sqlayer.blob = blob\n\n\n\n\n\n\n\n\n\n\n   local pcall = assert (pcall)\n   local gsub = assert(string.gsub)\n   local format = assert(string.format)\n\n\n\n\n\n\n\n   local function san(str)\n      return gsub(str, \"\'\", \"\'\'\")\n   end\n\n   sqlayer.san = san\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.format(str, ...)\n      local argv = {...}\n      str = gsub(str, \"%%s\", \"\'%%s\'\"):gsub(\"\'\'%%s\'\'\", \"\'%%s\'\")\n      for i, v in ipairs(argv) do\n         if type(v) == \"string\" then\n            argv[i] = san(v)\n         elseif type(v) == \"cdata\" then\n            -- assume this is a number of some kind\n            argv[i] = tonumber(v)\n         else\n            argv[i] = v\n         end\n      end\n      local success, ret = pcall(format, str, unpack(argv))\n      if success then\n         return ret\n      else\n         return success, ret\n      end\n   end\n\n\n\n\n\n\n\n\n\n   function sqlayer.pexec(conn, stmt, col_str)\n      -- conn:exec(stmt)\n      col_str = col_str or \"hik\"\n      local success, result, nrow = pcall(conn.exec, conn, stmt, col_str)\n      if success then\n         return result, nrow\n      else\n         return false, result\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.lastRowId(conn)\n      local result = conn:rowexec \"SELECT CAST(last_insert_rowid() AS REAL)\"\n      return result\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.unwrapKey(result_set)\n   if result_set and result_set[1] and result_set[1][1] then\n      local id = result_set[1][1]\n      if type(id) == \"cdata\" then\n         return tonumber(id)\n      else\n         return id\n      end\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.toRow(sql_result, num)\n   if not sql_result then return nil end\n   local one_result = false\n   local result_tab = {}\n   if not num then\n      num = 1\n      one_result = true\n   end\n   assert(type(num) == \"number\")\n   for key, column in pairs(sql_result) do\n      if type(key) == \"string\" then\n         for i = 1, num do\n            local v = type(column[i]) == \"cdata\"\n                      and tonumber(column[i])\n                      or column[i]\n            result_tab[i] = result_tab[i] or {}\n            result_tab[i][key] = v\n         end\n      end\n   end\n   if one_result then\n      return result_tab[1]\n   else\n      return result_tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local pragma_pre = \"PRAGMA \"\n\n   -- Builds and returns a pragma string\n   local function __pragma(prag, value)\n      local val\n      if value == nil then\n         return pragma_pre .. prag .. \";\"\n      end\n      if type(value) == \"boolean\" then\n         val = value and \" = 1\" or \" = 0\"\n      elseif type(value) == \"string\" then\n         val = \"(\'\" .. san(value) .. \"\')\"\n      elseif type(value) == \"number\" then\n         val = \" = \" .. tostring(value)\n      else\n         error(false, \"value of type \"\n               .. type(value) .. \", \"\n               .. tostring(value))\n      end\n      return pragma_pre .. prag .. val .. \";\"\n   end\n\n   -- Sets a pragma and checks its new value\n   local function _prag_set(conn, prag)\n      return function(value)\n         local prag_str = __pragma(prag, value)\n         conn:exec(prag_str)\n         -- cast booleans results to Lua booleans,\n         -- otherwise return the (string) result\n         local answer = conn:exec(pragma_pre .. prag .. \";\", \"i\")\n         if answer[1] and answer[1][1] then\n            if answer[1][1] == 1 then\n               return true\n            elseif answer[1][1] == 0 then\n               return false\n            else\n               return answer[1][1]\n            end\n         end\n      end\n   end\n\n\n\n\n\n\n   local function new_conn_index(conn, key)\n      local function _prag_index(_, prag)\n         return _prag_set(conn, prag)\n      end\n      if key == \"pragma\" then\n         return setmetatable({}, {__index = _prag_index})\n      else\n         return conn_mt[key]\n      end\n   end\n\n   conn_mt.__index = new_conn_index\n\n\n\n\n\n\n\n\n\n  local close = conn_mt.close\n\n  function conn_mt.pclose(conn)\n     local uv = require \"luv\"\n     local loop_alive = uv.loop_alive()\n     local close_idler = uv.new_idle()\n     close_idler:start(function()\n       local success = pcall(close, conn)\n       if not success then\n         return nil\n       else\n         close_idler:stop()\n       end\n     end)\n     if not loop_alive then\n        uv.run \'default\'\n     end\n  end\n\n\n\n\n\n\nend\nsql = sqlayer\nsqlayer = nil\n",
},
  { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "preamble",
hash = "54e015e312227373c3349244543a557d5aa9cae77b7ac0d7d29459b3dfd9bac1",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_Bridge = {}\n\n\n\n\n\n\n\n\n\n\n\n\npack = table.pack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"table.clear\"\nrequire \"table.new\"\nrequire \"table.isempty\"\nrequire \"table.isarray\"\nrequire \"table.nkeys\"\n-- require \"table.clone\" -- we provide a more general, but slower, version\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n_Bridge.bridge_modules = { }\n_Bridge.loaded = { }\n\n\n\n\n\n\n\n\n\nlocal bytecode_by_module = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nWHERE module.name = :name\nORDER BY module.time desc limit 1\n;\n]]\n\nlocal bytecode_by_module_and_project = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nINNER JOIN project\nON project.project_id = module.project\nWHERE project.name = :project_name\nAND module.name = :module_name\nORDER BY module.time desc limit 1\n;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal home_dir = os.getenv \"HOME\"\nlocal bridge_modules = os.getenv \"BRIDGE_MODULES\"\nlocal bridge_home = os.getenv \"BRIDGE_HOME\"\n\n   -- use BRIDGE_HOME if we have it\nif not bridge_home then\n   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"\n   if xdg_data_home then\n      bridge_home = xdg_data_home .. \"/bridge\"\n   else\n      bridge_home = home_dir .. \"/.local/share/bridge\"\n   end\nend\n\nif not bridge_modules then\n   bridge_modules = bridge_home.. \"/bridge.modules\"\nend\n\n_Bridge.bridge_home = bridge_home\n_Bridge.bridge_modules_home = bridge_modules\n\n\n\n\n\nlocal ok, bridge_conn = pcall(sql.open, bridge_modules, \"rw\")\nif ok then\n   _Bridge.modules_conn = bridge_conn\nelse\n   print \"no bridge.modules\"\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge_strap = home_dir .. \"/.local/share/bridge/~bridge.modules\"\nlocal ok, strap_conn = pcall(sql.open, bridge_strap, \"rw\")\nif ok then\n   _Bridge.bootstrap_conn = strap_conn\nend\n\n\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function resultMap(result)\n   if result == nil then return nil end\n   return toRow(result)\nend\n\nlocal function loaderGen(conn)\n   -- check that we have a database conn\n   if not conn then error(\"sql connection failed\") end\n   -- make prepared statements\n   local module_stmt = conn:prepare(bytecode_by_module)\n   local project_stmt = conn:prepare(bytecode_by_module_and_project)\n   -- return loader\n\n   return function (mod_name)\n      package.bridge_loaded = package.bridge_loaded or {}\n      -- split the module into project and modname\n      local bytecode = nil\n      local project, mod = string.match(mod_name, \"(.*):(.*)\")\n      if not mod then\n         mod = mod_name\n      end\n      local proj_name = project or \"\"\n      -- might be \"module/module\":\n      local mod_double = mod .. \"/\" .. mod\n      -- might be \"project:module\" -> \"project/module\"\n      local proj_double = \"\"\n      if project then\n         proj_double = project .. \"/\" .. mod\n      end\n      if project then\n         -- retrieve bytecode by project and module\n         bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                            module_name  = mod })\n                      : resultset())\n         if not bytecode then\n            -- try mod_double\n            project_stmt:reset()\n            bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                            module_name  = mod_double })\n                      : resultset())\n         end\n         if not bytecode then\n            -- try proj_double\n            project_stmt:reset()\n            bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                             module_name  = proj_double })\n                      : resultset())\n         end\n         project_stmt:reset()\n      else\n         -- retrieve by bare module name\n         bytecode = resultMap(\n                      module_stmt:bindkv ({ name  = mod })\n                      : resultset())\n         if not bytecode then\n            module_stmt:reset()\n            bytecode =resultMap(\n                      module_stmt:bindkv ({ name  = mod })\n\n                      : resultset())\n         end\n         module_stmt:reset()\n      end\n      if bytecode then\n         local binary, hash = bytecode.binary, bytecode.hash\n         -- return a module-loading closure if already in scope\n         if _Bridge.loaded[hash] then\n            return function()\n               return package.loaded[_Bridge.loaded[hash]]\n            end\n         end\n         _Bridge.bridge_modules[\"@\" .. mod_name] = true\n         local loadFn, errmsg = load(binary, \"@\" .. mod_name)\n         if loadFn then\n            _Bridge.loaded[hash] = mod_name\n            return loadFn\n         else\n             error(errmsg)\n         end\n      else\n         return nil, (\"unable to load: \" .. mod_name)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nif _Bridge.bootstrap_conn then\n   table.insert(package.loaders, 2, loaderGen(_Bridge.bootstrap_conn))\nend\nif _Bridge.modules_conn then\n   table.insert(package.loaders, 2, loaderGen(_Bridge.modules_conn))\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n   local getinfo, error, rawset, rawget = debug.getinfo, error, rawset, rawget\n   local strict = {}\n\n   local function what ()\n      local d = getinfo(3, \"S\")\n      return d and d.what or \"C\"\n   end\n\n   --- make an existing table strict.\n   -- @string name name of table (optional)\n   -- @tab[opt] mod table - if `nil` then we\'ll return a new table\n   -- @tab[opt] predeclared - table of variables that are to be considered predeclared.\n   -- @return the given table, or a new table\n   stricture = function (name,mod,predeclared)\n      local mt, old_newindex, old_index, old_index_type, global, closed\n      if predeclared then\n         global = predeclared.__global\n         closed = predeclared.__closed\n      end\n      if type(mod) == \'table\' then\n         mt = getmetatable(mod)\n         if mt and rawget(mt,\'__declared\') then return end -- already patched...\n      else\n         mod = {}\n      end\n      if mt == nil then\n         mt = {}\n         setmetatable(mod, mt)\n      else\n         old_newindex = mt.__newindex\n         old_index = mt.__index\n         old_index_type = type(old_index)\n      end\n      mt.__declared = predeclared or {}\n      mt.__newindex = function(t, n, v)\n         if old_newindex then\n            old_newindex(t, n, v)\n            if rawget(t,n)~=nil then return end\n         end\n         if not mt.__declared[n] then\n            if global then\n               local w = what()\n               if w ~= \"main\" and w ~= \"C\" then\n                  error(\"assign to undeclared global \'\"..n..\"\'\", 2)\n               end\n            end\n            mt.__declared[n] = true\n         end\n         rawset(t, n, v)\n      end\n      mt.__index = function(t,n)\n         if not mt.__declared[n] and what() ~= \"C\" then\n            if old_index then\n               if old_index_type == \"table\" then\n                  local fallback = old_index[n]\n                  if fallback ~= nil then\n                     return fallback\n                  end\n               else\n                  local res = old_index(t, n)\n                     if res ~= nil then\n                        return res\n                     end\n                  end\n               end\n               local msg = \"variable \'\"..n..\"\' is not declared\"\n               if name then\n                  msg = msg .. \" in \'\"..name..\"\'\"\n               end\n               error(msg, 2)\n            end\n         return rawget(t, n)\n      end\n\n      return mod\n   end\nend\n",
},
  { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "load",
hash = "7f90f3309549ea544f496b9050c6e46a4498ba57eebad5788ae540ce3d6a9579",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\n\n\n\n\nstricture(nil,_G,{_PROMPT=true,__global=true})\nstricture = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, C, Cg, Ct, R, match = L.P, L.C, L.Cg, L.Ct, L.R, L.match\nlocal format = assert(string.format)\nlocal MAX_INT = 9007199254740991\n\nlocal function cast_to_int(str_val)\n   local num = tonumber(str_val)\n   if num > MAX_INT then\n      error (\"version numbers cannot exceed 2^53 - 1, \"\n             .. str_val .. \" is invalid\")\n   end\n   return num\nend\n\nlocal function parse_version(str)\n   local major  = Cg(R\"09\"^1, \"major\")\n   local minor  = Cg(R\"09\"^1, \"minor\")\n   local patch  = Cg(R\"09\"^1, \"patch\")\n   local kelvin = P\"[\" * Cg(R\"09\"^1, \"kelvin\") * P\"]\"\n   local knuth  = Cg(R\"09\"^1, \"knuth\") * P\"..\"\n   local patt = Ct(major\n                  * (P\".\" * minor)\n                  * (P\".\" * (kelvin + knuth + patch) + P(-1)))\n                  * P(-1)\n   local ver = match(patt, str)\n   if not ver then\n      if match(R\"09\"^1 * P\".\"^-1 * P(-1), str) then\n         error(\"Must provide at least major and minor version numbers\")\n      else\n         error(\"invalid --version format: \" .. str)\n      end\n   end\n   -- Cast to number\n   for k,v in pairs(ver) do\n      ver[k] = cast_to_int(v)\n   end\n   -- make alternate patch forms into flags\n   if ver.kelvin then\n      ver.patch = ver.kelvin\n      ver.kelvin = true\n   elseif ver.knuth then\n      ver.patch = ver.knuth\n      ver.knuth = true\n   end\n\n   return ver\nend\n\n_Bridge.parse_version = parse_version\n\n\n\n\nlocal brParse = require \"argparse\" ()\n\n_Bridge.brParse = brParse\n\nbrParse\n   : require_command (false)\n   : name \"br\"\n   : description (\"An lua, howth castle & environs.\\n\\n\"\n               .. \"To view help for each command, type br <command> -h.\")\n   : epilog \"For more info, see https://special-circumstanc.es\"\n   : help_description_margin(25)\n   : option \"-f\" \"--file\"\n      : description \"load and run a file. Lua only, for now\"\n      : args(1)\n\nbrParse\n   : flag \"--show-arguments\"\n      : description \"display the args table. For development purposes.\"\n\nlocal orb_c = brParse : command \"orb o\"\n                         : description \"Literate compiler for Orb format.\"\n\norb_c\n   : require_command (false)\n\norb_c\n  : flag \"-P --pedantic\"\n    : description \"Perform all filters, linting, crash on errors, etc.\"\n\norb_c\n  : command \"old\"\n     : description \"Use the original compiler. Deprecated.\"\n\norb_c\n   : command \"serve\"\n      : description \"Launch the Orb server.\"\n\norb_c\n   : command \"knit\"\n      : description \"Knit the codex.\"\n\norb_c\n   : command \"weave\"\n      : description \"Weave the codex.\"\n\nlocal orb_command_c = orb_c\n   : command \"compile\"\n      : description \"Knits the codex and compiles the resulting sorcery files.\"\n      : help_vertical_space(1)\n\norb_command_c\n  : option \"-v --version\"\n     : description \"A (semantic) version string.\"\n     : convert(parse_version)\n     : args(1)\n\norb_command_c\n  : option \"-e --edition\"\n     : description ( \"A named edition:\\n  special meaning applies to \"\n                    .. \"SESSION, CANDIDATE, and RELEASE.\")\n     : args(1)\n\norb_command_c\n  : option \"-H --home\"\n     : description (\"URL to fetch versions of the project.\")\n     : args(1)\n\norb_command_c\n  : option \"-R --repo\"\n     : description ( \"URL for the project\'s source repository.\\n\"\n                  .. \"  Defaults to git remote \'origin\'.\")\n     : args(1)\n\norb_command_c\n  : option \"-W --website\"\n     : description (\"URL for the project\'s user-facing website:\\n\"\n                 .. \"  documentation, tutorials, examples, etc.\")\n     : args(1)\n\norb_command_c\n  : option \"-p --project\"\n     : description \"Name of project.  Defaults to name of home directory.\"\n\norb_c\n   : command \"revert\"\n   : description \"Revert the latest compiled changes in project.\"\n   : option \"-p --project\"\n      : description \"Project to revert.\"\n      : args(1)\n\nlocal grym_c = brParse : command \"grym\"\n                       : description (\"Backup compiler for Orb format.\\n\"\n                                    ..\"Not intended for long-term use.\")\nlocal helm_c = brParse\n                  : command \"helm i\"\n                     : description \"launch helm, the \'i\'nteractive REPL.\"\n                     : help_description_margin(35)\n\nhelm_c\n   : option \"-s --session\"\n      : description \"Start the repl with a given, named session.\"\n      : args(1)\n\nhelm_c\n   : option \"-n --new-session\"\n      : description \"Begin a new, named session.\"\n      : args(1)\n\nlocal export_c = brParse\n                    : command \"export\"\n                    : description \"Export a project from the database\"\n\nexport_c\n   : argument \"project\"\n     : description \"Project or projects to export\"\n     : args \"?\"\n\nexport_c\n  : option \"-o\" \"--outfile\"\n     : description (\"A file to export projects to.\"\n                 .. \"Defaults to ./<project>.bundle\")\n     : args(1)\n\nexport_c\n   : option \"-v\" \"--version\"\n      : description \"Version of the project to export\"\n      : convert(parse_version)\n      : args(1)\n\nexport_c\n   : flag \"-a\" \"--all\"\n      : description (\"Export all projects.\"\n                     .. \"Latest bundles if no version is specified.\")\n\nlocal import_c = brParse\n                    : command \"import\"\n                    : description \"import a project from a bundle file\"\n\nimport_c\n   : argument \"file\"\n   : description \"a bundled project file or files\"\n   : args \"+\"\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\ncollectgarbage()\n\n\n\n\n\n\n\n\nif rawget(_G, \"arg\") ~= nil then\n   -- shim the arg array to emulate the \"lua <scriptname>\" calling\n   -- convention which argparse expects\n   table.insert(arg, 0, \"\")\n   _Bridge.args = _Bridge.brParse:parse()\n   local args = _Bridge.args\n   if args.show_arguments then\n      args.show_arguments = nil -- no reason to include this\n      local ts = require \"helm:helm/repr\".ts\n      print(ts(args))\n   end\n   if args.orb then\n      if args.revert then\n         local revert = require \"bundle:revert\"\n         revert()\n      elseif args.old then\n         local orb = require \"orb\"\n         local uv = require \"luv\"\n         orb.run(uv.cwd())\n      else\n          local orb = require \"orb\"\n          local uv  = require \"luv\"\n          local lume = orb.lume(uv.cwd())\n          lume:run()\n          if args.serve then\n             lume:serve()\n          end\n      end\n   elseif args.grym == true then\n      local grym = require \"grym:orb\"\n      local uv = require \"luv\"\n      grym.run(uv.cwd())\n   elseif args.helm then\n      print \"helm\"\n      local helm = require \"helm:helm\"\n      setfenv(0, __G)\n      helm(__G)\n      setfenv(0, _G)\n   elseif args.export then\n      if (not args.project) and (not args.all) then\n         error \"at least one project required without --all flag\"\n      end\n      local bundle\n      if not args.all then\n         bundle = require \"bundle:export\".export(args.project,\n                                                    args.version)\n      else\n         bundle = require \"bundle:export\".exportAll(args.version)\n      end\n      if args.outfile then\n         local file = io.open(args.outfile, \"w+\")\n         if not file then\n            error(\"unable to open \" .. args.outfile)\n         end\n         file:write(bundle)\n         file:close()\n      else\n         local bundle_name = args.project or \"all_modules\"\n         local outfilepath = \"./\" .. bundle_name .. \".bundle\"\n         local file = io.open(outfilepath, \"w+\")\n         if not file then\n            error(\"unable to open \" .. outfilepath)\n         end\n         file:write(bundle)\n         file:close()\n      end\n   elseif args.import then\n      local import = assert(_Bridge.import)\n      for _, file in ipairs(args.file) do\n         import(file)\n      end\n   elseif args.file then\n      if args.file:sub(-4, -1) == \".lua\" then\n         dofile(args.file)\n      end\n      -- handle .orb files here\n   end\nend\n",
},
  { 
vc_hash = "a38dbdbdfe92eba5abe6350d2eba3c25de276717",
name = "argparse",
hash = "3d5c1648ca891b1e740077def87d52ad7f8853dd17fb3e1be3097b0cdc8ebc85",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage.preload.argparse = (function ()\n-- The MIT License (MIT)\n\n-- Copyright (c) 2013 - 2018 Peter Melnichenko\n--                      2019 Paul Ouellette\n\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n-- the Software, and to permit persons to whom the Software is furnished to do so,\n-- subject to the following conditions:\n\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nlocal function deep_update(t1, t2)\n   for k, v in pairs(t2) do\n      if type(v) == \"table\" then\n         v = deep_update({}, v)\n      end\n\n      t1[k] = v\n   end\n\n   return t1\nend\n\n-- A property is a tuple {name, callback}.\n-- properties.args is number of properties that can be set as arguments\n-- when calling an object.\nlocal function class(prototype, properties, parent)\n   -- Class is the metatable of its instances.\n   local cl = {}\n   cl.__index = cl\n\n   if parent then\n      cl.__prototype = deep_update(deep_update({}, parent.__prototype), prototype)\n   else\n      cl.__prototype = prototype\n   end\n\n   if properties then\n      local names = {}\n\n      -- Create setter methods and fill set of property names.\n      for _, property in ipairs(properties) do\n         local name, callback = property[1], property[2]\n\n         cl[name] = function(self, value)\n            if not callback(self, value) then\n               self[\"_\" .. name] = value\n            end\n\n            return self\n         end\n\n         names[name] = true\n      end\n\n      function cl.__call(self, ...)\n         -- When calling an object, if the first argument is a table,\n         -- interpret keys as property names, else delegate arguments\n         -- to corresponding setters in order.\n         if type((...)) == \"table\" then\n            for name, value in pairs((...)) do\n               if names[name] then\n                  self[name](self, value)\n               end\n            end\n         else\n            local nargs = select(\"#\", ...)\n\n            for i, property in ipairs(properties) do\n               if i > nargs or i > properties.args then\n                  break\n               end\n\n               local arg = select(i, ...)\n\n               if arg ~= nil then\n                  self[property[1]](self, arg)\n               end\n            end\n         end\n\n         return self\n      end\n   end\n\n   -- If indexing class fails, fallback to its parent.\n   local class_metatable = {}\n   class_metatable.__index = parent\n\n   function class_metatable.__call(self, ...)\n      -- Calling a class returns its instance.\n      -- Arguments are delegated to the instance.\n      local object = deep_update({}, self.__prototype)\n      setmetatable(object, self)\n      return object(...)\n   end\n\n   return setmetatable(cl, class_metatable)\nend\n\nlocal function typecheck(name, types, value)\n   for _, type_ in ipairs(types) do\n      if type(value) == type_ then\n         return true\n      end\n   end\n\n   error((\"bad property \'%s\' (%s expected, got %s)\"):format(name, table.concat(types, \" or \"), type(value)))\nend\n\nlocal function typechecked(name, ...)\n   local types = {...}\n   return {name, function(_, value) typecheck(name, types, value) end}\nend\n\nlocal multiname = {\"name\", function(self, value)\n   typecheck(\"name\", {\"string\"}, value)\n\n   for alias in value:gmatch(\"%S+\") do\n      self._name = self._name or alias\n      table.insert(self._aliases, alias)\n   end\n\n   -- Do not set _name as with other properties.\n   return true\nend}\n\nlocal function parse_boundaries(str)\n   if tonumber(str) then\n      return tonumber(str), tonumber(str)\n   end\n\n   if str == \"*\" then\n      return 0, math.huge\n   end\n\n   if str == \"+\" then\n      return 1, math.huge\n   end\n\n   if str == \"?\" then\n      return 0, 1\n   end\n\n   if str:match \"^%d+%-%d+$\" then\n      local min, max = str:match \"^(%d+)%-(%d+)$\"\n      return tonumber(min), tonumber(max)\n   end\n\n   if str:match \"^%d+%+$\" then\n      local min = str:match \"^(%d+)%+$\"\n      return tonumber(min), math.huge\n   end\nend\n\nlocal function boundaries(name)\n   return {name, function(self, value)\n      typecheck(name, {\"number\", \"string\"}, value)\n\n      local min, max = parse_boundaries(value)\n\n      if not min then\n         error((\"bad property \'%s\'\"):format(name))\n      end\n\n      self[\"_min\" .. name], self[\"_max\" .. name] = min, max\n   end}\nend\n\nlocal actions = {}\n\nlocal option_action = {\"action\", function(_, value)\n   typecheck(\"action\", {\"function\", \"string\"}, value)\n\n   if type(value) == \"string\" and not actions[value] then\n      error((\"unknown action \'%s\'\"):format(value))\n   end\nend}\n\nlocal option_init = {\"init\", function(self)\n   self._has_init = true\nend}\n\nlocal option_default = {\"default\", function(self, value)\n   if type(value) ~= \"string\" then\n      self._init = value\n      self._has_init = true\n      return true\n   end\nend}\n\nlocal add_help = {\"add_help\", function(self, value)\n   typecheck(\"add_help\", {\"boolean\", \"string\", \"table\"}, value)\n\n   if self._help_option_idx then\n      table.remove(self._options, self._help_option_idx)\n      self._help_option_idx = nil\n   end\n\n   if value then\n      local help = self:flag()\n         :description \"Show this help message and exit.\"\n         :action(function()\n            print(self:get_help())\n            os.exit(0)\n         end)\n\n      if value ~= true then\n         help = help(value)\n      end\n\n      if not help._name then\n         help \"-h\" \"--help\"\n      end\n\n      self._help_option_idx = #self._options\n   end\nend}\n\nlocal Parser = class({\n   _arguments = {},\n   _options = {},\n   _commands = {},\n   _mutexes = {},\n   _groups = {},\n   _require_command = true,\n   _handle_options = true\n}, {\n   args = 3,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   add_help\n})\n\nlocal Command = class({\n   _aliases = {}\n}, {\n   args = 3,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"summary\", \"string\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   typechecked(\"hidden\", \"boolean\"),\n   add_help\n}, Parser)\n\nlocal Argument = class({\n   _minargs = 1,\n   _maxargs = 1,\n   _mincount = 1,\n   _maxcount = 1,\n   _defmode = \"unused\",\n   _show_default = true\n}, {\n   args = 5,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n})\n\nlocal Option = class({\n   _aliases = {},\n   _mincount = 0,\n   _overwrite = true\n}, {\n   args = 6,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   boundaries(\"count\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"overwrite\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n}, Argument)\n\nfunction Parser:_inherit_property(name, default)\n   local element = self\n\n   while true do\n      local value = element[\"_\" .. name]\n\n      if value ~= nil then\n         return value\n      end\n\n      if not element._parent then\n         return default\n      end\n\n      element = element._parent\n   end\nend\n\nfunction Argument:_get_argument_list()\n   local buf = {}\n   local i = 1\n\n   while i <= math.min(self._minargs, 3) do\n      local argname = self:_get_argname(i)\n\n      if self._default and self._defmode:find \"a\" then\n         argname = \"[\" .. argname .. \"]\"\n      end\n\n      table.insert(buf, argname)\n      i = i+1\n   end\n\n   while i <= math.min(self._maxargs, 3) do\n      table.insert(buf, \"[\" .. self:_get_argname(i) .. \"]\")\n      i = i+1\n\n      if self._maxargs == math.huge then\n         break\n      end\n   end\n\n   if i < self._maxargs then\n      table.insert(buf, \"...\")\n   end\n\n   return buf\nend\n\nfunction Argument:_get_usage()\n   local usage = table.concat(self:_get_argument_list(), \" \")\n\n   if self._default and self._defmode:find \"u\" then\n      if self._maxargs > 1 or (self._minargs == 1 and not self._defmode:find \"a\") then\n         usage = \"[\" .. usage .. \"]\"\n      end\n   end\n\n   return usage\nend\n\nfunction actions.store_true(result, target)\n   result[target] = true\nend\n\nfunction actions.store_false(result, target)\n   result[target] = false\nend\n\nfunction actions.store(result, target, argument)\n   result[target] = argument\nend\n\nfunction actions.count(result, target, _, overwrite)\n   if not overwrite then\n      result[target] = result[target] + 1\n   end\nend\n\nfunction actions.append(result, target, argument, overwrite)\n   result[target] = result[target] or {}\n   table.insert(result[target], argument)\n\n   if overwrite then\n      table.remove(result[target], 1)\n   end\nend\n\nfunction actions.concat(result, target, arguments, overwrite)\n   if overwrite then\n      error(\"\'concat\' action can\'t handle too many invocations\")\n   end\n\n   result[target] = result[target] or {}\n\n   for _, argument in ipairs(arguments) do\n      table.insert(result[target], argument)\n   end\nend\n\nfunction Argument:_get_action()\n   local action, init\n\n   if self._maxcount == 1 then\n      if self._maxargs == 0 then\n         action, init = \"store_true\", nil\n      else\n         action, init = \"store\", nil\n      end\n   else\n      if self._maxargs == 0 then\n         action, init = \"count\", 0\n      else\n         action, init = \"append\", {}\n      end\n   end\n\n   if self._action then\n      action = self._action\n   end\n\n   if self._has_init then\n      init = self._init\n   end\n\n   if type(action) == \"string\" then\n      action = actions[action]\n   end\n\n   return action, init\nend\n\n-- Returns placeholder for `narg`-th argument.\nfunction Argument:_get_argname(narg)\n   local argname = self._argname or self:_get_default_argname()\n\n   if type(argname) == \"table\" then\n      return argname[narg]\n   else\n      return argname\n   end\nend\n\nfunction Argument:_get_choices_list()\n   return \"{\" .. table.concat(self._choices, \",\") .. \"}\"\nend\n\nfunction Argument:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self._name .. \">\"\n   end\nend\n\nfunction Option:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self:_get_default_target() .. \">\"\n   end\nend\n\n-- Returns labels to be shown in the help message.\nfunction Argument:_get_label_lines()\n   if self._choices then\n      return {self:_get_choices_list()}\n   else\n      return {self._name}\n   end\nend\n\nfunction Option:_get_label_lines()\n   local argument_list = self:_get_argument_list()\n\n   if #argument_list == 0 then\n      -- Don\'t put aliases for simple flags like `-h` on different lines.\n      return {table.concat(self._aliases, \", \")}\n   end\n\n   local longest_alias_length = -1\n\n   for _, alias in ipairs(self._aliases) do\n      longest_alias_length = math.max(longest_alias_length, #alias)\n   end\n\n   local argument_list_repr = table.concat(argument_list, \" \")\n   local lines = {}\n\n   for i, alias in ipairs(self._aliases) do\n      local line = (\" \"):rep(longest_alias_length - #alias) .. alias .. \" \" .. argument_list_repr\n\n      if i ~= #self._aliases then\n         line = line .. \",\"\n      end\n\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nfunction Command:_get_label_lines()\n   return {table.concat(self._aliases, \", \")}\nend\n\nfunction Argument:_get_description()\n   if self._default and self._show_default then\n      if self._description then\n         return (\"%s (default: %s)\"):format(self._description, self._default)\n      else\n         return (\"default: %s\"):format(self._default)\n      end\n   else\n      return self._description or \"\"\n   end\nend\n\nfunction Command:_get_description()\n   return self._summary or self._description or \"\"\nend\n\nfunction Option:_get_usage()\n   local usage = self:_get_argument_list()\n   table.insert(usage, 1, self._name)\n   usage = table.concat(usage, \" \")\n\n   if self._mincount == 0 or self._default then\n      usage = \"[\" .. usage .. \"]\"\n   end\n\n   return usage\nend\n\nfunction Argument:_get_default_target()\n   return self._name\nend\n\nfunction Option:_get_default_target()\n   local res\n\n   for _, alias in ipairs(self._aliases) do\n      if alias:sub(1, 1) == alias:sub(2, 2) then\n         res = alias:sub(3)\n         break\n      end\n   end\n\n   res = res or self._name:sub(2)\n   return (res:gsub(\"-\", \"_\"))\nend\n\nfunction Option:_is_vararg()\n   return self._maxargs ~= self._minargs\nend\n\nfunction Parser:_get_fullname(exclude_root)\n   local parent = self._parent\n   if exclude_root and not parent then\n      return \"\"\n   end\n   local buf = {self._name}\n\n   while parent do\n      if not exclude_root or parent._parent then\n         table.insert(buf, 1, parent._name)\n      end\n      parent = parent._parent\n   end\n\n   return table.concat(buf, \" \")\nend\n\nfunction Parser:_update_charset(charset)\n   charset = charset or {}\n\n   for _, command in ipairs(self._commands) do\n      command:_update_charset(charset)\n   end\n\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         charset[alias:sub(1, 1)] = true\n      end\n   end\n\n   return charset\nend\n\nfunction Parser:argument(...)\n   local argument = Argument(...)\n   table.insert(self._arguments, argument)\n   return argument\nend\n\nfunction Parser:option(...)\n   local option = Option(...)\n   table.insert(self._options, option)\n   return option\nend\n\nfunction Parser:flag(...)\n   return self:option():args(0)(...)\nend\n\nfunction Parser:command(...)\n   local command = Command():add_help(true)(...)\n   command._parent = self\n   table.insert(self._commands, command)\n   return command\nend\n\nfunction Parser:mutex(...)\n   local elements = {...}\n\n   for i, element in ipairs(elements) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument, (\"bad argument #%d to \'mutex\' (Option or Argument expected)\"):format(i))\n   end\n\n   table.insert(self._mutexes, elements)\n   return self\nend\n\nfunction Parser:group(name, ...)\n   assert(type(name) == \"string\", (\"bad argument #1 to \'group\' (string expected, got %s)\"):format(type(name)))\n\n   local group = {name = name, ...}\n\n   for i, element in ipairs(group) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument or mt == Command,\n         (\"bad argument #%d to \'group\' (Option or Argument or Command expected)\"):format(i + 1))\n   end\n\n   table.insert(self._groups, group)\n   return self\nend\n\nlocal usage_welcome = \"Usage: \"\n\nfunction Parser:get_usage()\n   if self._usage then\n      return self._usage\n   end\n\n   local usage_margin = self:_inherit_property(\"usage_margin\", #usage_welcome)\n   local max_usage_width = self:_inherit_property(\"usage_max_width\", 70)\n   local lines = {usage_welcome .. self:_get_fullname()}\n\n   local function add(s)\n      if #lines[#lines]+1+#s <= max_usage_width then\n         lines[#lines] = lines[#lines] .. \" \" .. s\n      else\n         lines[#lines+1] = (\" \"):rep(usage_margin) .. s\n      end\n   end\n\n   -- Normally options are before positional arguments in usage messages.\n   -- However, vararg options should be after, because they can\'t be reliable used\n   -- before a positional argument.\n   -- Mutexes come into play, too, and are shown as soon as possible.\n   -- Overall, output usages in the following order:\n   -- 1. Mutexes that don\'t have positional arguments or vararg options.\n   -- 2. Options that are not in any mutexes and are not vararg.\n   -- 3. Positional arguments - on their own or as a part of a mutex.\n   -- 4. Remaining mutexes.\n   -- 5. Remaining options.\n\n   local elements_in_mutexes = {}\n   local added_elements = {}\n   local added_mutexes = {}\n   local argument_to_mutexes = {}\n\n   local function add_mutex(mutex, main_argument)\n      if added_mutexes[mutex] then\n         return\n      end\n\n      added_mutexes[mutex] = true\n      local buf = {}\n\n      for _, element in ipairs(mutex) do\n         if not element._hidden and not added_elements[element] then\n            if getmetatable(element) == Option or element == main_argument then\n               table.insert(buf, element:_get_usage())\n               added_elements[element] = true\n            end\n         end\n      end\n\n      if #buf == 1 then\n         add(buf[1])\n      elseif #buf > 1 then\n         add(\"(\" .. table.concat(buf, \" | \") .. \")\")\n      end\n   end\n\n   local function add_element(element)\n      if not element._hidden and not added_elements[element] then\n         add(element:_get_usage())\n         added_elements[element] = true\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      local is_vararg = false\n      local has_argument = false\n\n      for _, element in ipairs(mutex) do\n         if getmetatable(element) == Option then\n            if element:_is_vararg() then\n               is_vararg = true\n            end\n         else\n            has_argument = true\n            argument_to_mutexes[element] = argument_to_mutexes[element] or {}\n            table.insert(argument_to_mutexes[element], mutex)\n         end\n\n         elements_in_mutexes[element] = true\n      end\n\n      if not is_vararg and not has_argument then\n         add_mutex(mutex)\n      end\n   end\n\n   for _, option in ipairs(self._options) do\n      if not elements_in_mutexes[option] and not option:_is_vararg() then\n         add_element(option)\n      end\n   end\n\n   -- Add usages for positional arguments, together with one mutex containing them, if they are in a mutex.\n   for _, argument in ipairs(self._arguments) do\n      -- Pick a mutex as a part of which to show this argument, take the first one that\'s still available.\n      local mutex\n\n      if elements_in_mutexes[argument] then\n         for _, argument_mutex in ipairs(argument_to_mutexes[argument]) do\n            if not added_mutexes[argument_mutex] then\n               mutex = argument_mutex\n            end\n         end\n      end\n\n      if mutex then\n         add_mutex(mutex, argument)\n      else\n         add_element(argument)\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      add_mutex(mutex)\n   end\n\n   for _, option in ipairs(self._options) do\n      add_element(option)\n   end\n\n   if #self._commands > 0 then\n      if self._require_command then\n         add(\"<command>\")\n      else\n         add(\"[<command>]\")\n      end\n\n      add(\"...\")\n   end\n\n   return table.concat(lines, \"\\n\")\nend\n\nlocal function split_lines(s)\n   if s == \"\" then\n      return {}\n   end\n\n   local lines = {}\n\n   if s:sub(-1) ~= \"\\n\" then\n      s = s .. \"\\n\"\n   end\n\n   for line in s:gmatch(\"([^\\n]*)\\n\") do\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nlocal function autowrap_line(line, max_length)\n   -- Algorithm for splitting lines is simple and greedy.\n   local result_lines = {}\n\n   -- Preserve original indentation of the line, put this at the beginning of each result line.\n   -- If the first word looks like a list marker (\'*\', \'+\', or \'-\'), add spaces so that starts\n   -- of the second and the following lines vertically align with the start of the second word.\n   local indentation = line:match(\"^ *\")\n\n   if line:find(\"^ *[%*%+%-]\") then\n      indentation = indentation .. \" \" .. line:match(\"^ *[%*%+%-]( *)\")\n   end\n\n   -- Parts of the last line being assembled.\n   local line_parts = {}\n\n   -- Length of the current line.\n   local line_length = 0\n\n   -- Index of the next character to consider.\n   local index = 1\n\n   while true do\n      local word_start, word_finish, word = line:find(\"([^ ]+)\", index)\n\n      if not word_start then\n         -- Ignore trailing spaces, if any.\n         break\n      end\n\n      local preceding_spaces = line:sub(index, word_start - 1)\n      index = word_finish + 1\n\n      if (#line_parts == 0) or (line_length + #preceding_spaces + #word <= max_length) then\n         -- Either this is the very first word or it fits as an addition to the current line, add it.\n         table.insert(line_parts, preceding_spaces) -- For the very first word this adds the indentation.\n         table.insert(line_parts, word)\n         line_length = line_length + #preceding_spaces + #word\n      else\n         -- Does not fit, finish current line and put the word into a new one.\n         table.insert(result_lines, table.concat(line_parts))\n         line_parts = {indentation, word}\n         line_length = #indentation + #word\n      end\n   end\n\n   if #line_parts > 0 then\n      table.insert(result_lines, table.concat(line_parts))\n   end\n\n   if #result_lines == 0 then\n      -- Preserve empty lines.\n      result_lines[1] = \"\"\n   end\n\n   return result_lines\nend\n\n-- Automatically wraps lines within given array,\n-- attempting to limit line length to `max_length`.\n-- Existing line splits are preserved.\nlocal function autowrap(lines, max_length)\n   local result_lines = {}\n\n   for _, line in ipairs(lines) do\n      local autowrapped_lines = autowrap_line(line, max_length)\n\n      for _, autowrapped_line in ipairs(autowrapped_lines) do\n         table.insert(result_lines, autowrapped_line)\n      end\n   end\n\n   return result_lines\nend\n\nfunction Parser:_get_element_help(element)\n   local label_lines = element:_get_label_lines()\n   local description_lines = split_lines(element:_get_description())\n\n   local result_lines = {}\n\n   -- All label lines should have the same length (except the last one, it has no comma).\n   -- If too long, start description after all the label lines.\n   -- Otherwise, combine label and description lines.\n\n   local usage_margin_len = self:_inherit_property(\"help_usage_margin\", 3)\n   local usage_margin = (\" \"):rep(usage_margin_len)\n   local description_margin_len = self:_inherit_property(\"help_description_margin\", 25)\n   local description_margin = (\" \"):rep(description_margin_len)\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if help_max_width then\n      local description_max_width = math.max(help_max_width - description_margin_len, 10)\n      description_lines = autowrap(description_lines, description_max_width)\n   end\n\n   if #label_lines[1] >= (description_margin_len - usage_margin_len) then\n      for _, label_line in ipairs(label_lines) do\n         table.insert(result_lines, usage_margin .. label_line)\n      end\n\n      for _, description_line in ipairs(description_lines) do\n         table.insert(result_lines, description_margin .. description_line)\n      end\n   else\n      for i = 1, math.max(#label_lines, #description_lines) do\n         local label_line = label_lines[i]\n         local description_line = description_lines[i]\n\n         local line = \"\"\n\n         if label_line then\n            line = usage_margin .. label_line\n         end\n\n         if description_line and description_line ~= \"\" then\n            line = line .. (\" \"):rep(description_margin_len - #line) .. description_line\n         end\n\n         table.insert(result_lines, line)\n      end\n   end\n\n   return table.concat(result_lines, \"\\n\")\nend\n\nlocal function get_group_types(group)\n   local types = {}\n\n   for _, element in ipairs(group) do\n      types[getmetatable(element)] = true\n   end\n\n   return types\nend\n\nfunction Parser:_add_group_help(blocks, added_elements, label, elements)\n   local buf = {label}\n\n   for _, element in ipairs(elements) do\n      if not element._hidden and not added_elements[element] then\n         added_elements[element] = true\n         table.insert(buf, self:_get_element_help(element))\n      end\n   end\n\n   if #buf > 1 then\n      table.insert(blocks, table.concat(buf, (\"\\n\"):rep(self:_inherit_property(\"help_vertical_space\", 0) + 1)))\n   end\nend\n\nfunction Parser:get_help()\n   if self._help then\n      return self._help\n   end\n\n   local blocks = {self:get_usage()}\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if self._description then\n      local description = self._description\n\n      if help_max_width then\n         description = table.concat(autowrap(split_lines(description), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, description)\n   end\n\n   -- 1. Put groups containing arguments first, then other arguments.\n   -- 2. Put remaining groups containing options, then other options.\n   -- 3. Put remaining groups containing commands, then other commands.\n   -- Assume that an element can\'t be in several groups.\n   local groups_by_type = {\n      [Argument] = {},\n      [Option] = {},\n      [Command] = {}\n   }\n\n   for _, group in ipairs(self._groups) do\n      local group_types = get_group_types(group)\n\n      for _, mt in ipairs({Argument, Option, Command}) do\n         if group_types[mt] then\n            table.insert(groups_by_type[mt], group)\n            break\n         end\n      end\n   end\n\n   local default_groups = {\n      {name = \"Arguments\", type = Argument, elements = self._arguments},\n      {name = \"Options\", type = Option, elements = self._options},\n      {name = \"Commands\", type = Command, elements = self._commands}\n   }\n\n   local added_elements = {}\n\n   for _, default_group in ipairs(default_groups) do\n      local type_groups = groups_by_type[default_group.type]\n\n      for _, group in ipairs(type_groups) do\n         self:_add_group_help(blocks, added_elements, group.name .. \":\", group)\n      end\n\n      local default_label = default_group.name .. \":\"\n\n      if #type_groups > 0 then\n         default_label = \"Other \" .. default_label:gsub(\"^.\", string.lower)\n      end\n\n      self:_add_group_help(blocks, added_elements, default_label, default_group.elements)\n   end\n\n   if self._epilog then\n      local epilog = self._epilog\n\n      if help_max_width then\n         epilog = table.concat(autowrap(split_lines(epilog), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, epilog)\n   end\n\n   return table.concat(blocks, \"\\n\\n\")\nend\n\nfunction Parser:add_help_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_help_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local help = self:command()\n      :description \"Show help for commands.\"\n   help:argument \"command\"\n      :description \"The command to show help for.\"\n      :args \"?\"\n      :action(function(_, _, cmd)\n         if not cmd then\n            print(self:get_help())\n            os.exit(0)\n         else\n            for _, command in ipairs(self._commands) do\n               for _, alias in ipairs(command._aliases) do\n                  if alias == cmd then\n                     print(command:get_help())\n                     os.exit(0)\n                  end\n               end\n            end\n         end\n         help:error((\"unknown command \'%s\'\"):format(cmd))\n      end)\n\n   if value then\n      help = help(value)\n   end\n\n   if not help._name then\n      help \"help\"\n   end\n\n   help._is_help_command = true\n   return self\nend\n\nfunction Parser:_is_shell_safe()\n   if self._basename then\n      if self._basename:find(\"[^%w_%-%+%.]\") then\n         return false\n      end\n   else\n      for _, alias in ipairs(self._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n   end\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n      if option._choices then\n         for _, choice in ipairs(option._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, argument in ipairs(self._arguments) do\n      if argument._choices then\n         for _, choice in ipairs(argument._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, command in ipairs(self._commands) do\n      if not command:_is_shell_safe() then\n         return false\n      end\n   end\n   return true\nend\n\nfunction Parser:add_complete(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:option()\n      :description \"Output a shell completion script for the specified shell.\"\n      :args(1)\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"--completion\"\n   end\n\n   return self\nend\n\nfunction Parser:add_complete_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:command()\n      :description \"Output a shell completion script.\"\n   complete:argument \"shell\"\n      :description \"The shell to output a completion script for.\"\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"completion\"\n   end\n\n   return self\nend\n\nlocal function base_name(pathname)\n   return pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\") or pathname\nend\n\nlocal function get_short_description(element)\n   local short = element:_get_description():match(\"^(.-)%.%s\")\n   return short or element:_get_description():match(\"^(.-)%.?$\")\nend\n\nfunction Parser:_get_options()\n   local options = {}\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         table.insert(options, alias)\n      end\n   end\n   return table.concat(options, \" \")\nend\n\nfunction Parser:_get_commands()\n   local commands = {}\n   for _, command in ipairs(self._commands) do\n      for _, alias in ipairs(command._aliases) do\n         table.insert(commands, alias)\n      end\n   end\n   return table.concat(commands, \" \")\nend\n\nfunction Parser:_bash_option_args(buf, indent)\n   local opts = {}\n   for _, option in ipairs(self._options) do\n      if option._choices or option._minargs > 0 then\n         local compreply\n         if option._choices then\n            compreply = \'COMPREPLY=($(compgen -W \"\' .. table.concat(option._choices, \" \") .. \'\" -- \"$cur\"))\'\n         else\n            compreply = \'COMPREPLY=($(compgen -f -- \"$cur\"))\'\n         end\n         table.insert(opts, (\" \"):rep(indent + 4) .. table.concat(option._aliases, \"|\") .. \")\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. compreply)\n         table.insert(opts, (\" \"):rep(indent + 8) .. \"return 0\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. \";;\")\n      end\n   end\n\n   if #opts > 0 then\n      table.insert(buf, (\" \"):rep(indent) .. \'case \"$prev\" in\')\n      table.insert(buf, table.concat(opts, \"\\n\"))\n      table.insert(buf, (\" \"):rep(indent) .. \"esac\\n\")\n   end\nend\n\nfunction Parser:_bash_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \'args=(\"${args[@]:1}\")\')\n   table.insert(buf, (\" \"):rep(indent) .. \'for arg in \"${args[@]}\"; do\')\n   table.insert(buf, (\" \"):rep(indent + 4) .. \'case \"$arg\" in\')\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. table.concat(command._aliases, \"|\") .. \")\")\n      if self._parent then\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"$cmd \' .. command._name .. \'\"\')\n      else\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"\' .. command._name .. \'\"\')\n      end\n      table.insert(buf, (\" \"):rep(indent + 12) .. \'opts=\"$opts \' .. command:_get_options() .. \'\"\')\n      command:_bash_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n      table.insert(buf, (\" \"):rep(indent + 12) .. \";;\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"esac\")\n   table.insert(buf, (\" \"):rep(indent) .. \"done\")\nend\n\nfunction Parser:_bash_cmd_completions(buf)\n   local cmd_buf = {}\n   if self._parent then\n      self:_bash_option_args(cmd_buf, 12)\n   end\n   if #self._commands > 0 then\n      table.insert(cmd_buf, (\" \"):rep(12) .. \'COMPREPLY=($(compgen -W \"\' .. self:_get_commands() .. \'\" -- \"$cur\"))\')\n   elseif self._is_help_command then\n      table.insert(cmd_buf, (\" \"):rep(12)\n         .. \'COMPREPLY=($(compgen -W \"\'\n         .. self._parent:_get_commands()\n         .. \'\" -- \"$cur\"))\')\n   end\n   if #cmd_buf > 0 then\n      table.insert(buf, (\" \"):rep(8) .. \"\'\" .. self:_get_fullname(true) .. \"\')\")\n      table.insert(buf, table.concat(cmd_buf, \"\\n\"))\n      table.insert(buf, (\" \"):rep(12) .. \";;\")\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_bash_cmd_completions(buf)\n   end\nend\n\nfunction Parser:get_bash_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {([[\n_%s() {\n    local IFS=$\' \\t\\n\'\n    local args cur prev cmd opts arg\n    args=(\"${COMP_WORDS[@]}\")\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    opts=\"%s\"\n]]):format(self._basename, self:_get_options())}\n\n   self:_bash_option_args(buf, 4)\n   self:_bash_get_cmd(buf, 4)\n   if #self._commands > 0 then\n      table.insert(buf, \"\")\n      table.insert(buf, (\" \"):rep(4) .. \'case \"$cmd\" in\')\n      self:_bash_cmd_completions(buf)\n      table.insert(buf, (\" \"):rep(4) .. \"esac\\n\")\n   end\n\n   table.insert(buf, ([=[\n    if [[ \"$cur\" = -* ]]; then\n        COMPREPLY=($(compgen -W \"$opts\" -- \"$cur\"))\n    fi\n}\n\ncomplete -F _%s -o bashdefault -o default %s\n]=]):format(self._basename, self._basename))\n\n   return table.concat(buf, \"\\n\")\nend\n\nfunction Parser:_zsh_arguments(buf, cmd_name, indent)\n   if self._parent then\n      table.insert(buf, (\" \"):rep(indent) .. \"options=(\")\n      table.insert(buf, (\" \"):rep(indent + 2) .. \"$options\")\n   else\n      table.insert(buf, (\" \"):rep(indent) .. \"local -a options=(\")\n   end\n\n   for _, option in ipairs(self._options) do\n      local line = {}\n      if #option._aliases > 1 then\n         if option._maxcount > 1 then\n            table.insert(line, \'\"*\"\')\n         end\n         table.insert(line, \"{\" .. table.concat(option._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\')\n         if option._maxcount > 1 then\n            table.insert(line, \"*\")\n         end\n         table.insert(line, option._name)\n      end\n      if option._description then\n         local description = get_short_description(option):gsub(\'[\"%]:`$]\', \"\\\\%0\")\n         table.insert(line, \"[\" .. description .. \"]\")\n      end\n      if option._maxargs == math.huge then\n         table.insert(line, \":*\")\n      end\n      if option._choices then\n         table.insert(line, \": :(\" .. table.concat(option._choices, \" \") .. \")\")\n      elseif option._maxargs > 0 then\n         table.insert(line, \": :_files\")\n      end\n      table.insert(line, \'\"\')\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(line))\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \")\")\n   table.insert(buf, (\" \"):rep(indent) .. \"_arguments -s -S \\\\\")\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"$options \\\\\")\n\n   if self._is_help_command then\n      table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :(\' .. self._parent:_get_commands() .. \')\" \\\\\')\n   else\n      for _, argument in ipairs(self._arguments) do\n         local spec\n         if argument._choices then\n            spec = \": :(\" .. table.concat(argument._choices, \" \") .. \")\"\n         else\n            spec = \": :_files\"\n         end\n         if argument._maxargs == math.huge then\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*\' .. spec .. \'\" \\\\\')\n            break\n         end\n         for _ = 1, argument._maxargs do\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"\' .. spec .. \'\" \\\\\')\n         end\n      end\n\n      if #self._commands > 0 then\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :_\' .. cmd_name .. \'_cmds\" \\\\\')\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*:: :->args\" \\\\\')\n      end\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"&& return 0\")\nend\n\nfunction Parser:_zsh_cmds(buf, cmd_name)\n   table.insert(buf, \"\\n_\" .. cmd_name .. \"_cmds() {\")\n   table.insert(buf, \"  local -a commands=(\")\n\n   for _, command in ipairs(self._commands) do\n      local line = {}\n      if #command._aliases > 1 then\n         table.insert(line, \"{\" .. table.concat(command._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\' .. command._name)\n      end\n      if command._description then\n         table.insert(line, \":\" .. get_short_description(command):gsub(\'[\"`$]\', \"\\\\%0\"))\n      end\n      table.insert(buf, \"    \" .. table.concat(line) .. \'\"\')\n   end\n\n   table.insert(buf, \'  )\\n  _describe \"command\" commands\\n}\')\nend\n\nfunction Parser:_zsh_complete_help(buf, cmds_buf, cmd_name, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   self:_zsh_cmds(cmds_buf, cmd_name)\n   table.insert(buf, \"\\n\" .. (\" \"):rep(indent) .. \"case $words[1] in\")\n\n   for _, command in ipairs(self._commands) do\n      local name = cmd_name .. \"_\" .. command._name\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(command._aliases, \"|\") .. \")\")\n      command:_zsh_arguments(buf, name, indent + 4)\n      command:_zsh_complete_help(buf, cmds_buf, name, indent + 4)\n      table.insert(buf, (\" \"):rep(indent + 4) .. \";;\\n\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"esac\")\nend\n\nfunction Parser:get_zsh_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {(\"#compdef %s\\n\"):format(self._basename)}\n   local cmds_buf = {}\n   table.insert(buf, \"_\" .. self._basename .. \"() {\")\n   if #self._commands > 0 then\n      table.insert(buf, \"  local context state state_descr line\")\n      table.insert(buf, \"  typeset -A opt_args\\n\")\n   end\n   self:_zsh_arguments(buf, self._basename, 2)\n   self:_zsh_complete_help(buf, cmds_buf, self._basename, 2)\n   table.insert(buf, \"\\n  return 1\")\n   table.insert(buf, \"}\")\n\n   local result = table.concat(buf, \"\\n\")\n   if #cmds_buf > 0 then\n      result = result .. \"\\n\" .. table.concat(cmds_buf, \"\\n\")\n   end\n   return result .. \"\\n\\n_\" .. self._basename .. \"\\n\"\nend\n\nlocal function fish_escape(string)\n   return string:gsub(\"[\\\\\']\", \"\\\\%0\")\nend\n\nfunction Parser:_fish_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"set -e cmdline[1]\")\n   table.insert(buf, (\" \"):rep(indent) .. \"for arg in $cmdline\")\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"switch $arg\")\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. \"case \" .. table.concat(command._aliases, \" \"))\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"set cmd $cmd \" .. command._name)\n      command:_fish_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"end\")\n   table.insert(buf, (\" \"):rep(indent) .. \"end\")\nend\n\nfunction Parser:_fish_complete_help(buf, basename)\n   local prefix = \"complete -c \" .. basename\n   table.insert(buf, \"\")\n\n   for _, command in ipairs(self._commands) do\n      local aliases = table.concat(command._aliases, \" \")\n      local line\n      if self._parent then\n         line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n            :format(prefix, basename, self:_get_fullname(true), aliases)\n      else\n         line = (\"%s -n \'__fish_%s_using_command\' -xa \'%s\'\"):format(prefix, basename, aliases)\n      end\n      if command._description then\n         line = (\"%s -d \'%s\'\"):format(line, fish_escape(get_short_description(command)))\n      end\n      table.insert(buf, line)\n   end\n\n   if self._is_help_command then\n      local line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n         :format(prefix, basename, self:_get_fullname(true), self._parent:_get_commands())\n      table.insert(buf, line)\n   end\n\n   for _, option in ipairs(self._options) do\n      local parts = {prefix}\n\n      if self._parent then\n         table.insert(parts, \"-n \'__fish_\" .. basename .. \"_seen_command \" .. self:_get_fullname(true) .. \"\'\")\n      end\n\n      for _, alias in ipairs(option._aliases) do\n         if alias:match(\"^%-.$\") then\n            table.insert(parts, \"-s \" .. alias:sub(2))\n         elseif alias:match(\"^%-%-.+\") then\n            table.insert(parts, \"-l \" .. alias:sub(3))\n         end\n      end\n\n      if option._choices then\n         table.insert(parts, \"-xa \'\" .. table.concat(option._choices, \" \") .. \"\'\")\n      elseif option._minargs > 0 then\n         table.insert(parts, \"-r\")\n      end\n\n      if option._description then\n         table.insert(parts, \"-d \'\" .. fish_escape(get_short_description(option)) .. \"\'\")\n      end\n\n      table.insert(buf, table.concat(parts, \" \"))\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_fish_complete_help(buf, basename)\n   end\nend\n\nfunction Parser:get_fish_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {}\n\n   if #self._commands > 0 then\n      table.insert(buf, ([[\nfunction __fish_%s_print_command\n    set -l cmdline (commandline -poc)\n    set -l cmd]]):format(self._basename))\n      self:_fish_get_cmd(buf, 4)\n      table.insert(buf, ([[\n    echo \"$cmd\"\nend\n\nfunction __fish_%s_using_command\n    test (__fish_%s_print_command) = \"$argv\"\n    and return 0\n    or return 1\nend\n\nfunction __fish_%s_seen_command\n    string match -q \"$argv*\" (__fish_%s_print_command)\n    and return 0\n    or return 1\nend]]):format(self._basename, self._basename, self._basename, self._basename))\n   end\n\n   self:_fish_complete_help(buf, self._basename)\n   return table.concat(buf, \"\\n\") .. \"\\n\"\nend\n\nlocal function get_tip(context, wrong_name)\n   local context_pool = {}\n   local possible_name\n   local possible_names = {}\n\n   for name in pairs(context) do\n      if type(name) == \"string\" then\n         for i = 1, #name do\n            possible_name = name:sub(1, i - 1) .. name:sub(i + 1)\n\n            if not context_pool[possible_name] then\n               context_pool[possible_name] = {}\n            end\n\n            table.insert(context_pool[possible_name], name)\n         end\n      end\n   end\n\n   for i = 1, #wrong_name + 1 do\n      possible_name = wrong_name:sub(1, i - 1) .. wrong_name:sub(i + 1)\n\n      if context[possible_name] then\n         possible_names[possible_name] = true\n      elseif context_pool[possible_name] then\n         for _, name in ipairs(context_pool[possible_name]) do\n            possible_names[name] = true\n         end\n      end\n   end\n\n   local first = next(possible_names)\n\n   if first then\n      if next(possible_names, first) then\n         local possible_names_arr = {}\n\n         for name in pairs(possible_names) do\n            table.insert(possible_names_arr, \"\'\" .. name .. \"\'\")\n         end\n\n         table.sort(possible_names_arr)\n         return \"\\nDid you mean one of these: \" .. table.concat(possible_names_arr, \" \") .. \"?\"\n      else\n         return \"\\nDid you mean \'\" .. first .. \"\'?\"\n      end\n   else\n      return \"\"\n   end\nend\n\nlocal ElementState = class({\n   invocations = 0\n})\n\nfunction ElementState:__call(state, element)\n   self.state = state\n   self.result = state.result\n   self.element = element\n   self.target = element._target or element:_get_default_target()\n   self.action, self.result[self.target] = element:_get_action()\n   return self\nend\n\nfunction ElementState:error(fmt, ...)\n   self.state:error(fmt, ...)\nend\n\nfunction ElementState:convert(argument, index)\n   local converter = self.element._convert\n\n   if converter then\n      local ok, err\n\n      if type(converter) == \"function\" then\n         ok, err = converter(argument)\n      elseif type(converter[index]) == \"function\" then\n         ok, err = converter[index](argument)\n      else\n         ok = converter[argument]\n      end\n\n      if ok == nil then\n         self:error(err and \"%s\" or \"malformed argument \'%s\'\", err or argument)\n      end\n\n      argument = ok\n   end\n\n   return argument\nend\n\nfunction ElementState:default(mode)\n   return self.element._defmode:find(mode) and self.element._default\nend\n\nlocal function bound(noun, min, max, is_max)\n   local res = \"\"\n\n   if min ~= max then\n      res = \"at \" .. (is_max and \"most\" or \"least\") .. \" \"\n   end\n\n   local number = is_max and max or min\n   return res .. tostring(number) .. \" \" .. noun ..  (number == 1 and \"\" or \"s\")\nend\n\nfunction ElementState:set_name(alias)\n   self.name = (\"%s \'%s\'\"):format(alias and \"option\" or \"argument\", alias or self.element._name)\nend\n\nfunction ElementState:invoke()\n   self.open = true\n   self.overwrite = false\n\n   if self.invocations >= self.element._maxcount then\n      if self.element._overwrite then\n         self.overwrite = true\n      else\n         local num_times_repr = bound(\"time\", self.element._mincount, self.element._maxcount, true)\n         self:error(\"%s must be used %s\", self.name, num_times_repr)\n      end\n   else\n      self.invocations = self.invocations + 1\n   end\n\n   self.args = {}\n\n   if self.element._maxargs <= 0 then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:check_choices(argument)\n   if self.element._choices then\n      for _, choice in ipairs(self.element._choices) do\n         if argument == choice then\n            return\n         end\n      end\n      local choices_list = \"\'\" .. table.concat(self.element._choices, \"\', \'\") .. \"\'\"\n      local is_option = getmetatable(self.element) == Option\n      self:error(\"%s%s must be one of %s\", is_option and \"argument for \" or \"\", self.name, choices_list)\n   end\nend\n\nfunction ElementState:pass(argument)\n   self:check_choices(argument)\n   argument = self:convert(argument, #self.args + 1)\n   table.insert(self.args, argument)\n\n   if #self.args >= self.element._maxargs then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:complete_invocation()\n   while #self.args < self.element._minargs do\n      self:pass(self.element._default)\n   end\nend\n\nfunction ElementState:close()\n   if self.open then\n      self.open = false\n\n      if #self.args < self.element._minargs then\n         if self:default(\"a\") then\n            self:complete_invocation()\n         else\n            if #self.args == 0 then\n               if getmetatable(self.element) == Argument then\n                  self:error(\"missing %s\", self.name)\n               elseif self.element._maxargs == 1 then\n                  self:error(\"%s requires an argument\", self.name)\n               end\n            end\n\n            self:error(\"%s requires %s\", self.name, bound(\"argument\", self.element._minargs, self.element._maxargs))\n         end\n      end\n\n      local args\n\n      if self.element._maxargs == 0 then\n         args = self.args[1]\n      elseif self.element._maxargs == 1 then\n         if self.element._minargs == 0 and self.element._mincount ~= self.element._maxcount then\n            args = self.args\n         else\n            args = self.args[1]\n         end\n      else\n         args = self.args\n      end\n\n      self.action(self.result, self.target, args, self.overwrite)\n   end\nend\n\nlocal ParseState = class({\n   result = {},\n   options = {},\n   arguments = {},\n   argument_i = 1,\n   element_to_mutexes = {},\n   mutex_to_element_state = {},\n   command_actions = {}\n})\n\nfunction ParseState:__call(parser, error_handler)\n   self.parser = parser\n   self.error_handler = error_handler\n   self.charset = parser:_update_charset()\n   self:switch(parser)\n   return self\nend\n\nfunction ParseState:error(fmt, ...)\n   self.error_handler(self.parser, fmt:format(...))\nend\n\nfunction ParseState:switch(parser)\n   self.parser = parser\n\n   if parser._action then\n      table.insert(self.command_actions, {action = parser._action, name = parser._name})\n   end\n\n   for _, option in ipairs(parser._options) do\n      option = ElementState(self, option)\n      table.insert(self.options, option)\n\n      for _, alias in ipairs(option.element._aliases) do\n         self.options[alias] = option\n      end\n   end\n\n   for _, mutex in ipairs(parser._mutexes) do\n      for _, element in ipairs(mutex) do\n         if not self.element_to_mutexes[element] then\n            self.element_to_mutexes[element] = {}\n         end\n\n         table.insert(self.element_to_mutexes[element], mutex)\n      end\n   end\n\n   for _, argument in ipairs(parser._arguments) do\n      argument = ElementState(self, argument)\n      table.insert(self.arguments, argument)\n      argument:set_name()\n      argument:invoke()\n   end\n\n   self.handle_options = parser._handle_options\n   self.argument = self.arguments[self.argument_i]\n   self.commands = parser._commands\n\n   for _, command in ipairs(self.commands) do\n      for _, alias in ipairs(command._aliases) do\n         self.commands[alias] = command\n      end\n   end\nend\n\nfunction ParseState:get_option(name)\n   local option = self.options[name]\n\n   if not option then\n      self:error(\"unknown option \'%s\'%s\", name, get_tip(self.options, name))\n   else\n      return option\n   end\nend\n\nfunction ParseState:get_command(name)\n   local command = self.commands[name]\n\n   if not command then\n      if #self.commands > 0 then\n         self:error(\"unknown command \'%s\'%s\", name, get_tip(self.commands, name))\n      else\n         self:error(\"too many arguments\")\n      end\n   else\n      return command\n   end\nend\n\nfunction ParseState:check_mutexes(element_state)\n   if self.element_to_mutexes[element_state.element] then\n      for _, mutex in ipairs(self.element_to_mutexes[element_state.element]) do\n         local used_element_state = self.mutex_to_element_state[mutex]\n\n         if used_element_state and used_element_state ~= element_state then\n            self:error(\"%s can not be used together with %s\", element_state.name, used_element_state.name)\n         else\n            self.mutex_to_element_state[mutex] = element_state\n         end\n      end\n   end\nend\n\nfunction ParseState:invoke(option, name)\n   self:close()\n   option:set_name(name)\n   self:check_mutexes(option, name)\n\n   if option:invoke() then\n      self.option = option\n   end\nend\n\nfunction ParseState:pass(arg)\n   if self.option then\n      if not self.option:pass(arg) then\n         self.option = nil\n      end\n   elseif self.argument then\n      self:check_mutexes(self.argument)\n\n      if not self.argument:pass(arg) then\n         self.argument_i = self.argument_i + 1\n         self.argument = self.arguments[self.argument_i]\n      end\n   else\n      local command = self:get_command(arg)\n      self.result[command._target or command._name] = true\n\n      if self.parser._command_target then\n         self.result[self.parser._command_target] = command._name\n      end\n\n      self:switch(command)\n   end\nend\n\nfunction ParseState:close()\n   if self.option then\n      self.option:close()\n      self.option = nil\n   end\nend\n\nfunction ParseState:finalize()\n   self:close()\n\n   for i = self.argument_i, #self.arguments do\n      local argument = self.arguments[i]\n      if #argument.args == 0 and argument:default(\"u\") then\n         argument:complete_invocation()\n      else\n         argument:close()\n      end\n   end\n\n   if self.parser._require_command and #self.commands > 0 then\n      self:error(\"a command is required\")\n   end\n\n   for _, option in ipairs(self.options) do\n      option.name = option.name or (\"option \'%s\'\"):format(option.element._name)\n\n      if option.invocations == 0 then\n         if option:default(\"u\") then\n            option:invoke()\n            option:complete_invocation()\n            option:close()\n         end\n      end\n\n      local mincount = option.element._mincount\n\n      if option.invocations < mincount then\n         if option:default(\"a\") then\n            while option.invocations < mincount do\n               option:invoke()\n               option:close()\n            end\n         elseif option.invocations == 0 then\n            self:error(\"missing %s\", option.name)\n         else\n            self:error(\"%s must be used %s\", option.name, bound(\"time\", mincount, option.element._maxcount))\n         end\n      end\n   end\n\n   for i = #self.command_actions, 1, -1 do\n      self.command_actions[i].action(self.result, self.command_actions[i].name)\n   end\nend\n\nfunction ParseState:parse(args)\n   for _, arg in ipairs(args) do\n      local plain = true\n\n      if self.handle_options then\n         local first = arg:sub(1, 1)\n\n         if self.charset[first] then\n            if #arg > 1 then\n               plain = false\n\n               if arg:sub(2, 2) == first then\n                  if #arg == 2 then\n                     if self.options[arg] then\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     else\n                        self:close()\n                     end\n\n                     self.handle_options = false\n                  else\n                     local equals = arg:find \"=\"\n                     if equals then\n                        local name = arg:sub(1, equals - 1)\n                        local option = self:get_option(name)\n\n                        if option.element._maxargs <= 0 then\n                           self:error(\"option \'%s\' does not take arguments\", name)\n                        end\n\n                        self:invoke(option, name)\n                        self:pass(arg:sub(equals + 1))\n                     else\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     end\n                  end\n               else\n                  for i = 2, #arg do\n                     local name = first .. arg:sub(i, i)\n                     local option = self:get_option(name)\n                     self:invoke(option, name)\n\n                     if i ~= #arg and option.element._maxargs > 0 then\n                        self:pass(arg:sub(i + 1))\n                        break\n                     end\n                  end\n               end\n            end\n         end\n      end\n\n      if plain then\n         self:pass(arg)\n      end\n   end\n\n   self:finalize()\n   return self.result\nend\n\nfunction Parser:error(msg)\n   io.stderr:write((\"%s\\n\\nError: %s\\n\"):format(self:get_usage(), msg))\n   os.exit(1)\nend\n\n-- Compatibility with strict.lua and other checkers:\nlocal default_cmdline = rawget(_G, \"arg\") or {}\n\nfunction Parser:_parse(args, error_handler)\n   return ParseState(self, error_handler):parse(args or default_cmdline)\nend\n\nfunction Parser:parse(args)\n   return self:_parse(args, self.error)\nend\n\nlocal function xpcall_error_handler(err)\n   return tostring(err) .. \"\\noriginal \" .. debug.traceback(\"\", 2):sub(2)\nend\n\nfunction Parser:pparse(args)\n   local parse_error\n\n   local ok, result = xpcall(function()\n      return self:_parse(args, function(_, err)\n         parse_error = err\n         error(err, 0)\n      end)\n   end, xpcall_error_handler)\n\n   if ok then\n      return true, result\n   elseif not parse_error then\n      error(result, 0)\n   else\n      return false, parse_error\n   end\nend\n\nlocal argparse = {}\n\nargparse.version = \"0.7.0\"\n\nsetmetatable(argparse, {__call = function(_, ...)\n   return Parser(default_cmdline[0]):add_help(true)(...)\nend})\n\nreturn argparse\n\nend)\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/scroll.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/scroll.git",
    home = "",
    website = "",
    name = "scroll",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "fb81cb5506b556ad9f6c24c41ab56a30e87ba68f",
name = "scroll",
hash = "c4d967ada9c0945d3b85df1d2611f8fc06a154b07aa8e92e8d0902601e03fae0",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"core:core\"\nlocal Node = require \"espalier:node\"\n\n\n\nlocal Scroll = {}\nScroll.__index = Scroll\n\n\n\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\n\n\nlocal lines = core.lines\n\nfunction Scroll.add(scroll, str, line_start, col_start, line_end, col_end)\n   if type(str) == \"string\" then\n      insert(scroll, str)\n   elseif str.isNode then\n      -- #todo source mapping\n      for line in lines(str:span()) do\n         insert(scroll, line)\n      end\n      if scroll[#scroll] == \"\" then\n         -- delete final empty line\n         remove(scroll)\n      end\n   else\n      insert(scroll, str)\n   end\nend\n\n\n\nfunction Scroll.__tostring(scroll)\n   return concat(scroll, \"\\n\")\nend\n\n\n\nlocal function new(seed)\n   local scroll = setmetatable({}, Scroll)\n   scroll.source_map = {}\n   if seed then\n      scroll:add(seed)\n   end\n   return scroll\nend\nScroll.idEst = new\n\n\n\nreturn new\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/set.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/set.git",
    home = "",
    website = "",
    name = "set",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "db7df6dd594baaba42d27583b5899dae625c50b9",
name = "set",
hash = "6cac5642779695b9ef858468961f587bc7e789bb88e776254798cb144519c5b1",
branch = "master",
binary = "\n\n\n\n\n\nlocal Set = {}\nSet.__index = Set\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(items)\n   local set = setmetatable({}, Set)\n   assert(type(items) == \"table\" or items == nil,\n          \"argument to set constructor must be a table\")\n   if items then\n      if items.idEst == new then\n         for k, _ in pairs(items) do\n            set[k] = true\n         end\n      else\n         for _,value in ipairs(items) do\n            set[value] = true\n         end\n      end\n   end\n   return set\nend\nSet.idEst = new\n\n\n\n\n\nfunction Set.insert(set, item)\n   if item ~= nil then\n      set[item] = true\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Set.remove(set, item)\n   local removed\n   if set[item] then\n      removed = true\n   end\n   set[item] = nil\n   if removed then return removed end\nend\n\n\n\n\n\n\nlocal function hasSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\", \"bad argument #2 to hasSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = true\n   for k, _ in pairs(maybe_subset) do\n     is_subset = is_subset and set[k]\n   end\n\n   return is_subset == true\nend\n\nSet.hasSubset = hasSubset\n\nfunction Set.__lte(head, tail)\n   return hasSubset(tail, head)\nend\n\n\n\n\n\n\nlocal function hasProperSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\",\n          \"bad argument #2 to hasProperSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = hasSubset(set, maybe_subset)\n   local is_superset = false\n   for k, _ in pairs(set) do\n      if not maybe_subset[k] then\n         is_superset = true\n      end\n   end\n   -- coerce a nil result to boolean for return value\n   return (is_subset and is_superset) == true\nend\n\nSet.hasProperSubset = hasProperSubset\n\nfunction Set.__lt(head, tail)\n   return hasProperSubset(tail, head)\nend\n\n\n\n\n\n\n\n\nfunction Set.__len(set)\n   local count = 0\n   for _, __ in pairs(set) do\n      count = count + 1\n   end\n   return count\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.__eq(left, right)\n   local same = true\n   for k, _ in pairs(left) do\n      same = same and right[k] ~= nil\n   end\n   for k, _ in pairs(right) do\n      same = same and left[k] ~= nil\n   end\n   return same == true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function union(head, tail)\n   local union = new(head)\n   assert(type(tail) == \"table\", \"bad argument #2 to union: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k, _ in pairs(tail) do\n      union[k] = true\n   end\n   return union\nend\n\nSet.union = union\n\nfunction Set.__add(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot make union of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return union(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function difference(head, tail)\n   local diff = new(head)\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to difference: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k,_ in pairs(tail) do\n      diff[k] = nil\n   end\n   return diff\nend\n\nSet.difference = difference\n\nfunction Set.__sub(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot take difference of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return difference(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.intersection(head, tail)\n   local section = new()\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to intersection: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k,_ in pairs(tail) do\n      if head[k] then\n         section[k] = true\n      end\n   end\n   return section\nend\n\n\n\n\n\n\n\n\nfunction Set.__newindex(set, key, value)\n   assert(value == true or value == nil,\n      \"Bad assignment to Set: must be true or nil\")\n   rawset(set, key, value)\nend\n\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate = require \"helm/repr/tabulate\"\nlocal Token = require \"helm/repr/token\"\n\nfunction Set.__repr(set, window, c)\n   return coroutine.wrap(function()\n      yield(Token(\"#{ \", c.base, { event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for v, _ in pairs(set) do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", c.base, { event = \"sep\" }))\n         end\n         for t in tabulate(v, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", c.base, { event = \"end\" }))\n   end)\nend\n\n\n\n\nreturn new\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/singletons.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/singletons.git",
    home = "",
    website = "",
    name = "singletons",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/codepoints",
hash = "2bfa9229ba88ce63edf5919cd0f572ea33aa3f65da5e07adc9b2fdb5d5b8d232",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"singletons/core\"\nlocal meta, utf8 = assert(core.meta), assert(core.utf8)\n\n\n\n\n\nlocal Codepoints = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal sub = assert(string.sub)\n\nfunction Codepoints.__call(codepoints, str, start, finish)\n   start = start or 1\n   finish = (finish and finish <= #str) and finish or #str\n   -- propagate nil\n   if not str then return nil end\n   -- break on bad type\n   assert(type(str) == \"string\", \"codepoints must be given a string\")\n   local codes = setmetatable({}, Codepoints)\n   local index = start\n   while index <= finish do\n      local width, err = utf8(str, index)\n      if width then\n         local point = sub(str, index, index + width - 1)\n         insert(codes, point)\n         index = index + width\n      else\n         -- take off a byte and store it\n         local err_packet = { char = sub(str, index, index),\n                              err  = err }\n         codes.err = codes.err or {}\n         insert(codes, \"ï¿½\")\n         -- place the error at the same offset in the err table\n         codes.err[#codes] = err_packet\n         index = index + 1\n      end\n   end\n   return codes\nend\n\n\n\n\n\n\n\n\n\nlocal clone = assert(core.clone)\n\nlocal function _adjustErrors(codepoints, pos, offset)\n   if pos and codepoints.err then\n      -- cache the error table so we can copy the\n      -- removed points without worrying about blasting them\n      -- before we reach them while iterating\n      local err_cache = clone(codepoints.err)\n      -- remove all errors above pos at once\n      for i, _ in pairs(codepoints.err) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i] = nil\n         end\n      end\n      -- now add them back, shifted by offset\n      for i, v in pairs(err_cache) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i + offset] = v\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Codepoints.insert(codepoints, pos, value)\n   if value then\n      -- Insert the fragment\n      insert(codepoints, pos, value)\n      -- Only need to adjust errors if inserting other than at the end\n      _adjustErrors(codepoints, pos, 1)\n   else\n      -- Work around arguable bug in table.insert where calling\n      -- insert({}, \"a\", nil) throws an error--the third parameter\n      -- must be actually omitted rather than merely nil\n      insert(codepoints, pos)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\n\nfunction Codepoints.remove(codepoints, pos)\n   local rem = remove(codepoints, pos)\n   -- Remove any corresponding error from the error table\n   if codepoints.err then\n      codepoints.err[pos or #codepoints + 1] = nil\n      -- And remove it altogether if it is now empty\n      if next(codepoints.err) then\n         _adjustErrors(codepoints, pos, -1)\n      else\n         codepoints.err = nil\n      end\n   end\n   return rem\nend\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nfunction Codepoints.__tostring(codepoints)\n   local output = codepoints\n   if codepoints.err then\n      output = {}\n      for i, v in ipairs(codepoints) do\n         local err_here = codepoints.err[i]\n         output[i] = err_here and err_here.char or v\n      end\n   end\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, byte = assert(string.format),\n                           assert(string.find),\n                           assert(string.byte)\n\nlocal escapes_map = {\n   [\'\"\'] = \'\\\\\"\',\n   [\"\'\"] = \"\\\\\'\",\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nfunction Codepoints.toLuaString(codepoints, preface, afterward)\n   if type(codepoints) == \"string\" then\n      codepoints = Codepoints.__call(nil, codepoints)\n   end\n   local phrase = {}\n   if preface then\n      insert(phrase, preface)\n   end\n   insert(phrase, \'\"\')\n   local err = codepoints.err or {}\n   for i,frag in ipairs(codepoints) do\n      -- escape map non-printing chars\n      -- replace errors with an \\x?? token\n      -- otherwise, insert the frag\n      if escapes_map[frag] or find(frag, \"%c\") then\n         frag = escapes_map[frag] or format(\"\\\\x%02x\", byte(frag))\n      end\n      if err[i] then\n         frag = format(\"\\\\x%02x\", byte(err[i].char))\n      end\n      insert(phrase, frag)\n   end\n   insert(phrase, \'\"\')\n   if afterward then\n      insert(phrase, afterward)\n   end\n   return concat(phrase)\nend\n\n\n\nlocal CP_constructor = setmetatable({}, Codepoints)\nCodepoints.idEst = CP_constructor\n\n\n\nreturn CP_constructor\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/check",
hash = "f0ddaf92f60a02052e48ecce2b975f368682f0a1b5377509204ba23f7ff7b0b3",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = require \"singletons/color\"\nlocal ts = tostring\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ItIndex(itself, verb)\n   if verb == \"won\" or verb == \"did\" then\n      return nil\n   end\n   verb = verb and verb or \"\"\n   local it = itself.current\n   local result = {success = false}\n   result.why = \"`check` does not understand the verb \" .. ts(verb)\n               .. \" at least, not yet\" -- Â¯\\_(ãƒ„)_/Â¯\n   io.write(result.why .. \"\\n\")\n   it.did.also(result)\n   return function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(it)\n   if it.won == nil then\n      it = it:collate()\n   end\n   if it.won then\n      return it.subject, it\n   else\n      return nil, it\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function __repr(it)\n   return it.digest\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n   if Object.isIt and Object.isIt == It then\n      return Object\n   end\n\n   local itself = setmetatable({}, {__index = It,\n                                    __call = call,\n                                    __repr = __repr})\n   It.current  = setmetatable({} , {__index = itself,\n                                    __call = call,\n                                    __repr = __repr} )\n   itself.isIt = It\n   itself.name = name and name or \"it\"\n   itself.subject = Object\n   itself = must(itself)\n   itself.did = {}\n   itself.did.also = function(result)\n                        result.modal = itself.modal\n                        itself.did[#itself.did + 1] = result\n                        return itself\n                     end\n   itself.did.last = function() return itself.did[#itself.did] end\n\n   return itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\n\n\nlocal ts = tostring -- stub, #todo replace with real deal\nlocal function verdict(it, subject, verb, object)\n   local subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n   return it.name .. \": \" .. subj .. it.modal.inThatIt\n          .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local must = setmetatable({}, Modal)\n   must.beTrue = true\n   must.because = because\n   must.inThatIt = \"must\"\n   it.modal = must\n   return it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local mustnt = setmetatable({}, Modal)\n   mustnt.because = because or \"\"\n   mustnt.beTrue = false\n   mustnt.inThatIt = \"mustn\'t\"\n   it.modal = mustnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n   local should = setmetatable({}, Modal)\n   should.because = because or \"\"\n   should.beTrue = true\n   should.inThatIt = \"should\"\n   it.modal = should\n   return it\nend\n\nfunction It.shouldnt(it, because)\n   local shouldnt = setmetatable({}, Modal)\n   shouldnt.because = because or \"\"\n   shouldnt.beTrue = false\n   shouldnt.inThatIt = \"shouldn\'t\"\n   it.modal = shouldnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.can(it, because)\n   local can = setmetatable({}, Modal)\n   can.because = because or \"\"\n   can.beTrue = nil\n   can.inThatIt = \"could\"\n   it.modal = can\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.could(it, because)\n   local could = setmetatable({}, Modal)\n   could.because = because or \"\"\n   could.beTrue = nil\n   could.inThatIt = \"could\"\n   it.modal = could\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n   local result = {}\n   local success = it.subject == rValue and true or false\n   if not it.modal.beTrue then\n      success = not success\n   end\n   if success then\n      result.why =  verdict(it, it.subject, \"equal\", rValue)\n   else\n      result.why = verdict(it, it.subject, \"not equal\", rValue)\n   end\n   result.success = success\n\n   return it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n   local result = {}\n   local success = false\n   local having = it.subject[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having\n\n   if having == nil then\n      -- todo better message if \'has\' failed,\n      -- the more common case.\n      result.why = \"equalTo must follow have/has\"\n   else\n      success = having == rValue and true or false\n      local subj, obj\n      if not it.modal.beTrue then\n         success = not success\n         subj, obj = having, rValue\n      else\n         subj, obj = rValue, having\n      end\n      if success then\n         result.why = because or verdict(it, subj, \"==\", obj)\n       else\n         result.why = because or verdict(it, subj, \"~=\", obj)\n       end\n       result.having = having -- to chain field checks\n   end\n\n   result.success = success\n   return it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n   local result = {}\n   local success = false\n   local last = it.did[#it.did]\n   local having = last.having\n   if type(len) ~= \"number\" then\n      result.why = \"ofLen param must be a number\"\n   elseif not having then\n      result.why = \"ofLen must have a value on it.did\"\n   else\n      success = #having == len and true or false\n      if not it.modal.beTrue then\n         success = not success\n      end\n      if success then\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"==\", len)\n       else\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"~=\", len)\n       end\n   end\n\n   result.success = success\n   result.inThatIt = it.modal.inThatIt\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n   local result = { success = false,\n                    why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n   return {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   local method = last.having\n   if not method then\n      result.why = \"calling must be performed on a value\"\n   elseif not type(method) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name .. \" field must be function: \" .. last.field)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = method(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.field  = last.field\n      local callee = ts(last.field, \"field\") .. \"(\"\n      if result.arg and result.arg.n >= 1 then\n         for i = 1, result.arg.n do\n            callee = callee .. ts(result.arg[i]) .. \", \"\n         end\n         callee = string.sub(callee, 1, -3)\n      end\n      callee = callee .. \")\"\n      result.why    = verdict(it, \"\", \"be callable with\", callee)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name\n                   .. \" passedTo needs a function: \" .. fn)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = fn(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.fn     = fn\n      result.why    = verdict(it, \"\", \"be passed to\", fn)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n   local success = false\n   local result = {}\n   local last = it.did.last()\n   local answer = last.answer\n   if answer == nil then\n      result.why = \"prior clause must provide an answer\"\n   else\n      -- build strings for verdict\n      local callee = \":anon:\"\n      if last.field then\n         callee = it.name .. ts(\":\" ..last.field, \"field\")\n      elseif last.fn then\n         callee = ts(last.fn)\n      end\n      local param = \"(\"\n      if last.fn then\n         param = param .. it.name\n      end\n      if last.arg and last.arg.n >= 1 then\n         if last.fn then param = param .. \", \" end\n         for i = 1, last.arg.n do\n            param = param .. ts(last.arg[i]) .. \", \"\n         end\n         param = string.sub(param, 1, -3)\n      end\n      param = param .. \")\"\n\n      local isSame = answer == rValue and true or false\n      if isSame then\n         if not last.b then\n            success = true\n            result.why = verdict(it, callee .. param, \"give\", ts(answer))\n         elseif b then\n            local gives = {ts(answer)}\n            local is_b_same  = last.b == b and true or false\n            gives[2] = ts(last.b)\n            success = true and is_b_same\n            result.why = vertict(it, callee .. param, \"give\", gives[1]\n                         .. \" \" .. gives[2])\n         end\n      else\n         result.why = it.name .. \":\" .. callee .. param .. \" \"\n                      .. it.modal.inThatIt .. \" give \" .. ts(rValue)\n                      .. \" not \" .. ts(answer)\n      end\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n\n   result.success = success\n\n\n   return it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n   return it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n   local phrase = \"\"\n   local Yes, No\n   if mood == \"must\" or mood == \"mustn\'t\" then\n      Yes, No = \"âœ…   \",  \"âŒ   \"\n   elseif mood == \"should\" or mood == \"shouldn\'t\" then\n      Yes, No = \"ðŸŒŸ   \",  \"ðŸ˜¡   \"\n   elseif mood == \"can\" or mood == \"could\" then\n      Yes, No = \"ðŸ‘   \",  \"ðŸ‘Ž   \"\n   end\n   if did.success then\n      phrase = phrase .. \"   \" .. Yes .. did.why\n   else\n      phrase = phrase .. \"   \" .. No .. did.why\n   end\n   phrase = phrase .. \"\\n\"\n   did.digest = phrase\n   return phrase\nend\n\n\n\n\nfunction It.collate(it)\n   local winning = true\n   local wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n   local musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n   local phrase = it.name .. \":\\n\"\n   for _, did in ipairs(it.did) do\n      winning = winning and did.success\n      local mood = did.modal.inThatIt\n      local digest = digestLine(did, mood)\n      phrase = phrase .. digest\n\n      if mood == \"must\" or mood == \"mustn\'t\" then\n         musts = musts + 1\n         if did.success then\n            wins.must = wins.must + 1\n         end\n      elseif mood == \"should\" or mood == \"shouldn\'t\" then\n         shoulds = shoulds + 1\n         if did.success then\n            wins.should = wins.should + 1\n         end\n      end\n   -- etc\n   end\n   if musts > 0 then\n      phrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n   end\n   if shoulds > 0 then\n      phrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n   end\n   it.won = winning\n   if it.won then\n      phrase = \"All clear!\\n\" .. phrase\n   else\n      phrase = \"Needs work:\\n\" .. phrase\n   end\n   phrase = phrase .. \"\\n\"\n   it.digest = phrase\n\n   return it\nend\n\n\n\nfunction It.report(it)\n   it = it:collate()\n   io.write(it.digest)\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n   It[#It + 1] = it\n   return it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n   local winning = true\n   if not rawget(_G, \"_Bridge\") then\n      for _, that in ipairs(It) do\n         that:report()\n         winning = winning and that.won\n      end\n      return it, winning\n   else\n      local digests = {}\n      for _, that in ipairs(It) do\n         that:collate()\n         table.insert(digests, that)\n      end\n      return digests\n   end\nend\n\nfunction It.allFailure(it)\n   for _, that in ipairs(It) do\n      that:check()\n      for _, did in ipairs(that.did) do\n         if not did.success then\n            io.write(did.digest)\n         end\n      end\n   end\n   return it\nend\n\n\n\nreturn check\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons",
hash = "3cabbfaac3c7bdfe9d76b803d493a3a6f42554b1a1d15b3b6700fb84f73c58f5",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable or setmeta)\n\n\n\n\n\n\nlocal S = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.core = require \"singletons/core\"\n\n\n\n\n\n\n\n\n\n\n\n\nS.anterm = require \"singletons/anterm\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.color = require \"singletons/color\"\n\n\n\n\n\n\n\n\nS.codepoints = require \"singletons/codepoints\"\nS.Codepoints = S.codepoints\n\n\n\n\n\nS.phrase = require \"singletons/phrase\"\nS.Phrase = S.phrase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.status = require \"singletons/status\"\n\n\n\n\n\nS.Status = S.status\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.check = require \"singletons/check\"\nS.It = S.check\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction S.new(tab)\n   new_singleton = tab or {}\n   return meta(new_singleton, S)\nend\n\n\n\n\n\n\nreturn S\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/stator",
hash = "5d93466c2bc0d01d4e852f02795752bfc8f697d01a4beae5f9282747b0c879f0",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable)\n\n\n\nlocal Stator = meta {}\n\n\n\n\n\n\n\n\n-- local _weakstate = setmeta({}, {__mode = \'v\'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(stator, _weakstate)\n   local _weakstate = _weakstate or setmeta({}, {__mode = \'v\'})\n   local _M = setmeta({}, {__index = stator, __call = call })\n   _M._weakstate =  _weakstate\n   return _M\nend\n\n\n\n\n\n\n\n\n\nlocal function new(Stator, _weakstate)\n   local stator = call(Stator, _weakstate)\n   stator.g, stator.G, stator._G = stator, stator, stator\n   return stator\nend\n\n\n\n\nreturn setmetatable(Stator, {__call = new})\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "ss",
hash = "55c3ba4d014ce5b98c75290cd6dc30d7902b1361045b76a80eb4d4129d3fe374",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"singletons\"\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "init",
hash = "b4efda6264dec99db37f8f52f91c05deb4e661bd4264a69a7ade7ca074c05bbc",
branch = "master",
binary = "\n\n\n\n\n\nreturn require \"singletons\"\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/anterm",
hash = "ed75834cdc82e8332349d59a69662da06768e0cb704075d0bbebde7de1f1908f",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert (pairs)\nlocal tostring = assert (tostring)\nlocal setmeta = assert (setmetatable)\nlocal error = assert (error)\nlocal require = assert (require)\nlocal rawget = assert (rawget)\n\nlocal schar = assert(string.char)\nlocal sub   = assert(string.sub)\nlocal rep   = assert(string.rep)\nlocal byte  = assert(string.byte)\nlocal bit   = assert(bit, \"anterm requires Luajit \'bit\' or compatible in _G\")\nlocal rshift = assert(bit.rshift)\nlocal core = require \"core:core\"\nbit = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anterm = {}\n\nlocal CSI = schar(27)..\'[\'\n\n\n\n\n\n\n\n\n\n\n\nlocal colormt = {}\ncolormt.__index = colormt\n\n\n\n\n\n\n\n\n\n\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        bold = 1,\n        dim = 2,\n        italic = 3,\n        underscore = 4,\n        underline = 4,\n        reverse = 7,\n        hidden = 8,\n        clear_bold = 22,\n        clear_dim  = 22,\n        clear_underline = 24,\n        clear_inverse = 27,\n        clear_hidden = 28 },\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = CSI .. value ..\"m\",\n        name = name,\n        kind = kind }\n    return setmetatable(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        anterm[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt.__tostring(color)\n    return color.value\nend\n\nfunction colormt.__concat(color, other)\n    return tostring(color) .. tostring(other)\nend\n\nlocal clear_fg, clear_bg, clear = anterm.clear_fg, anterm.clear_bg,\n                                  anterm.clear\nlocal clear_bold = anterm.clear_bold\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    if color.kind == \"fg\" then\n        return clear_fg\n    elseif color.kind == \"bg\" then\n        return clear_bg\n    elseif color.kind == \"attribute\" then\n       local name = color.name\n       if name == \"bold\" or name == \"dim\" then\n          return clear_bold\n       elseif name == \"underscore\" or name == \"underline\" then\n          return clear_underline\n       elseif name == \"inverse\" then\n          return clear_inverse\n       elseif name == \"hidden\" then\n          return clear_hidden\n       else\n          return clear\n       end\n    end\nend\n\nlocal __ts = colormt.__tostring\n\nfunction colormt.__call(color, str)\n    if str then\n        return __ts(color) .. str .. reset(color)\n    else\n        return __ts(color)\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function byte_panic(byte_p)\n   if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n      error \"xterm value must be 8 bit unsigned\"\n   end\nend\n\nlocal x256_store = setmetatable({}, {__mode = \"v\"})\n\nlocal function ansi_fg(byte)\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[38;5;\"..byte..\"m\",\n                        kind = \"fg\" }\n        return setmetatable(color, colormt)\n    end\n    if x256_store[byte] then\n        return x256_store[byte]\n    else\n        local color = make(byte)\n        x256_store[byte] = color\n        return color\n    end\nend\n\nlocal function ansi_bg(byte)\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[48;5;\"..byte..\"m\",\n                        kind = \"bg\" }\n        return setmetatable(color, colormt)\n    end\n    if x256_store[byte] then\n        return x256_store[byte]\n    else\n        local color = make(byte)\n        x256_store[byte] = color\n        return color\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal x24k = setmetatable({}, {__mode = \"v\"})\n\nlocal fg24pre = schar(27) .. \"[38;2;\"\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = fg24pre\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"fg\" }\n   if x24k[color] then\n      return x24k[color]\n   end\n   x24k[color] = color\n   return setmetatable(color, colormt)\nend\n\nlocal bg24pre = schar(27) .. \"[48;2;\"\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = bg24pre\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"bg\" }\n   if x24k[color] then\n      return x24k[color]\n   end\n   x24k[color] = color\n   return setmetatable(color, colormt)\nend\n\nanterm[\"fg\"], anterm[\"bg\"] = ansi_fg, ansi_bg\n\nanterm[\"fg24\"], anterm[\"bg24\"] = fg24, bg24\n\n\n\n\n\nlocal cursor = {}\n\nfunction cursor.stash()\n   return \"\\x1b7\"\nend\n\nfunction cursor.pop()\n   return \"\\x1b8\"\nend\n\nfunction cursor.hide()\n   return \"\\x1b[?25l\"\nend\n\nfunction cursor.show()\n   return \"\\x1b[?25h\"\nend\n\nanterm.cursor = cursor\n\n\n\n\n\nlocal jump = {}\n\nfunction jump.up(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"A\"\nend\n\nfunction jump.down(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"B\"\nend\n\nfunction jump.forward(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"C\"\nend\n\njump.right = jump.forward\n\nfunction jump.back(num)\n    if not num then num = \"1\" end\n    return CSI..num..\"D\"\nend\n\njump.left = jump.back\n\nlocal __nl = CSI .. 1 .. \"B\" .. CSI .. 1 .. \"G\"\n\nfunction jump.nl()\n   return __nl\nend\n\nlocal function Jump(_,row,column)\n    return CSI..row..\";\"..column..\"H\"\nend\n\nlocal J = { __call = Jump}\nsetmetatable(jump,J)\n\nanterm[\"jump\"] = jump\n\nfunction anterm.rc(row, column)\n   return CSI .. row .. \";\" .. column .. \"H\"\nend\n\nanterm.rowcol = anterm.rc\n\nfunction anterm.colrow(col, row)\n   return CSI .. row .. \";\" .. col .. \"H\"\nend\n\nfunction anterm.col(col)\n   col = col or 1\n   return CSI .. col .. \"G\"\nend\n\n\n\n\n\n\nlocal erase = {}\nanterm.erase = erase\n\nlocal e__below = CSI .. \"0J\"\nlocal e__above = CSI .. \"1J\"\nlocal e__all   = CSI .. \"2J\"\nlocal e__right = CSI .. \"0K\"\nlocal e__left  = CSI .. \"1K\"\nlocal e__line  = CSI .. \"2K\"\n\nfunction erase.below() return e__below end\n\nfunction erase.above() return e__above end\n\nfunction erase.all()   return e__all   end\n\nfunction erase.right() return e__right end\n\nfunction erase.left()  return e__left  end\n\nfunction erase.line()  return e__line  end\n\n\n\n\n\n\n\nfunction erase.box(tc, tr, bc, br, dash)\n   dash = dash or \" \"\n   assert(tr <= br and tc <= bc, \"box must be at least 1 by 1: \"\n          .. \" tc: \" .. tc .. \" tr: \" .. tr\n          .. \" bc: \" .. bc .. \" br: \" .. br)\n   local phrase = cursor.stash()\n               .. Jump(nil, tr, tc)\n   br = br + 1\n   bc = bc + 1\n   local blanks = rep(dash, bc - tc)\n   local nl = anterm.col(tc) .. jump.down(1)\n   for i = 1, br - tr do\n      phrase = phrase .. blanks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\nlocal random = assert(math.random)\n\nfunction erase.checker(tc, tr, bc, br, dash, mod)\n   mod = mod or 3\n   dash = dash or \".\"\n   local space = jump.forward()\n   assert(tr <= br and tc <= bc, \"box must be at least 1 by 1\")\n   local skip = random(1, mod)\n   local phrase = cursor.stash()\n               .. Jump(nil, tr, tc)\n   br = br + 1\n   bc = bc + 1\n\n   local nl = anterm.col(tc) .. jump.down(1)\n   for i = 1, br - tr do\n      local checks = \"\"\n      for j = 1, bc - tc do\n         if skip % mod == 0 then\n            checks = checks .. dash\n         else\n            checks = checks .. space\n         end\n         skip = skip + 1\n      end\n      phrase = phrase .. checks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\n\nlocal mouse = {}\nanterm.mouse = mouse\n\nlocal buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}\n\n\n\n\n\n\n\n\n\n\nfunction mouse.track(on)\n   if on == true then\n      return \"\\x1b[?1003h\"\n   end\n\n   return \"\\x1b[?1003l\"\nend\n\n\n\nfunction mouse.ismousemove(seq)\n   if sub(seq, 1, 3) == \"\\x1b[M\" then\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction mouse.parse_fast(seq)\n   local kind, col, row = byte(seq,4), byte(seq, 5), byte(seq, 6)\n   kind = kind - 32\n   local m = {row = row - 32, col = col - 32}\n   -- Get button\n   m.button = buttons[kind % 4]\n   -- Get modifiers\n   kind = rshift(kind, 2)\n   m.shift = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.meta = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.ctrl = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.moving = kind % 2 == 1\n   -- we skip a bit that seems to just mirror .moving\n   m.scrolling = kind == 2\n   return m\nend\n\n\n\n\n\n\n\n\nfunction mouse.parse(seq)\n   if mouse.ismousemove(seq) then\n      return mouse.parsefast(seq)\n   else\n      return nil, \"sequence was not a mouse move\", seq\n   end\nend\n\n\n\n\n\nfunction anterm.alternate_screen(use_alt)\n  return CSI .. \"?47\" .. (use_alt and \"h\" or \"l\")\nend\n\n\n\n\n\nfunction anterm.paste_bracketing(bracket_enable)\n   return CSI .. \"?2004\" .. (bracket_enable and \"h\" or \"l\")\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal report = {}\n\nfunction report.area()\n   return \"\\x1b[18t\"\nend\nanterm.report = report\n\n\n\n\n\n\n\n\n\nlocal totty = {}\nlocal lines = assert(core.lines)\nlocal collect = assert(core.collect)\n\n\n\n\n\n\n\n\n\n\n\nfunction totty.nl_to_jumps(str)\n  local l = collect(lines, str)\n  local phrase = \"\"\n  local length = 0\n  for i,v in ipairs(l) do\n    phrase = phrase..v..a.jump.down()..a.jump.back(utf8.width(v))\n    if length < utf8.width(v) then\n      length = utf8.width(v)\n    end\n  end\n  return phrase, length, #l\nend\n\n--- takes a string and a width in columns.\n--  Returns the amount of string which fits the width.\nfunction totty.truncate(str, width)\n  local trunc = utf8.sub(str,1,width)\n  if utf8.len(trunc) == utf8.width(trunc) then\n    return trunc\n  else\n    local i = 1\n    while utf8.width(trunc) > width do\n      -- io.write(\"width is \", utf8.width(trunc), \"  target: \", width, \"\\n\")\n      trunc = utf8.sub(str,1,width-i)\n      i = i + 1\n    end\n    return trunc\n  end\nend\n\n-- takes a string, returning a string which, when printed, will:\n-- print the string as a column, return to the top, and move one beyond\n-- the column thereby printed.\nfunction totty.collimate(str)\n  local phrase, length, lines = totty.nl_to_jumps(str)\n  return phrase..a.jump.up(lines)..a.jump.forward(length)\nend\n\nanterm.totty = totty\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __navigation = {  UP       = \"\\x1b[A\",\n                        DOWN     = \"\\x1b[B\",\n                        RIGHT    = \"\\x1b[C\",\n                        LEFT     = \"\\x1b[D\",\n                        SHIFT_UP = \"\\x1b[1;2A\",\n                        SHIFT_DOWN = \"\\x1b[1;2B\",\n                        SHIFT_RIGHT = \"\\x1b[1;2C\",\n                        SHIFT_LEFT  = \"\\x1b[1;2D\",\n                        HYPER_UP    = \"\\x1b[5~\",\n                        HYPER_DOWN  = \"\\x1b[6~\",\n                        HYPER_RIGHT = \"\\x1b[F\",\n                        HYPER_LEFT  = \"\\x1b[H\",\n                        ALT_UP    = \"\\x1b[1;3A\",\n                        ALT_DOWN  = \"\\x1b[1;3B\",\n                        ALT_RIGHT = \"\\x1b[1;3C\", -- heh\n                        ALT_LEFT  = \"\\x1b[1;3D\",\n                        SHIFT_ALT_UP = \"\\x1b[1;10A\",\n                        SHIFT_ALT_DOWN = \"\\x1b[1;10B\",\n                        SHIFT_ALT_RIGHT = \"\\x1b[1;10C\",\n                        SHIFT_ALT_LEFT  = \"\\x1b[1;10D\",\n                        SHIFT_TAB  = \"\\x1b[Z\",\n                        ALT_TAB    = \"\\x1b\\t\",\n                        NEWLINE    = \"\\n\",\n                        RETURN     = \"\\r\",\n                        SHIFT_RETURN = \"\\x1b[13;2u\",\n                        CTRL_RETURN = \"\\x1b[13;5u\",\n                        ALT_RETURN = \"\\x1b\\r\",\n                        TAB        = \"\\t\",\n                        BACKSPACE  = \"\\127\",\n                        DELETE     = \"\\x1b[3~\",\n                        ESC        = \"\\x1b\",\n                     }\n\n\n\n\n\n\nlocal __alt_nav = {  UP    = \"\\x1bOA\",\n                     DOWN  = \"\\x1bOB\",\n                     RIGHT = \"\\x1bOC\",\n                     LEFT  = \"\\x1bOD\"\n                  }\n\n\n\n\n\n\n\n__alt_nav.ALT_LEFT  = \"\\x1bb\"\n__alt_nav.ALT_RIGHT = \"\\x1bf\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal navigation = {}\n\nfor k,v in pairs(__navigation) do\n   navigation[v] = k\nend\nfor k,v in pairs(__alt_nav) do\n   navigation[v] = k\nend\n\n__navigation, __alt_nav = nil, nil\n\nanterm.navigation = navigation\n\nfunction anterm.is_nav(seq)\n   if navigation[seq] then\n      return navigation[seq]\n   else\n      return false, \"not a recognized NAV token\", seq\n   end\nend\n\n\n\n\n\n\nlocal PASTE_START = CSI .. \"200~\"\nlocal PASTE_END   = CSI .. \"201~\"\nfunction anterm.is_paste(seq)\n   if seq:sub(1, #PASTE_START) == PASTE_START then\n      assert(seq:sub(-#PASTE_END) == PASTE_END, \"Partial paste encountered\")\n      return true\n   else\n      return false\n   end\nend\n\nfunction anterm.parse_paste(seq)\n   return seq:sub(#PASTE_START + 1, -#PASTE_END - 1)\nend\n\n\n\n\nreturn anterm\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/phrase",
hash = "6fb77e64f761cb8519d2bee4aa583f7670ff8c1201a750fd56d9fc20a20c948c",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"singletons/status\" ()\nlocal It = require \"singletons/check\"\ns.angry = false\n\n\n\n\n\n\nlocal Phrase = {}\nPhrase.__index = Phrase\nPhrase.it = It\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal function spill(phrase)\n   local new_phrase = setmetatable({}, getmetatable(phrase))\n   for k, v in pairs(phrase) do\n      new_phrase[k] = v\n   end\n   new_phrase.interned = nil\n\n   return new_phrase\nend\n\n\nfunction Phrase.__concat(head_phrase, tail_phrase)\n   if type(head_phrase) == \'string\' then\n      -- bump the tail phrase accordingly\n      if tail_phrase.interned then\n         tail_phrase = spill(tail_phrase)\n      end\n\n      insert(tail_phrase, 1, head_phrase)\n      tail_phrase.len = tail_phrase.len + #head_phrase\n      return tail_phrase\n   end\n   local typica = type(tail_phrase)\n   if typica == \"string\" then\n      if head_phrase.interned then\n         head_phrase = spill(head_phrase)\n      end\n      insert(head_phrase, tail_phrase)\n      head_phrase.len = head_phrase.len + #tail_phrase\n      return head_phrase\n   elseif typica == \"table\" and tail_phrase.idEst == Phrase then\n      local new_phrase = setmetatable({}, getmetatable(head_phrase))\n      head_phrase.interned = true -- head_phrase is now in the middle of a string\n      tail_phrase.interned = true -- tail_phrase shouldn\'t be bump-catted\n      new_phrase[1] = head_phrase\n      new_phrase[2] = tail_phrase\n      new_phrase.len = head_phrase.len + tail_phrase.len\n      return new_phrase\n   end\n\n   return nil, \"tail phrase was unsuitable for concatenation\"\nend\n\n\n\n\n\n\n\n\nlocal function _gather_pieces(phrase, pieces)\n   pieces = pieces or {}\n   for _, v in ipairs(phrase) do\n      if type(v) == \"string\" then\n         insert(pieces, v)\n      else\n         _gather_pieces(v, pieces)\n      end\n   end\n   return pieces\nend\n\nfunction Phrase.__tostring(phrase)\n   return table.concat(_gather_pieces(phrase))\nend\n\n\n\n\n\n\n\nPhrase.toString = Phrase.__tostring\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__len(phrase)\n   return phrase.len\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__eq(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head == tail\nend\n\n\n\nfunction Phrase.__lt(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head < tail\nend\n\n\n\nfunction Phrase.__lte(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head <= tail\nend\n\n\n\n\n\n\n\n\n\nfunction Phrase.__repr(phrase)\n   return tostring(phrase)\nend\n\n\n\n\n\nfunction Phrase.__call(phrase, phrase_seed)\n   phrase_seed = phrase_seed or \"\"\n   local _PhraseM = getmetatable(phrase)\n   local new_phrase = {}\n   if type(phrase_seed) == \"string\" then\n      new_phrase[1] = phrase_seed\n      new_phrase.len = #phrase_seed\n   else\n      error \"bad argument #2 to Phrase, expected string\"\n   end\n   return setmetatable(new_phrase, _PhraseM)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.intern(phrase)\n   phrase.interned = true\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction Phrase.inherit(phrase, cfg)\n   local Phrase_M = getmetatable(phrase)\n   local phrase_child = setmetatable({}, Phrase_M)\n   ---[[\n   for k,v in pairs(Phrase_M) do\n      if sub(k, 1, 2) == \"__\" then\n         phrase_child[k] = v\n      end\n   end\n   phrase_child.__index = phrase_child\n   if cfg then\n      -- this can override the above metamethod assignment\n      for k,v in pairs(cfg) do\n         phrase_child[k] = v\n      end\n   end\n   return setmetatable({}, phrase_child)\n   --]]\nend\n\n\n\n\n\nPhrase.idEst = Phrase\n\n\n\nreturn setmetatable({}, Phrase)\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/core",
hash = "c3341fbb284d04b1908018ae0e7ae9de98da3efe1c19760859f5a03312a1ad05",
branch = "master",
binary = "\n\n\n\n\n\n\n\nlocal core = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n   return { n = select(\'#\', ...), ... }\nend\ncore.pack = pack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\nlocal thunk = core.thunk\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.partial(fn, ...)\n   local args = pack(...)\n   return function(...)\n      return fn(unpack(args, 1, args.n), ...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   if sub(mmethod,1,2) == \"__\" then\n      return rawget(M, mmethod)\n   else\n      return rawget(M, \"__\" .. mmethod)\n   end\nend\n\ncore.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert(pairs)\n\nfunction core.endow(Meta)\n   local MC = {}\n   for k, v in pairs(Meta) do\n      MC[k] = v\n   end\n   return MC\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction core.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(field, tab)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return true, tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(field, maybeIndex)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if not success then\n            return false\n         end\n         if result ~= nil then\n            return true, result\n         else\n            return false\n         end\n      else\n         return false\n      end\n   else\n      return false\n   end\nend\n\nlocal function _hf__index(_, field)\n   return function(tab)\n      return _hasfield(field, tab)\n   end\nend\n\nlocal function _hf__call(_, field, tab)\n   return _hasfield(field, tab)\nend\n\ncore.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive \" .. tostring(depth))\n   local _M = getmetatable(tab)\n   local clone = _M and setmetatable({}, _M) or {}\n   for k,v in pairs(tab) do\n      if depth > 1 and type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return clone\nend\ncore.clone = _clone\n\n\n\n\n\n\n\n\nfunction core.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      if type(val) ~= \"table\" then\n         return val\n      end\n      local copy\n      if dupes[val] then\n         copy = dupes[val]\n      else\n         copy = {}\n         dupes[val] = copy\n         for k,v in pairs(val) do\n            copy[_deep(k)] = _deep(v)\n         end\n         -- copy the metatable after, in case it contains\n         -- __index or __newindex behaviors\n         setmetatable(copy, _deep(getmetatable(val)))\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.isarray(tab)\n   local i = 1\n   for k,_ in pairs(tab) do\n      if k ~= i then return false end\n      i = i + 1\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction core.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\nfunction core.iscallable(val)\n   return type(val) == \"function\"\n      or hasmetamethod(\"call\", val)\nend\n\n\n\n\n\n\n\nfunction core.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction core.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _select(collection, tab, key, cycle)\n   cycle = cycle or {}\n   for k,v in pairs(tab) do\n      if key == k then\n         collection[#collection + 1] = v\n      end\n      if type(v) == \"table\" and not cycle[v] then\n         cycle[v] = true\n         collection = _select(collection, v, key, cycle)\n      end\n   end\n   return collection\nend\n\nfunction core.select(tab, key)\n   return _select({}, tab, key)\nend\n\n\n\n\n\n\n\n\nfunction core.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\nfunction core.keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local keys = {}\n   for k, _ in pairs(tab) do\n      keys[#keys + 1] = k\n   end\n\n   return keys, #keys\nend\n\n\n\n\n\n\nfunction core.values(tab)\n   assert(type(tab) == \"table\", \"vals must receive a table\")\n   local vals = {}\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction core.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = table.insert\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nfunction core.splice(tab, idx, into)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(idx) == \"number\" or idx == nil, _e_2)\n   if idx == nil then\n      idx = #tab + 1\n   end\n   assert(type(into) == \"table\", _e_3)\n    idx = idx - 1\n    local i = 1\n    for j = 1, #into do\n        insert(tab,i+idx,into[j])\n        i = i + 1\n    end\n    return tab\nend\n\n\n\n\n\n\n\n\nfunction core.safeget(tab, key)\n   local val = rawget(tab, key)\n   if val ~= nil then\n      return val\n   end\n   local _M = getmetatable(tab)\n   while _M ~= nil and rawget(_M, \"__index\") ~= nil do\n      local index_t = type(_M.__index)\n      if index_t == \"table\" then\n         val = rawget(_M.__index, key)\n      elseif index_t == \"function\" then\n         local success\n         success, val = pcall(_M.__index, table, key)\n         if success then\n            return val\n         else\n            val = nil\n         end\n      else\n         error(\"somehow, __index is of type \" .. index_t)\n      end\n      if val ~= nil then\n         return val\n      end\n      _M = index_t == \"table\" and getmetatable(_M.__index) or nil\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction core.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction core.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction core.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction core.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\n\n\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction core.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction core.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction core.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\ncore.cleave = cleave\n\n\n\n\n\n\n\n\nfunction core.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction core.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, {__index = _str_M})\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nlocal cp_M = {}\n\n\nfunction cp_M.__tostring(codepoints)\n   local answer = codepoints\n   if codepoints.err then\n      answer = {}\n      for i, v in ipairs(codepoints) do\n         local err_here = codepoints.err[i]\n         answer[i] = err_here and err_here.char or v\n      end\n   end\n   return concat(answer)\nend\n\nfunction core.codepoints(str, start, finish)\n   start = start or 1\n   finish = (finish and finish <= #str) and finish or #str\n   local utf8 = core.utf8\n   -- propagate nil\n   if not str then return nil end\n   -- break on bad type\n   assert(type(str) == \"string\", \"codepoints must be given a string\")\n   local codes = setmetatable({}, cp_M)\n   local index = start\n   while index <= finish do\n      local width, err = utf8(str, index)\n      if width then\n         local point = sub(str, index, index + width - 1)\n         insert(codes, point)\n         index = index + width\n      else\n         -- take off a byte and store it\n         local err_packet = { char = sub(str, index, index),\n                              err  = err }\n         codes.err = codes.err or {}\n         insert(codes, \"ï¿½\")\n         -- place the error at the same offset in the err table\n         codes.err[#codes] = err_packet\n         index = index + 1\n      end\n   end\n   return codes\nend\n\n\n\n\n\n\n\n\nfunction core.slurp(filename)\n  local f = io.open(filename, \"rb\")\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\n\n\nfunction core.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\nfunction core.bound(value, lower, upper)\n  if lower and value < lower then\n    value = lower\n  end\n  if upper and value > upper then\n    value = upper\n  end\n  return value\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format = string.format\n\nfunction core.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...))\n   end\nend\n\n\n\nreturn core\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/color",
hash = "1c691ec25f4c4272c2fd2255ef4a06701ff849b9a7d32ac8394b8a7fe27187fc",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"singletons/anterm\"\n\nlocal core = require \"singletons/core\"\n\nlocal Palette = require \"anterm:anterm/palette\"\n\nlocal WIDE_TABLE = 200 -- should be tty-specific\n\nlocal C = {}\n\nlocal thread_shade = a.fg24(240, 50, 100)\n\n-- #Todo make this into a proper color and use it again\n\nlocal function thread_color(str)\n   return a.italic .. thread_shade .. str .. a.clear\nend\n\nC.color = Palette {\n                    number = a.fg(42),\n                    string = a.fg(222),\n                    stresc = a.fg(225),\n                    table  = a.fg(64),\n                    func   = a.fg24(210,12,120),\n                    truth  = a.fg(231),\n                    falsehood  = a.fg(94),\n                    nilness    = a.fg(93),\n                    thread     = a.fg24(240, 50, 100),\n                    coro       = a.fg24(240, 50, 100),\n                    field      = a.fg(111),\n                    userdata   = a.fg24(230, 145, 23),\n                    cdata      = a.fg24(200, 115, 0),\n                    metatable  = a.fg24(242, 0, 234) }\n\nC.color[\"function\"] = C.color.func\nC.color[\"true\"]     = C.color.truth\nC.color[\"false\"]    = C.color.falsehood\nC.color[\"nil\"]      = C.color.nilness\n\nC.color.operator = a.fg24(220, 40, 150)\nC.color.keyword = a.fg24(100, 210, 100)\nC.color.comment = a.fg24(128,128,128)\n\n\nC.color.alert      = a.fg24(250, 0, 40)\nC.color.base       = a.fg24(200, 200, 200)\nC.color.search_hl = a.fg24(30, 230, 100)\nC.color.error = a.bg24(50,0,0)\nC.color.bold = a.bold\nC.color.greyscale = a.fg24(128,128,128)\n\nC.color.highlight = a.bg24(70, 70, 70)\n\nC.depth = 4 -- table print depth\n\n\n\n\n\n\n\n\n\nlocal no_color = {}\n-- if field accessed, pass through\nlocal function _no_c_index(nc, _)\n   return nc\nend\n\nlocal function _no_c_call(_, str)\n   return str or \"\"\nend\n\nlocal function _no_c_concat(head, tail)\n   head = head == no_color and \"\" or head\n   tail = tail == no_color and \"\" or tail\n   return head .. tail\nend\n\nsetmetatable(no_color, { __index  = _no_c_index,\n                                __call   = _no_c_call,\n                                __concat = _no_c_concat, })\n\nC.no_color = no_color\n\n-- Also attach a no_color option to the regular color table\nC.color.no_color = no_color\n\n\n\n\n\nreturn C\n",
},
  { 
vc_hash = "2495a4745cb3c931416ca0de1192f984c3b3a2eb",
name = "singletons/status",
hash = "3bbb9141c33b8ec6c15cee724be02ac124b89afafb1ad9564fe08a0e92dac5b2",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"singletons/anterm\"\nlocal debug = require \"debug\"\n\nlocal status = {}\n\nstatus.DjikstraWasRight = true -- I swear I\'m going to use this for something. Watch.\n\nstatus.chatty = true\nstatus.verbose = false\nstatus.grumpy = true\nstatus.angry = true\n\nstatus.traceOnComplain = true\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction status.halt(statusQuo, message, exitCode)\n    local bye = exitCode or 1\n    error(message)\n    os.exit(bye)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction status.chat(statusQuo, message)\n    if statusQuo.chatty then\n        statusQuo.out(message .. \"\\n\")\n    end\nend\n\n\n\n\n\n\n\nfunction status.verb(statusQuo, message)\n    if statusQuo.verbose then\n        statusQuo.out(message .. \"\\n\")\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction status.complain(statusQuo, topic, message, value)\n    if not message then\n        message = topic\n    else\n        topic = a.red(topic)\n    end\n    if statusQuo.grumpy then\n        statusQuo.out(topic .. \": \" .. message .. \"\\n\")\n    end\n    if statusQuo.traceOnComplain then\n        statusQuo.out(debug.traceback())\n    end\n    if statusQuo.angry then\n        os.exit(1)\n    end\nend\n\nlocal function call(statusQuo, outbox)\n    if outbox then\n        status.out = outbox\n    end\n    outbox = outbox or statusQuo.out or io.write\n    if not statusQuo.out then\n        statusQuo.out = outbox\n    end\n    return setmetatable({out = outbox}, {__index = statusQuo, __call = call})\nend\n\n\nreturn setmetatable(status, {__call = call})\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/status.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/status.git",
    home = "",
    website = "",
    name = "status",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "7363d81e6a852738085131fc433af0b226540eda",
name = "status",
hash = "b41f339a7b26a48369f6b5b2d5b5123577eb3d9a892e697ec8775b8b707b8d4a",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nlocal Status = {}\nStatus.__index = Status\n\n\n\n\n\n\nStatus.idEst = Status\n\n\n\n\n\n\n\n\n\nStatus[1] = io.stdout\nStatus[2] = io.stderr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.Grumpy = nil\nStatus.Angry  = nil\nStatus.Chatty = nil\nStatus.Verbose = nil\n\n\n\n\n\n\n\n\n\n\n\nStatus.grumpy = true\nStatus.angry  = false\nStatus.chatty = true\nStatus.verbose = false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.print = not _Bridge.helm\nStatus.log   = false\nStatus.helm = _Bridge.helm or false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _silent()\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _log(message)\n   if Status.print then\n      Status[1]:write(message .. \"\\n\")\n   end\n   if Status.log then\n      -- log to database\n   end\n   if Status.tail then\n      -- append to file\n   end\n   if Status.helm then\n      -- add to in-memory status \"file\"\n   end\nend\n\n\n\nlocal function _errlog(message, should_print)\n   if Status.print and should_print then\n      Status[2]:write(message .. \"\\n\")\n   end\n   if Status.log then\n      -- log to database\n   end\n   if Status.tail then\n      -- append to file\n   end\n   if Status.helm then\n      -- add to in-memory status \"file\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Status.halt(statusQuo, message, ...)\n   local msg = format(message, ...)\n   _errlog(msg, false)\n   error(msg, 2)\nend\n\n\n\n\n\n\nfunction Status.complain(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   local msg = format(message, ...)\n   _errlog(msg, (not statusQuo.angry))\n   if statusQuo.angry then\n      error(msg, 2)\n   end\nend\n\n\n\n\n\n\nfunction Status.warn(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   _errlog(format(message, ...), true)\nend\n\n\n\n\n\n\nfunction Status.chat(statusQuo, message, ...)\n   if not statusQuo.chatty then return end\n   _log(format(message, ...))\nend\n\n\n\n\n\n\nfunction Status.verb(statusQuo, message, ...)\n   if not statusQuo.verbose then return end\n   _log(format(message, ...))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Moods = Set {\'Angry\', \'Grumpy\', \'Chatty\', \'Verbose\'}\nlocal moods = Set {\'angry\', \'grumpy\', \'chatty\', \'verbose\'}\n\n\n\n\n\n\nlocal verbs = Set {\'halt\', \'complain\', \'chat\', \'verb\', \'warn\'}\n\n\n\n\n\n\n\n\nlocal upper, sub = assert(string.upper), assert(string.sub)\n\nlocal function status__newindex(statusQuo, key, value)\n   if Moods[key] then\n      error(\"Cannot assign capital Mood \" .. key .. \" to instance of status\")\n   end\n   local Mood = upper(sub(key, 1, 1)) .. sub(key, 2)\n   if Status[Mood] ~= nil then return end\n   assert(type(value) == \'boolean\',\n          \"fields on status instance must be true or false\")\n   if moods[key] then\n      rawset(statusQuo, key, value)\n      return\n   end\n   error (key .. \" is an invalid field to assign to a status instance\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal status_M = { __index = Status,\n                   __newindex = status__newindex }\nlocal function Status__call(statusQuo)\n   local s = setmetatable({}, status_M)\n   return s\nend\n\n\n\n\n\n\n-- \'tail\' and \'silent\' are handled with custom code\nlocal modes = Set {\'print\', \'log\', \'helm\'}\n\n\n\nlocal lower = assert(string.lower)\n\nlocal function Status__newindex(statusQuo, key, value)\n   if key == \'silent\' then\n      -- stub out all functions\n      for key in pairs(verbs) do\n         Status[key] = _silent\n      end\n   elseif key == \'tail\' then\n      -- reassign [1] and [2]\n   elseif modes[key] then\n      assert(type(value) == \'boolean\', \"Modes must be set true or false\")\n      rawset(Status, key, value)\n   elseif Moods[key] then\n      assert(type(value) == \'boolean\', \"Moods must be set true or false\")\n      rawset(Status, key, value)\n      rawset(Status, lower(key), value)\n   else\n      error(\"Cannot assign key \" .. key\n            .. \" to Status, with value \" .. tostring(value))\n   end\nend\n\n\n\nsetmetatable(Status, { __newindex = Status__newindex,\n                       __call     = Status__call })\n\n\n\nreturn Status\n",
},
} },
}