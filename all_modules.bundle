return { {
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/SQLun.git",
    repo_type = "git",
    repo_alternates = "",
    name = "SQLun",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "migrations",
hash = "4fd3ce6521ee9a5fdea23ce64d5faeb3b5a31d53f2c63eb342bc86977c1f06f4",
binary = "\n\n\n\n\n\n\n\n\nlocal arcivist = require \"SQLun:arcivist\"\n\nlocal schema, migration = arcivist.schema, arcivist.migration\n\n\n\nlocal spec = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal widgets = {}\nspec.widgets = widgets\nwidgets.schema = schema()\n\n\n\n\n\n\nlocal create_widget_table = [[\nCREATE TABLE IF NOT EXISTS widget (\n   widget_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   widget TEXT NOT NULL,\n   inventory INTEGER,\n   FOREIGN KEY (inventory)\n      REFERENCES inventory (inventory_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\nlocal create_inventory_table = [[\nCREATE TABLE IF NOT EXISTS inventory (\n  inventory_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  SKU INTEGER UNIQUE NOT NULL,\n  stock INTEGER NOT NULL\n);\n]]\n\n\nwidgets.schema\n   :addMigration(migration(create_widget_table, create_inventory_table))\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert_widget = [[\nINSERT INTO widget (widget, inventory) VALUES (:widget, :inventory);\n]]\n\nlocal insert_inventory = [[\nINSERT INTO inventory (SKU, stock) VALUES (:SKU, :stock);\n]]\n\n\n\n\n\nlocal _widg_pop = {\n   dongle = {2, 15},\n   variolater = {3, 8},\n   rat_trap = {5, 255},\n   acme_transmogrifier = {7, 1022},\n}\n\n\n\n\n\nlocal lastRowId = assert(sql.lastRowId)\n\nlocal function _populate(conn, s)\n   local ins_widget = conn:prepare(insert_widget)\n   local ins_inventory = conn:prepare(insert_inventory)\n   for name, nums in pairs(_widg_pop) do\n      ins_inventory :bind(nums[1], nums[2]) :step()\n      local inv_id = lastRowId(conn)\n      ins_widget :bind(name, inv_id) :step()\n      ins_inventory :clearbind() :reset()\n      ins_widget :clearbind() :reset()\n   end\n\n   return true\nend\n\n\n\nlocal migration_2 = migration(_populate)\nwidgets.schema:addMigration(migration_2)\n\n\n\n\n\n\n\n\nlocal widg_search = {}\n\n\nwidg_search.find_stock_by_widget = [[\nSELECT CAST(inventory.stock AS REAL) AS stock FROM widget\nINNER JOIN inventory ON inventory.inventory_id == widget.inventory\nWHERE widget.widget = :widget\n;\n]]\n\n\n\nwidgets.schema.search  = widg_search\n\n\n\n\n\n\n\n\n\n\nwidgets.arc = arcivist(\"\", \"widgets\")\n\n\n\nreturn spec\n\n",
name = "spec/arcivist",
vc_hash = "a5357b86fc410675c4fcd261eccde593cbaa9348",
},
  { 
branch = "migrations",
hash = "21f8b1f6173fc56efc3fef9952604dc81a34f266dfb8cf1af8ef5eb17569646d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\nlocal open = sql.open\n\nlocal cluster  = require \"core:core/cluster\"\nlocal meta, constructor = cluster.Meta, cluster.constructor\n\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nlocal Arcivist = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal arc_lib = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _archivists = setmetatable({}, { __mode = \'v\' })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(Arc, home, name, schema, OS_ENV)\n   assert(type(home) == \'string\', \"missing database home string\")\n\n   local arc = setmetatable({}, Arcivist)\n   arc.rel_path = home\n   -- optional parameters included if present\n   arc.name, arc.schema = name, schema\n\n   arc:home(home, OS_ENV)\n   -- check if we have one of these /resolved/ paths before opening the\n   -- database\n   if home ~= \"\" and _arcivists[arc.db_home] then\n      error(format(\"Arcivists must be unique, %s already exists\", arc.db_home))\n   else\n      arc:open()\n   end\n\n   if schema then\n      arc:apply(schema)\n   end\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _migrate(conn, migration, s)\n   if type(migration) == \'function\' then\n      migration(conn, s)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            s:verb(step)\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, s)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nfunction _boot(conn, migrations)\n   -- bail early with no migrations\n   if not migrations then return conn end\n   local version = #migrations\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      -- #Todo handle io redirect with status flags\n      --  chicken and egg thing...\n      local s = require \"status:status\" (io.stdout, io.stderr)\n      s.verbose = true -- probably not the correct default\n      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         s:chat(\"Performing migration %d\", i)\n         _migrate(conn, migrations[i], s)\n      end\n      conn:exec \"COMMIT;\"\n      s:chat \"Cleaning up...\"\n      conn:exec \"VACUUM;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n      s:chat(\"Migrations completed, your version is %d\", version)\n   elseif user_version > version then\n      error(format(\"Error: database version is %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _openConn(conn_handle)\n   assert(conn_handle, \"conn handle must be present\")\n   return assert(open(conn_handle, \'rwc\'), \"no conn! \" .. conn_handle)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Proxy = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _prepareStatements(conn, stmts)\n   return function(_, key)\n      if stmts[key] then\n         return conn:prepare(stmts[key])\n      elseif Proxy[key] then\n         return Proxy[key]\n      else\n         error(\"Don\'t have a statement \" .. key .. \" to prepare.\")\n      end\n   end\nend\n\nlocal function _readOnly(_, key, value)\n   error (\"can\'t assign to prepared statements table, key: \" .. key\n          .. \" value: \" .. value)\nend\n\nlocal lastRowId = assert(sql.lastRowId)\n\nfunction _makeProxy(conn, stmts)\n   if not stmts then\n      error \"no statements\"\n   end\n   local _stmts = {}\n   for name, stmt in pairs(stmts) do\n         _stmts[name] = stmt\n   end\n   return setmetatable({ lastRowId = function() return lastRowId(conn) end },\n                       { __index = _prepareStatements(conn, _stmts),\n                         __newindex = _readOnly })\nend\n\n\n\n\n\n\n\n\n\nlocal function proxy(arc, proxy_name)\n   local conn = arc and arc.conn or error \"No Arcivist or missing conn\"\n   assert(arc.schema, \"Arcivist must have a schema to derive proxies form\")\n   assert(type(proxy_name) == \'string\', \"Proxy name must be a string\")\n   if not arc.schema[proxy_name] then\n      error (\"No statements associated with \" .. proxy_name)\n   end\n\n   local stmts =  _makeProxy(conn, arc.schema[proxy_name])\n   rawset(stmts, \"beginTransaction\",\n          function()\n             return conn:exec \"BEGIN TRANSACTION;\"\n          end)\n   rawset(stmts, \"commit\",\n          function()\n             return conn:exec \"COMMIT;\"\n          end)\n   return stmts\nend\n\nArcivist.proxy = proxy\n\n\n\n\n\nProxy.idEst = proxy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Migration = meta {}\n\n\n\n\n\n\n\n\n\n\n\nfunction _migration(...)\n   local migr = setmetatable({}, Migration)\n   for i = 1, select(\'#\', ...) do\n      migr[i] = select(i, ...)\n   end\n\n   return migr\nend\n\nMigration.idEst = _migration\n\narc_lib.migration = _migration\n\n\n\n\n\n\nlocal Schema = meta {}\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Schema.addMigration(schema, migr)\n   assert(migr and migr.idEst == _migration, \"must pass a migration to schema\")\n   insert(schema[1], migr)\n   return schema\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Schema.addStatements(schema, name, stmts)\n   assert(type(name) == \'string\', \"#1 must be a string\")\n   assert(type(stmts) == \'table\', \"#2 must be a table\")\n   -- clone statements for uh. hygiene?\n   local _stmts = {}\n   schema[name] =  _stmts\n   for symbol, sql in pairs(stmts) do\n      _stmts[symbol] = sql\n   end\n\n   return schema\nend\n\n\n\n\n\n\n\n\nlocal function _migration_1()\n   return true\nend\n\nlocal function schema()\n   local _schema = setmetatable({{_migration_1}}, Schema)\n   _schema.stmts = {}\n   return _schema\nend\n\nSchema.idEst = schema\n\narc_lib.schema = schema\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Arcivist.apply(arc, schema)\n   if schema and arc.schema then\n      error (\"schema has already been applied to arcivist \"\n            .. (arc.name or \"\") .. \".\")\n   end\n   schema = schema or arc.schema or error \"no schema to apply\"\n   _boot(arc.conn, schema[1])\n   arc.schema = schema\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal getenv = assert(os.getenv)\n\nfunction Arcivist.home(arc, rel_path, OS_ENV)\n   assert(type(rel_path) == \'string\', \"rel_path must be a string.\")\n   assert((not OS_ENV) or type(OS_ENV) == \'string\',\n          \"OS_ENV must be nil or string\")\n   if rel_path == \"\" then\n      arc.db_home = \"\"\n      return arc\n   end\n   local path = (OS_ENV and getenv(OS_ENV)) or _Bridge.bridge_home .. rel_path\n   arc.db_home = path\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/string\" . assertfmt\nlocal format = assert(string.format)\n\n\nfunction Arcivist.open(arc)\n   assert(arc.db_home, \"Arcivist must have a database home to open\")\n   local conn =   _openConn(arc.db_home)\n                  or error \"can\'t open conn\"\n   arc.conn = conn\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Arcivist.close(arc, is_uv)\n   local conn = arc and arc.conn\n   if not arc.conn then return end\n\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   if not is_uv then\n      -- try once and leave\n      local ok = pcall(conn.close, conn)\n      if ok then\n         _arcivists[arc] = nil\n      end\n   else\n      -- otherwise set up an idler to close the conn, so that e.g. busy\n      -- exceptions don\'t blow up the hook\n      local close_idler = uv.new_idle()\n      close_idler:start(function()\n         local ok = pcall(conn.close, conn)\n         if not success then\n            return nil\n         else\n            close_idler:stop()\n            _arcivists[arc] = nil\n         end\n      end)\n   end\n   return arc\nend\n\n\n\n\nreturn constructor({}, new, arc_lib)\n\n",
name = "arcivist",
vc_hash = "a5357b86fc410675c4fcd261eccde593cbaa9348",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/actor.git\n",
    repo_type = "git",
    repo_alternates = "",
    name = "actor",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "message-2",
hash = "b0d97da47590b6ddacb4fa7f8448f74b5358824557cd3dc36e6bea3b68abb599",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal core = require \"qor:core\" -- #todo there\'s that qor again\nlocal iscallable = assert(core.fn.iscallable)\n-- #Todo these need to come from the cluster codex\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal constructor = assert(require \"core:cluster\" . constructor)\n\n\n\nlocal s = require \"status:status\" ()\ns.chatty = true\n\n\n\nlocal Message = require \"actor:message\"\nlocal Task    = require \"actor:task\"\n\n\n\nlocal Note  = require \"status:annotate\"\nlocal Deque = require \"deque:deque\"\n\n\n\n\n\n\nlocal yield, resume, create = assert(coroutine.yield),\n                                       assert(coroutine.resume),\n                                       assert(coroutine.create)\n\nlocal running, status = assert(coroutine.running),\n                        assert(coroutine.status)\n\n\n\n\n\n\n\n\n\n\n\nlocal mu = assert(core.fn.no_op)\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"cluster:cluster\"\nlocal genus, construct = assert(cluster.genus), assert(cluster.construct)\n\n\n\nlocal new, Actor, Actor_M = genus()\n\n\n\n\n\n\n\nlocal ts = require \"repr:repr\" . ts_color\n\nlocal function _dispatch(I, ...)\n   local msg = pack(...)\n   s:chat (\"dispatch reponse: %d\", msg.n)\n   for i = 1, msg.n do\n       s:chat(ts(msg[i]))\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(core.fn.curry)\n\nconstruct(new, function(Actor, I, ...)\n   s:chat \"\\ncreating actor\"\n   I.note = Note()\n   I.tasks = Deque()\n   I.respond = _dispatch\n   return I\nend)\n\nActor.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActor.construct = mu\nActor.launch    = mu\n\n\n\n\n\n\n\n\nlocal function dispatch_task(I, task)\n   s:chat \"dispatching task\"\n   return I:handleMessages(task.work, task.message)\nend\n\nfunction Actor.handleMessages(I, work, msg)\n   local ok, msg = true, msg\n   while ok do\n      ok, msg = resume(work, I, unpack(msg))\n      if not ok then\n         error(msg .. \"\\nIn coro:\\n\" .. debug.traceback(work))\n      elseif status(work) == \"dead\" then\n         -- End of body function, pass through the return value\n         return msg\n      else\n         msg = pack(msg)\n      end\n   end\nend\n\nfunction Actor_M.__call(I, ...)\n   -- build Task parameters\n   s:chat \"creating Task\"\n   local dispatch, message, work, event, context;\n   -- dispatch\n   dispatch = dispatch_task\n   -- message\n   message = pack(...)\n   -- work\n   work = create(I.respond)\n   -- event\n   if I.next_event then\n      event = I.next_event\n      I.next_event = nil\n   else\n      -- this will be a method, probably?\n      event = uv.new_idle()\n   end\n   -- context\n   local co, main = running()\n   if (not main) then\n      context = co\n   else\n      context = work\n   end\n\n   local task = Task(dispatch, message, work, event, context)\n   I.tasks:push(task)\n   event:start(I:wakeupOn(event))\nend\n\n\n\n\n\n\nfunction Actor.wakeupOn(I, event)\n   return function()\n      s:chat \"called wakeup\"\n      -- compare front of task queue with event\n      local task = I.tasks:peek()\n      if task.event == event and (not task.running) then\n         -- do stuff\n         s:chat \"reached the task\"\n         task:run(I)\n         event:stop()\n         I.tasks:pop()\n         I.next_event = event\n      end\n   end\nend\n\n\n\n\n\n\nreturn new\n\n",
name = "actor/next",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
  { 
branch = "message-2",
hash = "b2d363d68366686a4cf602c9f0b974e015a03c29511523de7e87da8165b64bf2",
binary = "\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\nlocal s = require \"status:status\" ()\ns.chatty = true\ns.verbose = true\n\n\n\nlocal Message = require \"actor:message\"\n\n\n\n\n\n\n\n\nlocal thread = assert(core.thread)\nlocal coro =  thread.nest \"actor\"\n\n\n\n\n\n\n\n\n\nlocal Yield, Resume, Create = assert(coro.yield),\n                              assert(coro.resume),\n                              assert(coro.create)\n\nlocal running, status = assert(coro.running),\n                        assert(coro.status)\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Actor, Actor_M = cluster.order()\n\n\n\n\n\nlocal dotask; -- = function(I, task, ...)\n\n\n\n\n\n\n\n\n\n\n\n\n\ncluster.construct(new, function(seed, I, ...)\n   -- make a \'tasker\' for launching tasks\n   local function task__index(tab, key)\n      tab[1] = key\n      return tab\n   end\n\n   local function task__call(tab, _, ...)\n      return dotask(I, tab[1], ...)\n   end\n\n   I.__tasker = setmetatable({}, { __index = task__index,\n                                        __call = task__call })\n   return I\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActor.setup = cluster.ur.chain\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Actor.send(actor, msg)\n   return Yield(msg)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Actor.task(I)\n   return I.__tasker\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal empty_ret = { n = 0 }\n\n\n\n\n\n\ndotask = function(I, task, ...)\n   local msg_ret = pack(I, ...)\n   -- the work: callable, always filled\n   local work;\n   -- the coroutine: optional\n   local co = nil\n   local task_t, task_name = type(task), tostring(task)\n   if type(task) == \'function\' then\n      work = task\n   elseif task_t == \'string\' then\n      work = assert(I[task], \"missing method\")\n   else\n      -- we could handle callable tables, but we\'d have to coerce them into a\n      -- function if we make a coroutine.\n      -- if you see this error because you somehow passed a callable table as\n      -- a task (callable for a method? I\'ve done it), the solution is\n      -- clear, and is unwritten because I\'m disinclined to test it this\n      -- weekend.\n      error(\"bad task of type \" .. task_t)\n      -- there\'s got to be something useful to do with a thread, but in the\n      -- meantime passing one qualifies as a mistake.\n   end\n   if I:immediately(task, ...) then\n      -- don\'t create a coroutine, just call the work\n      return work(I, ...)\n   end\n   co = Create(work)\n   -- return values\n   local ok, msg, packed;\n   repeat\n      if status(co) == \'dead\' then\n         s:warn(\"won\'t resume dead coroutine, returning %s\", tostring(msg))\n         return ok, msg\n      end\n\n      ok, msg, packed = Resume(co, unpack(msg_ret))\n\n      -- Mostly? msg is a Message. Never a message if not ok.\n      -- So we jump them to the front of the line.\n      if type(msg) == \'table\' and msg.idEst == Message then\n         goto delegate\n      end\n      -- Handle errors and return values.\n      if not ok then\n         return I:handleBrokenTask(co, msg, msg_ret)\n         or error((msg or \"\") .. \"\\nIn task: \" .. task_name\n                  .. \"\\n\" .. debug.traceback(co)\n                  .. debug.traceback(2))\n      elseif status(co) == \'dead\' then\n         -- End of body function, pass through the return value\n         return msg\n      end\n\n      if msg == nil then\n         -- setup for a Resume\n         -- we shouldn\'t see this yet, so let\'s warn about it\n         s:warn \"saw a nil yield in message dispatch, resuming\"\n         msg_ret = empty_ret\n         -- Every state in the protocol gets a chance to act, for nil it\'s\n         I:canPause()\n         -- and we might wake up in another callback, who knows\n         goto continue\n      end\n\n      if type(msg) == \'string\' then\n         -- handle action-type returns here\n         error(\"Don\'t yet know what to do with a string message like \" .. msg)\n      end\n\n      if not (msg and type(msg) == \'table\' and msg.idEst == Message) then\n         s:warn(\"bad message of type %s: %s\", type(msg), debug.traceback(co))\n         -- If it isn\'t message-shaped, this will throw\n         msg = Message(msg)\n      end\n\n      ::delegate::\n      msg_ret = I:delegate(msg)\n\n      ::continue::\n   until not msg_ret -- This exit is not intentional currently\n   ---[[ we hit this handling unexpected yields in eval\n   --   so I\'m knocking this out for now:\n   error \"this is not so much a question as a statement: \\\n          an actor returned a nil on :delegate\"\n   --]]\n\n   -- A good place for another :method\n\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActor.immediately = cluster.ur.no\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ts;\nfunction Actor.handleBrokenTask(I, co, msg, msg_ret)\n   if msg == \'cannot resume dead coroutine\' then\n      ts = ts or require \"repr:repr\" .ts_color\n      s:warn(\"tried to unpack %d values into a dead coro: %s\",\n             msg_ret.n, ts(msg_ret[2]))\n      return empty_ret\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Actor.delegate(I, msg)\n   return pack(I:dispatch(msg))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal gmatch = assert(string.gmatch)\nlocal keys = assert(core.table.keys)\n\nfunction Actor.dispatch(I, msg, ...)\n   -- The first glance at the Message goes through the inbox:\n   local target, envelope = I:inbox(msg, ...)\n   -- We can discard the message by providing no target\n   if not target then return end\n\n   -- The base returns -> I, nil. If the Actor changes the message,\n   -- envelope will contain it.\n   if envelope then\n      msg = envelope\n   end\n\n   local result;\n\n   while msg do\n      --  #todo replace this with construction-time translation to array,\n      --  maybe\n      if msg.sendto or msg.to then\n         local to = msg.sendto or msg.to\n         if type(to) == \'string\' then\n            for prop in gmatch(to, \"([^.]+)[.]?\") do\n               target = assert(target[prop], \"Actor lacks \'%s\' in %s\",\n                               prop, to)\n            end\n         elseif type(to) == \'table\' then\n            -- array of properties\n            for _, prop in ipairs(to) do\n               target = assert(target[prop], \"Actor lacks \'%s\' in %s\",\n                               prop, to)\n            end\n         end\n      end\n      if msg.property or msg.field then\n         local field = msg.property or msg.field\n         result = pack(target[field])\n      elseif msg.call == true then\n         result = pack(target(unpack(msg)))\n      elseif msg.call then\n         local fn = target[msg.call]\n         s:chat(\"  a method call on %s\", msg.call)\n         if not fn then\n            -- #todo this leaves out useful information in the case of a\n            -- nested message, and also doesn\'t know how to represent the\n            -- starting/root actor. We really want to stringify the whole\n            -- chain in a meaningful way\n            error(\"attempt to call a nil function \" .. msg.call\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(unpack(msg)))\n      elseif msg.method then\n         local fn = target[msg.method]\n         if not fn then\n            -- Similar concern as with .call, also this is annoyingly similar\n            error(\"attempt to call a nil method \" .. msg.method\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(target, unpack(msg)))\n      else\n         error(\"Message must have one of property, call, or method: \" ..\n            (require \"repr:repr\".ts(keys(msg))))\n      end\n      target = result[1]\n      msg = msg.message\n   end\n   return unpack(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActor.inbox = assert(cluster.ur.chain)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActor.canPause = assert(cluster.ur.mu)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Response = require \"cluster:response\"\nlocal Cache    = require \"gadget:cachebox\"\n\n\n\n\n\n\nlocal yield = assert(coroutine.yield)\n\n\n\n\n\nlocal function defer(I, task)\n   if not I.cache then\n      -- 8 is a made-up limit on the number of idle handles which the\n      -- cache will store, all of this will bear configuration eventually\n      I.cache = Cache(uv.new_idle, \'stop\', 8, \'close\')\n   end\n   local later = I.cache:take()\n   local response = Response(running)\n   later:start(function()\n      I.cache:done(later)\n      response:respond(task())\n   end)\n   return yield(response)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Actor_M.__call(I, ...)\n   return I :task() :act(...)\nend\n\n\n\n\n\nActor.act = assert(cluster.ur.chain)\n\n\n\n\nreturn new\n\n",
name = "actor",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
  { 
branch = "message-2",
hash = "ecb188b049ad72f86a632f218db635025c65aed49108eb488c371da6ad753e4c",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal act = meta {}\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal iscallable = assert(core.fn.iscallable)\nlocal meta = assert(core.cluster.meta)\nlocal constructor = assert(core.cluster.constructor)\n\n\n\nlocal yield, resume, create = assert(coroutine.yield),\n                                       assert(coroutine.resume),\n                                       assert(coroutine.create)\n\nlocal running, status = assert(coroutine.running),\n                        assert(coroutine.status)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __act_mth_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.borrowmethod(actor, method)\n   assert(iscallable(method) or type(method) == \'string\',\n          \"#2 for borrowmethod must be string or callable\")\n   local uid = {}\n   __act_mth_attr[uid] = actor\n   actor = nil\n   if type(method) == \'string\' then\n      -- return a lookup function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return _actor[method](_actor, ...)\n      end\n   else\n      -- return a direct-call function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return method(_actor, ...)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal __act_getter_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.getter(actor, slot)\n   local uid = {}\n   __act_getter_attr[uid] = actor\n   actor = nil\n   return function()\n             local _actor = __act_getter_attr[uid]\n             if not _actor then\n                error \"actor has gone out of scope\"\n             end\n             return _actor[slot]\n          end\nend\n\n\n\n\nreturn act\n\n",
name = "lib",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
  { 
branch = "message-2",
hash = "ec9ec157429782ca30224284e81182d0d3e8319863cbb2b30f5ac8cf61139889",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal MSG_VERSION = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new;\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal s = require \"status:status\"\n\ns.chatty = true\n\nlocal meta = assert(core.cluster.meta)\n\n\n\n\nlocal Message = meta {}\nMessage.v = MSG_VERSION\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = assert(core.set)\n\nlocal valid_key =  Set { \"sendto\", \"to\",\n                         \"method\", \"message\",\n                         \"property\", \"field\",\n                         \"call\", \"n\", \"msg_id\" }\n\n\n\n\n\nlocal valid_params = Set { \"method\", \"call\" }\n\nlocal function _forbidParameters(msg)\n   for field in pairs(valid_params) do\n      if msg[field] then\n         return false\n      end\n   end\n\n   return true\nend\n\n\n\n\n\n\n\n\n\nlocal function mold(_msg)\n   local _cyc = {}\n\n   local function _mold(msg, sub_msg)\n      if _cyc[msg] then\n        return nil, \"cycle encountered in message\"\n      end\n      _cyc[msg] = true\n\n      -- table?\n      if not type(msg) == \'table\' then\n         return nil, \"message is not a table!\"\n      end\n\n      -- sub_msg?\n      if sub_msg then\n         new(msg)\n         return true\n      -- already a Message?\n      elseif msg.idEst == new then\n         -- send the same message\n         return msg\n      end\n\n      -- has a msg_id? (this is bad)\n      if msg.msg_id then\n         return nil, \"message contained a msg_id\"\n      end\n\n      -- params?\n      if msg.n or (#msg > 0) then\n         -- confirm we should have parameters\n         if _forbidParameters(msg) then\n            return nil, \"arguments provided for un-callable message!\"\n         end\n         if not msg.n then\n            -- this we can fix\n            msg.n = #msg\n         end\n      else\n         msg.n = 0\n      end\n\n      -- valid (string) keys?\n      for key in pairs(msg) do\n         if type(key) == \'string\' then\n            if not valid_key[key] then\n               return nil, \"invalid key! \" .. key\n            end\n         elseif type(key) ~= \'number\' then\n            return nil, \"invalid key of type \" .. type(key)\n         end\n      end\n\n      if msg.call then\n         if not (type(msg.call) == \'string\' or msg.call == true) then\n            return nil, \"message.call not a string or =true=!\"\n         end\n      end\n\n      -- Sub-message?\n      if msg.message then\n         return _mold(msg.message, true)\n      end\n\n      return true\n   end\n\n   return _mold(_msg)\nend\n\n\n\n\n\n\n\n\nfunction Message.__newindex(t, k, v)\n   error (\"Attempt to assign to Message at slot \" .. k)\nend\n\n\n\n\n\n\n\n\n\nlocal yield, wrap = assert(coroutine.yield), assert(coroutine.wrap)\nlocal tabulate, Token;\n\nfunction Message.__repr(msg, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n\n   return wrap(function()\n      -- start with an indicator and the message id\n      yield(Token(\"📩 \", { color = \"base\" }))\n      yield(tabulate(msg.id, window, c)())\n      yield(Token(msg.stamp, { color = \"base\"}))\n      yield(Token(\" { \", { color = \"base\", event = \"map\"}))\n      window.depth = window.depth + 1\n      local first = true\n      for key, val in pairs(msg) do\n         if not (key == \'id\' or key == \'stamp\') then\n            if not first then\n               yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n            else\n               first = false\n            end\n            -- hack, pairs yields array portion first so we array-ify it\n            if not (type(key) == \'number\') then\n               yield(tabulate(key, window, c)())\n               yield(Token(\" = \", { color = \"base\", event = \"sep\" }))\n            end\n            yield(tabulate(val, window, c)())\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal msg_id = 0\n\n\n\n\n\n\nlocal ts = assert(require \"repr:repr\" . ts_color)\n\nnew = function(msg)\n   local ok, err = mold(msg)\n   if not ok then\n      error (\"Invalid message: \" .. err)\n   end\n   --  The mold returns tables which are already Messages, we pass them\n   --  through\n   if msg.idEst == new then\n      return msg\n   end\n   msg_id = msg_id + 1\n   msg.id = msg_id\n   -- hack in the call info for now\n   --- 3 gets past new and send\n   local info = debug.getinfo(3, \'nSl\')\n   msg.stamp = \" \" .. info.short_src .. \":\" .. (info.name or \"?\")\n               .. \":\" .. info.currentline\n   local M = setmetatable(msg, Message)\n   s:chat(ts(M))\n   return M\nend\n\nMessage.idEst = new\n\n\n\n\nreturn new\n\n",
name = "message",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
  { 
branch = "message-2",
hash = "27aac465fc0bc0a0da9f433bc9f164e1a52274e52cf9f7a1f52c16df7d3d712c",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal MSG_VERSION = 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal s = require \"status:status\"\ns.chatty = true\n\n\n\n\nlocal new, Message, Msg_M = cluster.order()\n\nMessage.v = MSG_VERSION\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = assert(core.set)\n\nlocal valid_key =  Set { \"to\", \"action\", -- \"author\",\n                         \"method\", \"message\",\n                         \"field\", \"call\", \"n\", \"msg_id\" }\n\nlocal replace = { sendto = \"to\", property = \"field\" }\n\n\n\n\n\n\nlocal valid_params = Set { \"method\", \"call\", \"action\"}\n\nlocal function _forbidParameters(msg)\n   for field in pairs(valid_params) do\n      if msg[field] then\n         return false\n      end\n   end\n\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal valid_with_action = Set {\"n\"} -- \"author\"\n\nlocal function isComplex(val)\n   if type(val) == \'number\' or type(val) == \'string\'\n      or type(val) == \'boolean\' or val == nil then\n      -- technically the check for nil will never happen here\n      return false\n   else\n      return true\n   end end\n\nlocal function constrainAction(msg)\n   for key, value in pairs(msg) do\n      local t = type(key)\n      if t == \'number\' then\n         if isComplex(value) then\n            return nil, \"action argument \" .. tostring(key) .. \" is not literal\"\n         end\n      elseif t == \'string\' then\n         if not valid_with_action(key) then\n            return nil, key .. \" may not be combined with an action\"\n         end\n      end\n      -- invalid keys of any other type will be rejected later\n   end\n\n   return true\nend\n\n\n\nlocal function mold(_msg)\n   local _cyc = {}\n\n   local function _mold(msg, sub_msg)\n      if _cyc[msg] then\n        return nil, \"cycle encountered in message\"\n      end\n      _cyc[msg] = true\n\n      -- table?\n      if not type(msg) == \'table\' then\n         return nil, \"message is not a table!\"\n      end\n\n      -- sub_msg?\n      if sub_msg then\n         new(msg)\n         return true\n      -- already a Message?\n      elseif msg.idEst == new then\n         -- send the same message\n         return msg\n      end\n\n      -- has a msg_id? (this is bad)\n      if msg.msg_id then\n         return nil, \"message contained a msg_id\"\n      end\n\n      -- params?\n      if msg.n or (#msg > 0) then\n         -- confirm we should have parameters\n         if _forbidParameters(msg) then\n            return nil, \"arguments provided for un-callable message!\"\n         end\n         if not msg.n then\n            -- this we can fix\n            msg.n = #msg\n         end\n      else\n         msg.n = 0\n      end\n\n      -- valid (string) keys?\n      for key, value in pairs(msg) do\n         if type(key) == \'string\' then\n            if not valid_key[key] then\n               if replace[key] then\n                  -- swap over, this is where we throw an error later\n                  msg[replace[key]] = value\n                  msg[key] = nil\n               else\n                  return nil, \"invalid key! \" .. key\n               end\n            end\n            if key == \'action\' then\n               local ok, why = constrainAction(msg, value)\n               if not ok then\n                  return nil, why\n               end\n            end\n         elseif type(key) ~= \'number\' then\n            return nil, \"invalid key of type \" .. type(key)\n         end\n      end\n\n      if msg.call then\n         if not (type(msg.call) == \'string\' or msg.call == true) then\n            return nil, \"message.call not a string or =true=!\"\n         end\n      end\n\n      -- Sub-message?\n      if msg.message then\n         return _mold(msg.message, true)\n      end\n\n      return true\n   end\n\n   return _mold(_msg)\nend\n\n\n\n\n\n\n\n\nfunction Message.__newindex(t, k, v)\n   error (\"Attempt to assign to Message at slot \" .. k)\nend\n\n\n\n\n\n\n\n\n\nlocal yield, wrap = assert(coroutine.yield), assert(coroutine.wrap)\nlocal tabulate, Token;\n\nfunction Msg_M.__repr(msg, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n\n   return wrap(function()\n      -- start with an indicator and the message id\n      yield(Token(\"📩 \", { color = \"base\" }))\n      yield(tabulate(msg.id, window, c)())\n      yield(Token(msg.stamp, { color = \"base\"}))\n      yield(Token(\" { \", { color = \"base\", event = \"map\"}))\n      window.depth = window.depth + 1\n      local first = true\n      for key, val in pairs(msg) do\n         if not (key == \'id\' or key == \'stamp\') then\n            if not first then\n               yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n            else\n               first = false\n            end\n            -- hack, pairs yields array portion first so we array-ify it\n            if not (type(key) == \'number\') then\n               yield(tabulate(key, window, c)())\n               yield(Token(\" = \", { color = \"base\", event = \"sep\" }))\n            end\n            yield(tabulate(val, window, c)())\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\n\n\nfunction Msg_M.__add(msg, tab)\n   local _next = clone1(msg)\n   for k, v in pairs(tab) do\n      assert(not msg[k])\n      _next[k] = v\n   end\n   return new(_next)\nend\n\n\n\nfunction Msg_M.__sub(msg, field)\n   assert(type(field) == \'string\' or type(field) == \'number\')\n   assert(msg[field])\n   local _next = clone1(msg)\n   _next[field] = nil\n   return new(_next)\nend\n\n\n\nfunction Msg_M.__mod(msg, tab)\n   local _next = clone1(msg)\n   for k, v in pairs(tab) do\n      _next[k] = v\n   end\n   return new(_next)\nend\n\n\n\n\n\n\n\n\n\n\nlocal msg_id = 0\n\n\n\n\n\n\nlocal ts = assert(require \"repr:repr\" . ts_color)\n\nlocal function creator (_new, msg)\n   local ok, err = mold(msg)\n   if not ok then\n      error (\"Invalid message: \" .. err)\n   end\n   --  The mold returns tables which are already Messages, we pass them\n   --  through\n   if msg.idEst == new then\n      return msg\n   end\n   msg_id = msg_id + 1\n   msg.id = msg_id\n   -- hack in the call info for now\n   --- 2 means we skip this function\n   local info = debug.getinfo(2, \'nSl\')\n   msg.stamp = \" \" .. info.short_src .. \":\" .. (info.name or \"?\")\n               .. \":\" .. info.currentline\n   return msg\nend\n\ncluster.create(new, creator)\n\n\n\n\nreturn new\n\n",
name = "message2",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
  { 
branch = "message-2",
hash = "a999495f2012b1c5b2d9fccbee6946e3a4738ddb357deecaea5b3c604e0416e9",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv   = require \"luv\"\nlocal core = require \"qor:core\" -- #todo remove qor\nlocal meta = assert(core.cluster.meta)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Task = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(dispatch, message, work, event, context)\n   local task = setmetatable({ dispatch = dispatch,\n                               message  = message,\n                               work     = work,\n                               event    = event,\n                               context  = context }, Task)\n   return task\nend\n\nTask.idEst = new\n\n\n\n\n\n\n\n\nfunction Task.run(task, I)\n   task.running = true\n   task.dispatch(I, task)\nend\n\n\n\n\nreturn new\n\n",
name = "task",
vc_hash = "9da25b8a4c7aeb082e5f6ab39151b0a746590044\n",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/anterm.git",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/anterm.git",
    name = "anterm",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "93a8fb4514866a8890c0f95947fec56ba86ce826281cfd791bd6e205f58a4866",
binary = "\n\n\nlocal Point = require \"anterm/point\"\nlocal Rectangle = require \"anterm/rectangle\"\nlocal instanceof = assert(require \"core/meta\" . instanceof)\n\n\n\nlocal cursor = {}\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\'\n\n\n\nfunction cursor.stash()\n   return \"\\x1b7\"\nend\n\nfunction cursor.pop()\n   return \"\\x1b8\"\nend\n\nfunction cursor.hide()\n   return \"\\x1b[?25l\"\nend\n\nfunction cursor.show()\n   return \"\\x1b[?25h\"\nend\n\n\n\n\n\nlocal jump = {}\n\nfor dir, letter in pairs {\n   up    = \"A\",\n   down  = \"B\",\n   right = \"C\",\n   left  = \"D\",\n   nl    = \"E\",\n   col   = \"G\"\n} do\n   jump[dir] = function(num)\n      num = num or 1\n      return num == 0 and \"\" or CSI..num..letter\n   end\nend\njump.forward = jump.right\njump.back    = jump.left\n\nlocal function _jump(row, col)\n   if instanceof(row, Point) then\n      row, col = row:rowcol()\n   end\n   return CSI .. row .. \";\" .. col .. \"H\"\nend\n\nlocal J = { __call = function(_, ...) return _jump(...) end }\nsetmetatable(jump,J)\n\njump.rc = _jump\njump.rowcol = _jump\n\nfunction jump.colrow(col, row)\n   return _jump(row, col)\nend\n\n\n\n\n\n\n\nlocal erase = {}\n\nfor key, value in pairs {\n   below = \"0J\",\n   above = \"1J\",\n   all   = \"2J\",\n   right = \"0K\",\n   left  = \"1K\",\n   line  = \"2K\"\n} do\n   local escape = CSI .. value\n   erase[key] = function() return escape end\nend\n\n\n\n\n\n\n\nlocal rep = assert(string.rep)\nfunction erase.box(rect, dash)\n   dash = dash or \" \"\n   rect:assertNotEmpty(\"Cannot erase empty region\")\n   local phrase = cursor.stash() .. _jump(rect:origin())\n   local blanks = rep(dash, rect:width())\n   local nl = jump.col(rect.left) .. jump.down(1)\n   for i = 1, rect:height() do\n      phrase = phrase .. blanks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\nlocal random = assert(math.random)\n\nfunction erase.checker(rect, dash, mod)\n   mod = mod or 3\n   dash = dash or \".\"\n   local space = jump.forward()\n   rect:assertNotEmpty(\"Cannot erase empty region\")\n   local skip = random(1, mod)\n   local phrase = cursor.stash()\n               .. _jump(rect:origin())\n\n   local nl = jump.col(rect.left) .. jump.down(1)\n   for i = 1, rect:height() do\n      local checks = \"\"\n      for j = 1, rect:width() do\n         if skip % mod == 0 then\n            checks = checks .. dash\n         else\n            checks = checks .. space\n         end\n         skip = skip + 1\n      end\n      phrase = phrase .. checks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\ncursor.jump = jump\ncursor.erase = erase\n\nreturn cursor\n\n",
name = "anterm/cursor",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "4ac68aeebf5716ebf2932ae79ae27640cd9a363029d0ebfe1483b1e63c53f1b8",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier:elpatt\"\nlocal C, Cg, Cnc, Ct = L.C, L.Cg, L.Cnc, L.Ct\nlocal P, R, S, U, V = L.P, L.R, L.S, L.U, L.V\n\n\n\nlocal input_event = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mod_shorthand_to_name = {\n   C = \"ctrl\",\n   M = \"meta\",\n   S = \"shift\"\n}\nlocal mod_shorthand_to_flag = {\n   C = 4,\n   M = 2,\n   S = 1\n}\nlocal mod_flag_to_name = {\n   [1] = \"shift\",\n   [2] = \"meta\",\n   [4] = \"ctrl\",\n   [8] = \"meta\"\n}\n\ninput_event.mod_shorthand_to_name = mod_shorthand_to_name\ninput_event.mod_shorthand_to_flag = mod_shorthand_to_name\ninput_event.mod_flag_to_name = mod_flag_to_name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bor = assert(require \"bit\" . bor)\nlocal function _marshal_one(evt)\n   local mod_letters = evt.modifiers\n   evt.modifiers = 0\n   for _, mod_name in pairs(mod_shorthand_to_name) do\n      evt[mod_name] = false\n   end\n   for _, mod in ipairs(mod_letters) do\n      local mod_name = mod_shorthand_to_name[mod]\n      local mod_flag = mod_shorthand_to_flag[mod]\n      evt[mod_name] = true\n      evt.modifiers = bor(evt.modifiers, mod_flag)\n   end\n   return evt\nend\n\nlocal base_grammar = {\n   modifiers     = Cg(Ct((C(S\"CMS\") * S\"-_\")^0), \"modifiers\"),\n   special_name  = P\"UP\" + P\"DOWN\" + P\"LEFT\" + P\"RIGHT\" +\n                   P\"HOME\" + P\"END\" + P\"PAGE_UP\" + P\"PAGE_DOWN\" +\n                   P\"ESC\" + P\"TAB\" + P\"BACKSPACE\" + P\"RETURN\" +\n                   P\"INSERT\" + P\"DELETE\" +\n                   (P\"F\" * (P\"1\" * R\"09\" + R\"19\")),\n   special       = Cg(V\"special_name\", \"key\"),\n   character     = Cg(U(1) - R\"\\x00\\x1f\" - P\"\\x7f\", \"key\"),\n   keypress      = (V\"special\" + V\"character\") * Cnc(\"type\", \"keypress\"),\n   wildcard_name = P\"SPECIAL\" + P\"CHARACTER\" + P\"MOUSE\",\n   wildcard      = Cg(P\"[\" * V\"wildcard_name\" * P\"]\", \"key\") *\n                   Cnc(\"type\", \"wildcard\"),\n   mouse_name    = (P\"MB\" * (P\"_LEFT\" + P\"_RIGHT\" + P\"_MIDDLE\" + S\"67\")) +\n                   (P\"SCROLL_\" * (P\"UP\" + P\"DOWN\")),\n   mouse         = Cg(V\"mouse_name\", \"key\") * Cnc(\"type\", \"mouse\"),\n   paste         = P\"PASTE\" * Cnc(\"type\", \"paste\"),\n   event         = Ct(V\"modifiers\" * (V\"wildcard\" + V\"mouse\" + V\"paste\" + V\"keypress\")) /\n                   _marshal_one\n}\n\nlocal clone = assert(require \"core:table\" . clone)\n\nlocal event_grammar = clone(base_grammar)\nevent_grammar[1] = V\"event\" * P(-1)\nevent_grammar = P(event_grammar)\n\nlocal sequence_grammar = clone(base_grammar)\nsequence_grammar[1] = Ct((V\"event\" * (P\" \" * V\"event\")^0)^-1) * P(-1)\nsequence_grammar = P(sequence_grammar)\n\nfunction input_event.marshal(str)\n   return event_grammar:match(str)\nend\n\nfunction input_event.marshal_sequence(str)\n   return sequence_grammar:match(str)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninput_event.special_keys = {\n   \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\",\n   \"HOME\", \"END\", \"PAGE_UP\", \"PAGE_DOWN\",\n   \"ESC\", \"TAB\", \"BACKSPACE\", \"RETURN\",\n   \"INSERT\", \"DELETE\"\n}\nlocal insert = assert(table.insert)\nfor i = 1, 19 do\n   insert(input_event.special_keys, \"F\" .. tostring(i))\nend\n\nlocal special_name_grammar = base_grammar.special_name * P(-1)\nfunction input_event.is_special_key(key_name)\n   return special_name_grammar:match(key_name)\nend\n\n\n\n\n\n\n\n\n\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal inverse = assert(require \"core:table\" . inverse)\nlocal modifier_shorthand = inverse(mod_shorthand_to_name)\nlocal modifier_order = { \"ctrl\", \"meta\", \"shift\" }\n\nlocal function _serialize(evt, accum)\n   for _, mod in ipairs(modifier_order) do\n      if evt[mod] then\n         insert(accum, modifier_shorthand[mod])\n         insert(accum, \"-\")\n      end\n   end\n   insert(accum, evt.key)\nend\n\nfunction input_event.serialize(evt)\n   local answer = {}\n   _serialize(evt, answer)\n   return concat(answer)\nend\n\nfunction input_event.serialize_sequence(evts)\n   local answer = {}\n   for i, evt in ipairs(evts) do\n      if i ~= 1 then\n         insert(answer, \" \")\n      end\n      _serialize(evt, answer)\n   end\n   return concat(answer)\nend\n\n\n\nreturn input_event\n\n",
name = "anterm/input-event",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "8a22f828f83fb1a33740fc0e5a2eae2cc7ad5fd5fff7ab4f5d95bf730f9af4aa",
binary = "\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal table = require \"core:core/table\"\n\n\n\nlocal Palette = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(table.cloneinstance)\n\nfunction Palette.__newindex(palette, name, color)\n   color = type(color) == \'table\' and cloneinstance(color) or color\n   if type(color) == \'table\' then\n      color.name = name\n   end\n   rawset(palette, name, color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Palette.change(palette, name, color)\n   local old_c = palette[name]\n   color = cloneinstance(color)\n   color.name = name\n   palette[name] = color\n   if not old_c then\n      return false\n   end\n   for n, c in pairs(palette) do\n      if c.kind == \'embedded\'\n         and c.reset == old_c\n         and c.reset.name == old_c.name then\n         c.reset = color\n      end\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(color_tab)\n   local palette = setmetatable({}, Palette)\n   if color_tab then\n      for name, color in pairs(color_tab) do\n         palette[name] = color\n      end\n   end\n   return palette\nend\n\nPalette.idEst = new\n\n\n\n\nreturn new\n\n",
name = "anterm/palette",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "77110e3ef9fcefdfc286fde73f1e39b180a70a8a1e1456cbb8be021286d09868",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier:elpatt\"\nlocal C, Cc, Cg, Cp, Ct = L.C, L.Cc, L.Cg, L.Cp, L.Ct\nlocal M, P, R, S, U, V = L.M, L.P, L.R, L.S, L.U, L.V\nlocal Cnc = assert(require \"espalier:elpatt\" . Cnc)\n\nlocal bit = require \"bit\"\nlocal band, bor, rshift = assert(bit.band), assert(bit.bor), assert(bit.rshift)\n\nlocal concat = assert(table.concat)\nlocal core_table = require \"core:table\"\nlocal addall, keys = assert(core_table.addall), assert(core_table.keys)\n\n\n\n\n\n\nlocal seq_grammar = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal special_ctrl_map = {\n   [\"\\t\"]   = \"TAB\",\n   [\"\\r\"]   = \"RETURN\",\n   [\"\\x7F\"] = \"BACKSPACE\",\n   -- Does any terminal ever send this for anything other than a\n   -- Ctrl-J, which we should treat as such?\n   -- [\"\\n\"] = \"NEWLINE\"\n}\n\naddall(seq_grammar,{\nESC = P\"\\x1b\",\nCSI = V\"ESC\" * P\"[\",\nPs  = (R\"09\" ^ 1) / tonumber,\nany_ctrl = R\"\\x00\\x1f\",\nspecial_ctrl = M(special_ctrl_map),\n-- Escape is only matched as such if it appears at the end of the input\nbare_ESC = V\"ESC\" * -1 * Cc(\"ESC\"),\n-- Any single character that maps directly to a key name\n-- Ordered choice, so the expression at the end will never match backspace\nbare_char = V\"special_ctrl\" + (U(1) - V\"any_ctrl\"),\nmodifiers = Cg(V\"Ps\" / function(n) return n - 1 end, \"modifiers\")\n})\n\n\n\n\n\n\n\n\n\n\nlocal CSI_tilde_map = {}\nfor k, v in pairs{\n   nil,\n   \"INSERT\",\n   \"DELETE\",\n   nil,\n   \"PAGE_UP\",\n   \"PAGE_DOWN\",\n   \"HOME\",\n   \"END\",\n   nil, nil,\n   \"F1\", \"F2\", \"F3\", \"F4\", \"F5\",\n   nil,\n   \"F6\", \"F7\", \"F8\", \"F9\", \"F10\",\n   nil,\n   \"F11\", \"F12\", \"F13\", \"F14\", \"F15\"\n} do\n   CSI_tilde_map[tostring(k)] = v\nend\n\nseq_grammar.CSI_tilde_seq = V\"CSI\" *\n   Cg(M(CSI_tilde_map), \"key\") *\n   (P\";\" * V\"modifiers\")^-1 *\n   P\"~\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal CSI_letter_map = {\n   A = \"UP\",\n   B = \"DOWN\",\n   C = \"RIGHT\",\n   D = \"LEFT\",\n   F = \"END\",\n   H = \"HOME\",\n   P = \"F1\",\n   Q = \"F2\",\n   R = \"F3\",\n   S = \"F4\",\n   -- There\'s a legacy of encoding Shift-Tab as CSI Z, and under CSI u\n   -- combinations containing Shift-Tab (e.g. Ctrl-Shift-Tab) are modified\n   -- on top of that similar to other letters. We\'ll put the Shift modifier\n   -- where it belongs later, for now just get this parsed somehow\n   Z = \"SHIFT_TAB\"\n}\n\nseq_grammar.CSI_letter_special_key = V\"CSI\" *\n   (P\"1;\" * V\"modifiers\")^-1 *\n   Cg(M(CSI_letter_map), \"key\")\n\n\n\n\n\n\n\n\n\n\nlocal utf8_char = assert(require \"lua-utf8\" . char)\nlocal function CSIu_char_convert(codepoint)\n   local char = utf8_char(codepoint)\n   return special_ctrl_map[char] or char\nend\nseq_grammar.CSIu_seq = V\"CSI\" *\n              Cg(V\"Ps\" / CSIu_char_convert, \"key\") *\n              P\";\" *\n              V\"modifiers\" *\n              P\"u\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ctrl_char_convert(ch)\n   if ch:byte() == 0 then\n      return \" \"\n   else\n      -- We represent letters as lowercase, but the symbols are still those\n      -- adjacent to the uppercase letters\n      return string.char(ch:byte() + (\"@\"):byte()):lower()\n   end\nend\n\naddall(seq_grammar, {\n-- Similar to how we handle bare ESC, we assume that =ESC [= represents the\n-- start of a CSI sequence unless it\'s the last piece of input.\nALT_seq      = V\"ESC\" * Cg(V\"bare_char\", \"key\") *\n               Cnc(\"modifiers\", 2),\nCTRL_char    = Cg((V\"any_ctrl\" - V\"special_ctrl\" - V\"ESC\") / ctrl_char_convert, \"key\"),\nCTRL_seq     = V\"CTRL_char\" *\n               Cnc(\"modifiers\", 4),\nCTRL_ALT_seq = V\"ESC\" * V\"CTRL_char\" *\n               Cnc(\"modifiers\", 6)\n})\n\n\n\n\n\nlocal key_seq = (Cg(V\"bare_char\", \"key\") +\n          V\"CSIu_seq\" + V\"CSI_tilde_seq\" + V\"CSI_letter_special_key\" +\n          V\"CTRL_ALT_seq\" + V\"ALT_seq\" + V\"CTRL_seq\") *\n          Cnc(\"type\", \"keypress\")\n\nlocal input_event = require \"anterm:input-event\"\nlocal function parse_modifiers(event)\n   for mask, key in pairs(input_event.mod_flag_to_name) do\n      event[key] = event[key] or band(event.modifiers, mask) ~= 0\n   end\nend\n\nseq_grammar.key_seq = Ct(key_seq) / function(event)\n   event.modifiers = event.modifiers or 0\n   -- Convert CSI Z\n   if event.key == \"SHIFT_TAB\" then\n      event.modifiers = bor(event.modifiers, 1) -- code for shift\n      event.key = \"TAB\"\n   end\n   parse_modifiers(event)\n   return event\nend\n\n\n\n\n\n\n\n\n\n\nlocal byteR = assert(require \"lpeg\" . R)\nseq_grammar.x10_number = byteR\"\\x20\\xff\" / function(ch)\n   return ch:byte() - 32\nend\nseq_grammar.x10_mouse_seq = V\"CSI\" * P\"M\" *\n                  Cg(V\"x10_number\", \"kind\") *\n                  Cg(V\"x10_number\", \"col\") *\n                  Cg(V\"x10_number\", \"row\") *\n                  -- X10 mode can\'t distinguish pressed state properly, so we\n                  -- want it set unless the button is MBNONE, but in that case\n                  -- we already clear it below, so here we just always set it\n                  Cnc(\"pressed\", true)\n\nseq_grammar.sgr_mouse_seq = V\"CSI\" * P\"<\" *\n                  Cg(V\"Ps\", \"kind\") * P\";\" *\n                  Cg(V\"Ps\", \"col\") * P\";\" *\n                  Cg(V\"Ps\", \"row\") *\n                  Cg(M{ M = true, m = false }, \"pressed\")\n\nlocal buttons = { [0] = \"MB_LEFT\", \"MB_RIGHT\", \"MB_MIDDLE\", \"MB_NONE\",\n                  [64] = \"SCROLL_UP\", [65] = \"SCROLL_DOWN\",\n                  -- Scrolling \"buttons\" are AKA MB4 and MB5\n                  [66] = \"MB6\", [67] = \"MB7\" }\nlocal button_mask = 67 -- 0b01000011; 1, 2 and 64 bits set\n\nseq_grammar.mouse_seq = Ct((V\"sgr_mouse_seq\" + V\"x10_mouse_seq\") *\n                           Cnc(\"type\", \"mouse\")) / function(event)\n   event.key = buttons[band(event.kind, button_mask)]\n   if event.key == \"MB_NONE\" then\n      event.pressed = false\n   elseif event.key == \"SCROLL_UP\" or event.key == \"SCROLL_DOWN\" then\n      event.scrolling = true\n   end\n   event.modifiers = band(rshift(event.kind, 2), 7)\n   parse_modifiers(event)\n   event.moving = band(event.kind, 2 ^ 5) ~= 0\n   event.kind = nil\n   return event\nend\n\n\n\n\n\n\n\n\n\naddall(seq_grammar, {\n   paste_bracket_start = V\"CSI\" * P\"200~\",\n   paste_bracket_end   = V\"CSI\" * P\"201~\",\n   bracketed_paste     = V\"paste_bracket_start\" *\n      Cg((P(1) - V\"paste_bracket_end\") ^ 0, \"text\") *\n      V\"paste_bracket_end\" *\n      Cnc(\"type\", \"paste\") * Cnc(\"key\", \"PASTE\")\n})\n\nseq_grammar.special_seq = Ct(V\"bracketed_paste\")\n\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(require \"core:table\" . clone)\nseq_grammar[1] = Ct((V\"special_seq\" + V\"mouse_seq\" + V\"key_seq\") ^ 0) * Cp()\nlocal strict_seq_grammar = clone(seq_grammar)\nstrict_seq_grammar.ALT_seq = -V\"CSI\" * strict_seq_grammar.ALT_seq\nstrict_seq_grammar = P(strict_seq_grammar)\nlocal loose_seq_grammar = clone(seq_grammar)\nloose_seq_grammar.bare_char = V\"bare_ESC\" + loose_seq_grammar.bare_char\nloose_seq_grammar = P(loose_seq_grammar)\n\nreturn function(seq, parse_ambiguous_escapes)\n   if parse_ambiguous_escapes then\n      return loose_seq_grammar:match(seq)\n   else\n      return strict_seq_grammar:match(seq)\n   end\nend\n\n",
name = "anterm/input-parser",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "1f6ac9858228e47d1529019e403c4d3120249723ea9c3c4fef06c78d2fac99c2",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert (pairs)\nlocal tostring = assert (tostring)\nlocal setmeta = assert (setmetatable)\nlocal error = assert (error)\nlocal require = assert (require)\nlocal rawget = assert (rawget)\n\nlocal schar = assert(string.char)\nlocal sub   = assert(string.sub)\nlocal byte  = assert(string.byte)\nlocal bit   = assert(bit, \"anterm requires Luajit \'bit\' or compatible in _G\")\nlocal rshift = assert(bit.rshift)\nlocal core = require \"core:core\"\nbit = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anterm = {}\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\'\n\n\n\n\n\n\n\n\n\n\n\nlocal colormt = {}\ncolormt.__index = colormt\n\n\n\n\n\n\n\n\nfunction colormt.__eq(a,b)\n   return a.value == b.value and a.reset == b.reset\nend\n\n\n\n\n\n\n\n\n\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        bold = 1,\n        dim = 2,\n        italic = 3,\n        underscore = 4,\n        underline = 4,\n        reverse = 7,\n        hidden = 8,\n        strikeout = 9,\n        double_underscore = 21,\n        clear_bold = 22,\n        clear_dim  = 22,\n        clear_italic = 23,\n        clear_underline = 24,\n        clear_inverse = 27,\n        clear_hidden = 28,\n        clear_strikeout = 29 },\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = CSI .. value ..\"m\",\n        name = name,\n        kind = kind }\n    return setmeta(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        anterm[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt.__tostring(color)\n    return color.value\nend\n\nfunction colormt.__concat(color, other)\n    return tostring(color) .. tostring(other)\nend\n\nlocal clear_fg, clear_bg, clear = anterm.clear_fg.value,\n                                  anterm.clear_bg.value,\n                                  anterm.clear.value\n\nlocal clear_attribute = { bright = anterm.clear_bold,\n                          bold = anterm.clear_bold,\n                          dim = anterm.clear_dim,\n                          italic = anterm.clear_italic,\n                          underscore = anterm.clear_underline,\n                          underline = anterm.clear_underline,\n                          reverse = anterm.clear_reverse,\n                          hidden = anterm.clear_hidden,\n                          strikeout = anterm.clear_strikeout,\n                          double_underscore = anterm.clear_underline }\n\nsetmeta(clear_attribute, {__index = function() return clear end})\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    if color.kind == \"fg\" then\n        return clear_fg\n    elseif color.kind == \"bg\" then\n        return clear_bg\n    elseif color.kind == \"attribute\" then\n       return clear_attribute[color.name]\n    elseif color.kind == \"embedded\" then\n       return color.reset.value\n    end\nend\n\nlocal __ts = colormt.__tostring\n\nfunction colormt.__call(color, str)\n    if str then\n        return __ts(color) .. str .. reset(color)\n    else\n        return __ts(color)\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function byte_panic(byte_p)\n   if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n      error \"xterm value must be 8 bit unsigned\"\n   end\nend\n\nlocal _color_cache = setmeta({}, {__mode = \"v\"})\n\nlocal function _make_color(value, kind)\n   if _color_cache[value] then\n       return _color_cache[value]\n   end\n   local color = setmeta({value = value, kind = kind}, colormt)\n   _color_cache[value] = color\n   return color\nend\n\n\nlocal ansi_fg_pre = CSI .. \"38;5;\"\n\nlocal function ansi_fg(byte)\n   byte_panic(byte)\n   local value = ansi_fg_pre .. byte .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal ansi_bg_pre = CSI .. \"48;5;\"\n\nlocal function ansi_bg(byte)\n   byte_panic(byte)\n   local value = ansi_bg_pre .. byte .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fg24pre = CSI .. \"38;2;\"\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = fg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal bg24pre = CSI .. \"48;2;\"\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = bg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\nanterm[\"fg\"], anterm[\"bg\"] = ansi_fg, ansi_bg\n\nanterm[\"fg24\"], anterm[\"bg24\"] = fg24, bg24\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction anterm.embedded(outer, inner)\n   outer = cloneinstance(outer)\n   outer.kind = \"embedded\"\n   outer.reset = inner\n   return outer\nend\n\n\n\n\n\n\nlocal cursor = require \"anterm/cursor\"\nanterm.cursor = cursor\nanterm.jump = cursor.jump\nanterm.erase = cursor.erase\n\n\n\n\n\nlocal mouse = {}\nanterm.mouse = mouse\n\nlocal buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function decset(number, enable)\n   return CSI .. \"?\" .. tostring(number) .. (enable and \"h\" or \"l\")\nend\n\n\n\n\n\n\n\n\n\nfunction mouse.track(on)\n   return decset(1003, on)\nend\n\nfunction mouse.sgr_mode(on)\n   return decset(1006, on)\nend\n\n\n\n\n\nfunction anterm.alternate_screen(use_alt)\n  return decset(47, use_alt)\nend\n\n\n\n\n\nfunction anterm.paste_bracketing(bracket_enable)\n   return decset(2004, bracket_enable)\nend\n\n\n\n\n\n\n\n\nfunction anterm.application_keypad(keypad_enable)\n   return \"\\x1b\" .. (keypad_enable and \"=\" or \">\")\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal report = {}\n\nfunction report.area()\n   return \"\\x1b[18t\"\nend\nanterm.report = report\n\n\n\n\n\n\n\n\n\nlocal totty = {}\nlocal lines = assert(core.lines)\nlocal collect = assert(core.collect)\n\n\n\n\n\n\n\n\n\n\n\nfunction totty.nl_to_jumps(str)\n  local l = collect(lines, str)\n  local phrase = \"\"\n  local length = 0\n  for i,v in ipairs(l) do\n    phrase = phrase..v..a.jump.down()..a.jump.back(utf8.width(v))\n    if length < utf8.width(v) then\n      length = utf8.width(v)\n    end\n  end\n  return phrase, length, #l\nend\n\n--- takes a string and a width in columns.\n--  Returns the amount of string which fits the width.\nfunction totty.truncate(str, width)\n  local trunc = utf8.sub(str,1,width)\n  if utf8.len(trunc) == utf8.width(trunc) then\n    return trunc\n  else\n    local i = 1\n    while utf8.width(trunc) > width do\n      -- io.write(\"width is \", utf8.width(trunc), \"  target: \", width, \"\\n\")\n      trunc = utf8.sub(str,1,width-i)\n      i = i + 1\n    end\n    return trunc\n  end\nend\n\n-- takes a string, returning a string which, when printed, will:\n-- print the string as a column, return to the top, and move one beyond\n-- the column thereby printed.\nfunction totty.collimate(str)\n  local phrase, length, lines = totty.nl_to_jumps(str)\n  return phrase..a.jump.up(lines)..a.jump.forward(length)\nend\n\nanterm.totty = totty\n\n\n\n\n\n\n\n\n\n\n\nanterm.iTerm = {}\nlocal iTerm = anterm.iTerm\nlocal LEET = OSC .. \"1337;\"\n\n\n\n\n\n\n\n\nlocal function iTerm__call(_anterm)\n   local term_str = os.getenv \"TERM_PROGRAM\"\n   if term_str == \"iTerm.app\" then\n      return true\n   else\n      return false\n   end\nend\n\nsetmeta(iTerm, {__call = iTerm__call})\n\n\n\n\n\n\n\n\nfunction iTerm.notify(msg)\n   return OSC .. \"9;\" .. msg .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal _iTerm_cursors = { block = 0,\n                         vertical = 1,\n                         underline = 2,\n                         [0] = \'0\', \'1\', \'2\' }\n\nfunction iTerm.cursor_shape(shape)\n   if not _iTerm_cursors[shape] then\n      error(\"bad parameter passed to cursor_shape: \" .. tostring(shape))\n   end\n   return LEET .. \"CursorShape=\" .. _iTerm_cursors[shape] .. \"\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.yank(text)\n   return LEET .. \"CopyToClipboard=general\\a\" .. text\n       .. LEET .. \"EndCopy\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.link(url, slug)\n   return OSC .. \"8;;\" .. url .. \'\\a\' .. slug .. OSC .. \"8;;\\a\"\nend\n\n\n\n\n\n\n\n\n\nfunction iTerm.annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\nfunction iTerm.hidden_annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddHiddenAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.fireworks()\n   return LEET .. \"RequestAttention=fireworks\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.bounce_icon()\n   return LEET .. \"RequestAttention=yes\\a\"\nend\n\n\n\n\nreturn anterm\n\n",
name = "anterm",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "632b6fac2d5cee686b66a359b5825e513f62e11c00f46b4722983dcbbe91f0c0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal box_parts = { \"horiz\", \"vert\",\n                    \"tl_square\", \"tr_square\", \"bl_square\", \"br_square\",\n                    \"left_tee\", \"top_tee\", \"right_tee\", \"bottom_tee\", \"cross\" }\nlocal boxen = {}\n\n\n\n\n\n\n\n\nboxen.light = { \"─\", \"│\",\n                \"┌\", \"┐\", \"└\", \"┘\",\n                \"├\", \"┬\", \"┤\", \"┴\", \"┼\" }\n\n\n\n\n\n\n\n\nboxen.heavy = { \"━\", \"┃\",\n                \"┏\", \"┓\", \"┗\", \"┛\",\n                \"┣\", \"┳\", \"┫\", \"┻\", \"╋\" }\n\n\n\n\n\n\n\n\nboxen.double = { \"═\", \"║\",\n                 \"╔\", \"╗\", \"╚\", \"╝\",\n                 \"╠\", \"╦\", \"╣\", \"╩\", \"╬\" }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal Rectangle = require \"anterm:rectangle\"\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal jump = assert(require \"anterm:cursor\" . jump)\nlocal Box = meta {}\n\n\n\n\n\n\n\n\nlocal function _addLineUsing(phrase, left, middle, right, line, ...)\n   local column_widths = {...}\n   for i, cols in ipairs(column_widths) do\n      insert(phrase, i == 1 and left or middle)\n      insert(phrase, line:rep(cols))\n   end\n   insert(phrase, right)\nend\n\nlocal function _lineUsing(box, fn, ...)\n   local phrase = {}\n   box[fn](box, phrase, ...)\n   return concat(phrase)\nend\n\nfunction Box.addTopLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.tl_square, box.top_tee, box.tr_square, box.horiz, ...)\nend\nfunction Box.topLine(box, ...)\n   return _lineUsing(box, \"addTopLine\", ...)\nend\n\nfunction Box.addSpanningLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.left_tee, box.cross, box.right_tee, box.horiz, ...)\nend\nfunction Box.spanningLine(box, ...)\n   return _lineUsing(box, \"addSpanningLine\", ...)\nend\n\nfunction Box.addBottomLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.bl_square, box.bottom_tee, box.br_square, box.horiz, ...)\nend\nfunction Box.bottomLine(box, ...)\n   return _lineUsing(box, \"addBottomLine\", ...)\nend\n\n\n\n\n\n\n\n\n\n\n-- #todo consider extending to support multiple columns?\nfunction Box.addContentLine(box, phrase, ...)\n   local column_widths = {...}\n   local total_width = 0\n   for _, width in ipairs(column_widths) do\n      insert(phrase, box.vert)\n      insert(phrase, jump.forward(width))\n      total_width = total_width + width + 1\n   end\n   insert(phrase, box.vert)\n   -- Leave 1 column of left padding\n   insert(phrase, jump.back(total_width - 1))\nend\nfunction Box.contentLine(box, ...)\n   return _lineUsing(box, \"addContentLine\", ...)\nend\n\n\n\n\n\n\n\n\n\nfunction Box.__call(box, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectange(rect, ...)\n   end\n   local width = rect:width()\n   local phrase = {}\n   insert(phrase, jump(rect:origin()))\n   box:addTopLine(phrase, width - 2)\n   local backup  = jump.back(width) .. jump.down(1)\n   local forward = jump.forward(width - 2)\n   for j = 1, rect:height() - 2 do\n      -- jump back and forth\n      insert(phrase, backup)\n      insert(phrase, box.vert) -- │\n      insert(phrase, forward)\n      insert(phrase, box.vert)\n   end\n   insert(phrase,backup)\n   box:addBottomLine(phrase, width - 2)\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nlocal box = {}\nfor box_type, slug in pairs(boxen) do\n   local this_box = setmetatable({}, Box)\n   for i = 1, #box_parts do\n      this_box[box_parts[i]] = slug[i]\n   end\n   box[box_type] = this_box\nend\n\n\n\nreturn box\n\n",
name = "anterm/box",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "29d18fcbb67a273cca286fe3a923811584259a3646454b771cc65bb1bcb42f19",
binary = "\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal Point = require \"anterm/point\"\nlocal Rectangle = meta {}\nlocal new\n\n\n\n\n\n\n\nfunction Rectangle.width(rect)\n   return rect.right - rect.left + 1\nend\nfunction Rectangle.height(rect)\n   return rect.bottom - rect.top + 1\nend\nfunction Rectangle.extent(rect)\n   return Point(rect:height(), rect:width())\nend\n\n\n\n\n\nfunction Rectangle.origin(rect)\n   return Point(rect.top, rect.left)\nend\nfunction Rectangle.corner(rect)\n   return Point(rect.bottom, rect.right)\nend\n\n\n\n\n\nfunction Rectangle.intersects(rect, other)\n   return rect.left   <= other.right  and\n          rect.right  >= other.left   and\n          rect.top    <= other.bottom and\n          rect.bottom >= other.top\nend\n\n\n\n\n\n\n\n\n\nfunction Rectangle.contains(rect, point, col)\n   local row\n   if instanceof(point, Point) then\n      row, col = point:rowcol()\n   else\n      row = point\n   end\n   return row >= rect.top  and row <= rect.bottom\n      and col >= rect.left and col <= rect.right\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.insetBy(rect, offset)\n   if not instanceof(offset, Point) then\n      offset = Point(offset, offset)\n   end\n   return new(rect.top    + offset.row,\n              rect.left   + offset.col,\n              rect.bottom - offset.row,\n              rect.right  - offset.col)\nend\n\n\n\n\n\nfunction Rectangle.__eq(rect, other)\n   return rect.left   == other.left   and\n          rect.top    == other.top    and\n          rect.right  == other.right  and\n          rect.bottom == other.bottom\nend\n\n\n\n\n\nlocal assertfmt = assert(require \"core/fn\" . assertfmt)\nfunction Rectangle.assertNotEmpty(rect, msg)\n   msg = msg or \"Empty rectangle\"\n   assertfmt(rect:height() > 0, \"%s: top: %d bottom: %d\", msg, rect.top, rect.bottom)\n   assertfmt(rect:width() > 0, \"%s: left: %d right: %d\", msg, rect.left, rect.right)\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Rectangle.__repr(rect, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Rectangle\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      for i, k in ipairs{\"top\", \"left\", \"bottom\", \"right\"} do\n         if i ~= 1 then\n            yield(Token(\", \", { color = \"operator\" }))\n         end\n         yield(nameFor(rect[k]))\n      end\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\n\n\nnew = function(top, left, bottom, right)\n   local rect  = setmetatable({}, Rectangle)\n   rect.top    = assert(top)\n   rect.left   = assert(left)\n   rect.bottom = assert(bottom)\n   rect.right  = assert(right)\n   return rect\nend\n\n\n\nRectangle.idEst = new\nreturn new\n\n",
name = "anterm/rectangle",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
  { 
branch = "trunk",
hash = "9340552a46d1c173d323aa9532d1e4b5449bacc69eb30a9b5e3e393ca66eec8f",
binary = "\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal Point = meta {}\nlocal new\n\n\n\n\n\n\n\nfunction Point.rowcol(point)\n   return point.row, point.col\nend\nfunction Point.colrow(point)\n   return point.col, point.row\nend\n\n\n\n\n\nfunction Point.__eq(point, other)\n   return point.row == other.row and\n          point.col == other.col\nend\n\n\n\n\n\n\n\n\nlocal instanceof = assert(require \"core/meta\" . instanceof)\nfunction Point.__add(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row + other, point.col + other)\n   elseif instanceof(other, new) then\n      return new(point.row + other.row, point.col + other.col)\n   else\n      error(\"Cannot add \" .. type(other) .. \" to Point\")\n   end\nend\n\nfunction Point.__unm(point)\n   return new(-point.row, -point.col)\nend\n\nfunction Point.__sub(point, other)\n   return point + -other\nend\n\nfunction Point.__mul(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row * other, point.col * other)\n   elseif instanceof(other, new) then\n      return new(point.row * other.row, point.col * other.col)\n   else\n      error(\"Cannot multiply Point by \" .. type(other))\n   end\nend\n\nfunction Point.__div(point, other)\n   if not instanceof(point, new) then\n      if type(point) ~= \"number\" then\n         error(\"Cannot divide \" .. type(point) .. \" by Point\")\n      end\n      point = new(point, point)\n   elseif not instanceof(other, new) then\n      if type(other) ~= \"number\" then\n         error (\"Cannot divide Point by \" .. type(other))\n      end\n      other = new(other, other)\n   end\n   return new(point.row / other.row, point.col / other.col)\nend\n\n\n\n\n\n\n\nlocal floor, ceil = assert(math.floor), assert(math.ceil)\nfunction Point.floor(point)\n   return new(floor(point.row), floor(point.col))\nend\nfunction Point.ceil(point)\n   return new(ceil(point.row), ceil(point.col))\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Point.__repr(point, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Point\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      yield(nameFor(point.row))\n      yield(Token(\", \", { color = \"operator\" }))\n      yield(nameFor(point.col))\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\n\n\nnew = function(row, col)\n   local point = setmetatable({}, Point)\n   point.row = assert(row)\n   point.col = assert(col)\n   return point\nend\n\n\n\nPoint.idEst = new\nreturn new\n\n",
name = "anterm/point",
vc_hash = "02da7533462d5a0a532a9f999f9b42eec66a594e",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/SQLun.git\n",
    repo_type = "git",
    repo_alternates = "",
    name = "arcivist",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "3e99caa077c6d708a0f6aa55a4fb0f5ccf0332994a22c87d2041ec8b89062a41",
binary = "\n\n\nlocal Arcivist = require \"sqlun:arcivist\"\n\nlocal schema = Arcivist.new_schema() -- do schema-ish things incl migration\n\nlocal arc = Arcivist :home \"\" :open() :apply(schema)\n\nlocal proxy = arc:new_proxy(proxy_name)\n\n",
name = "notes/arcivist-api",
vc_hash = "76e3b3c1616f289a7eead4e79dae09934167f282\n",
},
  { 
branch = "trunk",
hash = "4fd3ce6521ee9a5fdea23ce64d5faeb3b5a31d53f2c63eb342bc86977c1f06f4",
binary = "\n\n\n\n\n\n\n\n\nlocal arcivist = require \"SQLun:arcivist\"\n\nlocal schema, migration = arcivist.schema, arcivist.migration\n\n\n\nlocal spec = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal widgets = {}\nspec.widgets = widgets\nwidgets.schema = schema()\n\n\n\n\n\n\nlocal create_widget_table = [[\nCREATE TABLE IF NOT EXISTS widget (\n   widget_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   widget TEXT NOT NULL,\n   inventory INTEGER,\n   FOREIGN KEY (inventory)\n      REFERENCES inventory (inventory_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\nlocal create_inventory_table = [[\nCREATE TABLE IF NOT EXISTS inventory (\n  inventory_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  SKU INTEGER UNIQUE NOT NULL,\n  stock INTEGER NOT NULL\n);\n]]\n\n\nwidgets.schema\n   :addMigration(migration(create_widget_table, create_inventory_table))\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert_widget = [[\nINSERT INTO widget (widget, inventory) VALUES (:widget, :inventory);\n]]\n\nlocal insert_inventory = [[\nINSERT INTO inventory (SKU, stock) VALUES (:SKU, :stock);\n]]\n\n\n\n\n\nlocal _widg_pop = {\n   dongle = {2, 15},\n   variolater = {3, 8},\n   rat_trap = {5, 255},\n   acme_transmogrifier = {7, 1022},\n}\n\n\n\n\n\nlocal lastRowId = assert(sql.lastRowId)\n\nlocal function _populate(conn, s)\n   local ins_widget = conn:prepare(insert_widget)\n   local ins_inventory = conn:prepare(insert_inventory)\n   for name, nums in pairs(_widg_pop) do\n      ins_inventory :bind(nums[1], nums[2]) :step()\n      local inv_id = lastRowId(conn)\n      ins_widget :bind(name, inv_id) :step()\n      ins_inventory :clearbind() :reset()\n      ins_widget :clearbind() :reset()\n   end\n\n   return true\nend\n\n\n\nlocal migration_2 = migration(_populate)\nwidgets.schema:addMigration(migration_2)\n\n\n\n\n\n\n\n\nlocal widg_search = {}\n\n\nwidg_search.find_stock_by_widget = [[\nSELECT CAST(inventory.stock AS REAL) AS stock FROM widget\nINNER JOIN inventory ON inventory.inventory_id == widget.inventory\nWHERE widget.widget = :widget\n;\n]]\n\n\n\nwidgets.schema.search  = widg_search\n\n\n\n\n\n\n\n\n\n\nwidgets.arc = arcivist(\"\", \"widgets\")\n\n\n\nreturn spec\n\n",
name = "spec/arcivist",
vc_hash = "76e3b3c1616f289a7eead4e79dae09934167f282\n",
},
  { 
branch = "trunk",
hash = "937c6d4d0d09fb1a234097a96b055261e0ed00d02ec512583bc7f3c1c7270eee",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\nlocal open = sql.open\nlocal bridge = assert(require \"bridge\", \"_Bridge is deprecated, update pylon\")\n\nlocal cluster  = require \"core:core/cluster\"\nlocal meta, constructor = assert(cluster.Meta), assert(cluster.constructor)\n\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal arc_lib = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Schema = meta {}\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Schema.addMigration(schema, migr)\n   assert(migr and migr.idEst == _migration, \"must pass a migration to schema\")\n   insert(schema[1], migr)\n   return schema\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Schema.addStatements(schema, name, stmts)\n   assert(type(name) == \'string\', \"#1 must be a string\")\n   assert(type(stmts) == \'table\', \"#2 must be a table\")\n   -- clone statements for uh. hygiene?\n   local _stmts = {}\n   schema[name] =  _stmts\n   for symbol, sql in pairs(stmts) do\n      _stmts[symbol] = sql\n   end\n\n   return schema\nend\n\n\n\n\n\n\n\n\nlocal function _migration_1()\n   return true\nend\n\nlocal function schema()\n   local _schema = setmetatable({{_migration_1}}, Schema)\n   _schema.stmts = {}\n   return _schema\nend\n\nSchema.idEst = schema\n\narc_lib.schema = schema\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Migration = meta {}\n\n\n\n\n\n\n\n\n\n\n\nfunction _migration(...)\n   local migr = setmetatable({}, Migration)\n   for i = 1, select(\'#\', ...) do\n      migr[i] = select(i, ...)\n   end\n\n   return migr\nend\n\nMigration.idEst = _migration\n\narc_lib.migration = _migration\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Proxy = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _prepareStatements(conn, stmts)\n   return function(_, key)\n      if stmts[key] then\n         return conn:prepare(stmts[key])\n      elseif Proxy[key] then\n         return Proxy[key]\n      else\n         error(\"Don\'t have a statement \" .. key .. \" to prepare.\")\n      end\n   end\nend\n\nlocal function _readOnly(_, key, value)\n   error (\"can\'t assign to prepared statements table, key: \" .. key\n          .. \" value: \" .. value)\nend\n\nlocal lastRowId = assert(sql.lastRowId)\n\nfunction _makeProxy(conn, stmts)\n   if not stmts then\n      error \"no statements\"\n   end\n   local _stmts = {}\n   for name, stmt in pairs(stmts) do\n         _stmts[name] = stmt\n   end\n   return setmetatable({ lastRowId = function() return lastRowId(conn) end },\n                       { __index = _prepareStatements(conn, _stmts),\n                         __newindex = _readOnly })\nend\n\n\n\n\n\n\n\n\nlocal Arcivist = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal _arcivists = setmetatable({}, { __mode = \'v\' })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(Arc, home, name, OS_ENV, schema)\n   assert(type(home) == \'string\', \"missing database home string\")\n\n   local arc = setmetatable({}, Arcivist)\n   arc.rel_path = home\n   -- optional parameters included if present\n   arc.name, arc.schema = name, schema\n\n   arc:home(home, OS_ENV)\n   -- check if we have one of these /resolved/ paths before opening the\n   -- database\n   if home ~= \"\" and _arcivists[arc.db_home] then\n      error(format(\"Arcivists must be unique, %s already exists\", arc.db_home))\n   else\n      arc:open()\n   end\n\n   if schema then\n      arc:apply(schema)\n   end\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\nlocal function proxy(arc, proxy_name)\n   local conn = arc and arc.conn or error \"No Arcivist or missing conn\"\n   assert(arc.schema, \"Arcivist must have a schema to derive proxies form\")\n   assert(type(proxy_name) == \'string\', \"Proxy name must be a string\")\n   if not arc.schema[proxy_name] then\n      error (\"No statements associated with \" .. proxy_name)\n   end\n\n   local stmts =  _makeProxy(conn, arc.schema[proxy_name])\n   rawset(stmts, \"beginTransaction\",\n          function()\n             return conn:exec \"BEGIN TRANSACTION;\"\n          end)\n   rawset(stmts, \"commit\",\n          function()\n             return conn:exec \"COMMIT;\"\n          end)\n   return stmts\nend\n\nArcivist.proxy = proxy\n\n\n\n\n\nProxy.idEst = proxy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _migrate(conn, migration, s)\n   if type(migration) == \'function\' then\n      migration(conn, s)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n  --          s:verb(step)\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, s)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nfunction _boot(arc, conn, migrations)\n   -- bail early with no migrations\n   if not migrations then return conn end\n   local version = #migrations\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      arc.new_database = true\n      user_version = 1\n   end\n   if user_version < version then\n      -- #Todo handle io redirect with status flags\n      --  chicken and egg thing...\n --     local s = require \"status:status\" (io.stdout, io.stderr)\n--      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         local s = true -- shim\n         --s:chat(\"Performing migration %d\", i)\n         _migrate(conn, migrations[i], s)\n      end\n      conn:exec \"COMMIT;\"\n      --s:chat \"Cleaning up...\"\n      conn:exec \"VACUUM;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n      --s:chat(\"Migrations completed, your version is %d\", version)\n   elseif user_version > version then\n      error(format(\"Error: database version is %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\nfunction Arcivist.apply(arc, schema)\n   if schema and arc.schema then\n      error (\"schema has already been applied to arcivist \"\n            .. (arc.name or \"\") .. \".\")\n   end\n   schema = schema or arc.schema or error \"no schema to apply\"\n   _boot(arc, arc.conn, schema[1])\n   arc.schema = schema\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal getenv = assert(os.getenv)\n\nfunction Arcivist.home(arc, rel_path, OS_ENV)\n   assert(type(rel_path) == \'string\', \"rel_path must be a string.\")\n   assert((not OS_ENV) or type(OS_ENV) == \'string\',\n          \"OS_ENV must be nil or string\")\n   if rel_path == \"\" then\n      arc.db_home = \"\"\n      return arc\n   end\n   local abs_path = (OS_ENV and getenv(OS_ENV)) or bridge.bridge_home\n   local path =  abs_path .. rel_path\n   arc.db_home = path\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fstat = assert(uv.fs_stat)\n\nlocal function _openConn(conn_handle)\n   assert(conn_handle, \"conn handle must be present\")\n   local ok, conn = pcall(open, conn_handle, \'rwc\')\n\n   if not ok then\n      --| we can try and fix this by making the directory, but we also don\'t\n      --| want to create random junk either.\n      --|\n      --| As a compromise, we will create the directory if, and only if, the\n      --| parent directory exists, otherwise we will complain.\n      --\n      local db_file, why = require \"fs:file\" (conn_handle)\n      if not db_file then\n         -- so, it once happened that a user created one of our databases\n         -- as a directory, rather than creating the directory and letting\n         -- bridge create the DB.  This can be challenging to diagnose, so\n         -- why not be helpful if we can?\n            error (\"can\'t create \" .. conn_handle .. \":\\n\"\n                   .. why .. \"\\n\" .. conn)\n      end\n\n      local db_dir  = db_file :directory()\n      if db_dir and (not db_dir:exists()) then\n         if db_dir:parentDir():exists() then\n            db_dir:create()\n            ok, conn = pcall(open, conn_handle, \'rwc\')\n         end\n         -- we catch two \"not ok\" conditions here:\n         if not ok then\n            if db_file.path:isDir() then\n               error(tostring(db_file.path) .. \" is a directory:\\n\" ..conn)\n            end\n         end\n      end\n   end\n\n   return conn\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\n\nfunction Arcivist.open(arc)\n   assert(arc.db_home, \"Arcivist must have a database home to open\")\n   arc.conn =  _openConn(arc.db_home)\n                 or error (\"can\'t open conn at: \" .. arc.db_home)\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Arcivist.close(arc, is_uv)\n   local conn = arc and arc.conn\n   if not arc.conn then return end\n\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   if not is_uv then\n      -- try once and leave\n      local ok = pcall(conn.close, conn)\n      if ok then\n         _arcivists[arc] = nil\n      end\n   else\n      -- otherwise set up an idler to close the conn, so that e.g. busy\n      -- exceptions don\'t blow up the hook\n      local close_idler = uv.new_idle()\n      close_idler:start(function()\n         local ok = pcall(conn.close, conn)\n         if not success then\n            return nil\n         else\n            close_idler:stop()\n            _arcivists[arc] = nil\n         end\n      end)\n   end\n   return arc\nend\n\n\n\n\nreturn constructor({}, new, arc_lib)\n\n",
name = "arcivist",
vc_hash = "76e3b3c1616f289a7eead4e79dae09934167f282\n",
},
  { 
branch = "trunk",
hash = "e41d8ae08a04436ee6dca5c7092d05f2badd15f5595fda3370beddf7fc620666",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\n\nlocal Dat_M = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(data)\n   local model = {}\n   model[model] = data\n   assert(not data.dataHasChanged, \'dataHasChanged field shadowed, illegal\')\n   assert(not data.commitIfChanged, \'commitIfChanged field shadowed, illegal\')\n\n   return setmetatable(model, Model)\nend\n\n\n\n\n\n\nfunction Model.__index(model, key)\n   if key == \'idEst\' then\n      return new\n   elseif key == \'dataHasChanged\' then\n      return dataHasChanged\n   elseif key == \'commitIfChanged\' then\n      return commitIfChanged\n   else\n      return model[model][key]\n   end\nend\n\n",
name = "datum",
vc_hash = "76e3b3c1616f289a7eead4e79dae09934167f282\n",
},
} },
{
  project = {
    home = "",
    repo = "https://gitlab.com/special-circumstance/bridge",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/atman/br.git",
    name = "br",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "master",
hash = "4103fe9aaa6844fd0f9451fe98f6c0b3614a1e75847a66cdc767d6dcc3de89c2",
binary = "\n\n\n\n\nlocal a = require \"kore/ansi\"\n\nlocal C = {}\nC.color = {}\nC.color.number = a.fg(42)\nC.color.string = a.fg(222)\nC.color.table  = a.fg(64)\nC.color.func   = a.fg24(210,12,120)\nC.color.truth  = a.fg(231)\nC.color.falsehood  = a.fg(94)\nC.color.nilness   = a.fg(93)\nC.color.field  = a.fg(111)\n\nC.color.alert = a.fg24(250, 0, 40)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hints = { field = C.color.field,\n                  fn  = C.color.func }\n\nlocal anti_G = {}\n\nfor k, v in pairs(_G) do\n   anti_G [v] = k\nend\n\nfunction C.ts(value, hint)\n   local c = C.color\n   local str = tostring(value)\n   if hint == \"\" then\n      return str -- or just use tostring()?\n   end\n   if hint then\n      return hints[hint](str)\n   end\n\n   local typica = type(value)\n   if typica == \'number\' then\n      str = c.number(str)\n   elseif typica == \'table\' then\n      str = c.table(str)\n   elseif typica == \'function\' then\n      if anti_G[value] then\n         -- we have a global name for this function\n         str = c.func(anti_G[value])\n      else\n         local func_handle = \"func:\" .. string.sub(str, -6)\n         str = c.func(func_handle)\n      end\n   elseif typica == \'boolean\' then\n      str = value and c.truth(str) or c.falsehood(str)\n   elseif typica == \'string\' then\n      str = c.string(str)\n   elseif typica == \'nil\' then\n      str = c.nilness(str)\n   end\n   return str\nend\n\n\n\nreturn C\n\n",
name = "s/kore/color",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "f9a3cff6a40f56ea70864a0170fa3cf3501fc1d0c9f07391b8e2b14ae7a1a869",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = pairs\nlocal tostring = tostring\nlocal setmetatable = setmetatable\nlocal error = error\nlocal require = require\nlocal rawget = rawget\nlocal io = io\nlocal schar = string.char\n\nlocal _M = {}\n\n\nlocal colormt = {}\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        dim = 2,\n        underscore = 4,\n        blink = 5,\n        reverse = 7,\n        hidden = 8},\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = schar(27)..\'[\'..tostring(value)..\'m\',\n        name = name,\n        kind = kind }\n    return setmetatable(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        _M[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt:__tostring()\n    return self.value\nend\n\nfunction colormt:__concat(other)\n    return tostring(self) .. tostring(other)\nend\n\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    -- complex but tractable for attributes\n    if color.kind == \"fg\" then\n        return _M.clear_fg\n    elseif color.kind == \"bg\" then\n        return _M.clear_bg\n    elseif color.kind == \"attribute\" then\n        --error \"attribute reset NYI\"\n        return _M.clear\n    end\nend\n\nfunction colormt:__call(s)\n    if s then\n        return tostring(self) .. s .. reset(self)\n    else\n        return tostring(self)\n    end\nend\n\ncolormt.__metatable = {}\n\nlocal function byte_panic(byte_p)\n       if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n        error \"xterm value must be 8 bit unsigned\"\n    end\nend\n\nlocal function ansi_fg(byte)\n    local store = {} -- repeated allocation is a sin.\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[38;5;\"..byte..\"m\",\n                        kind = \"fg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function ansi_bg(byte)\n    local store = {}\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[48;5;\"..byte..\"m\",\n                        kind = \"bg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[38;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"fg\" }\n   return setmetatable(color, colormt)\nend\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[48;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"bg\" }\n   return setmetatable(color, colormt)\nend\n\n_M[\"fg\"], _M[\"bg\"] = ansi_fg, ansi_bg\n\n_M[\"fg24\"], _M[\"bg24\"] = fg24, bg24\n\n--- Jumps\n\nlocal jump = {}\n\nlocal CSI = schar(27)..\'[\'\n\njump.up = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"A\"\nend\n\njump.down = function(num)\n    if not num then num = \"\" end\n        return CSI..num..\"B\"\nend\n\njump.forward = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"C\"\nend\n\njump.back = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"D\"\nend\n\nlocal function Jump(_,row,column)\n    return CSI..row..\";\"..column..\"H\"\nend\n\nlocal J = { __call = Jump}\nsetmetatable(jump,J)\n\n_M[\"jump\"] = jump\n\n\nreturn _M\n\n\n\n",
name = "s/kore/ansi",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "9b40f01d5c9c80ad53b1272377b901b4d2e6bffcea4a5be6d41c8f63dbfe0357",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- #todo this should just be anterm\nlocal a = pcall(require, \"anterm\") or require \"ansi\"\nlocal debug = require \"debug\"\n\nlocal status = {}\n\nstatus.DjikstraWasRight = true -- I swear I\'m going to use this for something. Watch.\n\nstatus.chatty = true\nstatus.verbose = false\nstatus.grumpy = true\nstatus.angry = true\n\nstatus.traceOnComplain = true\n\n-- ** Status:halt(message)\n--\n--   This dies in pipeline modes.\n--\n-- In the fleshed-out Lun/Clu environment, this will pause execution\n-- and present as much of a debugger as it can.\n\nfunction status.halt(statusQuo, message, exitCode)\n    local bye = exitCode or 1\n    io.write(message.. \"\\n\")\n    assert(false)\n    os.exit(bye)\nend\n\nfunction status.chat(statusQuo, message)\n    if statusQuo.chatty then\n        io.write(message .. \"\\n\")\n    end\nend\n\nfunction status.verb(statusQuo, message)\n    if statusQuo.verbose then\n        io.write(message .. \"\\n\")\n    end\nend\n\n\n-- Complaints are recoverable problems that still shouldn\'t happen.\n--\n--  Almost time to orbify the library collection...\n--  The value parameter is being passed in so improved Status can\n--  do things with it.\n--\nfunction status.complain(statusQuo, topic, message, value)\n    if not message then\n        message = topic\n    else\n        topic = a.red(topic)\n    end\n    if statusQuo.grumpy then\n        io.write(topic .. \": \" .. message .. \"\\n\")\n    end\n    if statusQuo.traceOnComplain then\n        io.write(debug.traceback())\n    end\n    if statusQuo.angry then\n        os.exit(1)\n    end\nend\n\nlocal function call(statusQuo)\n    return setmetatable({}, {__index = statusQuo, __call = call})\nend\n\n\nreturn setmetatable(status, {__call = call})\n\n",
name = "s/kore/status",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "e70d49711816ae27deb15bff7edbd49892fa2887f58e50dad537a0333b198cbf",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = require \"kore/color\"\nlocal ts = c.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ItIndex(Itself, verb)\n\tif verb == \"won\" or verb == \"did\" then\n\t\treturn nil\n\tend\n\tverb = verb and verb or \"\"\n\tlocal it = Itself.current\n\tlocal result = {success = false}\n\tresult.why = \"`check` does not understand the verb \" .. ts(verb)\n\t\t\t\t\t.. \" at least, not yet\"\n\tio.write(result.why .. \"\\n\")\n\tit.did.also(result)\n\treturn function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal call = function (it)\n\tif it.won == nil then\n\t\tit = it:collate()\n\tend\n\tif it.won then\n\t\treturn it.subject, it\n\telse\n\t\treturn nil, it\n\tend\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n\tif Object.isIt and Object.isIt == It then\n\t\treturn Object\n\tend\n\n\tlocal itself = setmetatable({}, {__index = It,\n\t\t                              __call = call})\n\tIt.current  = itself  -- THIS IS NOT RE_ENTRANT FIND A BETTER WAY\n\titself.isIt = It\n\titself.name = name and name or \"it\"\n\titself.subject = Object\n\titself = must(itself)\n\titself.did = {}\n\titself.did.also = function(result)\n\t\t\t\t\t\t result.modal = itself.modal\n\t\t                 itself.did[#itself.did + 1] = result\n\t\t                 return itself\n\t\t              end\n \titself.did.last = function() return itself.did[#itself.did] end\n\n\treturn itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\nlocal function verdict(it, subject, verb, object)\n\tlocal subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n\treturn it.name .. \": \" .. subj .. it.modal.inThatIt\n\t       .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal must = setmetatable({}, Modal)\n\tmust.beTrue = true\n\tmust.because = because\n\tmust.inThatIt = \"must\"\n\tit.modal = must\n\treturn it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal mustnt = setmetatable({}, Modal)\n\tmustnt.because = because or \"\"\n\tmustnt.beTrue = false\n\tmustnt.inThatIt = \"mustn\'t\"\n\tit.modal = mustnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n\tlocal should = setmetatable({}, Modal)\n\tshould.because = because or \"\"\n\tshould.beTrue = true\n\tshould.inThatIt = \"should\"\n\tit.modal = should\n\treturn it\nend\n\nfunction It.shouldnt(it, because)\n\tlocal shouldnt = setmetatable({}, Modal)\n\tshouldnt.because = because or \"\"\n\tshouldnt.beTrue = false\n\tshouldnt.inThatIt = \"shouldn\'t\"\n\tit.modal = shouldnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n\tlocal result = {}\n\tlocal success = it.subject == rValue and true or false\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tif success then\n\t\tresult.why =  verdict(it, it.subject, \"equal\", rValue)\n\telse\n\t\tresult.why = verdict(it, it.subject, \"not equal\", rValue)\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal having = it.subject[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having\n\n\tif having == nil then\n\t\t-- todo better message if \'has\' failed,\n\t\t-- the more common case.\n\t\tresult.why = \"equalTo must follow have/has\"\n\telse\n\t\tsuccess = having == rValue and true or false\n\t\tlocal subj, obj\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\t\tsubj, obj = having, rValue\n\t\telse\n\t\t\tsubj, obj = rValue, having\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because or verdict(it, subj, \"==\", obj)\n\t    else\n\t    \tresult.why = because or verdict(it, subj, \"~=\", obj)\n\t    end\n\t    result.having = having -- to chain field checks\n\tend\n\n\tresult.success = success\n\treturn it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did[#it.did]\n\tlocal having = last.having\n\tif type(len) ~= \"number\" then\n\t\tresult.why = \"ofLen param must be a number\"\n\telseif not having then\n\t\tresult.why = \"ofLen must have a value on it.did\"\n\telse\n\t\tsuccess = #having == len and true or false\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because\n\t\t\t             or verdict(it, \"#\" .. ts(having), \"==\", len)\n\t    else\n\t    \tresult.why = because\n\t    \t             or verdict(it, \"#\" .. ts(having), \"~=\", len)\n\t    end\n\tend\n\n\tresult.success = success\n\tresult.inThatIt = it.modal.inThatIt\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n\tlocal result = { success = false,\n                     why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n\treturn {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n\tlocal method = last.having\n\tif not method then\n\t\tresult.why = \"calling must be performed on a value\"\n\telseif not type(method) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name .. \" field must be function: \" .. last.field)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = method(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.field  = last.field\n\t\tlocal callee = ts(last.field, \"field\") .. \"(\"\n\t\tif result.arg and result.arg.n >= 1 then\n\t\t\tfor i = 1, result.arg.n do\n\t\t\t\tcallee = callee .. ts(result.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tcallee = string.sub(callee, 1, -3)\n\t\tend\n\t\tcallee = callee .. \")\"\n\t\tresult.why    = verdict(it, \"\", \"be callable with\", callee)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name\n\t\t\t          .. \" passedTo needs a function: \" .. fn)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = fn(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.fn     = fn\n\t\tresult.why    = verdict(it, \"\", \"be passed to\", fn)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did.last()\n\tlocal answer = last.answer\n\tif answer == nil then\n\t\tresult.why = \"prior clause must provide an answer\"\n\telse\n\t\t-- build strings for verdict\n\t\tlocal callee = \":anon:\"\n\t\tif last.field then\n\t\t\tcallee = it.name .. ts(\":\" ..last.field, \"field\")\n\t\telseif last.fn then\n\t\t\tcallee = ts(last.fn)\n\t\tend\n\t\tlocal param = \"(\"\n\t\tif last.fn then\n\t\t\tparam = param .. it.name\n\t\tend\n\t\tif last.arg and last.arg.n >= 1 then\n\t\t\tif last.fn then param = param .. \", \" end\n\t\t\tfor i = 1, last.arg.n do\n\t\t\t\tparam = param .. ts(last.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tparam = string.sub(param, 1, -3)\n\t\tend\n\t\tparam = param .. \")\"\n\n\t\tlocal isSame = answer == rValue and true or false\n\t\tif isSame then\n\t\t\tif not last.b then\n\t\t\t\tsuccess = true\n\t\t\t\tresult.why = verdict(it, callee .. param, \"give\", ts(answer))\n\t\t\telseif b then\n\t\t\t\tlocal gives = {ts(answer)}\n\t\t\t\tlocal is_b_same  = last.b == b and true or false\n\t\t\t\tgives[2] = ts(last.b)\n\t\t\t\tsuccess = true and is_b_same\n\t\t\t\tresult.why = vertict(it, callee .. param, \"give\", gives[1]\n\t\t\t\t\t          .. \" \" .. gives[2])\n\t\t\tend\n\t\telse\n\t\t\tresult.why = it.name .. \":\" .. callee .. param .. \" \" .. it.modal.inThatIt\n\t\t\t              .. \" give \" .. ts(rValue) .. \" not \" .. ts(answer)\n\t\tend\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\n\tresult.success = success\n\n\n\treturn it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n\treturn it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n\tphrase = \"\"\n\tlocal Yes, No\n\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\tYes, No = \"✅   \",  \"❌   \"\n\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\tYes, No = \"🌟   \",  \"😡   \"\n\telseif mood == \"can\" then\n\t\tYes, No = \"👍   \",  \"👎   \"\n\tend\n\tif did.success then\n\t\tphrase = phrase .. \"   \" .. Yes .. did.why\n\telse\n\t\tphrase = phrase .. \"   \" .. No .. did.why\n\tend\n\tphrase = phrase .. \"\\n\"\n\tdid.digest = phrase\n\treturn phrase\nend\n\n\n\n\nfunction It.collate(it)\n\tlocal winning = true\n\tlocal wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n\tlocal musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n\tlocal phrase = it.name .. \":\\n\"\n\tfor _, did in ipairs(it.did) do\n\t\twinning = winning and did.success\n\t\tlocal mood = did.modal.inThatIt\n\t\tlocal digest = digestLine(did, mood)\n\t\tphrase = phrase .. digest\n\n\t\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\t\tmusts = musts + 1\n\t\t\tif did.success then\n\t\t\t\twins.must = wins.must + 1\n\t\t\tend\n\t\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\t\tshoulds = shoulds + 1\n\t\t\tif did.success then\n\t\t\t\twins.should = wins.should + 1\n\t\t\tend\n\t\tend\n\t-- etc\n\tend\n\tif musts > 0 then\n\t\tphrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n\tend\n\tif shoulds > 0 then\n\t\tphrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n\tend\n\tit.won = winning\n\tif it.won then\n\t\tphrase = \"All clear!\\n\" .. phrase\n\telse\n\t\tphrase = \"Needs work:\\n\" .. phrase\n\tend\n\tphrase = phrase .. \"\\n\"\n\tit.digest = phrase\n\n\treturn it\nend\n\n\n\nfunction It.report(it)\n \tit = it:collate()\n\tio.write(it.digest)\n\treturn it\nend\n\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n\tIt[#It + 1] = it\n\treturn it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n\tlocal winning = true\n\tfor _, that in ipairs(It) do\n\t\tthat:report()\n\t\twinning = winning and that.won\n\tend\n\treturn it, winning\nend\n\nfunction It.allFailure(it)\n\tfor _, that in ipairs(It) do\n\t\tthat:check()\n\t\tfor _, did in ipairs(that.did) do\n\t\t\tif not did.success then\n\t\t\t\tio.write(did.digest)\n\t\t\tend\n\t\tend\n\tend\n\treturn it\nend\n\n\n\nreturn check\n\n",
name = "s/kore/check",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "2fb7ce2117fc679dec89e0d1f8a69cc5353e337835ad1f3d131a7af0911388f1",
binary = "\n\n\n\n\n\n\n\n\nNode = require \"espalier:espalier/node\"\n\nnode = Node(\"a new node\")\n\nif node.idEst == Node then\n   -- do class-specific stuff here\nend\n\n",
name = "cluster/idEst",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "ddb756597b1b1a21c36847fc1ad03cf4f94029b95e75b3822ed0b26853916b02",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _doSeveralThings(obj)\n   obj:doFirstThing()\n   yield(obj:secondMessage(_passed))\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n\n",
name = "letters/mikemike",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
  { 
branch = "master",
hash = "47adf325fa39924ba8afc3f798a33519e2e5cfb7752177bc0d6d0e85f9e00e0b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n\n",
name = "design/lun",
vc_hash = "988584d1f09dafed5daa33c49f3ff815d69c38d5",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:bridgetools/requests.git\n",
    repo_type = "git",
    repo_alternates = "https://github.com/mnemnion/br-requests\n\n",
    name = "br-requests",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "fetch",
hash = "6c36777e5e95d35d5d102c4345a004d47c0e884f9a57627ee4b10b0d46a51672",
binary = "\n\n\n\n\n\n\n\nuv = require \"luv\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction get (info, PORT) do\n\n\tlocal raw = {}\n\tassert (type(PORT) == \"number\")\n\n\n\t-- instantiate a new tcp/ip obj (uv_tcp_t) \n\t-- bind to an ephemeral ip and port\n\t\t--> resolves to IPADDR_ANY (todo: verify this is true)\n\tlocal IP, family = info.addr, info.family\n   print(\"IP and family\", IP, family)\n\tlocal tether = uv.new_tcp(family)\n\ttether:bind(\"0.0.0.0\", 0)\n\tprint \"bound tether\"\n\n\tlocal res = tether:connect(IP, PORT, function (err)\n\t\tassert (not err, err)\n\t\tprint \"sending GET\"\n\t\tuv.write(tether, \"GET / HTTP/1.0\\n\\n\")\n\t\ttether:read_start(function (err, chunk)\n\t\t\tif chunk then\n\t\t\t\t--print (chunk)\n\t\t\t\ttable.insert(raw, chunk)\n\t\t\telse \n\t\t\t\ttether:close()\n\t\t\tend\n\t\tend)\n\tend)\n\t-- return raw[1]\n\n\t-- we dont actually have to run this, \n\t\t --> the event is going to live on helms event loop \n\tend\nend\n\nlocal check_uv = uv.new_idle()\n\ncheck_uv:start(function()\n  print \"uv has run\"\n  check_uv:stop()\nend)\n\n\nlocal function resolve (domain) do\n\treturn uv.getaddrinfo(domain)[1]\nend\nend\n--print (resolve(\"www.yahoo.com\"))\nget(resolve(\"www.yahoo.com\"), 80)\n\n\n",
name = "requests",
vc_hash = "b9d957031f20d1861ed84e76a8eaa073391e6085\n",
},
  { 
branch = "fetch",
hash = "ebf170c2f84dff071803ba592956f93da583ab994f5bd787a5890491b64939fd",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"requests\"\nlocal response = get(uv.getaddrinfo(\'www.yahoo.com\')[1].addr, 80)\n\ndom = {}\nmt = {}\n\nprint (response)\nsetmetatable(dom, mt)\n\nlocal function __call () do \n\n\tlocal count = 0\n\tlocal meta = {headers = {}, body = {}}\n\n  local peek \n\tfor token in string.gmatch(response, \"[^%s]+\") do \n\t\t if token == \"<!DOCTYPE\" or token == \"<!doctype\" then \n\t\t\t return meta.headers\n\t\t end \n\n\t\t if count == 0 then \n\t\t\t meta.headers.protocol = token\n\t\t elseif count == 1 then \n\t\t\t meta.headers.code = token\n\t\t elseif count == 2 then \n\t\t\t meta.headers.status = token \n\t\t end\n\n\t\t if string.find(token, \':\') and peek ~= true then \n\t\t\t peek = token\n\t\t elseif peek then\n\t\t \t\tmeta.headers[peek] = token\n\t\t\t  print (peek, meta.headers[peek])\n\t\t\t\tpeek = nil\n\t\t end\n\t\t count = count + 1\n\tend\n\treturn meta.headers\nend\n\nend\n\nmt.__index = __call \n\n\n",
name = "dom",
vc_hash = "b9d957031f20d1861ed84e76a8eaa073391e6085\n",
},
  { 
branch = "fetch",
hash = "4a7bf25a3b4894c3f37ce963f1e79d521255954283eba197664fcbcae9c8e260",
binary = "\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster\"\nlocal Response = require \"cluster:response\"\nlocal luv = require \"luv\"\n\n\n\nlocal new, Fetch = cluster.order()\n\n\n\n\nlocal function build(_new, fetch, IP, port)\n   IP = IP or \"0.0.0.0\"\n   port = port or 0\n   fetch.IP = IP\n   fetch.port = port\n   return fetch\nend\n\ncluster.construct(new, build)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function goodAddress(addrs)\n   for _, addr in ipairs(addrs) do\n      if addr.socktype == \'stream\' then\n         return addr.addr, addr.family\n      end\n   end\n   error \"never saw a stream socket in the addresses?\"\nend\n\n\n\n\n\n\nlocal running, yield = assert(coroutine.running), assert(coroutine.yield)\n\nfunction Fetch.get(fetch, domain)\n   local addrs, err = uv.getaddrinfo(domain)\n   if not addrs then\n      error(err)\n   end\n\n   local IP, family = goodAddress(addrs)\n   -- cache handles between calls\n   local tcp = fetch[family] or uv.new_tcp(family)\n   fetch[family] = tcp\n   -- bind to our ip and port\n   tcp:bind(fetch.IP, fetch.port)\n   -- set up our async threader and an n-table for buffers\n   local response = Response(running())\n   local res = {n = 0}\n   -- favor named callbacks named on[occasion]\n   local function onread(err, buffer)\n      assert(not err, err)\n      if buffer then\n         res.n = res.n + 1\n         res[res.n] = buffer\n      else\n         tcp:read_stop()\n         return response:respond(unpack(res))\n      end\n   end\n   local function onconnect(err)\n      assert(not err, err)\n      uv.write(tcp, \"GET / HTTP/1.0\\n\\n\")\n      tcp:read_start(onread)\n   end\n   tcp:connect(IP, 80, onconnect)\n\n   return yield(response)\nend\n\n\n\nreturn new\n\n",
name = "fetch",
vc_hash = "b9d957031f20d1861ed84e76a8eaa073391e6085\n",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/bundle.git\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/bundle.git\n\n",
    name = "bundle",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "4cfa6316446fa9d335b682f99b262a0a3cba9123005009d1d05d427102f9b232",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal Phrase = require \"singletons/phrase\"\n\n\n\nlocal Export = {}\n\n\n\n\n\nlocal latest_ids = [[\nSELECT\n   bundle_id, version, project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal latest_versioned_ids = [[\nSELECT\n   bundle_id, bundle.version, bundle.project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nINNER JOIN\n   version\nON\n   version.version_id = bundle.version\nWHERE\n   project.name = :project\nAND\n   version.major = :major\nAND\n   version.minor = :minor\nAND\n   version.patch = :patch\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal get_modules = [[\nSELECT\n   module.name, module.vc_hash, module.branch,\n   code.hash, code.binary\nFROM\n   module\nINNER JOIN\n   code\nON\n   module.code = code.code_id\nWHERE\n   module.bundle = ?\n;\n]]\n\n\n\nlocal get_version = [[\nSELECT * FROM version WHERE version_id = ?;\n]]\n\n\n\nlocal get_project = [[\nSELECT * FROM project WHERE project_id = ?;\n]]\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function exportProject(project, version)\n   -- lame hack to get rid of this pset atrocity\n   -- #todo remove\n   if project == \'pset\' then return nil end\n   local conn = _Bridge.modules_conn\n   local bundle_result\n   if version then\n      version.project = project\n      bundle_result = conn:prepare(latest_versioned_ids)\n                                :bindkv(version):step()\n      if not bundle_result then\n         error(\"unable to find \" .. project .. \" in the specified version\")\n      end\n   else\n      bundle_result = conn:prepare(latest_ids):bind(project):step()\n      if not bundle_result then\n         error(\"no bundle found for project \" .. project)\n      end\n   end\n   local bundle_id = bundle_result[1]\n   local version_id = bundle_result[2]\n   local project_id = bundle_result[3]\n   local mods = toRow(conn:prepare(get_modules):bind(bundle_id):resultset(\"ihk\"))\n   local version = conn:prepare(get_version):bind(version_id):resultset(\"ihk\")\n   local project = conn:prepare(get_project):bind(project_id):resultset(\"ihk\")\n   version = toRow(version)\n   project = toRow(project)\n   return version, mods, project\nend\n\nExport.exportProject = exportProject\n\n\n\n\n\n\nlocal toLuaString = Codepoints.toLuaString\n\nlocal function bundle(version, modules, project)\n   -- A project can exist without modules, in which case, we skip it\n   if modules == nil then return nil end\n   local phrase = Phrase \"{\\n  project = {\\n\"\n   for key, val in pairs(project) do\n      if key ~= \"project_id\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n            error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  version = {\"\n   for key, val in pairs(version) do\n      if key ~= \"version_id\" and key ~= \"project\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n             error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  modules = { \"\n   for _, mod in ipairs(modules) do\n      phrase = phrase .. \"  { \\n\"\n      for key, val in pairs(mod) do\n         phrase = phrase .. key .. \" = \" .. toLuaString(val) .. \",\\n\"\n      end\n      phrase = phrase .. \"},\\n\"\n   end\n   phrase = phrase .. \"} }\"\n   return tostring(phrase)\nend\nExport.bundle = bundle\n\n\n\n\n\n\n\n\n\n\nfunction Export.export(projects, version)\n   if type(projects) == \"table\" then\n      local phrase = Phrase \"return { \"\n      for _, project in ipairs(projects) do\n         local bundle_str = bundle(exportProject(project, version))\n         if bundle_str then\n            phrase = phrase .. bundle_str .. \",\\n\"\n         end\n      end\n      phrase = phrase .. \"}\"\n      return tostring(phrase)\n   elseif type(projects) == \"string\" then\n      local phrase = Phrase \"return \"\n      phrase = phrase .. bundle(exportProject(projects, version))\n      return tostring(phrase)\n   else\n      error(\"bad argument to export of type \" .. type(projects))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Export.exportAll(version)\n   -- ignoring the version parameter for now.\n   if not version then\n      local conn = _Bridge.modules_conn\n      local projects = conn:exec \"SELECT name FROM project;\"\n      return Export.export(projects.name, version)\n   end\nend\n\n\n\nreturn Export\n\n",
name = "export",
vc_hash = "1ee101e257d2b49bf7e95038f2727a68f477ed09\n",
},
  { 
branch = "trunk",
hash = "4d9072cab079073b19963086deea2baadf6b38f0550288e3adf4154b6dc10174",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n\n\n\n\nreturn import\n\n",
name = "import",
vc_hash = "1ee101e257d2b49bf7e95038f2727a68f477ed09\n",
},
  { 
branch = "trunk",
hash = "0a19a606c30d2b4cc2d9056116d9a5784bbbc5aa562d79cac5933fe845fca238",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT\n   bundle_id, time\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project_id = project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time DESC\nLIMIT 1\n;\n]]\n\nlocal delete_from_bundle = [[\nDELETE FROM bundle WHERE bundle_id = ? ;\n]]\n\n\nlocal sub = assert(string.sub)\n\nlocal function splitpath(path)\n    local i = #path\n    local ch = sub(path, i, i)\n    while i > 0 and ch ~= \"/\" and ch ~= \":\" do\n        i = i - 1\n        ch = sub(path,i, i)\n    end\n    if i == 0 then\n        return \'\', path\n    else\n        return sub(path, 1, i-1), sub(path, i+1)\n    end\nend\n\nlocal function base(str)\n   local _, base = splitpath(str)\n   return base\nend\n\n\n\n\nlocal format = assert(string.format)\nlocal function pf(l, ...) print(format(l, ...)) end\n\nlocal function revert()\n   local pwd = uv.cwd()\n   local conn = _Bridge.modules_conn\n   conn.pragma.foreign_keys(true)\n   local project = base(pwd)\n   pf(\"reverting latest commit to project %s\", project)\n   local result = conn:prepare(get_latest_bundle):bind(project):stepkv()\n   if not result then\n      pf(\"no bundles found for project %s\", project)\n      return\n   end\n   pf(\"deleting bundle from %s\", result.time)\n   conn:prepare(delete_from_bundle):bind(result.bundle_id):step()\n   result = conn:prepare(get_latest_bundle):bind(project):stepkv()\n   if result then\n      pf(\"newest remaining bundle is from %s\", result.time)\n   else\n      pf(\"no bundles remain\")\n   end\nend\n\n\n\n\nreturn revert\n\n",
name = "revert",
vc_hash = "1ee101e257d2b49bf7e95038f2727a68f477ed09\n",
},
} },
{
  project = {
    home = "",
    repo_type = "git",
    repo_alternates = "",
    name = "byron",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "94a3705d09b939998e79f103e9bef3c820f0c8a0660abfb3414f8d6fba52a8ce",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal byron = [[\n    byron  ←  shebang* _ body _ Error*\n\n  shebang  ←  \"#\" (!\"\\n\" 1)* \"\\n\"\n    body  ←  block\n    Error  ←  1+\n\n  `block`  ←   _ (statement _ semi?)* (_ last-statement _ semi?)?\n  `semi`   ←   \";\" _\n\n`statement`  ←  do\n             /  while\n             /  repeat\n             /  if\n             /  let\n             /  for\n             /  defn\n             /  assign\n             /  accumulate\n             /  goto\n             /  comefrom\n             /  action\n\n        do  ←  \"do\" t chunk \"end\" t\n     while  ←  \"while\" t condition \"do\" t when-true \"end\" t\n    repeat  ←  \"repeat\" t chunk \"until\" t condition\n        if  ←  \"if\" t condition \"then\" t when-true elseif* else? \"end\" t\n       let  ←  \"let\" ; t let-expr \"do\" t chunk \"end\"\n       for  ←  \"for\" t _ counter _ \"=\" range _ \"do\" t chunk \"end\" t\n            /  \"for\" t _ lvalue _ \"in\" t iterator \"do\" t chunk \"end\" t\n      defn  ←  fn-head _ closure\n    assign  ←  my-assign / mutable-assign\naccumulate  ←  l-expr _ in-op _ r-expr\n      goto  ←  \"goto\" t _ label\n`comefrom`  ←  \"::\" label \"::\"\n  `action`  ←  (chain / call) _ !(index)\n\n`last-statement`  ←  return / break\n          return  ←  \"->\" _ (exp-list)?\n           break  ←  \"break\" t\n\n           chunk  ←  block\n       condition  ←  _ expr _\n\n       elseif  ←  \"elseif\" t condition \"then\" t when-true\n         else  ←  \"else\" t when-false\n    when-true  ←  block\n   when-false  ←  block\n      counter  ←  variable\n   for-locals  ←  variable-list\n\n        range  ←  expression \",\" expression (\",\" expression)?\n     iterator  ←  expression (\",\" expression)? (\",\" expression)?\n\n   expression  ←  _ expr _\n\n       `expr`  ←  unop / value _ (binop  _ expr)* / group\n\n      `group`  ←  \"(\" _ expression _ \")\"\n\n          `fn-head`  ←  \"fn\" t _ function-name\n                     /  my _ \"fn\" t _ my-function-name\n      function-name  ←  reference _ (\".\" _ field)+ _ message?\n                     /  reference _ message\n                     /  variable\n              my  ←  \"my\" t\n      l-expr <- var\n      r-expr <- expression\n      in-op <- ({+-/*%^} / \"..\") \"=\"\nmy-function-name  ←  variable\n            message  ←  (\":\" _ field)\n\n  `my-assign`  ←  my _ lvalue _ (\"=\" _ rvalue)?\n`mutable-assign`  ←  var-list _ \"=\" _ rvalue\n          lvalue  ←  variable-list\n          rvalue  ←  exp-list\n ;; synonym for lvalue\n var-list  ←  var (_ \",\" _ var)*\n\n    label  ←  symbol\n\n`unop`  ←  (unm / len / not) _ expr\n   unm  ←  (!\"->\" \"-\")\n   len  ←  \"#\"\n   not  ←  \"not\"\n\n\n`binop`  ←  and / or / add / sub / mul / div / mod / pow / concat / compare\n    and  ←  \"and\" t\n     or  ←  \"or\" t\n    add  ←  \"+\"\n    sub  ←  \"-\"\n    mul  ←  \"*\"\n    mod  ←  \"%\"\n    div  ←  \"/\"\n    pow  ←  \"^\"\n concat  ←  \"..\"\n\n`compare`  ←  lte / gte / neq / eq / lt / gt\n      lte  ←  \"<=\"\n      gte  ←  \">=\"\n      neq  ←  \"~=\"\n       eq  ←  \"==\"\n       lt  ←  \"<\"\n       gt  ←  \">\"\n\n`value`  ←  nil / boolean / vararg / number / string\n         /  table / function\n         /  action / var\n         /  group\n\n      nil  ←  \"nil\" t\n  boolean  ←  \"true\" t / \"false\" t\n   vararg  ←  \"...\"\n\n       chain  ←  fn-lead (_ fn-segment)+\n   `fn-lead`  ←  call / reference\n`fn-segment`  ←  field-call\n              /  index  &(_ seg-next)\n              /  method-call\n\n       call  ←  caller (_ arguments)+ /  expr-method\n\n     caller  ←  group / reference\n    `index`  ←  \"[\" expression \"]\" / \".\" _ field\n      field  ←  symbol\n field-call  ←  index (_ arguments)+\nmethod-call  ←  \":\" _ message (_ arguments)+\nexpr-method  ←  group _ method-call\n `seg-next`  ←  _ {:.\\\"\'{[(}\n    message  ←  symbol\n\n      `var`  ←  var-chain / reference / index-expr\n\n    var-chain  ←  var-lead _ (var-segment _)+\n   `var-lead`  ←  call / reference / index-expr\n`var-segment`  ←  ( call / method-call ) _ &seg-next\n               /  index / index-expr\n   reference  ←  symbol\n\n`index-expr`  ←  group _ &index\n\n     table  ←  \"{\" _ form-list* _ \"}\"\n\n  function  ←  \"function\" t _ closure\n\n`form-list`  ←  form (_ (\",\" / \";\") _ form)* (\",\" / \";\")?\n     `form`  ←  pair\n             /  expression\n       pair  ←   key _ \"=\" _ val\n      `key`  ←  \"[\" expression \"]\" / field\n      `val`  ←  expression\n\n arguments  ←  \"(\" _ (exp-list _)? \")\"\n            /  string\n            /  table\n`exp-list`  ←  expression (\",\" expression)*\n\n        closure  ←  parameters _ body _ \"end\" t\n     parameters  ←  \"(\" _ (variable-list (_ \",\" _ vararg)*)* _ \")\"\n                 /  \"(\" _ vararg _ \")\"\n`variable-list`  ←  (variable _ (\",\" _ variable _)*)\n       variable  ←  symbol\n\n         ; #todo this doesn\'t support raw-escaping newlines\n         ; and is overly permissive in escapes syntax,\n         ; both of which need to be corrected\n         string  ←  single-string / double-string / long-string\n`single-string`  ←  \"\'\" (\"\\\\\" \"\'\" / \"\\\\\" 1 / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`double-string`  ←  \'\"\' (\'\\\\\' \'\"\' / \"\\\\\" 1 / (!\'\"\' !\"\\n\" 1))* \'\"\'\n  `long-string`  ←  ls_open (!ls_close 1)* ls_close\n\n `ls_open`  ←  \"[\" \"=\"*@eq \"[\"\n`ls_close`  ←  \"]\" \"=\"*@(eq) \"]\"\n\n`glyph` ← {!@#$%^&*()-+={[]\\\\|:;\\\"\'<,>.?/~`} / \"}\"\n\n`utf8`  ←  [\\x00-\\x7f]\n        /  [\\xc2-\\xdf] [\\x80-\\xbf]\n        /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n        /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n\n    `symbol`  ←   !keyword any-sym\n`any-sym`  ←   ;; first character not this:\n               (!(glyph / { \\t\\n\\r} / [0-9])\n               ;; but anything(?) else is ok:\n               utf8\n               ;; after which digits are also legal\n               (!(glyph / { \\t\\n\\r}) utf8)*)\n\n     number  ←  imaginary / real / long / hex / integer\n`imaginary`  ←  (real / integer) {Ii}\n     `real`  ←  integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n     `long`  ←  (integer / hex) {Uu}? {Ll}%2\n  `integer`  ←  [0-9]+\n      `hex`  ←  \"0\" {Xx} higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n    `higit`  ←  [0-9] / [a-f] / [A-F]\n\n           `_`  ←  comment+ / whitespace\n     `comment`  ←  whitespace long-comment whitespace\n                /  whitespace \"--\" (!\"\\n\" 1)* whitespace\n`long-comment`  ←  \"--\" long-string\n  `whitespace`  ←  { \\t\\n\\r}*\n\nkeyword  ←  ( \"and\" / \"break\" / \"do\" / \"elseif\" / \"else\"\n            / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n            / \"in\" / \"my\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n            / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n            t ; t is the most PEG thing about PEGs\n    `t`  ←  &(glyph / { \\t\\n\\r} / -1)\n]]\n\n\nreturn byron\n\n",
name = "read/peg",
vc_hash = "95ebb5c73313603d565c42de221c8eea1e5b9def\n",
},
  { 
branch = "trunk",
hash = "47920af74c4b5d47b733f635ce741ca6746793d51ca4893bdf4b24a8eb496d99",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:peg\" -- dji coming up...\n\nlocal ByronPegStr = require \"byron:read/peg\"\n\n\n\nreturn assert(Peg(ByronPegStr))\n\n",
name = "read/read",
vc_hash = "95ebb5c73313603d565c42de221c8eea1e5b9def\n",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/clu.git\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.com/atman/clu.git\n\nhttps://gitlab.com/special-circumstance/clu.git\n\n",
    name = "clu",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "evaluation-primitives",
hash = "ceaccb131cc22b389bf98e5d69403768153efa6bea72e9f918fa2a763cded1ad",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--require \"pl.strict\"\nlocal Bridge = {} -- This should inherit from a Cluster base type\n\n\n\n\n\n\n\n\n\n\nBridge.CODEX_PATH =  \"./?.lua;./?/?.lua;./lib/?.lua;./src/?.lua;./src/?/?.lua;\"\n                  .. \"./lib/?/?.lua;./lib/?/src/?.lua;./lib/?/src/?/?.lua;\"\n\nfunction Bridge.init(bridge)\n   io.write \"Welcome to bridge\\n\"\n   bridge.cache_PATH = \"\"\n   if package.path then\n      bridge.cache_PATH = package.path\n      return Bridge.CODEX_PATH .. package.path\n   end\n   return bridge.cache_PATH\nend\n\n\n\nfunction Bridge.exit(bridge)\n   package.path = bridge.cache_PATH or \"\"\nend\n\n\n\n\nreturn Bridge\n\n",
name = "br/br",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "16aeeca3e41561260c3859899efd308ce4f3a7d47cbb1507f075f3741520ad10",
binary = "\n\n\n\n\n\n\n\nlocal clu_peg = [=[\n         clu  ←  _ form* / EOF\n||||||| ca6438a\n#!lua\nlocal clu_peg = [[\n         clu :  _ form* / EOF\n=======\n#!peg @clu_peg #asLua\n         clu :  _ form* / EOF\n>>>>>>> 8a6a2f140222369726b65aa5668b95115cdaae73\n\n        form : _  unarymark* (atom / compound ) _\n\n `unarymark`  ←  ( quote\n             /    splice\n             /    unquote\n             /    quasiquote\n             /    readermacro ) _\n\n       quote : \"\'\"\n      splice : \"~@\"\n     unquote : \"~\"\n  quasiquote : \"`\"\n readermacro : \"#\" ; this rule bears some expansion...\n\n    `atom`  ←  null\n           /  boolean\n           /  ssyntax\n           /  keyword\n           /  symbol\n           /  number\n           /  vararg\n\n`compound`  ←  expr\n           /  map\n           /  vector\n           /  multiple\n\n   symbol   ←  latin !(forbidden) ANYTHING\n   keyword  ←  \":\" symbol\n\n    expr    ←  \"(\" form* \")\"\n    hash    ←  \"{\" (form form)* \"}\"\n    vector  ←  \"[\" form* \"]\"\n  multiple  ←  \"\\\\\" form \"\\\\\"\n forbidden  ←  {\\t\\r\\n\\\"\\\'[]()~@#`:.,} / \"{\" / \"}\"\n\n     latin  ←  ([A-Z] / [a-z])\n\n   comment  ←  \";\" (!\"\\n\" 1)* \"\\n\"\n\n<<<<<<< HEAD\n         _  ←  comment / { \\t\\r\\n}*\n]]\n]=]\n\n\n\n\n\n\n\n\n\n\nreturn Peg(clu_peg) -- add Reader metatables from separate module\n\n",
name = "clu/clupeg",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "d02a17a004cafc8be4e664001ba69e2649e58b3778b818790b244319929b80a0",
binary = "\n\n\n\n\n\nlocal Phrase = require \"singletons/phrase\"\n\n\n\n\n\nlocal lua_thor = assert(require \"helm:helm/lex\" . lua_thor)\nlocal concat = assert(table.concat)\nlocal lines = assert(require \"core:string\" . lines)\n\n\nlocal function lex(repr, window, c)\n   local toks = lua_thor(tostring(repr))\n   for i, tok in ipairs(toks) do\n     toks[i] = tok:toString(c)\n   end\n\n   return lines(concat(toks))\nend\n\n\n\nlocal CluPhrase = Phrase : inherit ({__repr = lex})\n\n\n\nreturn CluPhrase\n\n",
name = "clu/clumeta/cluphrase",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c190faa18df15dfc250dc7d64898af8eaf05200d78b6bc10e01c96dc920146ba",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _VERSION =  \'Lun 5.1  |  Clu 0.9.18 α\'\nlocal core     =  require \"qor:core\" -- #Todo remove all qor after refactor\n-- local fenv     =  assert(core.fenv)\n\n\n\nlocal clu_core =  { _VERSION =  _VERSION,\n                    assert   =  assert(core.string.assertfmt),\n                    core     =  assert(core),\n                    coro     =  assert(coroutine.create),\n                    eq       =  assert(rawequal),\n                    error    =  assert(error),\n                    getfenv  =  assert(getfenv),\n                    getmeta  =  assert(getmetatable),\n                    ipairs   =  assert(ipairs),\n                    meta     =  assert(assert(core.cluster.Meta)),\n                    next     =  assert(next),\n                    pack     =  assert(pack),\n                    pairs    =  assert(pairs),\n                    pcall    =  assert(pcall),\n                    print    =  assert(print),\n                    rawget   =  assert(rawget),\n                    rawlen   =  assert(rawlen),\n                    rawset   =  assert(rawset),\n                    read     =  assert(require \"clu/reader\" . parse),\n                    repr     =  assert(tostring),\n                    require  =  assert(require),\n                    resume   =  assert(coroutine.resume),\n                    running  =  assert(coroutine.running),\n                    select   =  assert(select),\n                    setfenv  =  assert(setfenv),\n                    setmeta  =  assert(setmetatable),\n                    status   =  assert(coroutine.status),\n                    tonum    =  assert(tonumber),\n                    type     =  assert(type),\n                    unpack   =  assert(unpack),\n                    unpack   =  assert(unpack),\n                    wrap     =  assert(coroutine.wrap),\n                    xpcall   =  assert(xpcall),\n                    yield    =  assert(coroutine.yield), }\n\n\n\n\n\n\n\n\n\n\n\nassert(true)\n\nlocal _Macroexclude =\n   {  read     =  true,\n      getmeta  =  true,\n      getfenv  =  true,\n      next     =  true,\n      rawget   =  true,\n      rawset   =  true,\n      rawlen   =  true,\n      eq       =  true,\n      xpcall   =  true,\n      running  =  true,\n      require  =  true,\n      yield    =  true,  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _Now = clu_core\n\nfor exclude in pairs(_Macroexclude) do\n   _Now[exclude] = nil\nend\n\n\n\n\n\n\n\n\nlocal libs  =  { core     =  core,\n                 string   =  core.string,\n                 debug    =  core.debug,\n                 io       =  io,\n                 math     =  math,\n                 os       =  os,\n                 package  =  package,\n                 table    =  core.table,\n                 L        =  require \"espalier:espalier/elpatt\",\n                 uv       =  require \"luv\",\n                 bit      =  require \"bit\",\n                 bridge   =  require \"bridge\" }\n\n\n\nlocal _C = {}\n\nfor k, v in pairs(clu_core) do\n   _C[k] = v\nend\n\nfor k, v in pairs(libs) do\n   -- iterating a table to own the libs\n   _C[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal read_env = {}\n\n\n\n\nreturn pack(_C, _Now, libs, read_env)\n\n",
name = "clu/C",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "1a36662e31b086ae24ffba40414acefdf8e9e7f136504567191ae13bd915815a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   unary = V\"quote\"\n         + V\"unquote\"\n         + V\"quasiquote\"\n         + V\"reader_macro\"\n   \n      quote = P\"\'\"\n   \n      unquote = P\"~\"\n   \n      quasiquote = P\"`\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Macros = {}\n\n",
name = "clu/macro",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "805585e97b684d5c7fe3af8292545377610fb4abdd600f0f64ae5272393a877c",
binary = "\n\n\n\n\n\n\n\nlocal Clu_metas = { require \"clu:meta/twig\",\n                    clu          =  require \"clu:meta/cluprime\",\n                    indent       =  require \"clu:meta/indent\",\n                    expr         =  require \"clu:meta/expr\",\n                    final        =  require \"clu:meta/final\",\n                    fn_t         =  require \"clu:meta/fn-t\",\n                    my_t         =  require \"clu:meta/my-t\",\n                    peek_t       =  require \"clu:meta/peek-t\",\n                    mut_t        =  require \"clu:meta/mut-t\",\n                    do_t         =  require \"clu:meta/do-t\",\n                    if_t         =  require \"clu:meta/if-t\",\n                    for_iter     =  require \"clu:meta/for-iter\",\n                    for_num      =  require \"clu:meta/for-num\",\n                    while_t      =  require \"clu:meta/while-t\",\n                    until_t      =  require \"clu:meta/until-t\",\n                    goto_t       =  require \"clu:meta/goto-label\"[1],\n                    label_t      =  require \"clu:meta/goto-label\"[2],\n                    now_t        =  require \"clu:meta/now\",\n                    vector       =  require \"clu:meta/vector\",\n                    for_range    =  require \"clu:meta/vector\",\n                    symbol       =  require \"clu:meta/symbol\",\n                    ssyntax      =  require \"clu:meta/ssyntax\",\n                    table        =  require \"clu:meta/table\",\n                    map          =  require \"clu:meta/map\",\n                    key          =  require \"clu:meta/key\",\n                    slot         =  require \"clu:meta/slot\",\n                    table        =  require \"clu:meta/table\",\n                    multiple     =  require \"clu:meta/multiple\",\n                    null         =  require \"clu:meta/nil\",\n                    boolean      =  require \"clu:meta/boolean\",\n                    vararg       =  require \"clu:meta/vararg\",\n                    number       =  require \"clu:meta/number\",\n                    operator     =  require \"clu:meta/operator\",\n                    unary_state  =  require \"clu:meta/unary\",\n                    methodcall   =  require \"clu:meta/methodcall\",\n                    field        =  require \"clu:meta/field\",\n                    lfield       =  require \"clu:meta/field\",\n                    comment      =  require \"clu:meta/comment\",\n                    string       =  require \"clu:meta/string\",\n                    unary        =  require \"clu:meta/unary\"  }\n\n\n\nlocal L = require \"espalier/elpatt\"\n\nlocal V, P, R, S, E, EOF = L.V, L.P, L.R, L.S, L.E, L.EOF -- #todo fix elpatt.S\n\nlocal Peg = require \"espalier:espalier/peg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clu_str = [[\n         clu  ←  (WS* chunk WS*)+\n\n         `WS` ←   comment / indent / { ,}+ ; \\t \\v and \\r will break Clu. shun.\n      indent  ←   \"\\n\" \" \"*\n     comment  ←   \";\" (!\"\\n\" 1)* (\"\\n\" / -1)\n\n     `chunk`  ←   WS* (statement &(statement / final))* final\n\n `statement`  ←  WS* (unary-statement / sexpr) WS*\n       final  ←  form / return\n\n\n unary-statement  ←  unary-mark WS* sexpr\n         `sexpr`  ←  template / expr\n          `form`  ←  unary-form\n                  /  bare-form\n      return  ←  WS* \"->\" t rval? ; this has to \'returnable\'\n\n `unary-form`  ←  unary\n        unary  ←  WS* unary-mark bare-form\n  `bare-form`  ←  WS* (atom / compound) WS*\n `unary-mark`  ←  quote\n               /  unquote-splice\n               /  unquote\n               /  quasi-quote\n               /  reader-macro\nquote          ←  \"\'\"       ; return form as AST (increments abstraction level)\nunquote-splice ←  \"~@\"      ; unquote after iterating compound (if compound)\nunquote        ←  \"~\"       ; return result of AST read\nquasi-quote    ←  \"`\"       ; decrement abstraction level, writing at zero.\nreader-macro   ←  \"#\"       ; extended forms e.g. dates.  See readermacro.orb\n\n\n`atom`  ←  ssyntax\n        /  number\n        /  boolean\n        /  null\n        /  Break\n        /  vararg\n        /  symbol\n        /  string\n\n`compound`  ←  sexpr\n            /  table\n            /  map\n            /  vector\n;           /  type-rule            ; save this for another day\n            /  multiple\n            /  syntax\n            /  grammar\n\n;; atom rules\n\n   ssyntax  ←  methodcall / field\nmethodcall  ←  symbol \":\" symbol\n     field  ←  symbol \".\" (ssyntax / symbol / number)\n\n   symbol   ←  !keyword (latin / glyph-symbol)  (symchar / \"_\")*\n\n     `latin`  ←  [A-Z] / [a-z]\n     `digit`  ←  [0-9]\nglyph-symbol  ←  \"!\" / \"$\" / \"%\" / \"^\" / \"*\" / \"+\"\n                 / \"=\" / \"<\" / \">\" / \"&\" / \"?\" / \"-\" / \"/\"\n  `symchar`  ←  latin / digit / glyph-symbol\n\n  `keyword`  ←  ( \"->\"\n                / unary-mark\n                / root\n                / op-symbol\n                / boolean\n                / null\n                / Break\n                 ) t\n\n   op-symbol  ←  \"..\" / \"==\" / \"<=\" / \">=\" / \"~=\"\n              /  \"and\" / \"or\" / \"not\"\n              /  {+-*/^><}\n\n      root  ←  ( \"λ\"\n               / \"fn\"\n               / \"my\"\n               / \"::\"     ; \'peek\'\n               / \"=:\"     ; \'mut\'\n               / \"do\"\n               / \"if\"\n               / \"elif\"   ; only valid within if templates\n               / \"for\"\n               / \"while\"\n               / \"until\"\n               / \"goto\"\n               / \"label\"\n               / \"now\"\n               / \"fexpr\"  ; only valid within now templates\n               )\n\n number  ←  real / hex / integer\ninteger  ←  [0-9]+\n   real  ←  integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n    hex  ←  \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit`  ←  [0-9] / [a-f] / [A-F]\n\nboolean  ←  \"true\" / \"false\"\n\n   null  ←  \"nil\"\n\n  Break  ←  \"break\"\n\n vararg  ←  \"...\"\n\n      string  ← \'\"\' (\'\\\\\' \'\"\' / \"\\\\\" 1 / (!\'\"\' !\"\\n\" 1))* \'\"\'\n\n;; compound rules\n\n\n\n      `template`  ←  \"(\" WS* template-forms \")\"\n`template-forms`  ←  operator / special\n\n        operator  ←  op-symbol t form form+ / unary-not\n       `special`  ←  fn_t\n                  /  my_t\n                  /  peek_t\n                  /  mut_t\n                  /  do_t\n                  /  if_t\n                  /  for_t\n                  /  while_t\n                  /  until_t\n                  /  goto_t\n                  /  label_t\n                  /  now_t\n\n         unary-not  ←  (&\"not\" op-symbol) t form\n\n         fn_t  ←  (\"fn\" / \"λ\") t WS* (param fn-body?)?\n         my_t  ←  \"my\" t lval rval?\n       peek_t  ←  \"::\" t form form+\n        mut_t  ←  \"=:\" t lval rval\n         do_t  ←  \"do\" t chunk*\n         if_t  ←  \"if\" t pred if-true-or-elif? if-false?\n      `for_t`  ←  for-num / for-iter\n      while_t  ←  \"while\" t pred chunk*\n      until_t  ←  \"until\" t pred chunk *\n       goto_t  ←  \"goto\"  t WS+ symbol\n      label_t  ←  \"label\" t WS+ symbol\n        now_t  ←  \"now\" t WS* now-chunk\n\n          param  ←  symbol / vector / vararg\n        fn-body  ←  chunk\n\n\n\n      `lval`  ←  WS* (multiple / lfield / symbol /  \"(\" WS* peek_t \")\") WS*\n      `rval`  ←  form ; not all forms are valid. but. later.\n\n      pred  ←  form\n      `if-true-or-elif`  ←  if-true? elif-if*\n      if-true  ←  final\n      if-false  ←  final\n      elif-if  ←  WS* \"(\" WS* \"elif\" t pred final? \")\" WS*\n      for-num  ←  \"for\" t WS* for-range WS* chunk*\n      for-iter  ←  \"for\" t lval rval chunk*\n\n      for-range  ←   \"[\"  WS* symbol form form form? \"]\"\n      `atom-rval`  ←  rval ; also not true...\n\n      lfield  ←   symbol \".\" (lfield / symbol / number)\n\n      `now-chunk`  ←   WS* (now-statement &(now-statement / now-final))* now-final\n\n      `now-statement`  ←   fexpr-state / statement\n\n      `fexpr-state`  ←   \"(\" WS* fexpr \")\" WS*\n\n      fexpr  ←   \"fexpr\" WS* now-chunk\n\n      `now-final`  ←  fexpr-state / form / now-return\n\n      `now-return`  ←  WS* \"->\" t (fexpr-state / rval)?\n\n\n       `t`  ←  !symchar\n\n      table  ←  \"{\" WS* multiple WS* (key slot)* \"}\"\n             /  \"{\" (key slot)* multiple WS* \"}\"\n        map  ←  \"{\" (key slot)* \"}\"\n     vector  ←  \"[\" form* \"]\"\n; type-rule  ←  \"⟨\" form* \"⟩\"\n;            /  \":[\" form* \"]:\"\n   multiple  ← \"\\\\\" form+ \"\\\\\"\n     syntax  ← \"|\" dispatch* \"|\"\n\n       expr  ←   \"(\" head? tail* \")\"\n       head  ←   form\n       tail  ←   form\n\n        key  ←  !(WS* multiple) form\n       slot  ←  !(WS* multiple) form\n\n  dispatch  ←  \"#\" symbol\n            /  grammar\n            /  \"--!\" dispatch-string\n            /  lun\n\ndispatch-string  ←  \"e.g.\"\n\n       lun  ←  \"etoin shrdlu\" ;  !\"|\" has lun in it\n\n   grammar  ←  \"<<\" (!\">>\" 1) \">>\" ; <<peg or <<ggg or other but why\n]]\n\n\n\nreturn Peg(clu_str, Clu_metas)\n\n",
name = "clu/reader",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "e170f4b402a00ae41e426f387c227b3887cf93266c695c1e71592ce658e50c72",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Metatable Protocols\n\nrequire \"pl.strict\" -- #Todo: stricture is in pylon, preload it\nlocal getmeta, setmeta = getmetatable, setmetatable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function pushmeta(tab, meta)\n   if not tab.__pushmeta then\n      local current_meta = getmeta(tab)\n      if not current_meta then\n         current_meta = {} -- should probably be a root metatable\n      end\n      setmeta(meta, current_meta)\n      meta.__index = current_meta\n      setmeta(tab,meta)\n      return true\n   else\n      return tab:__pushmeta(meta)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function popmeta(tab)\n   if not tab.__popmeta then\n      local current_meta = getmeta(tab)\n      if current_meta then\n         local next_meta = getmeta(current_meta)\n         if next_meta then\n            setmeta(tab,next_meta)\n            return current_meta\n         else\n            return {}\n         end\n      else\n         return {}\n      end\n   else\n      return tab:__popmeta()\n   end\nend\n\n",
name = "cluster/meta-protocol",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "8318fd93276c75ec3f4054d7547a2ab1a176ea583106cec5dc61c24b2f048ce0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n-- Function to export modules\n-- \n-- The first argument of util.inherit being filled with methods,\n-- the second argument is passed to util.export as =mod=, along\n-- with a function =constructor= which will serve to create a\n-- new instance.\n-- \nfunction cluster.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n-- A synonym is \"build\" because we don\'t always use it as a return\n-- value\ncluster.build = cluster.export\nreturn cluster\n\n",
name = "cluster/cluster",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "011c0be38dfde469d7eefc5e67b8132d1fa2551832d9949bcaaf22de1a77ab84",
binary = "\n\n\n\nlocal Do = require \"clu:meta/template\" :inherit \"do\"\n\n\n\nfunction Do.toLua(_do, scroll)\n   scroll :add \"do \"\n   for _, twig in ipairs(_do) do\n      twig:toLua(scroll)\n   end\n   scroll :add \"end \"\nend\n\n\n\n\nreturn Do\n\n",
name = "meta/do-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "a6b8d0e88d8b679d3a69bc60b9e967ec70aa20f79f834ed318e8fb6b49707c40",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\nlocal CluPhrase = require \"clu:clu/clumeta/cluphrase\"\n\nlocal Scroll = require \"scroll:scroll\" -- this will move soon(ish)\n                                       -- to text:scroll\n\nlocal s = require \"status\" ()\n\nlocal CluPrime = Twig:inherit()\nCluPrime.isClu = true\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal MicroScroll = {}\nMicroScroll.__index = MicroScroll\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction MicroScroll.add(scroll, thing)\n   if type(thing) == \'table\' and thing.isNode then\n      insert(scroll, thing:span())\n   elseif type(thing) == \'string\' then\n      insert(scroll, thing)\n   else\n      error(\"get the fuck out of here with yuor \" .. type(thing))\n   end\n   return nil -- , \"fuck you fancy scroll we\'re getting her done\"\nend\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nfunction MicroScroll.__tostring(scroll)\n   return concat(scroll)\nend\n\n\n\n\n\nlocal function μScroll()\n   return setmetatable({}, MicroScroll)\nend\n\n\n\n\n\n\nlocal function is_WS(twig)\n   if twig.id == \'indent\' or twig.id == \'comment\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\n\nfunction CluPrime.toLua(clu)\n   local scroll = μScroll() -- this should serve until we unbreak macroscroll\n   for _, twig in ipairs(clu) do\n      if twig.toLua then\n         twig:toLua(scroll)\n      else\n         s:insert(\"\'no toLua method for \" .. twig.id)\n      end\n   end\n   return CluPhrase(tostring(scroll))\nend\n\n\n\nreturn CluPrime\n\n",
name = "meta/cluprime",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "02cf9dbe5e6d96e76f9b2e6897ac111e159bf648b0d37a41c3e556fb145d84c3",
binary = "\n\n\nlocal Comment = require \"clu:meta/twig\" : inherit ()\nComment.is_WS = true\n\nfunction Comment.toLua(comment, scroll)\n   scroll:add(\"--\" .. string.sub(comment:span(), 2))\nend\n\nreturn Comment\n\n",
name = "meta/comment",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "77ec0ba88e58fdbf0ef84ec6697d1e87437bb1eb391ceefa21863b0b0ef48a49",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Boolean = Twig : inherit()\n\n\n\nfunction Boolean.toLua(bool, scroll)\n   scroll:add(bool)\nend\n\n\n\nreturn Boolean\n\n",
name = "meta/boolean",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c658c0d7300cb80969bde9bdb75afd31c848dfe2fa50509dda758118eec5709c",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Field = Twig:inherit()\n\nfunction Field.toLua(field, scroll, field_of)\n   local _ = field_of and scroll:add \"[\"\n   field[1]:toLua(scroll, field_of)\n   _ = field_of and scroll :add \"]\"\n   local no_ssyn = field[2].id ~= \'ssyntax\'\n   _ = no_ssyn and scroll :add \"[\"\n   field[2]:toLua(scroll, true)\n   _ = no_ssyn and scroll :add \"]\"\nend\n\nreturn Field\n\n",
name = "meta/field",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "4e619bdbc506be9d05d750a8032ca74356b1184f0ad1f8e327ee4af9f7100f9a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Final = require \"clu:meta/twig\" :inherit \'final\'\n\n\n\n\n\nfunction Final.toLua(final, scroll)\n   for _, twig in ipairs(final) do\n      if twig.is_WS then\n         twig:toLua(scroll)\n      else\n         if (not twig.is_template) and (twig.id ~= \'expr\') then\n            scroll :add \"return \"\n         end\n         twig:toLua(scroll)\n      end\n   end\nend\n\n\n\n\nreturn Final\n\n",
name = "meta/final",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c7a181b31a69e21b279a6de2aff81f088ed1c823584e880ca27e52a47a789c22",
binary = "\n\n\n\nlocal Twig = require \"clu:meta/twig\"\nlocal s = require \"status\"\n\nlocal Expr = Twig:inherit()\n\n\n\n\nlocal function darkspace(node)\n   return not node.is_WS\nend\n\nfunction Expr.toLua(expr, scroll)\n   local called, last_arg = false, nil\n   for i = 1, #expr do\n      local twig = expr[i]\n      local dark = darkspace(twig)\n      if not called then\n         -- we\'re building `sym(`\n         twig:toLua(scroll)\n         if dark then\n            scroll :add \"(\"\n            called = true\n         end\n      else\n         -- building a parameter list as one does...\n         if last_arg and dark then\n            -- we\'ve found another arg, which needs a comma\n            scroll :add \", \"\n         end\n         twig:toLua(scroll)\n         if dark then\n            last_arg = twig\n         else\n            last_arg = nil\n         end\n      end\n   end\n   scroll :add \") \"\nend\n\n\n\nreturn Expr\n\n",
name = "meta/expr",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "f0115ef1a7bdb0abd9f6a54dac9774f42cf8fbe51e076a2d55cab3cc422975ca",
binary = "\n\n\n\n\n\nlocal For_iter = require \"clu:meta/template\" :inherit \"for_iter\"\n\n\n\nfunction For_iter.toLua(_for, scroll)\n   scroll :add \"for \"\n   local state = \'lval\'\n   for _, twig in ipairs(_for) do -- mmmmmeta\n      local dark = not twig.is_WS\n      if dark and state == \'lval\' then\n         twig:toLua(scroll)\n         scroll :add \" in \"\n         state = \'rval\'\n      elseif dark and state == \'rval\' then\n         twig:toLua(scroll)\n         scroll :add \" do \"\n         state = \'body\'\n      else\n         twig:toLua(scroll)\n      end\n   end\n\n   scroll :add \" end \"\nend\n\n\n\nreturn For_iter\n\n",
name = "meta/for-iter",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c97782af634c3ba6f01a77a921e66d21bfb1bf1e6535935fc1b49f2855ce0bcf",
binary = "\n\n\n\n\nlocal For_num = require \"clu:meta/template\" :inherit \"for_num\"\n\n\n\nfunction For_num.toLua(_for, scroll)\n   scroll : add \"for \"\n   local f_state = \'range\'\n   for _, twig in ipairs(_for) do\n      local dark = not twig.is_WS\n      if dark and f_state == \'range\' then\n         local r_state = \'symbol\'\n         for _, shoot in ipairs(twig) do\n            local dark = not shoot.is_WS\n            if dark and r_state == \'symbol\' then\n               shoot:toLua(scroll)\n               scroll :add \" = \"\n               r_state = \'first_arg\'\n            elseif dark and r_state == \'first_arg\' then\n               shoot:toLua(scroll)\n               r_state = \'more_arg\'\n            elseif dark then -- more_arg is deduced here\n               scroll :add \", \"\n               shoot :toLua(scroll)\n            else\n               shoot:toLua(scroll)\n            end\n         end\n         scroll :add \" do \"\n         f_state = \'chunk\'\n      else\n         twig:toLua(scroll)\n      end\n   end\n   scroll :add \" end \"\nend\n\n\n\nreturn For_num\n\n",
name = "meta/for-num",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "0cc537fd99b502dd1492e11394feebd234ebbaa3411712ecb77f86d93d9996f9",
binary = "\n\n\n\n\n\nlocal Goto = require \"clu:meta/template\" :inherit \"Goto\"\nlocal Label = require \"clu:meta/template\" :inherit \"Label\"\n\n\n\nfunction Goto.toLua(_goto, scroll)\n   scroll :add \"goto \"\n   for _, twig in ipairs(_goto) do\n      twig:toLua(scroll)\n   end\n   scroll :add \" \"\nend\n\n\n\nfunction Label.toLua(_label, scroll)\n   scroll :add \"label \"\n   for _, twig in ipairs(_label) do\n      if twig.id == \'symbol\' then\n         scroll :add \"::\"\n         twig:toLua(scroll)\n         scroll :add \"::\"\n      else\n         twig:toLua(scroll)\n      end\n   end\nend\n\n\n\nreturn {Goto, Label}\n\n",
name = "meta/goto-label",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "111ef16ed09002c7a7351848e791a36c3739e63591d42bcba926b4d7ca4e5cad",
binary = "\n\n\nlocal If_t =require \"clu:meta/template\" :inherit \'if\'\n\n\n\nfunction If_t.toLua(_if, scroll)\n   scroll :add \" if \"\n   for _, twig in ipairs(_if) do\n      if twig.id == \'pred\' then -- meta metta heeey\n         twig:toLua(scroll)\n         scroll :add \" then \"\n      elseif twig.id == \'elif_if\' then\n         scroll :add \" elseif \"\n         for _, shoot in ipairs(twig) do\n            shoot:toLua(scroll)\n            if shoot.id == \'pred\' then\n               scroll :add \" then \"\n            end\n         end\n      elseif twig.id == \'if_false\' then\n         scroll :add \" else \"\n         twig:toLua(scroll)\n      else\n         twig:toLua(scroll)\n      end\n   end\n   -- speaking of end\n   scroll :add \" end \"\nend\n\n\n\nreturn If_t\n\n",
name = "meta/if-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "477f880baf873de463249657f1986100e9a8da568f98f94e98bb148cae19e484",
binary = "\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\n\n\n\nlocal Key = Twig :inherit \"key\"\n\n\n\nfunction Key.toLua(key, scroll)\n   for _, twig in ipairs(key) do\n      if twig.is_WS then\n         twig:toLua(scroll)\n      else\n         local lval_method = twig.asString\n         scroll:add \"[\"\n         if lval_method then\n            scroll:add(twig:asString())\n         else\n            twig:toLua(scroll)\n         end\n         scroll:add \"]\"\n      end\n   end\nend\n\n\n\nreturn Key\n\n",
name = "meta/key",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "adf18e7b9a8b5a349ae45a5302fd5a8c3aec185053ed2a70a8c90b8277cd5be6",
binary = "\n\n\n\n\n\n\nlocal Fn = require \"clu:meta/template\" :inherit \'fn\'\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Fn.toLua(fn, scroll)\n   scroll: add \"function (\"\n   for _, twig in ipairs(fn) do\n      if twig.id == \'param\' then\n         local param = twig[1]\n         if param.id == \'vector\' then -- or multiple I\'m conflicted about that still meh\n            param:toLua(scroll, true) -- return as a \'bare\', no braces\n         else\n            param:toLua(scroll)\n         end\n         state = \'body\'\n         scroll:add \") \"\n      else\n         twig:toLua(scroll)\n         scroll:add \" \"\n      end\n      scroll:add \" \"\n   end\n   scroll :add \" end \"\nend\n\n\n\nreturn Fn\n\n",
name = "meta/fn-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c57c9e354c5da027aa0da9adafb0367f4ebb912c105a43f2a8fb298ef114abac",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\n\n\nlocal Indent = Twig :inherit \"indent\"\n\nIndent.is_WS = true\n\n\n\nfunction Indent.toLua(indent, scroll)\n   assert(string.find(indent:span(), \"\\n\"))\n   scroll:add(indent)\n   --scroll:add(\"--[[]]\")\nend\n\n\n\nreturn Indent\n\n",
name = "meta/indent",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "0f1fcfe4cf009261e8a5cbbfaa0fe8da6bc1de472cd42a855472c552f3e1a9dc",
binary = "\n\n\nlocal Map = require \"clu:meta/twig\" : inherit ()\n\n\nfunction Map.toLua(map, scroll)\n   scroll :add \"{ \"\n   for _, twig in ipairs(map) do\n      if not (twig.id == \"key\" or twig.id == \"slot\") then\n         twig:toLua(scroll)\n      elseif twig.id == \"key\" then\n         twig:toLua(scroll)\n         scroll :add \" = \"\n      elseif twig.id == \"slot\" then\n         twig:toLua(scroll)\n         scroll :add \", \"\n      end\n   end\n\n   scroll :add \"}\"\nend\n\nreturn Map\n\n",
name = "meta/map",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "70c2f6ececa7eb63ca23c2dccb1cd5fb9a6c8fcd9773952ab1478bf4a9d59e43",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Meth = Twig:inherit()\n\nfunction Meth.toLua(meth, scroll)\n   scroll:add(meth[1]:span())\n   scroll:add(\":\")\n   scroll:add(meth[2]:span())\nend\n\nreturn Meth\n\n",
name = "meta/methodcall",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "5afb2db657d5999d66cbc7b0ab0b870144601633cf96d47a03971e4c9874f3d4",
binary = "\n\n\nlocal Multi = require \"clu:meta/twig\" : inherit ()\n\n\nfunction Multi.toLua(multi, scroll)\n   local last_val = nil\n   for i, twig in ipairs(multi) do\n      local dark = not twig.is_WS\n      if dark then\n         if last_val then\n            -- drop that comma\n            scroll:add \", \"\n            last_val = twig\n         else\n            last_val = dark\n         end\n      end\n      twig:toLua(scroll)\n      scroll:add \" \"\n   end\nend\n\nreturn Multi\n\n",
name = "meta/multiple",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "81eae3b6d96eb5d91a80d40816a984ce811514271d88f696f8a9bdb3e32cb59e",
binary = "\n\n\nlocal My = require \"clu:meta/template\" :inherit \"my\"\n\n\n\nfunction My.toLua(my, scroll)\n   local lval, rval = my[1], my[2], assert(not my[3])\n   scroll :add \"local \"\n   lval:toLua(scroll)\n   if rval then\n      scroll :add \" = \"\n      rval:toLua(scroll)\n   else\n      scroll :add \"; \"\n   end\nend\n\n\n\nreturn My\n\n",
name = "meta/my-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "3617f2cdabfe7998415154d89696447abc6d46339a16c1cfcbc2a2345c0ff21a",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Nil = Twig : inherit()\n\n\n\nfunction Nil.toLua(null, scroll)\n   scroll:add(null)\nend\n\n\n\nreturn Nil\n\n",
name = "meta/nil",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "486c2d10e9b5f509b6b790fe3746a0bbf4d2de501f31ad3d715ec04b1672f3b1",
binary = "\n\n\nlocal Mut = require \"clu:meta/template\" :inherit \"mut\"\n\n\n\nfunction Mut.toLua(mut, scroll)\n   local lval, rval = mut[1], mut[2], assert(not mut[3])\n   lval:toLua(scroll)\n   scroll :add \" = \"\n   rval:toLua(scroll)\nend\n\n\n\nreturn Mut\n\n",
name = "meta/mut-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "8a7de73cb452f0fdf24ed77e1426a10f81a228d3f2fde9a508c80b449bcbef13",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Now = require \"clu:meta/template\" :inherit \"now\"\n\n\n\n\n\n\nlocal clu;\n\n\n\n\n\n\nlocal serial  = require \"util:serpent\" . serialize\n\nlocal _opts = { sparse = true,\n                compact = true,\n                fatal = true,\n                nocode = true,\n                nohuge = true,\n                comment = false,\n                metatostring = false, }\n\nlocal function ascode(val)\n    return serial(val, _opts)\n end\n\n",
name = "meta/now",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "50ea353956115e07931da2c578be844792e8a9561abd187ec072f43c0a6dd23c",
binary = "\n\n\nlocal Peek = require \"clu:meta/template\" :inherit \"peek_t\"\n\n\n\nfunction Peek.toLua(peek, scroll)\n   peek[1]:toLua(scroll) -- the indexed\n   for i = 2, #peek do\n      local twig = peek[i]\n      scroll :add \"[\"\n      twig:toLua(scroll)\n      scroll :add \"]\"\n   end\nend\n\n\n\nreturn Peek\n\n",
name = "meta/peek-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "7deabe94d6a45470e58fd5e158bd84aced1bd532c1d22ca3b8ab78427699f2b0",
binary = "\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Num = Twig:inherit()\n\nfunction Num.toLua(number, scroll)\n   scroll:add(number:span(number))\nend\n\nreturn Num\n\n",
name = "meta/number",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "31ba58ebd30e0e2b61efd4d5085561e63654966c5428095be63161dd39df8f7d",
binary = "\n\n\nlocal Quote = require \"clu:meta/twig\" : inherit ()\n\nfunction Quote.toLua(quote, st, par_expr)\n   local phrase = \"\" -- st.phrase.idEst()\n   phrase = phrase .. st:indent() .. \"read([==[\\n\"\n   for i = 2, #par_expr do\n        phrase = phrase .. st:indent() .. par_expr[i]:span()\n   end\n   return phrase .. st:indent() ..  \"]==])\\n\"\nend\n\nreturn Quote\n\n",
name = "meta/quote",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "29b55c770420224557c1914c978a9f014a29357d12df6487c5ff40ff4c34acfb",
binary = "\n\n\n\n\nlocal Operator = require \"clu:meta/twig\" : inherit \"operator\"\n\n\n\n\n\nlocal function l_binop(operator, op, scroll)\n   scroll:add((\"(\"):rep(#operator - 2))\n   local first = true\n   for i = 2, #operator do\n      local twig = operator[i]\n      local dark = not twig.is_WS\n      if dark and first then\n         first = false\n         twig:toLua(scroll)\n      elseif dark then\n         scroll:add(op)\n         twig:toLua(scroll)\n         scroll :add \")\"\n      else\n         twig:toLua(scroll)\n      end\n   end\nend\n\n\n\n\n\nlocal function r_binop(operator, op, scroll)\n   scroll :add \"(\"\n   local first = true\n   for i = 2, #operator do\n      local twig = operator[i]\n      local dark = not twig.is_WS\n      if dark and first then\n         first = false\n         twig:toLua(scroll)\n      elseif dark then\n         scroll:add(op)\n         scroll :add \"(\"\n         twig:toLua(scroll)\n      else\n         twig:toLua(scroll)\n      end\n   end\n   scroll:add((\")\"):rep(#operator - 1))\nend\n\n\n\n\n\nlocal function _expr_for(left, lval, op, rval, scroll)\n   scroll:add(left)\n   lval:toLua(scroll)\n   scroll:add(op)\n   rval:toLua(scroll)\n   scroll :add \")\"\nend\n\nlocal function _compare(operator, op, scroll)\n   local left = \"(\" -- mutates to \" and (\"\n   local lval;\n   local drop_op = true\n   for _, twig in ipairs(operator) do\n      local dark = not twig.is_WS\n      if dark then\n         if drop_op then\n            drop_op = false -- skip the operator itself\n         elseif not lval then\n            lval = twig\n         else\n            _expr_for(left, lval, op, twig, scroll)\n            left = \" and (\"\n            lval = twig\n         end\n      else\n         twig:toLua(scroll)\n      end\n   end\nend\n\n\n\n\n\nlocal _ops = {}\n\n\n\nlocal _l_binops = {\"+\", \"*\", \"/\", \"-\", \"or\", \"and\"}\n\nfor _, v in ipairs(_l_binops) do\n   _ops[v] = l_binop\nend\n\n\n\nlocal _r_binops = {\"^\", \"..\"}\n\nfor _, v in ipairs(_r_binops) do\n   _ops[v] = r_binop\nend\n\n\n\n\nlocal _comps = {\"==\", \"~=\", \"<=\", \">=\"}\n\nfor _, v in ipairs(_comps) do\n   _ops[v] = _compare\nend\n\n\n\n\n\n_ops[\"not\"] = function(_not, op, scroll)\n   scroll:add \"not \"\n   for _, twig in ipairs(_not) do\n      if twig.id ~= \'op_symbol\' then\n         twig:toLua(scroll)\n      end\n   end\nend\n\n\n\n\n\nfunction Operator.toLua(operator, scroll)\n   local op = operator[1]:span()\n   _ops[op](operator, op, scroll)\nend\n\nreturn Operator\n\n",
name = "meta/operator",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "47df1946442f8413430a76c620954b4547643dbffd3862846f937fadea3dd834",
binary = "\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\n\n\nlocal Slot = Twig :inherit \"slot\"\n\n\n\nfunction Slot.toLua(slot, scroll)\n   for _, twig in ipairs(slot) do\n      twig:toLua(scroll)\n   end\nend\n\n\n\nreturn Slot\n\n",
name = "meta/slot",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "6002636df22be6e35829517e728034db86407cd7f341d9fa61082f94c7286709",
binary = "\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal SSyntax = Twig :inherit \"ssyntax\"\n\n-- \'tail\' passed through if the ssyntax is not in head position by \'field\'\nfunction SSyntax.toLua(ssyn, scroll, tail)\n   ssyn[1]:toLua(scroll, tail)\nend\n\nreturn SSyntax\n\n",
name = "meta/ssyntax",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "e2f7a9cc64b29561219d8f39c2857ee05ffb8e0ba9e8d703e4b0497a1148882b",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Str = Twig :inherit \"string\"\n\nfunction Str.toLua(str, scroll)\n   scroll:add(str)\nend\n\nreturn Str\n\n",
name = "meta/string",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "c50d3c2d25c629babc97e0bd959327e1fd3e99d31f0c52e9fe2e9dfaaae05877",
binary = "\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\n\n\nlocal Table = Twig :inherit \"table\"\n\n\n\nfunction Table.toLua(tab, scroll)\n   scroll:add \"{ \"\n\n   for _, twig in ipairs(tab) do\n      if twig.is_WS then\n         twig:toLua(scroll)\n      elseif twig.id == \'multiple\' then\n         twig:toLua(scroll)\n         scroll:add \", \"\n      elseif twig.id == \"key\" then\n         twig :toLua(scroll)\n         scroll :add \" = \"\n      elseif twig.id == \"slot\" then\n         twig[1]:toLua(scroll)\n         scroll:add(\", \")\n      else\n         error(\"weird: saw a \" .. twig.id)\n      end\n   end\n\n   scroll:add \" }\"\nend\n\n\n\nreturn Table\n\n",
name = "meta/table",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "56595b3592e93d5e7832f82784856ae81a651fe239d79d7c9396c7442e8bb45e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Symbol = Twig:inherit()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _syms = setmetatable({}, { __mode = \'kv\'})\n\nlocal _mangler = {\n   [\"-\"]  = \"_\",\n   [\"!\"]  = \"‼︎\",\n   [\"?\"]  = \"⁇\",\n   [\"%+\"] = \"﹢\",\n   [\"%%\"] = \"﹪\",\n   [\"%*\"] = \"✳︎\",\n}\n\nlocal function mangle(span)\n   if _syms[span] then return _syms[span] end\n   --   #Todo the _mangler table above is correct so let\'s switch it out when\n   --   we come back and start testing Byron.\n   --   oh, right.  This language is called Byron now.\n   --   Mad, Bad, and Dangerous to Know.\n   local ugly = span :gsub(\"-\", \"_\")\n                     :gsub(\"!\", \"❕\")\n                     :gsub(\"?\", \"❔\")\n                     :gsub(\"%+\", \"➕\")\n                     -- and so on for really quite awhile, let\'s add an important one\n                     :gsub(\"%%\", \"﹪\"):gsub(\"%*\", \"✳︎\")\n   _syms[span] = ugly\n   return ugly\nend\n\nfunction Symbol.toLua(symbol, scroll, lval)\n   local sym;\n   if lval then\n      sym = symbol:asString()\n   else\n      sym = mangle(symbol:span())\n   end\n   scroll:add(sym)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction Symbol.asString(symbol)\n   return format(\"%q\", mangle(symbol:span()))\nend\n\n\n\nreturn Symbol\n\n",
name = "meta/symbol",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "76b5834806614aedb613b7471bc9697321a8f96723adef10fb34e31f9d8445d7",
binary = "\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\n\n\n\n\n\n\nlocal Template = Twig :inherit \"template\"\nTemplate.is_template = true\n\n\n\n\nreturn Template\n\n",
name = "meta/template",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "bc7b3ee64e890a9002c4028653dd1b5b2593dd69867de1335eec608b939ccd21",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\nlocal Node = require \"espalier/node\"\nlocal s    = require \"status\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal CluPhrase = require \"clu:clu/clumeta/cluphrase\"\n\nlocal Templates, temps = Twig:inherit()\nTemplates.__index = Templates\nTemplates.isTemplate = true\n\n\n\n\n\n\n\nlocal function is_WS(twig)\n   if twig.id == \'indent\' or twig.id == \'comment\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal My = Templates:inherit()\nMy.id = \"def\"\n\nfunction My.toLua(my, st)\n   local phrase, tree = \"\", my :select \"tree\" ()\n   return \"local \" .. tree[1] :toLua(st)\n          .. \" = \" .. tree[2] :toLua(st()) .. \"\\n\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Fn = Templates:inherit()\nFn.id = \"fn\"\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Fn.toLua(fn, scroll)\n   scroll: add \"function (\"\n   local tree = fn :next \"tree\"\n   local state = \'param\'\n   for _, twig in ipairs(tree) do\n      if state == \'param\' then\n         if twig.id == \'vector\' then\n            twig:toLua(scroll, true) -- return as a \'bare\', no braces\n            state = \'body\'\n            scroll:add \") \"\n         elseif twig.id == \'symbol\' then\n            twig:toLua(scroll)\n         end\n      else\n         twig:toLua(scroll)\n         scroll:add \" \"\n      end\n   end\n   scroll :add \" end \"\nend\n\n\n\n\n\n\n\n\nlocal If = Templates:inherit()\nIf.id = \"if\"\n\nfunction If.toLua(iF, st)\n   local phrase, tree = \"if \", iF :select \"tree\" ()\n   local state = \'if\'\n   for _, twig in ipairs(tree) do\n      if is_WS(twig) then\n         phrase = phrase .. \" \" ..  twig:toLua(st)\n      else\n         -- cases\n         if state == \'if\' then\n            phrase = phrase .. twig:toLua(st) .. \" then \"\n            state = \'then\'\n         elseif state == \'then\' then\n            phrase = phrase .. \" \" .. twig:toLua(st)\n            state = \'else\'\n         elseif state == \'else\' then\n            phrase = phrase .. \" else \" .. twig:toLua(st)\n         end\n      end\n   end\n   phrase = phrase .. \"; end\"\n\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _numeric_for(tree)\n   for _, twig in ipairs(tree) do\n      if twig.id == \'vector\' then\n         return true\n      elseif twig.id == \'map\' then\n         return false\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal For = Templates:inherit()\nFor.id = \"for\"\n\nfunction For.toLua(fOr, st)\n   local block, tree = {}, fOr :select \"tree\" ()\n   insert(block, \"for \")\n   local state = \'for\'\n   if _numeric_for(tree) then\n      state = \'symbol\'\n      local vec = tree[1]\n      for _, twig in ipairs(vec) do\n         if is_WS(twig) then\n            insert(block, tostring(twig:toLua(st)))\n         elseif state == \'symbol\' then\n            insert(block, tostring(twig:toLua(st)))\n            insert(block, \" = \")\n            state = \'number\'\n         elseif state == \'number\' then\n            insert(block, tostring(twig:toLua(st)))\n            insert(block, \" , \")\n         end\n      end\n      -- trim \", \"\n      remove(block)\n   else -- generic for\n      -- multiple or symbol\n      local map = tree[1]\n      local state = \'lval\'\n      for _, twig in ipairs(map) do\n         if is_WS(twig) then\n            insert(block, tostring(twig:toLua(st)))\n         elseif state == \'lval\' then\n            insert(block, tostring(twig:toLua(st)))\n            insert(block, \" in \")\n            state = \'rval\'\n         elseif state == \'rval\' then\n            insert(block, tostring(twig:toLua(st)))\n         end\n      end\n   end\n   insert(block, \" do \")\n\n   -- rest of for template is generic:\n   for i = 2, #tree do\n      insert(block, tostring(tree[i]:toLua(st)))\n   end\n   insert(block, \"; end\")\n\n   return concat(block)\nend\n\n\n\nreturn {\n--   use     =  Use,\n-- let     =  Let,\n   my      =  My,\n   fn      =  Fn,\n   [\'λ\']   =  Fn,\n   [\'if\']  =  If,\n   [\'for\'] =  For,\n}\n\n",
name = "meta/templates",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "381f4019ee132f83fdb2ea83dae7f3d78a7526bdd80f249baa258a1d8303be00",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"espalier/node\" : inherit ()\n\n\n\nfunction Twig.toLua(twig, scroll)\n   -- add this if we need to see a base method\n   --[=[\n   scroll:add(\"--[[\" ... twig.id .. \"]]\")\n   --]=]\n   for _, sprig in ipairs(twig) do\n      sprig:toLua(scroll)\n      scroll:add \" \"\n   end\nend\n\nreturn Twig\n\n",
name = "meta/twig",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "5fdca49b7370e2a20b6ac99b9fe4f2c97a05397bf3ea6951f23e2ba8d8f17565",
binary = "\n\n\n\n\n\n\n\n\nlocal Until = require \"clu:meta/template\" :inherit \"until\"\n\n\n\nfunction Until.toLua(_until, scroll)\n   local pred;\n   scroll: add \"repeat \"\n   for _, twig in ipairs(_until) do\n      if twig.id == \'pred\' then\n         -- we\'ll need this later\n         pred = twig\n      else\n         twig:toLua(scroll)\n      end\n   end\n   scroll :add \" until \"\n   pred:toLua(scroll)\nend\n\n\n\nreturn Until\n\n",
name = "meta/until-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "ec6b04f64968951dfdcbda1292d9bd897d460e3ccb5bcd7e34b08de6776d31a9",
binary = "\n\n\n\n\n\nlocal Twig = require \"clu:meta/twig\"\nlocal Unary = {\n   quote = Twig :inherit \'quote\',\n   unquote_splice = Twig :inherit \'unquote_splice\',\n   unquote = Twig :inherit \'unquote\',\n   quasi_quote = Twig :inherit \'quasi_quote\',\n   reader_macro = Twig :inherit \'reader_macro\',\n   Return = Twig :inherit \'Return\',\n}\n\n\n\n\nfunction Unary.Return.toLua(ret, scroll)\n   scroll :add \"return \"\n   ret[1]:toLua(scroll)\nend\n\n\n\n\nreturn function(t, offset)\n   -- this is kinda weird, but it fits, we lift the identity off 1 and blot it\n   -- out with 2 then go home\n   setmetatable(t, assert(Unary[t[1].id]))\n   t.id = nil\n   t[1] = t[2]\n   t[2] = nil\n   return t\nend\n\n",
name = "meta/unary",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "50e814346526e874fc9b38e52ba45f12b3080ee091b314dea5ce58dfe0dbdf7f",
binary = "\n\n\nlocal Twig = require \"clu:meta/twig\"\n\nlocal Vararg = Twig : inherit \"vararg\"\n\nfunction Vararg.toLua(vararg, scroll)\n   return scroll:add(vararg)\nend\n\nreturn Vararg\n\n",
name = "meta/vararg",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "922291643af32e52f4d22ebf20732065d3c6bbed0936861de128b1ea0f082e52",
binary = "\n\n\n\nlocal Twig = require \"clu:meta/twig\"\nlocal CluPhrase = require \"clu:clu/clumeta/cluphrase\"\n\nlocal Vec = Twig:inherit()\n\n\nlocal function darkspace(node)\n   return not node.is_WS\nend\n\nfunction Vec.toLua(vector, scroll, bare)\n   if not bare then\n      -- this is a wrapped vector, the normal kind\n      scroll:add(\"{ \")\n   end\n   local last_val = nil\n   for i, twig in ipairs(vector) do\n      local dark = darkspace(twig)\n      if dark then\n         if last_val then\n            -- drop that comma\n            scroll:add \", \"\n            last_val = twig\n         else\n            last_val = dark\n         end\n      end\n      twig:toLua(scroll)\n      scroll:add \" \"\n   end\n   if not bare then\n      scroll:add(\" }\")\n   end\nend\n\n\nreturn Vec\n\n\n",
name = "meta/vector",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "37fe99d835a61eea84400b4615d77a7ab2b6c48b8d319f139f24244d09783eb5",
binary = "\n\n\nlocal While = require \"clu:meta/template\" :inherit \"while\"\n\n\n\nfunction While.toLua(_while, scroll)\n   scroll :add \"while \"\n   for _, twig in ipairs(_while) do\n      twig:toLua(scroll)\n      if twig.id == \'pred\' then\n         scroll :add \" do \"\n      end\n   end\n   scroll :add \" end \"\nend\n\n\n\nreturn While\n\n",
name = "meta/while-t",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "2c54d923af1daa84a6050600ccd6ffa423e2041cf57be82f00de31ce376afae9",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif type(key) == \"string\"\n   and type(value) == \"table\"\n   or  type(value) == \"function\" then\n       -- the name of the table is `key`.\nend\n\n",
name = "notes/inspector-gadget",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "f60a751ffeedad745fd2949be62e47403bfd4afb5789921bba2ce1163019b14e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"core:cluster\"\n-- Clu  = require \"clu:clu/clu\" \'Clu\'\n\ns():chat(\"hello\")\n\n\n\n\n\n\n\n\n\n\n\nlocal clu_bar =    [==[\n(clu 12)\n\n(my con {answer 42})\n\n(fn\n  [bar bingo bongo]\n   (baz)\n   (query forth)\n   bux.quux\n   (fn\n     [who dat]\n     (it dis)\n     (oh yeah))\n   5)\n\n(for [i 1 10]\n     (print i)\n     (print con))\n\n(for { [key val]  (ipairs con) }\n     (print val))\n\n#_(if this\n    th2at\n    !?the-other) ]==]\n\nlocal why_hello =  [==[\n(use lpeg \'lpeg)\n(my con 34)\n(my con-print (fn\n    [x%+!?*] ; unused parameter...\n    (set con 23)\n    (print con)\n    (print (string.sub \"hello world\" 2 3))))\n\n;; lambda form\n((λ x (print 23)) Clu)\n\n(my \\my-map my-fn\\\n         \\{ one-form two-form\n            red-form blue-form }\n          ((λ x (print x)) Clu)/)\n\n(my ten (< 1 2 3 4))\n\n(for { \\k v\\ (ipairs [1 2 3]) }\n   (print v))\n\n(print ten)\n\ncon-print\n\n(assert \'this works\' (thunk (error \"didn\'t though\"))\n]==]\n\n\nlocal long_fn = [[\n(my long-fn\n  (λ [_ x bar baz]\n    (if _\n       (print bar)\n       (print baz))))\n\n(long-fn true \"bar\" \"baz\")\n\n;((fn z (print z )) 12)\n\n(print \'(print 23) \"\\n\")\n\n;((fn (print $) \"quux\")\n]]\n\n",
name = "notes/scaffolding",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "44324359fee0b979bfc3eb6935fe1603dce368304d64b34a8247bf66071fcd7d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal core = require \"core:core\"\n\nlocal read = assert(require \"clu:clu/reader\" . parse)\n\nlocal Valiant = require \"valiant:valiant\"\n\nlocal _Clu, _Now, _Libs, _read_env = unpack(require \"clu/C\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(true)\n\nlocal function new_reader_evaluator(env, _now, reader)\n   local clu = Valiant(env, _now, nil, reader)\n   return clu\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function read_call(_, expr)\n   return read(expr)\nend\n\nlocal function new(env, _Now)\n   env = env or _Clu\n   _Now = _Now or _Now\n   local reader = setmetatable({}, { __call = read_call })\n   return new_reader_evaluator(env, nil, reader) -- add _Now for nil later\nend\n\n\n\n\n\nreturn new\n\n",
name = "clu",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
  { 
branch = "evaluation-primitives",
hash = "63153cce068785addfd905ef073a947b888e1b4e9e7a15e3bbbb6eccab2ad53c",
binary = "\n\n\n\nlocal if_string = [[\nlocal function i_f(a, b ,c)\n   if a then\n      return b\n   else\n      return c\n   end\nend\n]]\n\n",
name = "preamble",
vc_hash = "b72a05c1980782963fbd3f93c32c9755fb930682\n",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:bridgetools/cluster.git\n",
    repo_type = "git",
    repo_alternates = "",
    name = "cluster",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "7600efef0c893c3ab6bcc8da5bf92fdb8b4292ea432b96e1683c75cdd76d9d55",
binary = "\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal Widget = require \"cluster:spec/widget\"\n\n\n\nlocal new, Gizmo, Gizmo_M = cluster.genus(Widget)\n\n\n\n\n\nGizmo.direction = \'up\'\n\n\n\n\n\ncluster.extendbuilder(new,\n   function(_new, gizmo, color, number, direction)\n      gizmo.direction = direction\n      return gizmo\n   end)\n\n\n\n\n\nlocal format, gsub = assert(string.format), assert(string.gsub)\n\n\ncluster.extend.super(Gizmo, \"report\",\n   function(gizmo, as_widget)\n      if as_widget ~= \'as-widget\' then\n         -- some delicate surgery\n         local report = gizmo.as_reported\n                           :gsub(\"widget\", \"gizmo\")\n                           :gsub(\"hello!\", \"my direction is %%s! hello!\")\n         gizmo.as_reported = format(report, gizmo.direction)\n      end\n      return gizmo.as_reported\n   end)\n\n\n\n\n\nreturn new\n\n",
name = "spec/gizmo",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "f6f6919a3c4064ef95b673a9ecce3f6a027c17d9efb2cba1b4222a0c29e735b5",
binary = "\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal s = require \"status:status\" ()\n\n\n\nlocal new, Widget, Widget_M = cluster.genus()\n\n\n\n\n\nWidget.color = \'black\'\nWidget.number = 1\n\n\n\n\n\ncluster.construct(new,\n   function(_, widget, color, number)\n      widget.color = color\n      widget.number = number\n      return widget\n   end)\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction Widget.report(widget)\n   widget.as_reported = format(\"I\'m a %s widget! number %d! hello!\",\n                 widget.color, widget.number)\n   return widget.as_reported\nend\n\n\n\n\n\n\n\n\n\nfunction Widget_M.__add(l_widget, r_widget)\n   return new(l_widget.color, l_widget.number + r_widget.number)\nend\n\n\n\n\n\nreturn new\n\n",
name = "spec/widget",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "caa8d69e7b3f730ef64505b3c70f0a88984dc92a916e7fdcad378b1ec05567b9",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status = assert(coroutine.create), assert(coroutine.status)\nlocal yield, resume = assert(coroutine.yield), assert(coroutine.resume)\n\nlocal bridge = require \"bridge\"\n\nlocal function autothreader(thread)\n   return function(...)\n      local work;\n      bridge.green = 1 -- #TODO check that bridge is truthy and run on block\n      if type(thread) == \'thread\' then\n         work = thread\n      elseif type(thread) == \'function\' then\n         work = create(thread)\n      else -- if thread isn\'t callable this will break\n         work = create(function(...)\n                          return thread(...)\n                       end)\n      end\n      local res = pack(resume(work, ...))\n      local ok, response, state = res[1], res[2], status(work)\n      if ok and state == \'dead\' then\n         return select(2, unpack(res))\n      elseif not ok then\n         error(response)\n      elseif type(response) == \'table\' and response.isResponse then\n         response.work = work\n      else\n         yield(select(2, unpack(res)))\n      end\n      bridge.green = -1\n      return nil\n   end\nend\n\nlocal autothread = function(thread, ...) return autothreader(thread)(...) end\n\n\n\n\nreturn autothread\n\n",
name = "autothread",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "aea171f8fdc685225b8b390641078d3a848f0a59bbb557da874e9bc79bd2e14f",
binary = "\n\n\n\n\n\n\nlocal N_G = {\n   _OG = _G,\n   setmeta = setmetatable,\n   getmeta = getmetatable,\n   yield   = assert(coroutine.yield),\n   resume  = assert(coroutine.resume),\n   _VERSION = _VERSION,\n   arg = arg,\n   assert = assert,\n   bit = bit,\n   collectgarbage = collectgarbage,\n   debug = debug,\n   dofile = dofile,\n   error = error,\n   gcinfo = gcinfo,\n   getfenv = getfenv,\n   io = io,\n   ipairs = ipairs,\n   jit = jit,\n   load = load,\n   loadfile = loadfile,\n   loadstring = loadstring,\n   math = math,\n   newproxy = newproxy,\n   next = next,\n   os = os,\n   pack = pack,\n   package = package,\n   pairs = pairs,\n   pcall = pcall,\n   print = print,\n   rawequal = rawequal,\n   rawget = rawget,\n   rawlen = rawlen,\n   rawset = rawset,\n   require = require,\n   select = select,\n   setfenv = setfenv,\n   string = string,\n   table = table,\n   tonumber = tonumber,\n   tostring = tostring,\n   type = type,\n   unpack = unpack,\n   xpcall = xpcall,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create = assert(coroutine.create)\nlocal coro = setmetatable({}, { __call = function(_, fn)\n                                            return create(fn)\n                                         end })\nfor k,v in pairs(coroutine) do\n   coro[k] = v\nend\n\nN_G.coro = coro\n\n\n\nreturn N_G\n\n",
name = "G",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "453f4a50fbc00cda5c3a00b1dade142b9d23f2e837c0d1fa4d430aa9675bae68",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clade = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _basal(basis)\n   -- ignore basis for now\n   local basal = {} -- make note of this?\n   return basal\nend\nclade.basal = _basal\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _phyle(basis)\n   local phyle = {basis}\n   return phyle\nend\n\nclade.phyle = _phyle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function trait_index(mixin, field)\n   mixin[field] = {}\n   return mixin[field]\nend\n\nlocal trait_M = { __index = trait_index }\n\nfunction clade.trait(onindex)\n   local _M;\n   if onindex then\n      _M = { __index = onindex }\n   else\n      _M = trait_M\n   end\n   return setmetatable({}, _M)\nend\n\n",
name = "clade",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "d423fb42389c016555335df16eb462d9220a81d9dd1af1e9e03782e88bd851f0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal assert = assert\nlocal require = assert(require)\nlocal error   = assert(error)\nlocal getmeta, setmeta = assert(getmetatable), assert(setmetatable)\n-- I\'m going to shadow these because I\'ll forget otherwise\nlocal getmetatable, setmetatable = nil, nil\n\n\n\n\nlocal core = require \"qor:core\"\nlocal lazyloader = assert(core.module.lazyloader)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = lazyloader { \'cluster\',\n                   response = \"cluster:response\",\n                   mold     = \"cluster:mold\",\n                   contract = \"cluster:contract\",\n                   -- clade = \"cluster:clade\",\n                   -- G     = \"cluster:G\",\n                }\n\n\n\n\n\n\n\n\n\nlocal weak = assert(core.meta.weak)\n\n\n\n\n\n\n\n\n\nlocal is_seed, is_tape, is_meta = weak \'k\', weak \'k\', weak \'k\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal seed_tape, tape_seed = weak \'kv\', weak \'kv\'\nlocal tape_meta, meta_tape = weak \'kv\', weak \'kv\'\nlocal meta_seed, seed_meta = weak \'kv\', weak \'kv\'\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function register(seed, tape, meta)\n   is_seed[seed] = true\n   is_tape[tape] = true\n   is_meta[meta] = true\n   seed_tape[seed] = tape\n   tape_seed[tape] = seed\n   tape_meta[tape] = meta\n   meta_tape[meta] = tape\n   meta_seed[meta] = seed\n   seed_meta[seed] = meta\n   return seed, tape, meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function idest(pred, obj)\n   -- primitive\n   if type(pred) == \'string\' then\n      return type(obj) == pred\n   end\n   -- try new-style first\n   if type(obj) == \'table\' then\n      local _M = getmeta(obj)\n      if _M and is_meta[_M] then\n         while _M do\n            if _M.__meta.seed == pred then\n               return true\n            end\n            _M = _M.__meta.meta\n         end\n      elseif obj.idEst == pred then\n         return true\n      end\n   end\n\n   return false\nend\ncluster.idest = idest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert(pairs)\n\nlocal function genus(order)\n   local seed, tape, meta = register({}, {}, {})\n   meta.__meta = {}\n   setmeta(seed, { __index = tape })\n   if order then\n      assert(is_seed[order], \"provide constructor to extend genus\")\n      local meta_tape = seed_tape[order]\n      setmeta(tape, { __index = meta_tape })\n      local _M = seed_meta[order]\n      for k, v in pairs(_M) do\n         -- meta we copy\n         if k == \'__meta\' then\n            for _, __ in pairs(v) do\n              meta.__meta[_] = __\n            end\n         else\n            meta[k] = v\n         end\n      end\n      meta.__meta.meta = _M -- ... yep.\n   end\n   meta.__index = tape\n   meta.__meta.seed = seed\n   return seed, tape, meta\nend\n\ncluster.genus = genus\n\n\n\nlocal function order(no_table)\n   if no_table then\n      error \"calling cluster.order with a contract is NYI\"\n   end\n   return genus()\nend\n\ncluster.order = order\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compose = assert(core.fn.compose)\n\nlocal function makeconstructor(builder, meta)\n   return function(seed, ...)\n      local instance = {}\n      return setmeta(assert(builder(seed, instance, ...),\n                            \"builder must return the subject\"),\n                     meta)\n   end\nend\n\nlocal function construct(seed, builder)\n   assert(is_seed[seed], \"#1 to construct must be a seed\")\n   -- assert(iscallable(builder), \"#2 to construct must be callable\")\n   local meta = assert(seed_meta[seed], \"missing metatable for seed!\")\n   meta.__meta.builder = builder\n   getmeta(seed).__call = makeconstructor(builder, meta)\n\n   return;\nend\n\ncluster.construct = construct\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function create(seed, creator)\n   assert(is_seed[seed], \"#1 to construct must be a seed\")\n   local meta = assert(seed_meta[seed], \"missing metatable for seed!\")\n   local function _call(...)\n      return setmeta(assert(creator(...), \"creator must return subject\"), meta)\n   end\n   meta.__meta.builder = creator\n   getmeta(seed).__call = _call\nend\n\ncluster.create = create\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function extendbuilder(seed, builder)\n   assert(is_seed[seed], \"#1 to construct must be a seed\")\n   local meta = assert(seed_meta[seed], \"missing metatable for seed\")\n   local _M = meta.__meta.meta\n   if not _M then\n      error(\"can\'t extend a constructor with no inheritance, use construct\")\n   end\n   local super_build = assert(_M.__meta.builder, \"metatable missing a builder\")\n   -- true means reuse the builder\n   if builder == true then\n      meta.__meta.builder = super_build\n      getmeta(seed).__call = makeconstructor(super_build, meta)\n      return\n   end\n   -- we should assert callability here?\n\n   local function _build(seed, instance, ...)\n      local _inst = super_build(seed, instance, ...)\n      return builder(seed, _inst, ...)\n   end\n   meta.__meta.builder = _build\n\n   getmeta(seed).__call = makeconstructor(_build, meta)\nend\n\ncluster.extendbuilder = extendbuilder\n\n\n\n\n\ncluster.extend = {}\ncluster.extend.builder = extendbuilder\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal iscallable = assert(core.fn.iscallable)\nlocal rawget = assert(rawget)\n\nlocal function super(tape, message, after_method)\n   assert(is_tape[tape], \"#1 error: cluster.super extends a cassette\")\n   assert(type(message) == \'string\', \"#2 must be a string\")\n   assert(iscallable(after_method), \"#3 must be callable\")\n   -- let\'s prevent this happening twice\n   if rawget(tape, message) then\n      error(\"cassette already has \" .. message)\n   end\n   local super_method = tape[message]\n   assert(iscallable(super_method), \"super method value isn\'t callable\")\n   tape[message] = function(_tape, ...)\n                      super_method(_tape, ...)\n                      return after_method(_tape, ...)\n                   end\n   return;\nend\n\ncluster.super = super\ncluster.extend.super = super\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ur = {}\ncluster.ur = ur\n\n\n\n\n\n\n\n\nfunction ur.mu()\n   return\nend\n\n\n\n\n\n\n\n\nfunction ur.pass(...)\n   return ...\nend\n\n\n\n\n\n\n\n\nfunction ur.chain(a)\n   return a\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction ur.thru(_, ...)\n   return ...\nend\n\nur.through = ur.thru\n\n\n\n\n\n\n\n\nfunction ur.NYI()\n   error \"missing method!\"\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction ur.no()\n   return false\nend\n\n\n\nfunction ur.yes()\n   return true\nend\n\n\n\n\nreturn cluster\n\n",
name = "cluster",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "aa8c4211eafd9c5014e73c4f33d5ce676665199baf10ded5f5725ba7367bf6f9",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal basis = {}\n\n\n\n\n\n\n\n\n\n\n\nfunction basis.some(a)\n   if a then return a end\n   return nil\nend\n\n\n\nfunction basis.none(a)\n   if (not a) then\n      return (not a)\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\nfunction basis.isnil(a)\n   return (a == nil) or nil\nend\n\n\n\n\nfunction basis.isboolean(a)\n   if type(a) == \'boolean\' then return true end\n   return nil\nend\n\n\n\nfunction basis.isnumber(a)\n   if type(a) == \'number\' then return a end\n   return nil\nend\n\n\n\nfunction basis.isstring(a)\n   if type(a) == \'string\' then return a end\n   return nil\nend\n\n\n\nfunction basis.isfunction(a)\n   if type(a) == \'function\' then return a end\n   return nil\nend\n\n\n\nfunction basis.istable(a)\n   if type(a) == \'table\' then return a end\n   return nil\nend\n\n\n\nfunction basis.isthread(a)\n   if type(a) == \'thread\' then return a end\n   return nil\nend\n\n\n\nfunction basis.isuserdata(a)\n   if type(a) == \'userdata\' then return a end\n   return nil\nend\n\n\n\nfunction basis.iscdata(a)\n   if type(a) == \'cdata\' then return a end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasmetamethod = core.meta.hasmetamethod\n\n\n\nlocal hascall;\n\n\n\n\n\n\n\n\nlocal law = {}\n\n\n\ndo\n   local function lay_down_the_law(law, name, predicate)\n      local fail_str = \"argument fails \" .. name\n      law[name] = function(a)\n         return assert(predicate(a), fail_str)\n      end\n   end\n\n   for name, predicate in pairs(basis) do\n      lay_down_the_law(law, name, predicate)\n   end\nend\n\n\n\nreturn { basis = basis, law = law }\n\n",
name = "contract",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "ee9a72cd0b72cdca82c7d3ebd0235743ad6e0b13400efb07a714a186098b7cd4",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal conn = assert(require \"bridge\" . modules_conn)\n\n\n\n\n\n\n\nlocal get_all_project = [[\nSELECT project_id as project, name FROM project;\n]]\n\n\n\n\nlocal project = {}\n\nfor i, id, name in conn:prepare(get_all_project):cols() do\n   project[name] = id\nend\n\n\n\n\n\n\n\n\nlocal get_distinct_modules = [[\nSELECT DISTINCT name FROM module\nWHERE module.project = :id\nGROUP BY name\nORDER BY MAX(module.time) DESC\n]]\n\n\n\n\n\n\n\nlocal EZ = {__meta = {__keys = project}}\n\n\n\nlocal get_mods = conn:prepare(get_distinct_modules)\n\nlocal Mod_M = {}\n\nfunction EZ.__index(tab, name)\n   if project[name] then\n      local modmap = {name}\n      local modules = get_mods :bind(project[name]) :resultset \'i\' [1]\n      get_mods :clearbind() :reset()\n      local modmap = {}\n      for i, str in ipairs(modules) do\n        -- what we actually do here is kinda fun but not now\n        modmap[str] = true\n      end\n\n      return setmetatable(modmap, Mod_M)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Mod_M.__call(mod)\n   return require (mod[1] .. \":\" .. mod[1])\nend\n\n\n\n\nreturn setmetatable({}, EZ)\n\n",
name = "ezloader",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "71aeca524bc125ada792c2cbe7eee08482b41709dbfb5fc59649c55b113a0051",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function mold(_use, mention)\n   -- break out all mention categories as I write them:\n   local just = mention and mention.just\n   local function _mold(subject, use)\n      use = use or _use\n      for key, mold in pairs(use) do\n         local value = subject[key]\n         local valtype, moldtype = type(value), type(mold)\n         if value then\n            if mold == false then\n               return nil, \"subject contains forbidden key \" .. key\n            end\n            if moldtype == \'string\' then\n               if valtype ~= mold then\n                  return nil, \"subject \" .. key .. \" of type \" .. valtype\n                              .. \" not \" .. mold\n               end\n            elseif moldtype == \'table\' then\n               local molded, why = _mold(value, mold)\n               if not molded then\n                  return nil, why\n               end\n            elseif mold ~= true then\n               return nil , \"unsupported mold shape \" .. type(mold)\n            end\n         elseif mold == true then\n            return nil, \"mandatory field \" .. key .. \" is missing\"\n         end\n      end\n\n      if just then\n         for key, value in pairs(just) do\n            if subject[key] ~= value then\n               return nil, \"value of \" .. key .. \" is not \" .. tostring(value)\n            end\n         end\n      end\n\n      return subject\n   end\n\n   return _mold\nend\n\n\n\nreturn mold\n\n",
name = "mold",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "e8b9670839b4b8574d7655820b8cbaea9c3df6e69779417d0ad5cc6a6731ed51",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\n\n\n\n\n\n\n\n\n\n\n\n\nlocal autothread = require \"cluster:autothread\"\n\n\n\n\n\n\nlocal Response = {}\nResponse.__index = Response\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal running = assert(coroutine.running)\n\nlocal function new(handle)\n   s:bore(\"created a response\") --, trace %s\", debug.traceback())\n   local response = {}\n   response.co = running()\n   response.work = response.co\n   response.handle = handle\n   response.pending = true\n   return setmetatable(response, Response)\nend\n\nResponse.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResponse.isResponse = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Response.pack(response, ...)\n   response[1] = pack(...)\n   response.pending = false\n   return response\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal resume = assert(coroutine.resume)\n\nfunction Response.respond(response, ...)\n   local autothread = response.autothread or autothread\n   response:pack(...)\n   if response.work == response.co then\n      return resume(response.co, ...)\n   else\n      return autothread(response.work, ...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Response.ready(response)\n   return not response.pending\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Response.unpack(response)\n   return unpack(response[1])\nend\n\n\n\n\n\n\n\n\nfunction Response.__len(response)\n   if response.pending then\n      return 0\n   end\n\n   return #response[1]\nend\n\n\n\nreturn new\n\n",
name = "response",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
  { 
branch = "trunk",
hash = "1f257adceb24023c23cfb2a0214e50aebc158f3aa69e9d3045f5f1aa92cb29fa",
binary = "\n\n\n\n\nlocal scratch = {}\n\n\n\nlocal core = require \"qor:core\" -- last one I promise\n\n\n\n\n\nfunction scratch.just(object)\n   local err_msg = \"value is not just a \"\n                   .. type(object) .. \" \" .. tostring(object)\n   return function(tested)\n      if object == tested then\n         return true\n      end\n      return nil, err_msg\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal allpairs = assert(core.table.allpairs)\n\nlocal function bones(tab, limit)\n   assert(type(tab) == \'table\', \'can only handle tables for now\')\n   local dupes = {}\n   local count;\n   local function eviscerate(tab, depth)\n      if dupes[tab] then\n         return dupes[tab]\n      end\n      local new = {}\n      dupes[tab] = new\n      for key, value in allpairs(tab) do\n         local key_t, val_t = type(key), type(value)\n         -- we\'ll deal with the consequences of key_t someday\n         -- for instance trying to collapse the type of the array portion\n         -- in some useful cases\n         if val_t == \'table\' then\n            if depth and depth > limit then\n               new[key] = val_t\n            elseif depth then\n               new[key] = eviscerate(value, depth + 1)\n            else\n               new[key] = eviscerate(value)\n            end\n         else\n            new[key] = val_t\n         end\n      end\n\n      -- handle metatable for new and return it\n      return new\n   end\n   if limit then\n      return eviscerate(tab, 1)\n   else\n      return eviscerate(tab)\n   end\nend\nscratch.bones = bones\n\n\n\n\nreturn scratch\n\n",
name = "scratch",
vc_hash = "04194ec861bb07d3a34d3c9ca95d210510e121b2\n",
},
} },
{
  project = {
    home = "",
    repo = "git@gitlab.com:special-circumstance/core.git\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/core.git\n\n",
    name = "core",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "6a3854d3a1d0f3ed3488c615d9bea90623c6f6ac3ae4e8cb6734a9274f724766",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal s   = require \"status:status\"\ns.verbose = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function beats(roshambo, champ, loser)\n   --needs check for opposite condition,\n   --which is nilled out.\n   if roshambo._beats[loser] and\n      roshambo._beats[loser][champ] then\n      roshambo:pr \"reversal of fortune\"\n      roshambo._beats[loser] = roshambo._beats[loser] - champ\n      roshambo:pr(roshambo._beats[loser])\n   end\n   champion = roshambo._beats[champ]\n   if champion then\n      champion = champion + Set{loser}\n   else\n      champion = Set{loser}\n   end\n   roshambo._beats[champ] = champion\n   roshambo:pr(champ..\" beats \"..tostring(roshambo._beats[champ]))\nend\n\n\n\n\n\n\nlocal function duel(roshambo,champ,challenge)\n   if roshambo._duel_with then\n      roshambo:pr \"it\'s a duel!\"\n      local winner, loser = roshambo:_duel_with(champ,challenge)\n      roshambo:beats(winner,loser)\n      return winner, loser\n   else\n      roshambo:pr \"victory by fiat\"\n      roshambo:beats(champ,challenge)\n      return champ, challenge\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function duel_with(roshambo, fn)\n   roshambo._duel_with = fn\nend\n\n\n\n\n\n\n\n\nlocal function fight(roshambo, champ, challenge)\n   if roshambo._beats[champ] then\n      if roshambo._beats[champ](challenge) then\n          roshambo:pr(tostring(champ)..\" wins\")\n          return champ, challenge\n      elseif roshambo._beats[challenge] then\n         if roshambo._beats[challenge](champ) then\n            roshambo:pr(tostring(challenge)..\" wins\")\n            return challenge, champ\n         end\n      else --duel here\n         s:verb(tostring(challenge) .. \" not found\")\n         return duel(roshambo,champ,challenge)\n      end\n   else --duel here as well\n      s:verb(tostring(champ)..\" not found\")\n      return duel(roshambo, champ, challenge)\n   end\nend\n\n\n\n\n\n\n\n\nfunction roshambo_sort(roshambo, champ, challenge)\n   local victor = fight(roshambo, champ, challenge)\n   return victor == champ and true or false\nend\n\nlocal R = {}\nR.fight = fight\nR.beats = beats\nR.duel_with = duel_with\nR.sort  = roshambo_sort\n--- an alias for fight\n-- @function __call\n-- @param champ\n-- @param challenge\n-- @within metamethods\nR[\"__call\"] = fight\nR[\"__index\"] = R\nsetmetatable(R,{}) -- clu.Meta\n\n--- instantiates a roshambo\n-- @function Roshambo\n-- @param init a optional table of champ/loser key/value pairs.\n-- @return an instance of roshambo\nlocal function Roshambo(init)\n   local rosh = {}\n   rosh._beats = {}\n   if init then\n      if type(init) == \"table\" then\n         for i,v in pairs(init) do\n            rosh._beats[i] = Set{v}\n         end\n      else\n         error(\"Roshambo must be initialized with a table\")\n      end\n   end\n   setmetatable(rosh,R)\n   rosh.foo = \"bar\"\n   return rosh\nend\n\n\n\nreturn Roshambo\n\n",
name = "core/cluster/roshambo",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "bc509c41590807b8fb366915ae5ecde7ed2d9f5d109c5bc7bb86eb2deccacf8b",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal _Message_fields = {\n   method  = true,\n   message = true,\n   sendto  = true,\n   call    = true,\n}\n\n",
name = "core/cluster/mold",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "66e67677a494c534aae88fa23dad086a084ce200c8d45ba76e6882e9f4932322",
binary = "\n\n\n\n\n\n\n\n\n\nlocal _base = {}\n\n\n\n\n\n\n\n\n\n\nfunction _base.no_op()\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction _base.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction _base.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...), 2)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction _base.iscallable(val)\n   if type(val) == \'function\' then return true end\n   if type(val) == \'table\' then\n      local M = getmetatable(val)\n      if M and rawget(M, \"__call\") then\n         return true\n      end\n   end\n   return false\nend\n\n\n\nreturn _base\n\n",
name = "core/_base",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "d19df2dcc1031aebb22e2ee17b675a51c1e7f2d2cf9620379c4e21ac88e81b4e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal elpatt = require \"espalier:elpatt\"\nlocal C, P, R, S = assert(L.C), assert(L.P), assert(L.R), assert(L.S)\nlocal gsub, M = assert(elpatt.gsub), assert(elpatt.M)\n\n\n\n\nlocal escape_module = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_map = {\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nlocal function _generic_escape(ch)\n   return (\"\\\\x%02x\"):format(ch:byte())\nend\n\nlocal needs_escape = M(escape_map) + (R\"\\x00\\x1f\" + P\"\\x7f\") / _generic_escape\n\nfunction escape_module.escape(str, quotes)\n   local patt = needs_escape\n   if quotes then\n      patt = S(quotes) / \"\\\\%0\" + patt\n   end\n   return gsub(str, patt)\nend\n\nfunction escape_module.escape_char(ch, quotes)\n   local escaped = escape_map[ch]\n   if escaped then\n      return escaped\n   elseif quotes and quotes:find(ch) then\n      return \"\\\\\" .. ch\n   elseif ch:find(\"%c\") then\n      return _generic_escape(ch)\n   else\n      return ch\n   end\nend\n\n\n\n\n\n\n\n\nlocal char = assert(string.char)\n\nlocal unescape_map = {}\nfor k, v in pairs(escape_map) do\n   unescape_map[v] = k\nend\n\nlocal higit = R\"09\" + R\"af\"\n\nlocal escaped_char = M(unescape_map) +\n                     (P\"\\\\\" * C(S\"\'\\\"[]\")) / 1 +\n                     (P\"\\\\x\" * C(higit * higit)) / function(hex)\n                        return char(tonumber(\"0x\" .. hex))\n                     end\n\nfunction escape_module.unescape(str)\n   return gsub(str, escaped_char)\nend\n\n\n\nreturn escape_module\n\n",
name = "core/string/escape",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "7e64796a80b79f1e3f3924a93fa562a66218b47a73a056c2d4516062dc375b5d",
binary = "\n\n\n\n\n\n\nPrint = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\nlocal floor, max = assert(math.floor), assert(math.max)\nlocal inbounds = assert(require \"core:math\" . inbounds)\n\nlocal split_at = {}\nfor _, v in ipairs{\" \", \"-\", \"(\", \"{\", \"[\"} do\n   split_at[v] = v == \" \" and -1 or 0\nend\n\nfunction Print.breakascii(str, width)\n   if #str <= width then\n      return str, 1, #str\n   end\n   local lines = {}\n   local actual_width = 0\n   local left = 1\n   local min_width = floor(width / 2)\n   while left <= #str do\n      local min_right = left + min_width - 1\n      local max_right = left + width - 1\n      local line\n      if max_right >= #str then\n         line = str:sub(left)\n         lines[#lines + 1] = line\n         actual_width = max(actual_width, #line)\n         break\n      end\n      local split_index, offset\n      -- Check one past the max width because we might be able to\n      -- remove a trailing space\n      for i = max_right + 1, min_right, -1 do\n         offset = split_at[str:sub(i, i)]\n         -- But now we do need to check if we\'ll actually be in bounds\n         if offset and inbounds(i + offset, min_right, max_right) then\n            split_index = i\n            break\n         end\n      end\n      if not split_index then\n         -- Didn\'t find a natural breakpoint, just chop at the max width\n         split_index = max_right\n         offset = 0\n      end\n      line = str:sub(left, split_index + offset)\n      lines[#lines + 1] = line\n      actual_width = max(actual_width, #line)\n      left = split_index + 1\n   end\n   return concat(lines, \"\\n\"), #lines, actual_width\nend\n\n\n\n\nfunction Print.center(str, width)\n   local diff = width - #str\n   local lmargin, rmargin\n   if diff % 2 ~= 0 then\n      lmargin, rmargin = math.floor(diff / 2), math.floor(diff / 2) + 1\n   else\n      lmargin, rmargin = diff / 2, diff / 2\n   end\n   return  (\" \"):rep(lmargin) .. str .. (\" \"):rep(rmargin)\nend\n\n\n\n\nreturn Print\n\n",
name = "core/string/print",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "f58508da224a283c9334e3a54d24409330ee56b4d2f1f39092e09dfec99734f4",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:_base\"\nlocal iscallable = assert(_base.iscallable)\n\n\n\n\n\n\nlocal act = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __act_mth_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.borrowmethod(actor, method)\n   assert(iscallable(method) or type(method) == \'string\',\n          \"#2 for borrowmethod must be string or callable\")\n   local uid = {}\n   __act_mth_attr[uid] = actor\n   actor = nil\n   if type(method) == \'string\' then\n      -- return a lookup function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return _actor[method](_actor, ...)\n      end\n   else\n      -- return a direct-call function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return method(_actor, ...)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal __act_getter_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.getter(actor, slot)\n   local uid = {}\n   __act_getter_attr[uid] = actor\n   actor = nil\n   return function()\n             local _actor = __act_getter_attr[uid]\n             if not _actor then\n                error \"actor has gone out of scope\"\n             end\n             return _actor[slot]\n          end\nend\n\n\n\n\n\n\n\n\n\nlocal gmatch = assert(string.gmatch)\nlocal function dispatchmessage(actor, msg)\n   local result\n   while msg do\n      -- #todo replace this with construction-time translation to nested message?\n      if msg.sendto then\n         for prop in gmatch(msg.sendto, \"([^.]+)[.]?\") do\n            actor = actor[prop]\n         end\n      end\n      if msg.property then\n         result = pack(actor[msg.property])\n      elseif msg.call == true then\n         result = pack(actor(unpack(msg)))\n      elseif msg.call then\n         local fn = actor[msg.call]\n         if not fn then\n            -- #todo this leaves out useful information in the case of a\n            -- nested message, and also doesn\'t know how to represent the\n            -- starting/root actor. We really want to stringify the whole\n            -- chain in a meaningful way\n            error(\"attempt to call a nil function \" .. msg.call\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(unpack(msg)))\n      elseif msg.method then\n         local fn = actor[msg.method]\n         if not fn then\n            -- Similar concern as with .call, also this is annoyingly similar\n            error(\"attempt to call a nil method \" .. msg.method\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(actor, unpack(msg)))\n      else\n         error(\"Message must have one of property, call, or method: \" .. (require \"repr:repr\".ts(msg)))\n      end\n      actor = result[1]\n      msg = msg.message\n   end\n   return unpack(result)\nend\nact.dispatchmessage = dispatchmessage\n\n\n\n\n\nreturn act\n\n",
name = "core/cluster/actor",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "acccd1623d0dffb0b48927c84425313dafc8d8fb119957ef8d637026a5a98b77",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal act = require \"core:core/cluster/actor\"\n\n\n\n\n\n\nlocal cluster = {}\n\nfor k, v in pairs(act) do\n   cluster[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal isempty = table.isempty\n                or\n                function(tab)\n                   local empty = true\n                   for _, __ in next, tab, nil do\n                      empty = false\n                      break\n                   end\n                   return empty\n                end\n\nfunction cluster.Meta(Meta)\n   if Meta and Meta.__index then\n      -- inherit\n      local tab = {}\n      for field, value in next, Meta, nil do\n         if sub(field, 1, 2) == \"__\" then\n            tab[field] = value\n         end\n      end\n      if Meta.__meta then\n         tab.__meta = tab.__meta or {}\n         for _, __ in next, Meta.__meta, nil do\n            tab.__meta[_] = __\n         end\n      end\n      tab.__index = tab\n      return setmetatable(tab, Meta)\n\n   elseif Meta\n      and type(Meta) == \'table\'\n      and isempty(Meta) then\n      -- decorate\n      Meta.__index = Meta\n      return Meta\n   elseif not Meta then\n      local _M = {}\n      _M.__index = _M\n      return _M\n   end\n   error (\"cannot make metatable from type\" .. type(Meta))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.constructor(mt, new, instance)\n   instance = instance or {}\n   if new then\n      mt.__call = new\n   elseif not mt.__call then\n      error \"nil metatable passed to constructor without __call metamethod\"\n   end\n\n   local constructor = setmetatable(instance, mt)\n   mt.idEst = constructor\n   return constructor\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\n\n\nfunction cluster.methodchain(method, key_method)\n\n   -- per-method cache of the value-caller\n   local _cache = {}\n\n   local function value__call(value_catch, value, ...)\n      method(value_catch[1], value_catch[2], value, ...)\n      value_catch[2] = nil\n      return remove(value_catch)\n   end\n\n   return function (obj, first)\n      local launch;\n\n      if key_method then\n         obj, first = key_method(obj, first)\n      end\n      if #_cache == 0 then\n         _cache[1], _cache[2] = obj, first\n         launch = _cache\n      else\n         launch = {obj, first}\n         -- we do this optimistically, figuring most method chains complete\n         -- and ones which don\'t, might not\n         _cache = launch\n      end\n      return setmetatable(launch, { __call = value__call })\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.indexafter(idx_fn, idx_super)\n   if type(idx_super) == \'table\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super[key]\n         end\n      end\n   elseif type(idx_super) == \'function\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super(tab,key)\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _instances = setmetatable({}, { __mode = \'k\'})\n\nfunction cluster.instancememo(instance, message)\n   local memos = { [message] = {} }\n   -- grab the method, we\'re going to need it later\n   local method = instance[message]\n   _instances[instance] = memos\n   local function memo_method(inst, p, ...)\n      local param_set = assert(_instances[inst][message],\n                             \"missing instance or message\")\n      local results = param_set[p]\n      if results then return unpack(results) end\n\n      results = pack(method(inst, p, ...))\n      param_set[p] = results\n      return unpack(results)\n   end\n   instance[message] = memo_method\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--| if =fn= exists, bind fn(obj, ...)\nlocal function _maybe_bind(obj, fn)\n  if not fn then return nil end\n  return function(...)\n     return fn(obj, ...)\n  end\nend\n\nlocal function _get_idx(obj)\n   local M = getmetatable(obj)\n   return M and M.__index\nend\n\nfunction cluster.super(obj, field)\n   local super_idx\n   -- If the object has such a field directly, consider the implementation\n   -- from the metatable to be the \"super\" implementation\n   if rawget(obj, field) then\n      super_idx = _get_idx(obj)\n   -- Otherwise, look one step further up the inheritance chain\n   else\n      local M_idx = _get_idx(obj)\n      super_idx = type(M_idx) == \'table\' and _get_idx(M_idx) or nil\n   end\n   if super_idx then\n      return type(super_idx) == \'table\'\n         and _maybe_bind(obj, super_idx[field])\n         or  _maybe_bind(obj, super_idx(obj, field))\n   end\n   -- No superclass, or our class uses an __index function so we can\'t\n   -- meaningfully figure out what to do\n   return nil\nend\n\n\n\n\nreturn cluster\n\n",
name = "core/cluster",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "26107ce88da0dfe67365e5617940c541defa5b93624f99f7d5fb97f50b33550d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal fn = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _curried = setmetatable({}, { __mode = \'k\' })\n\nlocal currier = {\n   false, -- this shouldn\'t happen\n   function(fn, a, b) -- [2]\n      return function(...)\n         return fn(a, b, ...)\n      end\n   end,\n   function(fn, a, b, c) -- [3]\n      return function(...)\n         return fn(a, b, c, ...)\n      end\n   end,\n   function(fn, a, b, c, d) -- [4]\n      return function(...)\n         return fn(a, b, c, d, ...)\n      end\n   end,\n   function(fn, a, b, c, d, e) -- [5]\n      return function(...)\n         return fn(a, b, c, d, e, ...)\n      end\n   end,\n}\n\nlocal function curry(fn, param)\n   assert(type(fn) == \'function\' or\n          type(fn) == \'table\' and getmetatable(fn).__call,\n          \'#1 of curry must be a function or callable table\')\n   local curried;\n   local pre = _curried[fn]\n   if not pre then\n      curried = function(...) return fn(param, ...) end\n      _curried[curried] = { param, n = 1 , fn = fn }\n   else\n      if pre.n <= 4 then\n         local post = {}\n         for i = 1, pre.n do\n            post[i] = pre[i]\n         end\n         post.n = pre.n + 1\n         post.fn = pre.fn\n         post[post.n] = param\n         curried = currier[post.n](post.fn, unpack(post, 1, post.n))\n         _curried[curried] = post\n      else\n         curried = function(...) return fn(param, ...) end\n      end\n   end\n\n   return curried\nend\n\nfn.curry = curry\n\n\n\n\n\n\n\n\n\n\nfn.thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.deferSend(obj, msg, ...)\n   assert(type(obj) == \'table\', \"#1 to deferSend must be a table\")\n   assert(type(msg) == \'string\', \"#2 to deferSend must be a string\")\n   local packed = pack(...)\n   return function()\n      return obj[msg](obj, unpack(packed))\n   end\nend\n\n\n\n\n\n\n\n\nfn.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.partial(fn, ...)\n   for i = 1, select(\'#\', ...) do\n      fn = curry(fn, select(i, ...))\n   end\n   return fn\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.itermap(fn, iter)\n   local ret, res = {}\n   while true do\n      res = pack(fn(iter()))\n      if #res == 0 then\n         return ret\n      else\n         ret[#ret + 1] = res\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _dynamics_call = setmetatable({}, {__mode = \'k\'})\nlocal _dynamics_registry  = setmetatable({}, {__mode = \'kv\'})\n\nlocal function dynamic(fn)\n   -- make a unique table as key\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local function dyn_fn(...)\n      return _dynamics_call[uid](...)\n   end\n   _dynamics_registry[dyn_fn] = uid\n   return dyn_fn\nend\n\nfn.dynamic = dynamic\n\n\n\n\n\n\n\n\n\nfunction fn.patch_dynamic(dyn_fn, fn)\n   assert(_dynamics_registry[dyn_fn], \"cannot patch a non-dynamic function\")\n   local uid = _dynamics_registry[dyn_fn]\n   _dynamics_call[uid] = fn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _pre_hook, _post_hook = setmetatable({}, {__mode = \'k\'}),\n                              setmetatable({}, {__mode = \'k\'})\n\nlocal function _call_with_hooks(uid, ...)\n   local fn = _dynamics_call[uid]\n   assert(fn, \"_dynamics_call is missing a hookable function\")\n   local pre, post = _pre_hook[uid], _post_hook[uid]\n\n   if pre and post then\n      local new_arg = pack(pre(...))\n      local rets = pack(fn(unpack(new_arg)))\n      -- make into one pack, because you can only apply multiple arguments at\n      -- the end of a function call\n      for i = 1, rets.n do\n         new_arg[#new_arg + 1] = rets[i]\n      end\n      new_arg.n = new_arg.n + rets.n\n      return post(unpack(rets))\n   elseif pre then\n      return fn(pre(...))\n   elseif post then\n      local args, rets = pack(...), pack(fn(...))\n      -- same trick here...\n      for i = 1, args.n do\n         rets[#rets + 1] = args[i]\n      end\n      rets.n = rets.n + args.n\n      return post(unpack(rets))\n   else\n      return fn(...)\n   end\nend\n\nlocal function prehook(hooked, pre_hook)\n   _pre_hook[_dynamics_registry[hooked]] = pre_hook\nend\n\nlocal function posthook(hooked, post_hook)\n   _post_hook[_dynamics_registry[hooked]] = post_hook\nend\n\nfn.prehook, fn.posthook = prehook, posthook\n\nfunction fn.hookable(fn, pre, post)\n   -- make a uid, add to _dynamics_call\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local hookable = function(...)\n                       return _call_with_hooks(uid, ...)\n                    end\n   -- register the hookable in the dynamics registry\n   _dynamics_registry[hookable] = uid\n   return hookable\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfn.assertfmt = _base.assertfmt\n\n\n\nreturn fn\n\n",
name = "core/fn",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "89b137bd96939d355e731786a4fbf19d1202ea42d04f4b75cfbf29d4a7d09592",
binary = "\n\n\n\n\nlocal Debug = {}\n\nfor k,v in pairs(assert(debug)) do\n   Debug[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal getupvalue, getinfo = assert(debug.getupvalue), assert(debug.getinfo)\n\nlocal function _findrefs(copies, val, dupes, subject)\n   if dupes[subject] then return end\n   dupes[subject] = true\n   local function test_one(test, container)\n      -- check key first\n      if rawequal(test, val) then\n         copies[#copies + 1] = container\n         copies.n = copies.n + 1\n      end\n      if type(test) == \'table\' then\n         if not dupes[test] then\n            _findrefs(copies, val, dupes, test)\n         end\n      elseif type(test) == \'function\' then\n         -- look in the upvalues\n         if not copies[test] then\n            dupes[test] = true\n            local name, ups, idx = \"\", true, 1\n            while ups ~= nil do\n               name, ups = getupvalue(test, idx)\n               if name == nil then\n                  ups = nil\n               else\n                  if ups == val then\n                     copies[#copies + 1] = debug.getinfo(test)\n                     copies.n = copies.n + 1\n                  end\n                  if type(ups) == \'table\' or type(ups) == \'function\'\n                     and (not dupes[ups]) then\n                     _findrefs(copies, val, dupes, ups)\n                  end\n                  idx = idx + 1\n               end\n            end\n         end\n         dupes[test] = true\n      end\n   end\n   if type(subject) == \'function\' then\n      test_one(subject)\n   elseif type(subject) == \'table\' then\n      for k, v in next, subject do\n         test_one(k, subject)\n         test_one(v, subject)\n      end\n      local _M = getmetatable(subject)\n      if _M then\n         _findrefs(copies, val, dupes, _M)\n      end\n   end\n   return copies\nend\n\nfunction Debug.findrefs(val)\n   local dupes = {}\n   return unpack(_findrefs({n = 0}, val, dupes, getfenv(1)))\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _tracer(tab)\n   return tab[1]\nend\n\nlocal lines;\nlocal function _repr(tab, window, c)\n   lines = lines or require \"core:core/string\" . lines\n   return lines(tab[1])\nend\n\nlocal __trace_M = { __repr = _repr,\n                    __tostring = _tracer}\n\nlocal traceback = assert(debug.traceback)\n\nfunction Debug.reprtrace(msg)\n   local trace;\n   if not msg then\n      trace = traceback(\"\", 2):sub(2)\n   else\n      trace = traceback(msg, 2)\n   end\n   return setmetatable({trace}, __trace_M)\nend\n\n\n\n\nreturn Debug\n\n",
name = "core/debug",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "70febee49581cca907e3f422d832a6bf4d007caf11c751c94ba8849eff6be395",
binary = "\n\n\n\n\n\n\nlocal next = assert(next) -- !\n\nlocal Env = {}\nfunction Env.fenv(...)\n   local _env = {}\n   local f = unpack(...)\n   if not f then return _env end\n   if f then\n      for k,v in next, f, nil do\n         _env[k] = v\n      end\n      return _env\n   end\nend\n\n\n\nreturn Env\n\n",
name = "core/env",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "9238fa5e52f7f63e0ee8a1ac4e36c78484461ad151a51c4c940294feaede60d0",
binary = "\n\n\nlocal coro = {}\n\n\n\n\nlocal _base = require \"core:core/_base\"\nlocal thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\nlocal coro = {}\nfor k,v in next, coroutine do\n   coro[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction coro.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction coro.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction coro.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coro.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal running = assert(coroutine.running)\n\nfunction coro.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\n\nreturn coro\n\n",
name = "core/coro",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "5d2b2c4f1552dc0c7405f5320db001b80c6c7a236d444b184f0a251df09b70fb",
binary = "\n\n\nlocal Math = {}\n\n\n\n\n\n\n\n\nfunction Math.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\n\n\nlocal assertfmt = assert(require \"core:_base\" . assertfmt)\nfunction Math.clamp(value, lower, upper)\n   if lower and upper then\n      assertfmt(lower <= upper, \"Clamp range must be nonempty (lower <= upper), got (%d, %d)\", lower, upper)\n   end\n   if lower and value < lower then\n      value = lower\n   end\n   if upper and value > upper then\n      value = upper\n   end\n   return value\nend\n\n\n\n\nreturn Math\n\n",
name = "core/math",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "8b1b76c7741f0a6bfe57be9954444b966491f61ebed4cf0c0e0b88d81eeac1f0",
binary = "\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\nlocal meta = require \"core/meta\"\nlocal Tab = {}\nfor k, v in pairs(table) do\n   Tab[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal N_M = {}\nN_M.__index = N_M\n\nfunction N_M.__len(tab)\n   return tab.n\nend\n\nfunction N_M.__ipairs(tab)\n   local i = 1\n   return function()\n      if i >= tab.n then return nil end\n      i = i + 1\n      return i - 1, tab[i - 1]\n   end\nend\n\nfunction Tab.n_table(tab, djikstra)\n   tab = tab or {}\n   tab.n = 0\n   return setmetatable(tab, N_M)\nend\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction Tab.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(tab, field)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(maybeIndex, field)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if success and result ~= nil then\n            return result\n         end\n      end\n   end\n   return nil\nend\n\nlocal function _hf__index(_, field)\n   return function(tab)\n      return _hasfield(tab, field)\n   end\nend\n\nlocal function _hf__call(_, tab, field)\n   return _hasfield(tab, field)\nend\n\nTab.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive \" .. tostring(depth))\n   local clone = {}\n   for k,v in next, tab do\n      if depth > 1 and type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return setmetatable(clone, getmetatable(tab))\nend\nTab.clone = _clone\n\n\n\n\n\n\n\n\nfunction Tab.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            -- copy the metatable after, in case it contains\n            -- __index or __newindex behaviors\n            copy = setmetatable(copy, _deep(getmetatable(val)))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.cloneinstance(tab)\n   assert(type(tab) == \"table\",\n          \"cannot cloneinstance of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            copy = setmetatable(copy, getmetatable(val))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.isarray(tab)\n   local i = 1\n   for k,_ in next, tab do\n      if k ~= i then return false end\n      i = i + 1\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Tab.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert (could be =insert(ret, (fn(val)))=...)\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.compact(tab, n)\n   n = assert(n or tab.n, \"a numeric value must be provided for non-ntables\")\n   local cursor, slot, empty = 1, nil, nil\n   while cursor <= n do\n      slot = tab[cursor]\n      if slot == nil and empty == nil then\n         -- mark the empty position\n         empty = cursor\n      end\n      if slot ~= nil and empty ~= nil then\n         tab[empty] = slot\n         tab[cursor] = nil\n         cursor = empty\n         empty = nil\n      end\n      cursor = cursor + 1\n   end\n   if tab.n then\n      tab.n = #tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.inverse(tab)\n   local bat = {}\n   for k,v in pairs(tab) do\n      if bat[v] then\n         error(\"duplicate value on key \" .. k)\n      end\n      bat[v] = k\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.flatten(tab, level)\n   local ret, copies = {}, {}\n   local function _flat(t, depth)\n      if level and depth > level then\n         ret[#ret + 1] = t\n         return nil\n      end\n      for _,v in ipairs(t) do\n         if type(v) ~= \"table\" then\n            ret[#ret + 1] = v\n         else\n            if not copies[v] then\n               copies[v] = true\n               _flat(v, depth + 1)\n            end\n         end\n      end\n   end\n   _flat(tab, 0)\n   return ret\nend\n\n\n\n\n\n\n\n\n\nTab.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\nfunction Tab.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _select(collection, tab, key, cycle)\n   cycle = cycle or {}\n   for k,v in pairs(tab) do\n      if key == k then\n         collection[#collection + 1] = v\n      end\n      if type(v) == \"table\" and not cycle[v] then\n         cycle[v] = true\n         collection = _select(collection, v, key, cycle)\n      end\n   end\n   return collection\nend\n\nfunction Tab.select(tab, key)\n   return _select({}, tab, key)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.keysort(a, b)\n   if (type(a) == \'string\' and type(b) == \'string\')\n      or (type(a) == \'number\' and type(b) == \'number\') then\n      return a < b\n   elseif type(a) == \'number\' and type(b) == \'string\' then\n      return false\n   elseif type(a) == \'string\' and type(b) == \'number\' then\n      return true\n   elseif type(a) == \'string\' or type(a) == \'number\' then\n      -- we want these tags at the bottom\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.deleterange(tab, start, stop)\n   if start > stop then return end\n   local offset = stop - start + 1\n   for i = start, #tab do\n      tab[i] = tab[i + offset]\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local keys = {}\n   for k, _ in pairs(tab) do\n      keys[#keys + 1] = k\n   end\n\n   return keys, #keys\nend\n\n\n\n\n\n\nfunction Tab.values(tab)\n   assert(type(tab) == \"table\", \"values must receive a table\")\n   local vals = {}\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nlocal function push(queue, x)\n   queue.tail = queue.tail + 1\n   queue[queue.tail] = x\nend\n\nlocal function pop(queue)\n   if queue.tail == queue.head then return nil end\n   queue.head = queue.head + 1\n   return queue[queue.head]\nend\n\nfunction Tab.splice(tab, index, to_add)\n   assert(type(tab) == \"table\", _e_1)\n   if to_add == nil then\n      to_add = index\n      index = nil\n   end\n   if index == nil then\n      index = #tab + 1\n   end\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n\n   index = index - 1\n   local queue = { head = 0, tail = 0}\n   local i = 1\n   -- replace elements, spilling onto queue\n   for j = 1, #to_add do\n      push(queue, tab[i + index])\n      tab[i + index] = to_add[j]\n      i = i + 1\n   end\n   -- run the queue up the remainder of the table\n   local elem = pop(queue)\n   while elem ~= nil do\n      push(queue, tab[i + index])\n      tab[i + index] = elem\n      i = i + 1\n      elem = pop(queue)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compact, splice = Tab.compact, Tab.splice\n\nfunction Tab.replace(tab, index, to_add, span)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n   span = span or #to_add\n   -- easiest to handle the three cases as distinct.\n   if span == #to_add then\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n   elseif span > #to_add then\n      local top = #tab\n      -- replace #to_add worth of elements\n      for i = index, index + #to_add - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- nil out remaining elements\n      for i = index + #to_add, index + span - 1 do\n         tab[i] = nil\n      end\n      compact(tab, top)\n   else -- if span < #to_add\n      -- replace span worth of elements\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- make a table to hold the rest, copy\n      local spill = {}\n      for i = 1, #to_add - span do\n        spill[i] = to_add[i + span]\n      end\n      splice(tab, index + span, spill)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.addall(tab, to_add)\n   for k, v in pairs (to_add) do\n      tab[k] = v\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.pget(tab, key)\n   local ok, val = pcall(function() return tab[key] end)\n   if ok then\n      return val\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.safeget(tab, key)\n   while tab ~= nil do\n      local val = rawget(tab, key)\n      if val ~= nil then return val end\n      local M = getmetatable(tab)\n      if M then\n         tab = rawget(M, \'__index\')\n         if type(tab) ~= \'table\' then\n            return nil\n         end\n      else\n         tab = nil\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.fromkeys(tab, ...)\n   local answer = {}\n   local keys = pack(...)\n   for _, k in ipairs(keys) do\n      answer[k] = tab[k]\n   end\n   return answer\nend\n\n\n\nreturn Tab\n\n",
name = "core/table",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "a49f5f894fcf917e4ad09e8f264f2d7799601abda568c94c5d4a4833ac0e803e",
binary = "\n\n\n\n\n\nlocal Mod = {}\n\n\n\n\nlocal assert = assert(require \"core:core/_base\" . assertfmt)\nlocal require, pack, unpack = assert(require), assert(pack), assert(unpack)\n\n\n\n\n\n\n\n\n\n\n\nfunction Mod.import(req_str, ...)\n   local mod = require(req_str)\n   local fields, exports = pack(...), {}\n   for i = 1, fields.n do\n       exports[i] = assert(mod[fields[i]], \"can\'t require %s\", fields[i])\n   end\n   exports.n = fields.n\n   return unpack(exports)\nend\n\n\n\n\n\n\n\n\nlocal pcall = assert(pcall)\n\nfunction Mod.request(module)\n   local ok, mod = pcall(require, module)\n   if ok then\n      return mod\n   else\n      return nil\n   end\nend\n\n\n\nreturn Mod\n\n",
name = "core/module",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "869b8923596bba84e6ecc6b057ccadd03b7f9e6956606b151aebb38746b951ec",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mods = {}\nlocal core = {}\nlocal insert = assert(table.insert)\ninsert(mods, require \"core:core/cluster\")\ninsert(mods, require \"core:core/coro\")\ninsert(mods, require \"core:core/fn\")\ninsert(mods, require \"core:core/math\")\ninsert(mods, require \"core:core/meta\")\ninsert(mods, require \"core:core/module\")\ninsert(mods, require \"core:core/string\")\ninsert(mods, require \"core:core/table\")\ninsert(mods, require \"core:core/thread\")\ninsert(mods, require \"core:core/env\")\ninsert(mods, require \"core:core/uv\")\n\nfor _, mod in ipairs(mods) do\n   for k,v in pairs(mod) do\n      core[k] = v\n   end\nend\nreturn core\n\n",
name = "core",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "8a282fc2970e23856075b573ca8f19e0c4ee03774676a5dc44360e495ba8a0ee",
binary = "\n\n\n\n\n\n\nlocal assert = assert or error \"no assert\"\n\nlocal Uv = {}\n\nlocal uv = assert(require \"luv\")\n\n\n\n\n\n\n\n\n\n\nfunction Uv.deferby(event, ms)\n   ms =  ms or 0\n   local timer = uv.new_timer()\n\n   local _event = function()\n      event()\n      timer:stop()\n   end\n\n   timer:start(ms, 0, _event)\n\n   return;\nend\n\n\n\n\nreturn Uv\n\n",
name = "core/uv",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "464f9248847a57c1d881f512821753d26349d30bf04fdfa61709c795635fafbd",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal meta = {}\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   if sub(mmethod,1,2) == \"__\" then\n      return rawget(M, mmethod)\n   else\n      return rawget(M, \"__\" .. mmethod)\n   end\nend\n\nmeta.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\nfunction meta.instanceof(obj, Class)\n   if type(Class) == \'string\' then\n      return type(obj) == Class\n   else\n      return type(obj) == \'table\' and obj.idEst == Class\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.weak(mode)\n   mode = mode or \'kv\'\n   return setmetatable({}, { __mode = mode })\nend\n\n\n\nreturn meta\n\n",
name = "core/meta",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "2017c116e0450f5e8c91391cffdf6efbedf44c529b77cddcc908e19b940ebd09",
binary = "\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal thread = {}\n\n\n\nlocal running, yield = assert(coroutine.running),\n                       assert(coroutine.yield)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.onloop()\n   local _, main = running()\n   return main and uv.loop_alive()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\nreturn thread\n\n",
name = "core/thread",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
  { 
branch = "trunk",
hash = "2205c7fda0bb2d18f902dfbd0d15ca37773cafa6dcc5875d1bc700e67d89ed78",
binary = "\n\n\n\n\n\n\nlocal String = {}\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/_base\".assertfmt\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nfor k, v in next, string do\n  String[k] = v\nend\n\n\n\n\n\n\n\n\n\nString.assertfmt = assertfmt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction String.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.findall(str, patt)\n   local find = type(str) == \'string\' and find or str.find\n   local matches = {}\n   local index = 1\n   local left, right\n   repeat\n     left, right = find(str, patt, index)\n     if left then\n        matches[#matches + 1] = {left, right}\n        index = right + 1\n     end\n   until left == nil\n   if #matches > 0 then\n      return matches\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction String.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction String.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\nString.cleave = cleave\n\n\n\n\n\n\n\n\n\n\nlocal find = assert(string.find)\nfunction String.isidentifier(str)\n   return find(str, \"^[a-zA-Z_][a-zA-Z0-9_]+$\") == 1\nend\n\n\n\n\n\n\n\nfunction String.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction String.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, _str_M)\nend\n\n\n\n\n\n\n\n\n\n\nfunction String.slurp(filename)\n  local f = io.open(tostring(filename), \"rb\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.spit(filename, file)\n  local f = io.open(tostring(filename), \"w+\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local ok = f:write(file)\n  f:close()\nend\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction String.splice(to_split, to_splice, index)\n   assert(type(to_split) == \"string\", \"bad argument #1 to splice: \"\n           .. \"string expected, got %s\", type(to_split))\n   assert(type(to_splice) == \"string\", \"bad argument #2 to splice: \"\n           .. \"string expected, got %s\", type(to_splice))\n   assert(type(index) == \"number\", \"bad argument #2 to splice: \"\n          .. \" number expected, got %s\", type(index))\n   assert(index >= 0 and index <= #to_split, \"splice index out of bounds\")\n   local head, tail = sub(to_split, 1, index), sub(to_split, index + 1)\n   return head .. to_splice .. tail\nend\n\n\n\nreturn String\n\n",
name = "core/string",
vc_hash = "a616e311745112bc372386bcd705d470dcf564d4\n",
},
} },
{
  project = {
    home = "",
    repo_type = "git",
    repo_alternates = "",
    name = "cursory",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "f60a5db398ad8f34754971f8bcb4fc6e07b5c86ca02915e55a290c519811a992",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table = core.table\n\n\n\nlocal style = require \"cursory:term/style\"\n\n\n\nlocal Palette = meta {}\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(table.cloneinstance)\n\nfunction Palette.__newindex(palette, name, color)\n   color = type(color) == \'table\' and cloneinstance(color) or color\n   if type(color) == \'table\' then\n      color.name = name\n   end\n   rawset(palette, name, color)\nend\n\n\n\n\n\n\n\n\nlocal function __index(palette, _)\n   return palette[1] or nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Palette.change(palette, name, color)\n   local old_c = palette[name]\n   color = cloneinstance(color)\n   color.name = name\n   palette[name] = color\n   if not old_c then\n      return false\n   end\n   for n, c in pairs(palette) do\n      if c.kind == \'embedded\'\n         and c.reset == old_c\n         and c.reset.name == old_c.name then\n         c.reset = color\n      end\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(color_tab)\n   local palette = setmetatable({}, Palette)\n   if color_tab then\n      for name, color in pairs(color_tab) do\n         palette[name] = color\n      end\n   end\n   return palette\nend\n\nPalette.idEst = new\n\n\n\n\nreturn new\n\n",
name = "term/palette",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "f1cea2db909de2e39b80d916576cd3f8a9cebb29a861c58841df0c541cceec48",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal box_parts = { \"horiz\", \"vert\",\n                    \"tl_square\", \"tr_square\", \"bl_square\", \"br_square\",\n                    \"left_tee\", \"top_tee\", \"right_tee\", \"bottom_tee\", \"cross\" }\nlocal boxen = {}\n\n\n\n\n\n\n\n\nboxen.light = { \"─\", \"│\",\n                \"┌\", \"┐\", \"└\", \"┘\",\n                \"├\", \"┬\", \"┤\", \"┴\", \"┼\" }\n\n\n\n\n\n\n\n\nboxen.heavy = { \"━\", \"┃\",\n                \"┏\", \"┓\", \"┗\", \"┛\",\n                \"┣\", \"┳\", \"┫\", \"┻\", \"╋\" }\n\n\n\n\n\n\n\n\nboxen.double = { \"═\", \"║\",\n                 \"╔\", \"╗\", \"╚\", \"╝\",\n                 \"╠\", \"╦\", \"╣\", \"╩\", \"╬\" }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal Rectangle = require \"cursory:shape/rectangle\"\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal jump = assert(require \"anterm:cursor\" . jump)\nlocal Box = meta {}\n\n\n\n\n\n\n\n\nlocal function _addLineUsing(phrase, left, middle, right, line, ...)\n   local column_widths = {...}\n   for i, cols in ipairs(column_widths) do\n      insert(phrase, i == 1 and left or middle)\n      insert(phrase, line:rep(cols))\n   end\n   insert(phrase, right)\nend\n\nlocal function _lineUsing(box, fn, ...)\n   local phrase = {}\n   box[fn](box, phrase, ...)\n   return concat(phrase)\nend\n\nfunction Box.addTopLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.tl_square, box.top_tee, box.tr_square, box.horiz, ...)\nend\nfunction Box.topLine(box, ...)\n   return _lineUsing(box, \"addTopLine\", ...)\nend\n\nfunction Box.addSpanningLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.left_tee, box.cross, box.right_tee, box.horiz, ...)\nend\nfunction Box.spanningLine(box, ...)\n   return _lineUsing(box, \"addSpanningLine\", ...)\nend\n\nfunction Box.addBottomLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.bl_square, box.bottom_tee, box.br_square, box.horiz, ...)\nend\nfunction Box.bottomLine(box, ...)\n   return _lineUsing(box, \"addBottomLine\", ...)\nend\n\n\n\n\n\n\n\n\n\n\n-- #todo consider extending to support multiple columns?\nfunction Box.addContentLine(box, phrase, ...)\n   local column_widths = {...}\n   local total_width = 0\n   for _, width in ipairs(column_widths) do\n      insert(phrase, box.vert)\n      insert(phrase, jump.forward(width))\n      total_width = total_width + width + 1\n   end\n   insert(phrase, box.vert)\n   -- Leave 1 column of left padding\n   insert(phrase, jump.back(total_width - 1))\nend\nfunction Box.contentLine(box, ...)\n   return _lineUsing(box, \"addContentLine\", ...)\nend\n\n\n\n\n\n\n\n\n\nfunction Box.__call(box, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectange(rect, ...)\n   end\n   local width = rect:width()\n   local phrase = {}\n   insert(phrase, jump(rect:origin()))\n   box:addTopLine(phrase, width - 2)\n   local backup  = jump.back(width) .. jump.down(1)\n   local forward = jump.forward(width - 2)\n   for j = 1, rect:height() - 2 do\n      -- jump back and forth\n      insert(phrase, backup)\n      insert(phrase, box.vert) -- │\n      insert(phrase, forward)\n      insert(phrase, box.vert)\n   end\n   insert(phrase,backup)\n   box:addBottomLine(phrase, width - 2)\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nlocal box = {}\nfor box_type, slug in pairs(boxen) do\n   local this_box = setmetatable({}, Box)\n   for i = 1, #box_parts do\n      this_box[box_parts[i]] = slug[i]\n   end\n   box[box_type] = this_box\nend\n\n\n\nreturn box\n\n",
name = "shape/box",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "2cb5f6d68c93e8cf51c91c0a8c9dd676292dc004d46ba0a2502020fc811ec216",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs    = assert (pairs)\nlocal tostring = assert (tostring)\nlocal error    = assert (error)\nlocal require  = assert (require)\nlocal rawget   = assert (rawget)\nlocal setmeta  = assert (setmetatable)\n\n\nlocal schar  = assert(string.char)\nlocal sub    = assert(string.sub)\nlocal byte   = assert(string.byte)\nlocal bit    = assert(bit, \"anterm requires Luajit \'bit\' or compatible in _G\")\nlocal rshift = assert(bit.rshift)\nlocal core   = require \"core:core\"\n\n\n\nlocal style = {}\n\n\n\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\' -- #Todo check if we use this\n\n\n\n\n\n\n\n\n\n\n\nlocal Style = {}\n\n\n\n\n\n\n\nlocal function makecolor(value, name, kind)\n    local color = { value = CSI .. value ..\"m\",\n                    name = name,\n                    kind = kind }\n    return setmeta(color, Style)\nend\n\n\n\n\n\n\n\n\nfunction Style.__call(color, str)\n    if str then\n        return color.value .. str .. color.reset\n    else\n        return color.value\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Style.__eq(a, b)\n   return a.value == b.value\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        bold = 1,\n        dim = 2,\n        italic = 3,\n        underscore = 4,\n        underline = 4,\n        reverse = 7,\n        hidden = 8,\n        strikeout = 9,\n        double_underscore = 21,\n        clear_bold = 22,\n        clear_dim  = 22,\n        clear_italic = 23,\n        clear_underline = 24,\n        clear_inverse = 27,\n        clear_hidden = 28,\n        clear_strikeout = 29 },\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\n\n\n\n\n\n\n\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        style[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction Style.__tostring(color)\n    return color.value\nend\n\nfunction Style.__concat(color, other)\n    return tostring(color) .. tostring(other)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal clear_fg, clear_bg, clear = style.clear_fg.value,\n                                  style.clear_bg.value,\n                                  style.clear.value\n\nlocal clear_attribute = { bright = style.clear_bold,\n                          bold = style.clear_bold,\n                          dim = style.clear_dim,\n                          italic = style.clear_italic,\n                          underscore = style.clear_underline,\n                          underline = style.clear_underline,\n                          reverse = style.clear_reverse,\n                          hidden = style.clear_hidden,\n                          strikeout = style.clear_strikeout,\n                          double_underscore = style.clear_underline }\n\nsetmeta(clear_attribute, {__index = function() return clear end})\n\nlocal function makereset(style)\n    -- given a style, reset its action.\n    -- simple for fg and bg\n    if style.kind == \"fg\" then\n        return clear_fg\n    elseif style.kind == \"bg\" then\n        return clear_bg\n    elseif style.kind == \"attribute\" then\n       return clear_attribute[style.name]\n    elseif style.kind == \"embedded\" then\n       return style.reset.value\n    end\nend\n\nfor name, _style in pairs(style) do\n   _style.reset = makereset(_style)\nend\n\n\n\n\n\n\n\n\nfunction Style.__add(a, b)\n   local style  = { value = a.value .. b.value,\n                    name  = a.name .. \"+\" .. b.name,\n                    reset = b.reset .. a.reset,\n                    kind  = \'composed\' }\n   return setmeta(style, Style)\nend\n\n\n\n\n\n\n\n\n\n\nlocal function byte_panic(byte_p)\n   if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n      error \"xterm value must be 8 bit unsigned\"\n   end\nend\n\nlocal _color_cache = setmeta({}, {__mode = \"v\"})\n\nlocal function _make_color(value, kind)\n   if _color_cache[value] then\n       return _color_cache[value]\n   end\n   local color = setmeta({value = value, kind = kind}, colormt)\n   _color_cache[value] = color\n   return color\nend\n\n\nlocal ansi_fg_pre = CSI .. \"38;5;\"\n\nlocal function ansi_fg(byte)\n   byte_panic(byte)\n   local value = ansi_fg_pre .. byte .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal ansi_bg_pre = CSI .. \"48;5;\"\n\nlocal function ansi_bg(byte)\n   byte_panic(byte)\n   local value = ansi_bg_pre .. byte .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fg24pre = CSI .. \"38;2;\"\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = fg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal bg24pre = CSI .. \"48;2;\"\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = bg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\nstyle.fg, style.bg = ansi_fg, ansi_bg\n\nstyle.fg24, style.bg24 = fg24, bg24\n\n\n\n\n\nreturn style\n\n",
name = "term/style",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "c53754d13ec1b07d598586336272e501d43a8ab42564380715158bebcaac0930",
binary = "\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal core = require \"qor:core\"\nlocal math = assert(core.math)\n\n\n\nlocal Point = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal floor = assert(math.floor)\n\nlocal function int(num)\n   if floor(num) == num then\n      return num\n   end\n   error \"non-integer value in point\"\nend\n\nlocal function new(row, col)\n   if type(row) == \'table\' then\n      col = row[2]\n      row = row[1]\n   end\n\n   local point = setmetatable({}, Point)\n   point.row = int(row)\n   point.col = int(col)\n   return point\nend\n\n\n\n\n\n\n\n\nfunction Point.split(point)\n   return point.row, point.col\nend\n\n\n\n\n\n\n\n\n\n\n\nPoint.rowcol = Point.split\n\nfunction Point.colrow(point)\n   return point.col, point.row\nend\n\n\n\n\n\nfunction Point.__eq(point, other)\n   return point.row == other.row and\n          point.col == other.col\nend\n\n\n\n\n\n\n\n\n\nlocal instanceof = assert(require \"core/meta\" . instanceof)\n\n\nfunction Point.__add(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row + other, point.col + other)\n   elseif instanceof(other, new) then\n      return new(point.row + other.row, point.col + other.col)\n   else\n      error(\"Cannot add \" .. type(other) .. \" to Point\")\n   end\nend\n\nfunction Point.__unm(point)\n   return new(-point.row, -point.col)\nend\n\nfunction Point.__sub(point, other)\n   return point + -other\nend\n\nfunction Point.__mul(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row * other, point.col * other)\n   elseif instanceof(other, new) then\n      return new(point.row * other.row, point.col * other.col)\n   else\n      error(\"Cannot multiply Point by \" .. type(other))\n   end\nend\n\nfunction Point.__div(point, other)\n   if not instanceof(point, new) then\n      if type(point) ~= \"number\" then\n         error(\"Cannot divide \" .. type(point) .. \" by Point\")\n      end\n      point = new(point, point)\n   elseif not instanceof(other, new) then\n      if type(other) ~= \"number\" then\n         error (\"Cannot divide Point by \" .. type(other))\n      end\n      other = new(other, other)\n   end\n   return new(point.row / other.row, point.col / other.col)\nend\n\n\n\n\n\n\n\nlocal floor, ceil = assert(math.floor), assert(math.ceil)\nfunction Point.floor(point)\n   return new(floor(point.row), floor(point.col))\nend\nfunction Point.ceil(point)\n   return new(ceil(point.row), ceil(point.col))\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Point.__repr(point, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Point\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      yield(nameFor(point.row))\n      yield(Token(\", \", { color = \"operator\" }))\n      yield(nameFor(point.col))\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\nPoint.idEst = new\nreturn new\n\n",
name = "shape/point",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "09e747831d8bddb11c464efb599e8df3f3e7deecac7d5cab403e88263ea1c905",
binary = "\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal core = require \"qor:core\"\nlocal Point = require \"anterm/point\"\nlocal Rectangle = meta {}\n\n\n\n\n\n\n\n\nlocal posint = assert(core.math.posint)\n\nlocal function new(tRow, lCol, bRow, rCol)\n   local rect  = setmetatable({}, Rectangle)\n   rect.tRow    = posint(tRow)\n   rect.lCol   = posint(lCol)\n   rect.bRow = posint(bRow)\n   rect.rCol  = posint(rCol)\n   return rect\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.width(rect)\n   return rect.rCol - rect.lCol + 1\nend\nfunction Rectangle.height(rect)\n   return rect.bRow - rect.tRow + 1\nend\nfunction Rectangle.extent(rect)\n   return Point(rect:height(), rect:width())\nend\n\n\n\n\n\n\nfunction Rectangle.origin(rect)\n   return Point(rect.tRow, rect.lCol)\nend\nfunction Rectangle.corner(rect)\n   return Point(rect.bRow, rect.rCol)\nend\n\n\n\n\n\n\nfunction Rectangle.intersects(rect, other)\n   return rect.lCol   <= other.rCol  and\n          rect.rCol  >= other.lCol   and\n          rect.tRow    <= other.bRow and\n          rect.bRow >= other.tRow\nend\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.contains(rect, point, col)\n   local row\n   if instanceof(point, Point) then\n      row, col = point:rowcol()\n   else\n      row = point\n   end\n   return row >= rect.tRow  and row <= rect.bRow\n      and col >= rect.lCol and col <= rect.rCol\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.insetBy(rect, offset)\n   if not instanceof(offset, Point) then\n      offset = Point(offset, offset)\n   end\n   return new(rect.tRow    + offset.row,\n              rect.lCol   + offset.col,\n              rect.bRow - offset.row,\n              rect.rCol  - offset.col)\nend\n\n\n\n\n\n\n\n\n\n\nlocal floor = assert(math.floor)\n\nfunction Rectangle.splitCol(rect, num)\n   num = num and posint(num) or 2\n   local half = rect:width() / 2\n   local split = floor(half)\n   -- draw that owl homie\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.__eq(rect, other)\n   return rect.lCol   == other.lCol   and\n          rect.tRow    == other.tRow    and\n          rect.rCol  == other.rCol  and\n          rect.bRow == other.bRow\nend\n\n\n\n\n\nlocal assertfmt = assert(require \"core/fn\" . assertfmt)\nfunction Rectangle.assertNotEmpty(rect, msg)\n   msg = msg or \"Empty rectangle\"\n   assertfmt(rect:height() > 0, \"%s: top: %d bottom: %d\", msg, rect.tRow, rect.bRow)\n   assertfmt(rect:width() > 0, \"%s: left: %d right: %d\", msg, rect.lCol, rect.rCol)\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Rectangle.__repr(rect, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Rectangle\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      for i, k in ipairs{\"tRow\", \"lCol\", \"bRow\", \"rCol\"} do\n         if i ~= 1 then\n            yield(Token(\", \", { color = \"operator\" }))\n         end\n         yield(nameFor(rect[k]))\n      end\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\n\n\nRectangle.idEst = new\nreturn new\n\n",
name = "shape/rectangle",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "9cab76808f644c040aea682e1e0b2d5bb7dc24f665e6feee5a9ef27ed1a77976",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new, CYOA = cluster.order()\n\n\n\n\n\n\n\n\ncluster.construct(new, function(new, cyoa, script, In, Out)\n   cyoa.script = assert(script, \"a script must be provided\")\n   -- might want this\n   cyoa.tty    = require \"bridge\" . is_tty\n   cyoa.read   = In or io.read\n   cyoa.write  = Out or io.write\n   cyoa.at_label = \'start\'\n   cyoa.state = assert(script.start, \'script is missing the start element\')\n\n   return cyoa\nend)\n\n\n\n\n\n\n\nfunction CYOA.enter(cyoa)\n   cyoa.write(assert(cyoa.state.intro))\n\n   return cyoa:awaitReply()\nend\n\n\n\nfunction CYOA.says(cyoa)\n   if cyoa.state.says then\n      return cyoa.state.says\n   else -- there are more cases?\n      return \"\"\n   end\nend\n\n\n\n\nfunction CYOA.awaitReply(cyoa)\n   -- read returns the first letter, lowercased, and the full reply.\n   local letter, reply = cyoa:read()\n   if cyoa:expects(letter, reply) then\n      return cyoa:follow(letter, reply)\n   else\n      return cyoa:apologize(reply)\n   end\nend\n\n\n\nfunction CYOA.expects(cyoa, letter, reply)\n--   for key in ipairs()\nend\n\n\n\nreturn new\n\n",
name = "cyoa",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "4ac68aeebf5716ebf2932ae79ae27640cd9a363029d0ebfe1483b1e63c53f1b8",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier:elpatt\"\nlocal C, Cg, Cnc, Ct = L.C, L.Cg, L.Cnc, L.Ct\nlocal P, R, S, U, V = L.P, L.R, L.S, L.U, L.V\n\n\n\nlocal input_event = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mod_shorthand_to_name = {\n   C = \"ctrl\",\n   M = \"meta\",\n   S = \"shift\"\n}\nlocal mod_shorthand_to_flag = {\n   C = 4,\n   M = 2,\n   S = 1\n}\nlocal mod_flag_to_name = {\n   [1] = \"shift\",\n   [2] = \"meta\",\n   [4] = \"ctrl\",\n   [8] = \"meta\"\n}\n\ninput_event.mod_shorthand_to_name = mod_shorthand_to_name\ninput_event.mod_shorthand_to_flag = mod_shorthand_to_name\ninput_event.mod_flag_to_name = mod_flag_to_name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bor = assert(require \"bit\" . bor)\nlocal function _marshal_one(evt)\n   local mod_letters = evt.modifiers\n   evt.modifiers = 0\n   for _, mod_name in pairs(mod_shorthand_to_name) do\n      evt[mod_name] = false\n   end\n   for _, mod in ipairs(mod_letters) do\n      local mod_name = mod_shorthand_to_name[mod]\n      local mod_flag = mod_shorthand_to_flag[mod]\n      evt[mod_name] = true\n      evt.modifiers = bor(evt.modifiers, mod_flag)\n   end\n   return evt\nend\n\nlocal base_grammar = {\n   modifiers     = Cg(Ct((C(S\"CMS\") * S\"-_\")^0), \"modifiers\"),\n   special_name  = P\"UP\" + P\"DOWN\" + P\"LEFT\" + P\"RIGHT\" +\n                   P\"HOME\" + P\"END\" + P\"PAGE_UP\" + P\"PAGE_DOWN\" +\n                   P\"ESC\" + P\"TAB\" + P\"BACKSPACE\" + P\"RETURN\" +\n                   P\"INSERT\" + P\"DELETE\" +\n                   (P\"F\" * (P\"1\" * R\"09\" + R\"19\")),\n   special       = Cg(V\"special_name\", \"key\"),\n   character     = Cg(U(1) - R\"\\x00\\x1f\" - P\"\\x7f\", \"key\"),\n   keypress      = (V\"special\" + V\"character\") * Cnc(\"type\", \"keypress\"),\n   wildcard_name = P\"SPECIAL\" + P\"CHARACTER\" + P\"MOUSE\",\n   wildcard      = Cg(P\"[\" * V\"wildcard_name\" * P\"]\", \"key\") *\n                   Cnc(\"type\", \"wildcard\"),\n   mouse_name    = (P\"MB\" * (P\"_LEFT\" + P\"_RIGHT\" + P\"_MIDDLE\" + S\"67\")) +\n                   (P\"SCROLL_\" * (P\"UP\" + P\"DOWN\")),\n   mouse         = Cg(V\"mouse_name\", \"key\") * Cnc(\"type\", \"mouse\"),\n   paste         = P\"PASTE\" * Cnc(\"type\", \"paste\"),\n   event         = Ct(V\"modifiers\" * (V\"wildcard\" + V\"mouse\" + V\"paste\" + V\"keypress\")) /\n                   _marshal_one\n}\n\nlocal clone = assert(require \"core:table\" . clone)\n\nlocal event_grammar = clone(base_grammar)\nevent_grammar[1] = V\"event\" * P(-1)\nevent_grammar = P(event_grammar)\n\nlocal sequence_grammar = clone(base_grammar)\nsequence_grammar[1] = Ct((V\"event\" * (P\" \" * V\"event\")^0)^-1) * P(-1)\nsequence_grammar = P(sequence_grammar)\n\nfunction input_event.marshal(str)\n   return event_grammar:match(str)\nend\n\nfunction input_event.marshal_sequence(str)\n   return sequence_grammar:match(str)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninput_event.special_keys = {\n   \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\",\n   \"HOME\", \"END\", \"PAGE_UP\", \"PAGE_DOWN\",\n   \"ESC\", \"TAB\", \"BACKSPACE\", \"RETURN\",\n   \"INSERT\", \"DELETE\"\n}\nlocal insert = assert(table.insert)\nfor i = 1, 19 do\n   insert(input_event.special_keys, \"F\" .. tostring(i))\nend\n\nlocal special_name_grammar = base_grammar.special_name * P(-1)\nfunction input_event.is_special_key(key_name)\n   return special_name_grammar:match(key_name)\nend\n\n\n\n\n\n\n\n\n\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal inverse = assert(require \"core:table\" . inverse)\nlocal modifier_shorthand = inverse(mod_shorthand_to_name)\nlocal modifier_order = { \"ctrl\", \"meta\", \"shift\" }\n\nlocal function _serialize(evt, accum)\n   for _, mod in ipairs(modifier_order) do\n      if evt[mod] then\n         insert(accum, modifier_shorthand[mod])\n         insert(accum, \"-\")\n      end\n   end\n   insert(accum, evt.key)\nend\n\nfunction input_event.serialize(evt)\n   local answer = {}\n   _serialize(evt, answer)\n   return concat(answer)\nend\n\nfunction input_event.serialize_sequence(evts)\n   local answer = {}\n   for i, evt in ipairs(evts) do\n      if i ~= 1 then\n         insert(answer, \" \")\n      end\n      _serialize(evt, answer)\n   end\n   return concat(answer)\nend\n\n\n\nreturn input_event\n\n",
name = "input-event",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "3fd55a570160a535184328a1bc05e9318a8c4a01595f96d41e9f4b217b34fc1c",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Keeper, Keeper_M = cluster.order()\n\n\n\n\n\n\n\n\n\ncluster.construct(new, function(_new, keeper, args)\n   keeper.args = args\n   if (uv.guess_handle(1) ~= \'tty\')\n      or (uv.guess_handle(0) ~= \'tty\') then\n      error \"keeper must run in a tty (for the moment)\"\n   end\n\n   return keeper\nend)\n\n\n\n\n\n\n\n\n\nfunction Keeper.stdio(keeper)\n   local stdin, stdout = uv.new_tty(0, true), uv.new_tty(1, false)\n   keeper.stdin = stdin\n   keeper.stdout = stdout\n   return stdin, stdout\nend\n\n\n\n\n\n\n\n\n\nfunction Keeper.write(keeper, ...)\n   uv.write(keeper.stdout, {...})\nend\n\n\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal Point = require \"anterm:point\"\n\n\n\nfunction Keeper.setup(keeper)\n   local stdin = keeper:stdio()\n   return keeper\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SETUP_RAW_ALTERNATE_TERMINAL =\n\"\\0277\\27[?47h\\27[2J\\27[1;1H\\27[?2004h\\27[?1003h\\27[?1006h\"\n\n\n\nlocal tty_set_mode = assert(uv.tty_set_mode)\n\nfunction Keeper.start(keeper)\n   if not keeper.stdin then\n      keeper:setup()\n   end\n   tty_set_mode(keeper.stdin, 2)\n   keeper:write(SETUP_RAW_ALTERNATE_TERMINAL)\nend\n\n\n\n\n\n\n\n\n\nfunction Keeper.winsize(keeper)\n   return keeper.stdin:get_winsize()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal CLOSING_CEREMONY = \"\\27[?1006l\\27[?1003l\\27[?2004l\\27[?47l\\0278\\27[?25h\"\n\nfunction Keeper.shutdown(keeper)\n   keeper:write(a.mouse.sgr_mode(false),\n                a.mouse.track(false),\n                a.paste_bracketing(false),\n                a.alternate_screen(false),\n                a.cursor.pop(),\n                a.cursor.show())\n   -- Back to normal mode\n   uv.tty_reset_mode()\n   uv.read_stop(keeper.stdin)\n   keeper.stdin:close()\n   keeper.stdout:close()\n   keeper.closed = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Keeper.closures(keeper)\n   local stdout, write = assert(keeper.stdout)\n   local function _write(...)\n      if keeper.closed then return end\n      uv.write(stdout, {...})\n   end\n   local function _shutdown()\n      if keeper.closed then return end -- harmless\n      keeper:shutdown()\n   end\n\n   return _write, _shutdown\nend\n\n\n\n\nreturn new\n\n",
name = "keeper",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "77110e3ef9fcefdfc286fde73f1e39b180a70a8a1e1456cbb8be021286d09868",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier:elpatt\"\nlocal C, Cc, Cg, Cp, Ct = L.C, L.Cc, L.Cg, L.Cp, L.Ct\nlocal M, P, R, S, U, V = L.M, L.P, L.R, L.S, L.U, L.V\nlocal Cnc = assert(require \"espalier:elpatt\" . Cnc)\n\nlocal bit = require \"bit\"\nlocal band, bor, rshift = assert(bit.band), assert(bit.bor), assert(bit.rshift)\n\nlocal concat = assert(table.concat)\nlocal core_table = require \"core:table\"\nlocal addall, keys = assert(core_table.addall), assert(core_table.keys)\n\n\n\n\n\n\nlocal seq_grammar = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal special_ctrl_map = {\n   [\"\\t\"]   = \"TAB\",\n   [\"\\r\"]   = \"RETURN\",\n   [\"\\x7F\"] = \"BACKSPACE\",\n   -- Does any terminal ever send this for anything other than a\n   -- Ctrl-J, which we should treat as such?\n   -- [\"\\n\"] = \"NEWLINE\"\n}\n\naddall(seq_grammar,{\nESC = P\"\\x1b\",\nCSI = V\"ESC\" * P\"[\",\nPs  = (R\"09\" ^ 1) / tonumber,\nany_ctrl = R\"\\x00\\x1f\",\nspecial_ctrl = M(special_ctrl_map),\n-- Escape is only matched as such if it appears at the end of the input\nbare_ESC = V\"ESC\" * -1 * Cc(\"ESC\"),\n-- Any single character that maps directly to a key name\n-- Ordered choice, so the expression at the end will never match backspace\nbare_char = V\"special_ctrl\" + (U(1) - V\"any_ctrl\"),\nmodifiers = Cg(V\"Ps\" / function(n) return n - 1 end, \"modifiers\")\n})\n\n\n\n\n\n\n\n\n\n\nlocal CSI_tilde_map = {}\nfor k, v in pairs{\n   nil,\n   \"INSERT\",\n   \"DELETE\",\n   nil,\n   \"PAGE_UP\",\n   \"PAGE_DOWN\",\n   \"HOME\",\n   \"END\",\n   nil, nil,\n   \"F1\", \"F2\", \"F3\", \"F4\", \"F5\",\n   nil,\n   \"F6\", \"F7\", \"F8\", \"F9\", \"F10\",\n   nil,\n   \"F11\", \"F12\", \"F13\", \"F14\", \"F15\"\n} do\n   CSI_tilde_map[tostring(k)] = v\nend\n\nseq_grammar.CSI_tilde_seq = V\"CSI\" *\n   Cg(M(CSI_tilde_map), \"key\") *\n   (P\";\" * V\"modifiers\")^-1 *\n   P\"~\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal CSI_letter_map = {\n   A = \"UP\",\n   B = \"DOWN\",\n   C = \"RIGHT\",\n   D = \"LEFT\",\n   F = \"END\",\n   H = \"HOME\",\n   P = \"F1\",\n   Q = \"F2\",\n   R = \"F3\",\n   S = \"F4\",\n   -- There\'s a legacy of encoding Shift-Tab as CSI Z, and under CSI u\n   -- combinations containing Shift-Tab (e.g. Ctrl-Shift-Tab) are modified\n   -- on top of that similar to other letters. We\'ll put the Shift modifier\n   -- where it belongs later, for now just get this parsed somehow\n   Z = \"SHIFT_TAB\"\n}\n\nseq_grammar.CSI_letter_special_key = V\"CSI\" *\n   (P\"1;\" * V\"modifiers\")^-1 *\n   Cg(M(CSI_letter_map), \"key\")\n\n\n\n\n\n\n\n\n\n\nlocal utf8_char = assert(require \"lua-utf8\" . char)\nlocal function CSIu_char_convert(codepoint)\n   local char = utf8_char(codepoint)\n   return special_ctrl_map[char] or char\nend\nseq_grammar.CSIu_seq = V\"CSI\" *\n              Cg(V\"Ps\" / CSIu_char_convert, \"key\") *\n              P\";\" *\n              V\"modifiers\" *\n              P\"u\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ctrl_char_convert(ch)\n   if ch:byte() == 0 then\n      return \" \"\n   else\n      -- We represent letters as lowercase, but the symbols are still those\n      -- adjacent to the uppercase letters\n      return string.char(ch:byte() + (\"@\"):byte()):lower()\n   end\nend\n\naddall(seq_grammar, {\n-- Similar to how we handle bare ESC, we assume that =ESC [= represents the\n-- start of a CSI sequence unless it\'s the last piece of input.\nALT_seq      = V\"ESC\" * Cg(V\"bare_char\", \"key\") *\n               Cnc(\"modifiers\", 2),\nCTRL_char    = Cg((V\"any_ctrl\" - V\"special_ctrl\" - V\"ESC\") / ctrl_char_convert, \"key\"),\nCTRL_seq     = V\"CTRL_char\" *\n               Cnc(\"modifiers\", 4),\nCTRL_ALT_seq = V\"ESC\" * V\"CTRL_char\" *\n               Cnc(\"modifiers\", 6)\n})\n\n\n\n\n\nlocal key_seq = (Cg(V\"bare_char\", \"key\") +\n          V\"CSIu_seq\" + V\"CSI_tilde_seq\" + V\"CSI_letter_special_key\" +\n          V\"CTRL_ALT_seq\" + V\"ALT_seq\" + V\"CTRL_seq\") *\n          Cnc(\"type\", \"keypress\")\n\nlocal input_event = require \"anterm:input-event\"\nlocal function parse_modifiers(event)\n   for mask, key in pairs(input_event.mod_flag_to_name) do\n      event[key] = event[key] or band(event.modifiers, mask) ~= 0\n   end\nend\n\nseq_grammar.key_seq = Ct(key_seq) / function(event)\n   event.modifiers = event.modifiers or 0\n   -- Convert CSI Z\n   if event.key == \"SHIFT_TAB\" then\n      event.modifiers = bor(event.modifiers, 1) -- code for shift\n      event.key = \"TAB\"\n   end\n   parse_modifiers(event)\n   return event\nend\n\n\n\n\n\n\n\n\n\n\nlocal byteR = assert(require \"lpeg\" . R)\nseq_grammar.x10_number = byteR\"\\x20\\xff\" / function(ch)\n   return ch:byte() - 32\nend\nseq_grammar.x10_mouse_seq = V\"CSI\" * P\"M\" *\n                  Cg(V\"x10_number\", \"kind\") *\n                  Cg(V\"x10_number\", \"col\") *\n                  Cg(V\"x10_number\", \"row\") *\n                  -- X10 mode can\'t distinguish pressed state properly, so we\n                  -- want it set unless the button is MBNONE, but in that case\n                  -- we already clear it below, so here we just always set it\n                  Cnc(\"pressed\", true)\n\nseq_grammar.sgr_mouse_seq = V\"CSI\" * P\"<\" *\n                  Cg(V\"Ps\", \"kind\") * P\";\" *\n                  Cg(V\"Ps\", \"col\") * P\";\" *\n                  Cg(V\"Ps\", \"row\") *\n                  Cg(M{ M = true, m = false }, \"pressed\")\n\nlocal buttons = { [0] = \"MB_LEFT\", \"MB_RIGHT\", \"MB_MIDDLE\", \"MB_NONE\",\n                  [64] = \"SCROLL_UP\", [65] = \"SCROLL_DOWN\",\n                  -- Scrolling \"buttons\" are AKA MB4 and MB5\n                  [66] = \"MB6\", [67] = \"MB7\" }\nlocal button_mask = 67 -- 0b01000011; 1, 2 and 64 bits set\n\nseq_grammar.mouse_seq = Ct((V\"sgr_mouse_seq\" + V\"x10_mouse_seq\") *\n                           Cnc(\"type\", \"mouse\")) / function(event)\n   event.key = buttons[band(event.kind, button_mask)]\n   if event.key == \"MB_NONE\" then\n      event.pressed = false\n   elseif event.key == \"SCROLL_UP\" or event.key == \"SCROLL_DOWN\" then\n      event.scrolling = true\n   end\n   event.modifiers = band(rshift(event.kind, 2), 7)\n   parse_modifiers(event)\n   event.moving = band(event.kind, 2 ^ 5) ~= 0\n   event.kind = nil\n   return event\nend\n\n\n\n\n\n\n\n\n\naddall(seq_grammar, {\n   paste_bracket_start = V\"CSI\" * P\"200~\",\n   paste_bracket_end   = V\"CSI\" * P\"201~\",\n   bracketed_paste     = V\"paste_bracket_start\" *\n      Cg((P(1) - V\"paste_bracket_end\") ^ 0, \"text\") *\n      V\"paste_bracket_end\" *\n      Cnc(\"type\", \"paste\") * Cnc(\"key\", \"PASTE\")\n})\n\nseq_grammar.special_seq = Ct(V\"bracketed_paste\")\n\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(require \"core:table\" . clone)\nseq_grammar[1] = Ct((V\"special_seq\" + V\"mouse_seq\" + V\"key_seq\") ^ 0) * Cp()\nlocal strict_seq_grammar = clone(seq_grammar)\nstrict_seq_grammar.ALT_seq = -V\"CSI\" * strict_seq_grammar.ALT_seq\nstrict_seq_grammar = P(strict_seq_grammar)\nlocal loose_seq_grammar = clone(seq_grammar)\nloose_seq_grammar.bare_char = V\"bare_ESC\" + loose_seq_grammar.bare_char\nloose_seq_grammar = P(loose_seq_grammar)\n\nreturn function(seq, parse_ambiguous_escapes)\n   if parse_ambiguous_escapes then\n      return loose_seq_grammar:match(seq)\n   else\n      return strict_seq_grammar:match(seq)\n   end\nend\n\n",
name = "input-parser",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "372b1804dfd0afa2563ee725ea47e8a58cc8f74100fa716c4a771d79c85b5400",
binary = "\n\n\n\n\nlocal uv = require \"luv\"\nlocal input_parse = require \"cursory:input-parser\"\nlocal Deque = require \"deque:deque\"\nlocal _auto = require \"cluster:autothread\"\nlocal core = require \"qor:core\"\nlocal table = assert(core.table)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function is_scroll(event)\n   return event.type == \"mouse\" and event.scrolling\nend\n\nlocal compact = assert(table.compact)\n\nlocal function consolidate_scroll_events(events)\n   -- We\'re going to nil-and-compact, so convert to ntable\n   events.n = #events\n   local i = 1\n   while i <= events.n do\n      local j = i + 1\n      if is_scroll(events[i]) then\n         events[i].num_lines = 1\n         while j <= events.n\n            and is_scroll(events[j])\n            and events[j].key == events[i].key do\n            events[i].num_lines = events[i].num_lines + 1\n            events[j] = nil\n            j = j + 1\n         end\n      end\n      i = j\n   end\n   compact(events)\nend\n\n\n\n\n\nlocal function new(stdin, fn, autothread)\n   autothread = autothread or _auto\n   local parse_input = require \"anterm:input-parser\"\n\n   local should_dispatch_all = false\n   local input_timer = uv.new_timer()\n   local event_idle = uv.new_idle()\n   local input_buffer = \"\"\n\n   local eventQ = Deque()\n\n   local function dispatch_input(seq, dispatch_all)\n      -- Clear the flag and timer indicating whether we should clear down the\n      -- input buffer this cycle. We explicitly stop the timer in case\n      -- another loop iteration occurs before the 5ms delay elapses (e.g. due\n      -- to an idler). We must use a timer with a nonzero delay because it\n      -- seems that the loop sometimes fails to retrieve input that should\n      -- logically already be present (e.g. due to a large paste) unless we\n      -- wait.\n      input_timer:stop()\n      -- Try parsing, letting the parser know whether it should definitely\n      -- consume everything it can or hold off on possible incomplete escape\n      -- sequences\n      local events, pos = parse_input(seq, dispatch_all)\n      input_buffer = seq:sub(pos)\n      if #input_buffer > 0 then\n         if dispatch_all then\n            -- If it\'s been a little while and we still have stuff we can\'t\n            -- parse, figure we might have something actually invalid.\n            -- #todo perform some kind of useful error recovery here\n            error(\"Unparseable input encountered:\\n\" .. input_buffer)\n         else\n            -- Use a timer to wait until all available input has arrived to\n            -- set the flag that will cause our check handler to clear the\n            -- input buffer. If more input is available sooner than the 5ms\n            -- timeout, it will be processed immediately and the timer reset.\n            -- This is (hopefully) an upper bound on how long it will take the\n            -- next chunk of a large paste to arrive.\n            local should_dispatch_all = false\n            input_timer:start(5, 1, function()\n               if not should_dispatch_all then\n                  should_dispatch_all = true\n                  return\n               end\n               input_timer:stop()\n               if #input_buffer > 0 then\n                  autothread(dispatch_input, input_buffer, true)\n               end\n            end)\n         end\n      end\n      consolidate_scroll_events(events)\n      eventQ:pushN(unpack(events))\n      local idx = 0\n      if not event_idle:is_active() then\n         event_idle:start(function()\n            if eventQ:isEmpty() then\n               event_idle:stop()\n            else\n               fn(eventQ:pop())\n            end\n         end)\n      end\n   end\n\n   local function onseq(err, seq)\n      local success, err_trace = xpcall(function()\n         if err then error(err) end\n         autothread(dispatch_input, input_buffer .. seq, false)\n      end, debug.traceback)\n      if not success then\n         -- we\'ll need more than this\n         error(err_trace)\n      end\n   end\n\n   uv.read_start(stdin, onseq)\nend\n\n\n\nreturn new\n\n",
name = "onread",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "82711123cc682741090aa2010bbaa8c0916d544a768ba3e5ffb82f6c4b95a194",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:peg\"\n\n\nlocal term_str = [[\n   term  ←  (color / phrase)+\n `color` ←  \"\\x1b[\" int (\";\" int)* \"m\"\n phrase  ←  (!\"\\x1b\" 1)+ / bad-esc-seq\n  `int`  ←  [0-9]+\n\nbad-esc-seq  ←  !color 1+\n]]\n\n\n\n\n\n\n\nlocal tparse = Peg(term_str).parse\n\n\n\n\n\n\nlocal width = require \"utf8\" . width\nlocal function termwidth(str)\n   local parsed = tparse(str)\n   if #parsed == 1 and parsed[1].id == \'phrase\' then\n      return width(str)\n   end\n\n   local wid = 0\n   for _, phrase in ipairs(parsed) do\n      if phrase.id == \'bad_esc_seq\' then\n         error(string.format(\"bad escape sequence %q\", phrase:span()))\n      end\n      wid = wid + width(phrase:span())\n   end\n   return wid\nend\n\n\n\n\n\n\nlocal function strip(str)\n   local parsed = tparse(str)\n   if #parsed == 1 and parsed[1].id == \'phrase\' then\n      return str\n   end\n\n   local chunk = {}\n   for i, phrase in ipairs(parsed) do\n      chunk[i] = phrase\n   end\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nreturn setmetatable({\n   parse = tparse,\n   termwidth = termwidth,\n   strip = strip,\n}, {__call = function(_, str) return termwidth(str) end})\n\n",
name = "termwidth",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
  { 
branch = "trunk",
hash = "815d991175608deba7c993ebb5e08d1720b2fb4b7bd2daab20076927a2c907bc",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\nlocal string = assert(core.string)\n\n\n\nlocal Point = require \"cursory:shape/point\"\nlocal a = require \"anterm:anterm\"\nlocal Rectangle = require \"cursory:shape/rectangle\"\nlocal termwidth = assert(require \"cursory:termwidth\" . termwidth)\nlocal Box = require \"cursory:shape/box\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Panel = cluster.order()\n\ncluster.construct(new, function(_new, panel, cfg)\n   if #cfg == 4 then\n      panel.extent = Rectangle(unpack(cfg))\n   else\n      assert(#cfg == 0, \"zero or four numbers for a panel, not \" .. #cfg)\n      assert(cfg.origin, \"can\'t make a panel without a Point on origin\")\n      local tR, lC = cfg.origin:split()\n      -- how\'s this for a compromise\n      local depth = cfg.depth or cfg.height\n                        or error \"a depth or height is needed\"\n      local bR, rC = tR + depth, lC + assert(cfg.width)\n      panel.extent = Rectangle(tR, lC, bR, rC)\n   end\n   panel.contents = \"\"\n   panel.was      = \"\"\n\n   ---[[  This we won\'t need for long, or we\'ll want a whole Set to exclude,\n   --      which is at least as likely.\n   for k, v in pairs(cfg) do\n      if type(k) ~= \'number\' then\n         panel[k] = v\n      end\n   end\n   panel.write = panel.write or io.write\n   panel.contents = panel.contents or \"\"\n   panel.justify = cfg.justify or \'left\'\n   -- we call the colors to get the strings out\n   panel.fg = panel.fg and panel.fg() or a.clear_fg()\n   panel.bg = panel.bg and panel.bg() or a.clear_bg()\n\n   return panel\nend)\n\n\n\n\n\n\n\n\n\nfunction Panel.height(panel)\n   return panel.extent:height()\nend\n\nfunction Panel.width(panel)\n   return panel.extent:width()\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Panel.clientBounds(panel)\n   if panel.border then\n      return panel.extent:insetBy(Point(1,2))\n   else\n      return panel.extent\n   end\nend\n\n\n\n\n\n\nfunction Panel.clientWidth(panel)\n   return panel :clientBounds() :width()\nend\n\nfunction Panel.clientHeight(panel)\n   return panel :clientBounds() :height()\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Panel.overlaps(panel, other_panel)\n   -- One or both panels may be uninitialized--treat this as nonoverlapping\n   return panel.extent\n      and other_panel.extent\n      and panel.extent:intersects(other_panel.extent)\nend\n\n\n\n\n\n\n\n\nfunction Panel.replace(panel, contents)\n   panel.was = panel.contents\n   -- maybe not adequate, should carry the day\n   panel.contents = contents and tostring(contents) or \"\"\n   return panel\nend\n\n\n\n\n\n\n\n\n\nlocal instanceof = assert(core.meta.instanceof)\n\nfunction Panel.setBounds(panel, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectangle(rect, ...)\n   end\n   rect:assertNotEmpty(\"Panel must have non-zero area\")\n   if panel.extent ~= rect then\n      panel.extent = rect\n      update_content_extent(panel)\n      -- Technically this could be incomplete in the case where we relinquish some cells,\n      -- but as long as every cell is covered by at least one Panel by the time layout is\n      -- complete, the new owner will figure things out.\n      panel:beTouched()\n   end\n   return panel\nend\n\n\n\n\n\n\nfunction Panel.setVisibility(panel, new_visibility)\n   if new_visibility ~= panel.visible then\n      panel.visible = new_visibility\n      panel:beTouched()\n   end\n   return panel\nend\n\nfunction Panel.show(panel)\n   return panel:setVisibility(true)\nend\nfunction Panel.hide(panel)\n   return panel:setVisibility(false)\nend\n\n\n\n\n\n\n\n\n\nfunction Panel.paintBorder(panel)\n   if panel.border then\n      panel.write(Box[panel.border](panel.extent))\n   end\nend\n\n\n\n\n\n\nlocal reset_fg, reset_bg = a.clear_fg(), a.clear_bg()\n\nfunction Panel.erase(panel)\n   local write = panel.write\n   write(panel.bg)\n   write(a.erase.box(panel.extent))\n   write(reset_bg)\nend\n\n\n\n\n\n\n\n\n\nlocal function _nl(panel)\n   return a.jump.col(panel:clientBounds().lCol) .. a.jump.down(1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal floor = assert(math.floor)\n\nfunction Panel.linePadding(panel, line)\n   if panel.justify == \'left\' then\n      return \"\", 0\n   end\n   -- for anything else we need:\n   local line_width, print_width = termwidth(line), panel:clientWidth()\n   local blanks = print_width - line_width\n   if panel.justify == \'right\' then\n      return (\" \"):rep(blanks), 0\n   elseif panel.justify == \'center\' then\n      local split = blanks / 2\n      local half  = floor(split)\n      local even  = half == split\n      return (\" \"):rep(half), even and 0 or 1 -- hi Javascript, Python. btfo\n   else\n      error(\"can\'t have panel.justify \" .. tostring(panel.justify))\n   end\nend\n\n\n\n\n\n\nlocal lines = assert(string.lines)\n\nlocal function _writeLines(panel)\n   local nl = _nl(panel)\n   local pr_row = panel.extent.tRow\n   local write = panel.write\n   -- this is where we do fancy things, for now, tostring\n   local contents = tostring(panel.contents)\n   for line in lines(contents) do\n       local pad = panel:linePadding(line)\n       write(pad, line, nl)\n       pr_row = pr_row + 1\n       if pr_row > panel.extent.rCol then\n          break\n       end\n   end\nend\n\nlocal function painter(panel)\n   panel:paintBorder()\n   local contents = panel.contents\n   if contents then\n      panel.write(a.jump(panel:clientBounds():origin()))\n      -- render\n      _writeLines(panel)\n   end\n   panel.touched = false\nend\n\nfunction Panel.paint(panel)\n   panel:erase()\n   painter(panel)\nend\n\n\n\n\n\n\n\n\nfunction Panel.overlay(panel)\n   painter(panel)\nend\n\n\n\nreturn new\n\n",
name = "panel",
vc_hash = "bcf8c800a534cda5030c19b6d6c09f8ead0bb16a\n",
},
} },
{
  project = {
    home = "",
    name = "deque",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/deque.git\n\n",
    website = "",
    repo = "git@gitlab.com:special-circumstance/deque.git\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "1b1fbe6de4777d0a7af95668ec3a5fafd148ebbfb63678b8c41fe2ed29cd4dec",
binary = "\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"cluster:cluster\"\nlocal core = require \"qor:core\"\n\n\n\n\n\nlocal new, Deque, Deque_M = cluster.order()\n\n\n\nlocal t_new = assert(table.new)\n\nlocal function creator(_new, size)\n   local deque;\n   if size then\n       assert(type(size) == \'number\',\n              \"size parameter of Deque must be a number\")\n       deque = t_new(size, 8)\n       deque.threshold = size\n   else\n      deque = {}\n      deque.threshold = 510\n   end\n   deque.head, deque.tail = 0, 0\n   assert(deque.threshold)\n   return deque\nend\n\ncluster.create(new, creator)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function flipped_contents(deque)\n   local r = {}\n   for i = deque.tail, deque.head + 1, -1 do\n      r[#r + 1] = deque[i]\n   end\n   return r\nend\n\nlocal directions = { push = \"pushLeftN\",\n                     pop  = \"popRight\",\n                     pushN = \"pushLeftN\",\n                     peek = \"peekRight\",\n                     peekAll = \"peekAllRight\",\n                     popAll  = \"popAllRight\",\n                     pushRight = \"pushLeft\",\n                     pushLeft  = \"pushRight\",\n                     pushRightN = \"pushLeftN\",\n                     pushLeftN = \"pushRightN\",\n                     peekRight = \"peekLeft\",\n                     peekLeft  = \"peekRight\",\n                     popRight  = \"popLeft\",\n                     popLeft   = \"popRight\",\n                     rotateRight = \"rotateLeft\",\n                     rotateLeft  = \"rotateRight\",\n                     removeRight = \"removeLeft\",\n                     removeLeft  = \"removeRight\",\n                     peekAllRight  = \"peekAllLeft\",\n                     peekAllLeft   = \"peekAllRight\",\n                     popAllRight   = \"popAllLeft\",\n                     popAllLeft    = \"popAllRight\",\n                     contents      = true, }\n\nlocal function _flip(deque)\n   if deque.flipped then return end\n   for method, reversal in pairs(directions) do\n      deque[method] = Deque[reversal]\n   end\n   -- add backward contents\n   deque.contents = flipped_contents\n   deque.flipped = true\nend\n\nlocal function _unflip(deque)\n   if not deque.flipped then return end\n   for method in pairs(directions) do\n      deque[method] = nil\n   end\n   deque.flipped = nil\nend\n\nlocal function reverse_queue(deque)\n   if deque.flipped then\n      _unflip(deque)\n   else\n      _flip(deque)\n   end\nend\n\n\n\n\n\n\nlocal t_clear = assert(table.clear)\nfunction Deque.clear(deque)\n   t_clear(deque)\n   deque.head, deque.tail = 0, 0\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _reset_on_empty(deque)\n   if deque.head == deque.tail then\n      deque:clear()\n   end\nend\n\n\n\n\n\n\n\n\nlocal function _compact(deque)\n   local head, tail, width = deque.head, deque.tail, #deque\n   deque.prev_head, deque.prev_tail = head, tail\n   -- or, at first, negative.\n   if head > 0 then\n      for i = 1, width do\n         deque[i] = deque[i + head]\n      end\n      for i = width + 1, tail do\n         deque[i] = nil\n      end\n      deque.head = 0 -- this invalidates #deque\n      deque.tail = width -- this restores it\n      -- let\'s make it official\n      deque.compacted = true\n   end\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _traveler(deque)\n   return deque.tail / #deque >= 2\nend\n\n\n\n\n\n\n\n\n\nlocal function _resizeGuard(deque)\n   if not deque.threshold then return end\n   if deque.tail < deque.threshold then return end\n   if _traveler(deque) then\n      _compact(deque)\n   else\n      -- we\'ll resize, so double up\n      deque.threshold = deque.threshold * 2\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Deque.pushRight(deque, x)\n   if x == nil then return end\n   _resizeGuard(deque)\n   deque.tail = deque.tail + 1\n   deque[deque.tail] = x\nend\n\n\n\n\nfunction Deque.pushLeft(deque, x)\n   if x == nil then return end\n   deque[deque.head] = x\n   deque.head = deque.head - 1\nend\n\n\n\n\n\n\n\n\nlocal function pushRightN(deque, ...)\n   local top, next = ...\n   if top == nil then return end\n   deque:pushRight(top)\n   if next then\n      pushRightN(deque, select(2, ...))\n   end\nend\n\nDeque.push = pushRightN\n\n\n\nlocal function pushLeftN(deque, ...)\n   local top = ...\n   if top == nil then return end\n   deque:pushLeft(top)\n   pushLeftN(deque, select(2, ...))\nend\n\nDeque.pushRightN = pushRightN\nDeque.pushLeftN  = pushLeftN\nDeque.pushN      = pushRightN\n\n\n\n\n\n\n\n\n\nfunction Deque.peekLeft(deque)\n   return deque[deque.head + 1]\nend\n\nDeque.peek = Deque.peekLeft\n\n\n\n\nfunction Deque.peekRight(deque)\n   return deque[deque.tail]\nend\n\n\n\n\n\n\n\n\n\n\nfunction Deque.popRight(deque)\n   if deque:isEmpty() then return nil end\n   local r = deque[deque.tail]\n   deque[deque.tail] = nil\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\n   return r\nend\n\nfunction Deque.popLeft(deque)\n   if deque:isEmpty() then return nil end\n   deque.head = deque.head + 1\n   local r = deque[deque.head]\n   deque[deque.head] = false -- keeps the queue in the array form\n   _reset_on_empty(deque)\n   return r\nend\n\nDeque.pop = Deque.popLeft\n\n\n\n\n\n\n\n\n\nfunction Deque.rotateRight(deque, n)\n   n = n or 1\n   if deque:isEmpty() then return nil end\n   for i = 1, n do deque:pushLeft(deque:popRight()) end\nend\n\nfunction Deque.rotateLeft(deque, n)\n   n = n or 1\n   if deque:isEmpty() then return nil end\n   for i = 1, n do deque:pushRight(deque:popLeft()) end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _remove_at_internal(deque, idx)\n   local elem = deque[idx]\n   for i = idx, deque.tail do deque[i] = deque[i+1] end\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\n   return elem\nend\n\nfunction Deque.removeRight(deque, x)\n   local offset = deque.tail - x + 1\n   if offset <= deque.tail and offset > deque.head then\n      return _remove_at_internal(deque, offset)\n   end\n   return nil\nend\n\nfunction Deque.removeLeft(deque, x)\n   local offset = deque.head + x\n   if offset <= deque.tail and offset > deque.head then\n      return _remove_at_internal(deque, offset)\n   end\n   return nil\nend\n\nDeque.remove = Deque.removeLeft\n\n\n\n\n\n\n\n\nfunction Deque.length(deque)\n   return (not deque.flipped)\n           and deque.tail - deque.head\n           or deque.head - deque.tail\n\nend\n\nDeque_M.__len = Deque.length\n\n\n\n\n\n\n\n\nfunction Deque.isEmpty(deque)\n   return deque.tail == deque.head\nend\n\n\n\n\n\n\n\n\n\nfunction Deque.contents(deque)\n   local r = {}\n   for i = deque.head + 1, deque.tail do\n      r[i-deque.head] = deque[i]\n   end\n   return r\nend\n\n\n\n\n\n\n\n\n\nfunction Deque.peekAllRight(deque)\n   local i = deque.tail + 1\n   return function()\n      if i > deque.head + 1 then\n         i = i - 1\n         return deque[i]\n      end\n   end\nend\n\nfunction Deque.peekAllLeft(deque)\n   local i = deque.head\n   return function()\n      if i < deque.tail then\n         i = i + 1\n         return deque[i]\n      end\n   end\nend\n\nDeque.peekAll = Deque.peekAllLeft\n\n\n\n\n\n\n\n\nfunction Deque.popAllLeft(deque)\n   return function()\n      return deque:popLeft()\n   end\nend\n\nfunction Deque.popAllRight(deque)\n   return function()\n      return deque:popRight()\n   end\nend\n\nDeque.popAll = Deque.popAllLeft\n\n\n\n\n\n\n\n\nfunction Deque.spill(deque, out)\n   if out == nil then return end\n   for elem in out:popAll() do\n      deque:push(elem)\n   end\nend\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate, Token\nlocal sortedpairs = assert(core.table.sortedpairs)\n\nfunction Deque_M.__repr(deque, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n\n   return wrap(function()\n      yield(Token(\"{| \", { color = \"base\", event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for elem in deque:peekAllLeft() do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n         end\n         for t in tabulate(elem, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" |}\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
name = "deque",
vc_hash = "b1133229745e9386af1e9552c7ab19f3f23d45d5\n",
},
} },
{
  project = {
    home = "",
    name = "emcee",
    repo_type = "git",
    repo_alternates = "",
    website = "",
    repo = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
branch = "trunk",
hash = "8d11cbf5401d74b9f30d54d476d01c802124264691e8794cd389c8cc28f02c84",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, resume, yield = assert(coroutine.create),\n                              assert(coroutine.resume),\n                              assert(coroutine.yield)\nlocal running               = assert(coroutine.running)\n\n\n\n\n\n\n\nlocal function co_tab_gen(fn)\n   local co = create(fn)\n   return setmetatable({}, { __call = function(_, ...)\n                                         return resume(co, ...)\n                                      end })\nend\n\n\n\n\n\n\n\n\nlocal function co_fn_gen(fn)\n   local co = create(fn)\n   return function(...)\n      return resume(co, ...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ontogenesis(fn, env)\n   -- what if we took a table\n   local ontos = {}\n\n   -- created a coroutine out of the function\n   local co = create(fn)\n\n   -- put it on the table thingy\n   ontos.co = co\n\n\n   -- made ourselves a call metamethod that just does this:\n   local function __call_me_maybe(...)\n      return resume(ontos.co, ontos, ...)\n   end\n\n   -- now we need a truly oddball __newindex\n   local function __fenv_all_the_vals(ontos, key, val)\n      -- new functions inherit the fenv from the calling function so\n      -- if we\'re in =co= we just return\n      if running() == co then\n         rawset(ontos, key, val)\n         return\n      end\n\n      -- otherwise we need to set them\n      -- this doesn\'t capture callables or fields on tables but there\'s a\n      -- can of worms there.\n\n      if type(val) == \'function\' then\n         setfenv(val, ontos)\n         rawset(ontos, key, val)\n      end\n   end\n\n   local ontos_M = { __call = __call_me_maybe,\n                     __index = env,\n                     __newindex = __fenv_all_the_vals }\n\n   setfenv(__call_me_maybe, ontos) -- oh no\n   setfenv(fn, ontos_M) -- .. maybe?\n\n   -- ¯\\_(ツ)_/¯\n   return setmetatable(ontos, ontos_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn ontos\n\n",
name = "bluesky/ontos",
vc_hash = "f6b9689b039a1001fba72b7656d67a10c1d93d6a",
},
} },
{
  project = {
    home = "",
    name = "espalier",
    repo = "https://gitlab.com/special-circumstance/espalier\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.com/special-circumstance/espalier.git/\n\nhttps://gitlab.special-circumstanc.es/bridge-tools/espalier.git\n\n",
    website = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "qoph-combinator",
hash = "4c58312f8cae8ab972dd5068caa4690cd6faf2b7f498ad592c5d6d1de55b8307",
binary = "\n\n\n\n\n\n\n\nlocal dot_peg = [[\ndot <- \"strict\" _ (\"graph\" / \"digraph\") _ ID _ \"{\" _ statements _ \"}\"\n\n_ <- { \\t\\r\\n}*\n]]\n\n\n\n\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\nlocal L       =  require \"espalier/elpatt\"\n\nlocal P, R, E, V, S    =  L.P, L.R, L.E, L.V, L.S\n\nlocal _ = (P\" \" + P\"\\n\" + P\"\\t\" + P\"\\r\")^0\n\nlocal IDstart =  R(\"az\", \"AZ\") + \"_\" -- dot is actually latin-1 but\nlocal IDrest  =  IDstart + R\"09\"\n\nlocal num     =  P\"-\"^0 * (P\".\" + R\"09\"^1)\n              +  R\"09\"^1 * P\".\"^0 * R\"09\"^0\n\nlocal string_patt = P\"\\\"\" * (P(1) - (P\"\\\"\" * - P\"\\\\\\\"\"))^0 * P\"\\\"\"\n\nlocal function dot_fn(_ENV)\n   START \"dot\"\n\n   dot =  _ * P\"strict\"^0 * _ * (P\"graph\" + P\"digraph\")\n       *  _ * V\"ID\"^0 * _ * \"{\" * _ * V\"statment_list\" * _ * \"}\" * _\n\n   statement_list =  V\"statement\"^0 * _ * P\";\"^0 * _ * V\"statement\"^0\n\n   statement  =  V\"node_statement\"\n              +  V\"edge_statement\"\n              +  V\"attr_statement\"\n              +  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n              +  V\"subgraph\"\n\n   attr_statement =  (P\"graph\" + \"node\" + \"edge\") * V\"attr_list\"\n   attr_list      =  P\"[\" * _ * V\"a_list\"^0 * _ * P\"]\" * _ * V\"attr_list\"^0\n   a_list         =  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n                  * (P\";\" + P\",\")^0 * _ * V\"a_list\"^0\n\n   edge_statement =  (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\" * V\"attr_list\"^0\n   edgeRHS        =  V\"edgeop\" * _ * (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\"^0\n\n   node_statement =  V\"node_id\" * _ * V\"attr_list\"^0\n   node_id        =  V\"ID\" * _ * V\"port\"^0\n   port           =  P\":\" * _ * V\"ID\" * _ * (P\":\" * _ * V\"compass_point\")^0\n\n   subgraph       =  (V\"subgraph\" * _ * V\"ID\"^0)^0 * _\n                  *  \"{\" * _ * V\"statement_list\" * _ * \"}\"\n\n   compass_point  =  S(\"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\",\"_\")\n\n   ID    =  (V\"IDstart\"^1 * V\"IDrest\"^0) + V\"num\" + V\"string_patt\"\n\n   -- Add C-style comments\n\nend\n\nreturn Grammar(dot_fn)\n\n",
name = "espalier/grammars/dot",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "4b8433dc412e98d4d51c9e3a4a6574f9f741ab971e2f23eec609be4e84b5bede",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal date_peg = [[\n   date  =  yearMonthDayTime\n         /  yearMonthDay\n         /  yearMonth\n         /  year\n\n   `yearMonthDay` = year \"-\" monthDay\n   `yearMonth` = year \"-\" month\n\n   year = positiveYear / negativeYear / \"0000\"\n\n   `positiveYear` =  [1-9] [0-9] [0-9] [0-9]\n                  /  \"0\"   [1-9] [0-9] [0-9]\n                  /  \"00\"        [1-9] [0-9]\n                  /  \"000\"             [1-9]\n   `negativeYear` = \"-\" positiveYear\n\n   `monthDay` =  m31 \"-\" day\n              /  m30 \"-\" (!longMonth day)\n              /  mFeb \"-\" (!threeDecan day)\n   m31      =  \"01\" / \"03\" / \"05\" / \"07\" / \"08\" / \"10\" / \"12\"\n   m30      =  \"06\" / \"04\" / \"09\" / \"11\"\n   mFeb     =  \"02\"\n\n   ; only used in negative lookahead\n   longMonth = \"31\"\n   threeDecan = \"31\" / \"30\"\n\n   month  =  m31 / m30 / mFeb\n\n   day  =  \"0\" [1-9]\n        /  (\"1\" / \"2\") [0-9]\n        /  (\"30\" / \"31\")\n\n   `yearMonthDayTime` = yearMonthDay separator time\n   `separator` = \"T\" / \" \" / \"::\" ; opinionated!\n\n\n   time = hourMinuteSecond\n        / hourMinute\n        / hour\n\n   `hourMinuteSecond` = hour \":\" minute \":\" second fracSecond? timeZone?\n   `hourMinute` = hour \":\" minute\n   hour = [0-1] [1-9] / \"2\" [0-3]\n   minute = sexigesimal\n   second = sexigesimal\n   fracSecond = \".\" [0-9] [0-9]? [0-9]?\n\n   timeZone = zulu /  offset\n   `offset` = (positive / negative) (hour \":\" minute / hour minute / hour)\n   positive = \"+\"\n   negative = \"-\"\n   zulu = \"Z\"\n   `sexigesimal` = [0-5] [0-9]\n]]\n\n\n\nreturn Peg(date_peg):toGrammar()\n\n",
name = "espalier/grammars/date",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "f5bb65ad2a8cd0c3ac52e6a3fae57023448fc02aa817244aa052afcd34dd33b0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\n\n\nlocal lua_str = [[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr \",\" expr (\",\" expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\nreturn Peg(lua_str)\n\n",
name = "espalier/grammars/lua",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "9c429d20d64211fc9f0c3c322e7177b78bacc5a0abdc5be1d654042a771b8a83",
binary = "\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal lua_tok_str = [[\nlua = _ (token _)+\n`token` = keyword / operator\n\nkeyword = \"function\" / \"local\" / \"for\" / \"in\" / \"do\"\n           / \"and\" / \"or\" / \"not\" / \"true\" / \"false\"\n           / \"while\" / \"break\" / \"if\" / \"then\" / \"else\" / \"elseif\"\n           / \"goto\" / \"repeat\" / \"until\" / \"return\" / \"nil\"\n           / \"end\"\n\noperator = \"+\" / \"-\" / \"*\" / \"/\" / \"%\" / \"^\" / \"#\"\n           / \"==\" / \"~=\" / \"<=\" / \">=\" / \"<\" / \">\"\n           / \"=\" / \"(\" / \")\" / \"{\" / \"}\" / \"[\" / \"]\"\n           / \";\" / \":\" / \"...\" / \"..\" / \".\" / \",\"\n\n _     = { \\t\\n,}*\n\n]]\n\n\n\nreturn Peg(lua_tok_str):toGrammar()\n\n",
name = "espalier/grammars/luatoken",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "df636106dcdbff2c281ba9b50b8463276a694c3539d7cda5d42210ba4bd70148",
binary = "\n\n\n\n\n\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg = require \"espalier/peg\"\nlocal Node = require \"espalier/node\"\n\n\n\n\n\nlocal micro_lisp_peg = [[\nlisp = _ ((atom)+ / list)\nlist = pel _ (atom / list)* per _\natom = _(number / symbol)_\nsymbol = _(alpha / other) (alpha / digit / other)*_\nnumber = float / integer\n`integer` = [0-9]+\n`float` = [0-9]+ \".\" [0-9]+ ; expand\n`pel` = \'(\'\n`per` = \')\'\n`alpha` = [A-Z]/[a-z]\n`digit` = [0-9]\n`other` = {-_-=+!@#$%^&*:/?.\\\\~}\n  `_`     = { \\t\\r\\n,}*\n]]\n\n\nlocal micro_lisp_metas = { lisp = Node : inherit \"lisp\",\n                           atom = Node : inherit \"atom\",\n                           symbol = Node : inherit \"symbol\",\n                           number = Node : inherit \"number\" }\n\n\n\nreturn Peg(micro_lisp_peg, micro_lisp_metas)\n\n",
name = "espalier/grammars/microlisp",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "767af695d35fd074820f911eafb7200ba8419c9683c4f1eb9fb5369f13a7321c",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal j_object = [[\n   object <- \"{\" _ pair _ \"}\"\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal j_whitespace = [[\n  `_` <- { \\t\\n\\r}*\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal j_pair = [[\npair <- key _ \":\" _ value _ \",\"\nkey <- string\nvalue <- string\nstring <- \'\"\' (!\'\"\' 1) \'\"\'\n]]\n",
name = "espalier/grammars/jisp",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "38bb45f217d4541ce423a3a2f246608cd9f47bff1c5685794df5d92d77845a44",
binary = "\n\n\n\n\nlocal regex = {}\n\n\nregex.xs_pattern = [[\nregex <- branch (\"|\" branch)*\nbranch <- piece+\n\npiece <- suffixed / atom\n`suffixed` <- optional / zero-plus / one-plus / repeat\natom <- char / char-class / \"(\" regex \")\"\n\noptional <- atom \"?\"\nzero-plus <- atom \"*\"\none-plus <- atom \"+\"\nrepeat <- atom \"{\" quantity \"}\"\n\n char <- !{[]^.\\?*+()} 1\n char-class <- class-esc ; etc: / class-expr / wildcard-esc\n\n`quantity` <- quant-range / quant-min / quant-exact\nquant-range <- quant-exact \",\" quant-exact\nquant-min <- quant-exact \",\"\nquant-exact <- [0-9]+\n\n\n`class-esc` <- single-esc ; etc: / multi-esc / catEst / complEsc\n single-esc <- \"\\\\\" ({nrt\\\\|.?*+()[]^} / \"{\" / \"}\")\n]]\n",
name = "espalier/grammars/regex",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "16af8ffdf764ed914239396abc7e4e52b19d06d9e18b441c7f91d492ec852b06",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--local Node    =  require \"espalier/node\"\n--local Grammar =  require \"espalier/grammar\"\nlocal require = assert(require)\nlocal L       =  require \"espalier/elpatt\"\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\n\nlocal P, R, E, V, S, D   =  L.P, L.R, L.E, L.V, L.S, L.D\n\n\n\n\n\n\nlocal Day = Node : inherit ()\nDay.id = \"day\"\nlocal Month = Node : inherit ()\nMonth.id = \"month\"\nlocal Year = Node : inherit ()\nYear.id =  \"year\"\n\nlocal date_metas = { oneThru30 = Day,\n                     oneThru29 = Day,\n                     m31       = Month,\n                     m30       = Month,\n                     mFeb      = Month,\n                     year      = Year }\n\n\n\n\n\nlocal function _date_fn(_ENV)\n\n   START \"date\"\n\n   SUPPRESS (\"positiveYear\", \"negativeYear\"\n            , \"yearMonth\", \"yearMonthDay\", \"monthDay\"\n             -- , \"oneThru12\", \"oneThru29\",\n             -- , \"oneThru30\", \"oneThru31\"\n             )\n\n   date         = V\"yearMonthDay\"\n                + V\"yearMonth\"\n                + V\"year\"\n\n   year         = V\"positiveYear\" + V\"negativeYear\" + P\"0000\"\n\n   positiveYear = R\"19\"  * R\"09\" * R\"09\" * R\"09\"\n                + P\"0\"   * R\"19\" * R\"09\" * R\"09\"\n                + P\"00\"  * R\"19\" * R\"09\"\n                + P\"000\" * R\"19\"\n\n   negativeYear =  P\"-\" * V\"positiveYear\"\n\n   monthDay     = V\"m31\"  * P\"-\" * V\"day\"\n                + V\"m30\"  * P\"-\" * (-V\"longMonth\" * V\"day\")\n                + V\"mFeb\" * P\"-\" * (-V\"threeDecan\" * V\"day\")\n\n   m31          = (P\"01\" + P\"03\" + P\"05\" + P\"07\" + \"08\" + \"10\" + \"12\")\n\n   m30          = (P\"04\" + P\"06\" + P\"09\" + P\"11\")\n\n   mFeb         = P\"02\"\n\n   yearMonth    = V\"year\" * P\"-\" * V\"month\"\n\n   yearMonthDay = V\"year\" * P\"-\" *  V\"monthDay\"\n\n   month        = V\"m31\" + V\"m30\" + V\"mFeb\"\n\n   day          = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n                + P\"30\"\n                + P\"31\"\n\n   oneThru12    = (P\"0\" *  R\"19\") + P\"10\" + P\"11\" + P\"12\"\n\n   oneThru29    = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n\n   oneThru30    = P\"30\" + V\"oneThru29\"\n\n   oneThru31    = V\"longMonth\" + V\"oneThru30\"\n\n   longMonth    = P\"31\"\n\n   threeDecan   = V\"longMonth\" + P\"30\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   uaDate        = V\"yearMonthDay\" * V\"uaSymbol\"\n\n   uaSymbol      = P\"?\" + P\"~\" + P\"%\"\n\n   reducedDate   = (V\"year\" + V\"yearMonth\") * V\"uaSymbol\"\n\n   qualifiedDate = V\"uaSymbol\"^0 * V\"year\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"month\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"day\" * V\"uaSymbol\"^0\n\n   unspecifiedDate    = (V\"yearMonth\" * P\"-XX\")\n                      + (V\"year\" * P\"-XX-XX\")\n                      * P \"XXXX-XX-XX\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn Grammar(_date_fn, date_metas, nil, nil)\n\n",
name = "espalier/grammars/ortho-8600",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "9db4a7179c39f47708da93dcb9c5da3fbb5e06aef4ccbd551a18efba456da5bc",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal sql_statement = [[\n          sql  ←  _ (statement _ semi _)+\n\n`statement`  ←  explain? ( alter-table\n                         / analyze\n                         / attach\n                         / begin\n                         / commit\n                         / create-index\n                         / create-table\n                         / create-trigger\n                         / create-view\n                         / create-virtual-table\n                         / delete\n                         / detach\n                         / drop\n                         / insert\n                         / pragma\n                         / reindex\n                         / release\n                         / rollback\n                         / savepoint\n                         / select\n                         / update\n                         / vacuum )\n       `semi`  ←  \";\" / -1\n\nexplain  ←  EXPLAIN (QUERY PLAN)?\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_table = [[\ncreate-table  ←  CREATE (TEMP / TEMPORARY)? TABLE if-not-exists?\n                 schema-prefix? table-name _\n                 ( AS select /\n                    \"(\" _ column-def\n                    (_ \",\" _ column-def)*\n                    (_ \",\" (_ table-constraint)+)? _ \")\" _\n                    table-options* )\n if-not-exists  ←  IF NOT EXISTS\n\n `schema-prefix`  ←  schema-name _ \".\" _\n\n  schema-name  ←  name-val\n   table-name  ←  name-val\ntable-options  ←  t-opt (\",\" _  t-opt)*\n      `t-opt`  ←  (WITHOUT ROWID / STRICT)\n]]\n\n\n\n\nlocal create_index = [[\ncreate-index  ←  CREATE UNIQUE? INDEX if-not-exists? schema-prefix?\n                 index-name _ ON table-name _ indexed-columns (WHERE expr)?\n  index-name  ←  name-val\n]]\n\n\n\n\nlocal create_trigger = [[\ncreate-trigger  ←  CREATE (TEMPORARY / TEMP)? TRIGGER if-not-exists?\n                   schema-prefix? trigger-name (BEFORE / AFTER / INSTEAD OF)?\n                   (DELETE / INSERT / UPDATE OF column-names) ON table-name _\n                   (FOR EACH ROW)? (WHEN expr)?\n                   BEGIN trigger-stmts END\n\n`trigger-stmts`  ←  ((update / insert / delete / select) _ semi _)+\n\ntrigger-name  ←  name-val\n]]\n\n\n\n\n\n\n\nlocal column_def = [[\n column-def  ←  column-name _ (type-name)? (_ column-constraint)*\ncolumn-name  ←  name-val\n\n`type-name`  ←  (affinity _) column-width?\n\n; these have no actual semantic value in SQLite\ncolumn-width  ←  \"(\"_ signed-number _\")\"_\n              /  \"(\"_ signed-number _\",\"_ signed-number _\")\"_\n]]\n\n\n\nlocal column_affinity = [[\n    `affinity`  ←  blob-column\n                /  integer-column\n                /  text-column\n                /  real-column\n                /  numeric-column\n\n   blob-column  ←  B L O B !follow-char\n\ninteger-column  ←  (no-affinity _)* integer-word (_ name-val)*\n`integer-word`  ←  &((!int-affin !t 1)* int-affin) name-val\n\n   text-column  ←  (no-affinity _)* text-word (_ name-val)*\n   `text-word`  ←  &((!text-affin !t 1)* text-affin) id\n\n   real-column  ←  (no-affinity _)* real-word (_ name-val)*\n   `real-word`  ←  &((!text-affin !t 1)* text-affin) id\n\n `no-affinity`  ←  &((!affine !t 1)+) name\n\n      `affine`  ←  int-affin / text-affin / real-affin\n\n   `int-affin`  ←  I N T\n\n  `text-affin`  ←  C H A R / C L O B / T E X T\n\n  `real-affin`  ←  R E A L / F L O A / D O U B\n\nnumeric-column  ←  name-val (_ name-val)*\n]]\n\n\n\n\nlocal column_table_constraints = [[\ncolumn-constraint  ←  CONSTRAINT name\n\n                   /  NOT NULL  ; conflict-clause?\n                   /  PRIMARY KEY (ASC / DESC)? conflict-clause? AUTOINCREMENT?\n                   /  UNIQUE conflict-clause?\n                   /  CHECK expr ;group-expr\n                   /  DEFAULT (literal-value / group-expr / signed-number)\n                   /  COLLATE collation-name\n                   /  foreign-key-clause\n                   /  (GENERATED ALWAYS)? AS group-expr (STORED / VIRTUAL)?\n\n\n\n table-constraint  ←  CONSTRAINT name _\n                   /  FOREIGN KEY column-names foreign-key-clause\n                   /  ( PRIMARY KEY\n                      / UNIQUE ) indexed-columns conflict-clause?\n                   /  CHECK group-expr\n\n`conflict-clause`  ←  ON CONFLICT (ROLLBACK / ABORT / FAIL / IGNORE / REPLACE)\n\n   `column-names`  ←  \"(\" _ column-name _ (\",\"_ column-name _)* \")\" _\n`indexed-columns`  ←  \"(\" _ indexed-column (\",\"_ indexed-column)* _ \")\" _\n\n   indexed-column  ←  (column-name / expr) _ (COLLATE name _)? (ASC / DESC)?\n\n       group-expr  ←  \"(\"_ expr _ \")\"\n]]\n\n\n\n\nlocal foreign_key_clause = [[\nforeign-key-clause  ←  REFERENCES table-name _ column-names?\n                       fk-on-clause*\n                       (NOT? DEFERRABLE (INITIALLY (DEFERRED / IMMEDIATE))?)?\n\n    `fk-on-clause`  ←  (ON (DELETE / UPDATE)\n                           ( SET (NULL / DEFAULT)\n                           / CASCADE\n                           / RESTRICT\n                           / NO ACTION ))\n                    /  MATCH name _\n]]\n\n\n\n\nlocal select_stmt = [[\n         select  ←  common-table-expr-clause?\n                    (select-clause / val-clause)\n                       (compound-operator (select-clause / val-clause))*\n                    order-clause?\n                    limit-clause?\n\ncommon-table-expr-clause  ←  \"\"\n\n`select-clause`  ←  SELECT (DISTINCT / ALL)?\n                       result-column (\",\"_ result-column)*\n                    from-clause?\n                    where-clause?\n                    group-clause?\n                    window-clause?\n\n`result-column`  ←  ( expr-as\n                    / expr\n                    / glob\n                    / table-glob ) _\n        expr-as  ←  expr _  pAS column-alias\n           glob  ←  \"*\"\n     table-glob  ←  table-name _ \".\" _ glob\n\n\ncolumn-alias  ←  name-val\n\nval-clause <- VALUES \"(\" _ expr-list _ \")\" _\n\nfrom-clause  ←  FROM (join-clause / table-or-subquery) _\n\nwhere-clause  ←  WHERE expr _\n\ngroup-clause  ←  GROUP BY expr-list _ (HAVING expr _)?\n\nwindow-clause  ←  WINDOW name AS window-defn (_\",\"_ name as window-defn)\n\norder-clause  ←  ORDER BY ordering-terms\n\nlimit-clause  ←  LIMIT expr _ (OFFSET expr / \",\"_ expr)? _\n]]\n\nlocal table_or_subquery = [[\ntable-or-subquery  ←  schema-prefix? indexable-table\n                   /  table-function-name _\"(\"_ expr-list _\")\" as-alias?\n                   /  \"(\" _ select _ \")\" as-alias?\n                   /  \"(\" _ join-clause \")\"\n                   /  \"(\" _ subqueries  \")\"\n\n     `subqueries`  ←  table-or-subquery _ (\",\" _ table-or-subquery)*\n\n`indexable-table`  ←  table-name as-alias?\n                      (INDEXED BY index-name / NOT INDEXED)?\n       `as-alias`  ←  _ AS? table-alias _\n\ntable-alias  ←  name-val\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal expression = [[\n           expr  ←  expr-term !binop\n                 /  expr-term _ expr-rest\n\n    `expr-term`  ←  unop _ expr\n                 /  literal-value\n                 /  bind-parameter\n                 /  function-expr\n                 /  raise-function\n                 /  schema-name _\".\"_ table-name _\".\"_ column-name\n                 /  table-name  _\".\"_ column-name\n                 /  column-name\n                 /  group-expr\n                 /  CAST \"(\"_ expr AS type-name _\")\"\n                 /  NOT EXISTS \"(\"_ select \")\"\n                 /  CASE (expr _)*\n                        (WHEN expr _ THEN expr _)+\n                        (ELSE expr _)?\n                    END\n\n        ; these rules are purely predicate\n        `binop`  ←   _ ( binop-glyph\n                       / COLLATE\n                       / NOTNULL\n                       / NOT\n                       / AND\n                       / OR\n                       / ISNULL\n                       / IS\n                       / EXISTS\n                       / LIKE\n                       / GLOB\n                       / REGEXP\n                       / MATCH )\n  `binop-glyph`  ←  \"||\" / \"->>\" / \"->\" / \"<<\" / \">>\"\n                 /  \"<=\" / \"=>\"  / \"!=\" / \"<>\" / \"==\"\n                 /  {*/+-%<>=&|}\n\n         `unop`  ←  uplus / uminus / bit-not\n\n\n          uplus  ←  \"+\"\n         uminus  ←  \"-\"\n        bit-not  ←  \"~\"\n\n    `expr-rest`  ←  operator _ expr\n                 /  (AND / OR) expr\n                 /  COLLATE name\n                 /  like-op expr (_ ESCAPE exexpr)?\n                 /  match-op expr\n                 /  ISNULL\n                 /  NOT NULL\n                 /  NOTNULL\n                 /  is-op expr\n                 /  between-expr\n                 /  in-select-expr\n\n             like-op  ←   NOT? LIKE\n            match-op  ←   NOT? (GLOB / REGEXP / MATCH)\n               is-op  ←   IS NOT? (DISTINCT FROM)?\n        between-expr  ←   NOT? BETWEEN expr AND expr\n      ; in-select-expr\n\n      `operator`  ←  concat / extract / neq / gte / lte / lshift / rshift\n                  /  eq /  lt / gt / add / sub / mul / div / mod\n                  /  bit-and / bit-or\n\n                concat  ←  \"||\"\n               extract  ←  \"->>\" / \"->\"\n                   neq  ←  \"<>\" / \"!=\"\n                   gte  ←  \">=\"\n                   lte  ←  \"<=\"\n                lshift  ←  \"<<\"\n                rshift  ←  \">>\"\n\n                    eq  ←  \"==\" / \"=\"\n                    lt  ←  \"<\"\n                    gt  ←  \">\"\n                   add  ←  \"+\"\n                   sub  ←  \"-\"\n                   mul  ←  \"*\"\n                   div  ←  \"/\"\n                   mod  ←  \"%\"\n               bit-and  ←  \"&\"\n                bit-or  ←  \"|\"\n\n\n\nfunction-expr  ←  function-name \"(\"_ (\"*\" / (DISTINCT? expr-list)) _\")\"_\n                  filter-clause? over-clause?\n\nfunction-name  ←  name-val\n    expr-list  ←  expr (_\",\"_ expr)*\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal name_rules = [[\n               name  ←   quoted / id\n         `name-val`  ←   quoted / id\n\n           `quoted`  ←  \'\"\' quote-name \'\"\'\n                     /  deprecated-quote\n               `id`  ←  !keyword bare-name\n                     /  !keyword dollar-name\n\n         quote-name  ←  (!\'\"\' 1)+\n   deprecated-quote  ←  \"[\" (!\"]\" 1)+ \"]\"\n                     /  \"`\" (!\"`\" 1)+ \"`\"\n                     /  \"\'\" (!\"\'\") \"\'\"\n\n        `bare-name`  ←  lead-char follow-char*\n        dollar-name  ←  lead-char dollow-foller+\n\n        `lead-char`  ←  [\\x80-\\xff] / [A-Z] / [a-z] / \"_\"\n      `follow-char`  ←  lead-char / [0-9]\n    `dollow-foller` ←  follow-char  / \"$\"\n]]\n\n\n\n\n\nlocal literal_rules = [[\n`literal-value`  ←  (number / string / blob / NULL / TRUE / FALSE\n                    / CURRENT_TIMESTAMP / CURRENT_TIME / CURRENT_DATE)\nsigned-number  ←  {+-} number\n\n       number  ←  real / hex / integer\n\n       real  ←  ((integer (\".\" fraction)) / (\".\" fraction))\n                  ((\"e\" / \"E\") \"-\"? exponent)?\n        hex  ←  \"0\" {Xx} higit+ (\".\" higit*)?\n    integer  ←  digit+\n\n   fraction  ←  digit+\n   exponent  ←  digit+\n\n      `digit`  ←  [0-9]\n      `higit`  ←  digit / [a-f] / [A-F]\n\n       string  ←  \"\'\" ((!\"\'\" 1) / \"\'\'\")* \"\'\"\n         blob  ←  {xX} \"\'\" higit* \"\'\"\n]]\n\n\n\n\n\n\nlocal whitespace_rules = [[\n  `_`  ←  ws*\n `ws`  ←  (comment / dent / WS)+\n\n; tracking indentation can be useful\n`dent`  ←  \"\\n\" (!\"\\n\" WS)*\n\n; whitespace token rule, defined in hex as in the documentation\n; why \\f and not \\v? don\'t know!\n`WS`  ←  {\\x09\\x0a\\x0c\\x0d\\x20} ; {\\t\\n\\f\\r }\n\n`comment`  ←  line-comment / block-comment\n`line-comment`  ←  \"--\" (!\"\\n\" 1)*\n`block-comment`  ←  \"/*\" (!\"*/\" 1)* (\"*/\" / -1)\n]]\n\n\n\n\n\n\nlocal terminal_rule = [[\n`t`  ←  !follow-char\n]]\n\n\n\n\n\n\n\n\n\n\n\n\nlocal keyword_rules = [[\n               ABORT  ←  A B O R T t _\n              ACTION  ←  A C T I O N t _\n                 ADD  ←  A D D t _\n               AFTER  ←  A F T E R t _\n                 ALL  ←  A L L t _\n               ALTER  ←  A L T E R t _\n              ALWAYS  ←  A L W A Y S t _\n             ANALYZE  ←  A N A L Y Z E t _\n                 AND  ←  A N D t _\n                 ASC  ←  A S C t _\n                  AS  ←  A S t _\n              ATTACH  ←  A T T A C H t _\n       AUTOINCREMENT  ←  A U T O I N C R E M E N T t _\n              BEFORE  ←  B E F O R E t _\n               BEGIN  ←  B E G I N t _\n             BETWEEN  ←  B E T W E E N t _\n                  BY  ←  B Y t _\n             CASCADE  ←  C A S C A D E t _\n                CASE  ←  C A S E t _\n                CAST  ←  C A S T t _\n               CHECK  ←  C H E C K t _\n             COLLATE  ←  C O L L A T E t _\n              COLUMN  ←  C O L U M N t _\n              COMMIT  ←  C O M M I T t _\n            CONFLICT  ←  C O N F L I C T t _\n          CONSTRAINT  ←  C O N S T R A I N T t _\n              CREATE  ←  C R E A T E t _\n               CROSS  ←  C R O S S t _\n        CURRENT_DATE  ←  C U R R E N T \"_\" D A T E t _\n   CURRENT_TIMESTAMP  ←  C U R R E N T \"_\" T I M E S T A M P t _\n        CURRENT_TIME  ←  C U R R E N T \"_\" T I M E t _\n            DATABASE  ←  D A T A B A S E t _\n             DEFAULT  ←  D E F A U L T t _\n          DEFERRABLE  ←  D E F E R R A B L E t _\n            DEFERRED  ←  D E F E R R E D t _\n              DELETE  ←  D E L E T E t _\n                DESC  ←  D E S C t _\n              DETACH  ←  D E T A C H t _\n            DISTINCT  ←  D I S T I N C T t _\n                DROP  ←  D R O P t _\n                EACH  ←  E A C H t _\n                ELSE  ←  E L S E t _\n                 END  ←  E N D t _\n              ESCAPE  ←  E S C A P E t _\n              EXCEPT  ←  E X C E P T t _\n           EXCLUSIVE  ←  E X C L U S I V E t _\n              EXISTS  ←  E X I S T S t _\n             EXPLAIN  ←  E X P L A I N t _\n                FAIL  ←  F A I L t _\n               FALSE  ←  F A L S E t _\n             FOREIGN  ←  F O R E I G N t _\n                 FOR  ←  F O R t _\n                FROM  ←  F R O M t _\n                FULL  ←  F U L L t _\n           GENERATED  ←  G E N E R A T E D t _\n                GLOB  ←  G L O B t _\n               GROUP  ←  G R O U P t _\n              HAVING  ←  H A V I N G t _\n                  IF  ←  I F t _\n              IGNORE  ←  I G N O R E t _\n           IMMEDIATE  ←  I M M E D I A T E t _\n               INDEX  ←  I N D E X t _\n           INITIALLY  ←  I N I T I A L L Y t _\n               INNER  ←  I N N E R t _\n              INSERT  ←  I N S E R T t _\n             INSTEAD  ←  I N S T E A D t _\n           INTERSECT  ←  I N T E R S E C T t _\n                INTO  ←  I N T O t _\n                  IN  ←  I N t _\n              ISNULL  ←  I S N U L L t _\n                  IS  ←  I S t _\n                JOIN  ←  J O I N t _\n                 KEY  ←  K E Y t _\n                LEFT  ←  L E F T t _\n                LIKE  ←  L I K E t _\n               LIMIT  ←  L I M I T t _\n               MATCH  ←  M A T C H t _\n             NATURAL  ←  N A T U R A L t _\n             NOTNULL  ←  N O T N U L L t _\n                 NOT  ←  N O T t _\n                  NO  ←  N O t _\n                NULL  ←  N U L L t _\n              OFFSET  ←  O F F S E T t _\n                  OF  ←  O F t _\n                  ON  ←  O N t _\n               ORDER  ←  O R D E R t _\n                  OR  ←  O R t _\n               OUTER  ←  O U T E R t _\n                PLAN  ←  P L A N t _\n              PRAGMA  ←  P R A G M A t _\n             PRIMARY  ←  P R I M A R Y t _\n               QUERY  ←  Q U E R Y t _\n          REFERENCES  ←  R E F E R E N C E S t _\n               RAISE  ←  R A I S E t _\n              REGEXP  ←  R E G E X P t _\n             REINDEX  ←  R E I N D E X t _\n              RENAME  ←  R E N A M E t _\n             REPLACE  ←  R E P L A C E t _\n            RESTRICT  ←  R E S T R I C T t _\n               RIGHT  ←  R I G H T t _\n            ROLLBACK  ←  R O L L B A C K t _\n               ROWID  ←  R O W I D t _\n                 ROW  ←  R O W t _\n              SELECT  ←  S E L E C T t _\n                 SET  ←  S E T t _\n              STORED  ←  S T O R E D t _\n              STRICT  ←  S T R I C T t _\n               TABLE  ←  T A B L E t _\n           TEMPORARY  ←  T E M P O R A R Y t _\n                TEMP  ←  T E M P t _\n                THEN  ←  T H E N t _\n                  TO  ←  T O t _\n         TRANSACTION  ←  T R A N S A C T I O N t _\n             TRIGGER  ←  T R I G G E R t _\n                TRUE  ←  T R U E t _\n               UNION  ←  U N I O N t _\n              UNIQUE  ←  U N I Q U E t _\n              UPDATE  ←  U P D A T E t _\n               USING  ←  U S I N G t _\n              VACUUM  ←  V A C U U M t _\n              VALUES  ←  V A L U E S t _\n                VIEW  ←  V I E W t _\n             VIRTUAL  ←  V I R T U A L t _\n                WHEN  ←  W H E N t _\n               WHERE  ←  W H E R E t _\n             WITHOUT  ←  W I T H O U T t _\n]]\n\n\n\n\n\n\n\n\n\nlocal keyword_rule = [[\n `keyword`  ←  (  ABORT / ACTION / ADD / AFTER / ALL / ALTER / ALWAYS\n               /  ANALYZE / AND / ASC / AS / ATTACH / AUTOINCREMENT / BEFORE\n               /  BEGIN / BETWEEN / BY / CASCADE / CASE / CAST / CHECK\n               /  COLLATE / COLUMN / COMMIT / CONFLICT / CONSTRAINT / CREATE\n               /  CROSS / CURRENT_DATE / CURRENT_TIMESTAMP / CURRENT_TIME\n               /  DATABASE / DEFAULT / DEFERRABLE / DEFERRED / DELETE / DESC\n               /  DETACH / DISTINCT / DROP / EACH / ELSE / END / ESCAPE\n               /  EXCEPT / EXCLUSIVE / EXISTS / EXPLAIN / FAIL / FALSE\n               /  FOREIGN / FOR / FROM / FULL / GENERATED / GLOB / GROUP\n               /  HAVING / IF / IGNORE / IMMEDIATE / INDEX / INITIALLY\n               /  INNER / INSERT / INSTEAD / INTERSECT / INTO / IN / ISNULL\n               /  IS / JOIN / KEY / LEFT / LIKE / LIMIT / MATCH / NATURAL\n               /  NOTNULL / NOT / NO / NULL / OFFSET / OF / ON / ORDER / OR\n               /  OUTER / PLAN / PRAGMA / PRIMARY / QUERY / REFERENCES\n               /  RAISE / REGEXP / REINDEX / RENAME / REPLACE / RESTRICT\n               /  RIGHT / ROLLBACK / ROWID / ROW / SELECT / SET / STORED\n               /  STRICT / TABLE / TEMPORARY / TEMP / THEN / TO / TRANSACTION\n               /  TRIGGER / TRUE / UNION / UNIQUE / UPDATE / USING / VACUUM\n               /  VALUES / VIEW / VIRTUAL / WHEN / WHERE / WITHOUT )\n]]\n\n\n\n\n\n\n\n\n\nlocal caseless_letters = [[\n`A`  ←  {Aa}\n`B`  ←  {Bb}\n`C`  ←  {Cc}\n`D`  ←  {Dd}\n`E`  ←  {Ee}\n`F`  ←  {Ff}\n`G`  ←  {Gg}\n`H`  ←  {Hh}\n`I`  ←  {Ii}\n`J`  ←  {Ji}\n`K`  ←  {Kk}\n`L`  ←  {Ll}\n`M`  ←  {Mm}\n`N`  ←  {Nn}\n`O`  ←  {Oo}\n`P`  ←  {Pp}\n`Q`  ←  {Qq}\n`R`  ←  {Rr}\n`S`  ←  {Ss}\n`T`  ←  {Tt}\n`U`  ←  {Uu}\n`V`  ←  {Vv}\n`W`  ←  {Ww}\n`X`  ←  {Xx}\n`Y`  ←  {Yy}\n`Z`  ←  {Zz}\n]]\n\n\n\n\n\n\n\n\n\nlocal column_affinity = column_affinity or \"\"\n\nlocal sqlite_blocks = {\n   sql_statement,\n   create_table,\n   create_index,\n   create_trigger,\n   column_def,\n   column_table_constraints,\n   column_affinity,\n   foreign_key_clause,\n   select_stmt,\n   table_or_subquery,\n   expression,\n   -- the \'lexer\' rules\n   literal_rules,\n   name_rules,\n   keyword_rules,\n   keyword_rule,\n   caseless_letters,\n   whitespace_rules,\n   terminal_rule,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {table.concat(sqlite_blocks, \"\\n\\n\"), blocks = sqlite_blocks}\n\n",
name = "espalier/grammars/sqlite",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "2ce6c0bc3b9307b3b33f2f5b1a13d082a8cf0ee3665d41003dcef2a53b0d3ebe",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\n\n\nlocal toml_str = [=[\n\n;; Overall Structure\n\n   toml    <-  expression (nl expression)*\n\n`expression` <-  ws keyval ws comment?\n             /  ws table  ws comment?\n             /  ws comment\n             /  ws &nl\n\n;; Whitespace\n\n        `ws`  <-  {\\t }*\n    `wschar`  <-  {\\t }+\n\n;; Newline\n\n        `nl`  <- \"\\n\" / \"\\r\\n\"\n\n;; Comment\n\n     comment  <- \"#\" (!nl 1)*\n\n;; Key-Value pairs\n\n      keyval  <-  key ws \"=\" ws val\n               /  key ws \"=\" ws Error\n\n         key  <-  dotted-key / simple-key ; / (!\"=\" 1) &\"=\" Error\n\n`simple-key`  <-  quoted-key / unquoted-key\n\nunquoted-key  <-  ([A-Z] / [a-z] / [0-9] / \"-\" / \"_\")+\n\n  quoted-key  <-  basic-string / literal-string\n\n  dotted-key  <-  simple-key (\".\" simple-key)+\n\n         val  <-  string / boolean / array / inline-table\n                  / date-time / float / integer\n\n;; String\n\n        `string`  <-  ml-basic-string   / basic-string\n                  /   ml-literal-string / literal-string\n\n;; Note: this isn\'t technically TOML, because we\'ll use Lua string\n;; conventions. I have no interest in implementing \\u.\n\n    basic-string  <-  \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n                  /   \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* &\"\\n\" Error\n\n ml-basic-string  <- \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' 1) / &\'\"\"\"\"\' \'\"\')* \'\"\"\"\'\n                  /  \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' !-2 1))* Error\n\n  literal-string  <-  \"\'\"  (!\"\'\" !\"\\n\" 1)* \"\'\"\n                  /   \"\'\"  (!\"\'\" !\"\\n\" 1)* &\"\\n\" Error\n\nml-literal-string <- \"\'\'\'\" (!\"\'\'\'\" 1 / &\"\'\'\'\'\" \"\'\")* \"\'\'\'\"\n                  /  \"\'\'\'\" (!\"\'\'\'\" !-2 1)* Error\n\n;; Integer\n\n    integer  <-  hexadecimal / octal / binary / decimal\n\n    decimal  <-  sign? dec-int\n\n       sign  <-  \"+\" / \"-\"\n\n  `dec-int`  <-  [0-9] / [1-9] ([0-9] / \"_\" [0-9])+\n\nhexadecimal  <-  \"0x\" higit (higit / \"_\" higit)*\n\n    `higit`  <- [A-F] / [a-f] / [0-9]\n\n      octal  <- \"0o\" [0-7] ([0-7] / \"_\" [0-7])*\n\n     binary  <- \"0b\" [0-1] ([0-1] / \"_\" [0-1])*\n\n;; Float\n\nfloat <- decimal \".\" decimal* ((\"e\" / \"E\") \"-\"? decimal)?\n      /  special-float\n\nspecial-float = sign? (\"inf\" / \"nan\")\n\n;; Boolean\n\nboolean = \"true\" / \"false\"\n\n;;; Not in the mood to port dates from \'ortho8600\'\n;; Date and Time (as defined in RFC 3339)\n\ndate-time <- \"placeholder@#$%@$#%\"\n\n;; Offset Date-Time\n\noffset-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date-Time\n\nlocal-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date\n\nlocal-date <- \"placeholder@#$%@$#%\"\n\n;; Local Time\n\nlocal-time <- \"placeholder@#$%@$#%\"\n\n;; Array\n\n        array  <-  \"[\" array-values? opt-comment \"]\"\n\n`opt-comment`  <-  (ws comment? nl ws)+ / ws\n\n array-values  <-  opt-comment val (opt-comment \",\" opt-comment val)* \",\"*\n\n;; Table\n\ntable  <-  std-table / array-table\n\n;; Standard Table\n\nstd-table  <-  \"[\" ws key ws \"]\"\n\n;; Inline Table\n\ninline-table <-  \"{\" ws (keyval (ws \",\" ws keyval)*)* ws \"}\"\n\n;; Array Table\n\narray-table <- \"[[\" ws key ws \"]]\"\n\n;; Error\n\nError  <-  1*\n]=]\n\n\nreturn Peg(toml_str)\n\n",
name = "espalier/grammars/toml",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "815074ab7651da5e99bd2cde0fb46a93638c5a9b6b42cfaee9ab70a5ed0b69d5",
binary = "\n\n\n\n\n\n\n\n\n\nlocal lpeg = require \"lpeg\"\nlocal C, Cmt, Ct = assert(lpeg.C),\n                   assert(lpeg.Ct),\n                   assert(lpeg.Ct)\nlocal P, R, S, V = assert(lpeg.P),\n                   assert(lpeg.R),\n                   assert(lpeg.S),\n                   assert(lpeg.V)\n\n\n\n\n\nlocal elpatt = {}\nfor k, v in pairs(lpeg) do\n   elpatt[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal I = lpeg.Cp()\n\nfunction elpatt.anywhere(p)\n     return P{ I * C(p) * I + 1 * V(1) }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function rep(patt, n, m)\n   patt = P(patt)\n   assert(n, \"missing argument #2 to \'rep\' (n is required)\")\n   assert(n >= 0, \"bad argument #2 to \'rep\' (n cannot be negative)\")\n   assert(not m or m >= n, \"bad argument #3 to \'rep\' (m must be >= n)\")\n   -- m == n is equivalent to omitting m altogether, easiest to\n   -- take care of this up front\n   if m == n then\n      m = nil\n   end\n   if n == 0 then\n      if m then\n         return patt ^ -m\n      else\n         return -patt\n      end\n   else\n      local answer = patt\n      for i = 1, n - 1 do\n         answer = answer * patt\n      end\n      if m then\n         answer = answer * patt^(n - m)\n      end\n      return answer\n   end\nend\n\nelpatt.rep = rep\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sort = assert(table.sort)\n\nfunction elpatt.M(tab)\n   local keys = {}\n   for k in pairs(tab) do\n      assert(type(k) == \'string\', \"Keys passed to M() must be strings\")\n      keys[#keys + 1] = k\n   end\n   --sort(keys)\n   local rule = P(keys[#keys])\n   for i = #keys - 1, 1, - 1 do\n      local k = keys[i]\n      rule = rule + P(k)\n   end\n   return rule / tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cc, Cg = assert(lpeg.Cc), assert(lpeg.Cg)\nfunction elpatt.Cnc(name, value)\n  return Cg(Cc(value), name)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal utf8_cont = R\"\\x80\\xbf\"\nlocal utf8_char = R\"\\x00\\x7f\" +\n                  R\"\\xc2\\xdf\" * utf8_cont +\n                  R\"\\xe0\\xef\" * rep(utf8_cont, 2) +\n                  R\"\\xf0\\xf4\" * rep(utf8_cont, 3)\nlocal utf8_str  = Ct(C(utf8_char)^0) * -1\nlocal ascii_str = R\"\\x00\\x7f\"^0 * -1\n\n\n\n\n\n\n\n\nlocal codepoint = assert(require \"lua-utf8\" . codepoint)\nlocal inbounds = assert(require \"core:math\" . inbounds)\nlocal insert = assert(table.insert)\nlocal assertfmt = assert(require \"core:fn\" . assertfmt)\n\nlocal function R_unicode(...)\n   local args = pack(...)\n   local ascii_ranges, utf_ranges = {}, {}\n   for i, range in ipairs(args) do\n      if ascii_str:match(range) then\n         -- Throw this error here while we still know which argument this was\n         assertfmt(#range == 2,\n            \"bad argument #%d to \'R\' (range must have two characters)\", i)\n         insert(ascii_ranges, range)\n      else\n         range = utf8_str:match(range)\n         assertfmt(range, \"bad argument #%d to \'R\' (invalid utf-8)\", i)\n         assertfmt(#range == 2,\n            \"bad argument #%d to \'R\' (range must have two characters)\", i)\n         insert(utf_ranges, { codepoint(range[1]), codepoint(range[2]) })\n      end\n   end\n   local answer;\n   if #ascii_ranges > 0 then\n      answer = R(unpack(ascii_ranges))\n   end\n   if #utf_ranges ~= 0 then\n      local utf_answer =  P(function(subject, pos)\n           local char = C(utf8_char):match(subject, pos)\n           if not char then return false end\n           local code = codepoint(char)\n           for _, range in ipairs(utf_ranges) do\n              if inbounds(code, range[1], range[2]) then\n                 return pos + #char\n              end\n           end\n           return false\n        end)\n      answer = answer and answer + utf_answer or utf_answer\n   end\n   return answer\nend\n\nelpatt.R = R_unicode\n\n\n\n\n\n\n\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\nlocal function S_unicode(chars)\n   -- We *could* skip this early-out and we\'d still return an identical\n   -- pattern, since we separate out the ASCII characters below,\n   -- but let\'s keep the degenerate case clear and fast\n   if ascii_str:match(chars) then\n      return S(chars)\n   end\n   chars = utf8_str:match(chars)\n   assert(chars, \"bad argument #1 to \'S\' (invalid utf-8)\")\n   local patt;\n   local ascii_chars = {}\n   for _, char in ipairs(chars) do\n      if #char == 1 then\n         insert(ascii_chars, char)\n      else\n         patt = patt and P(char) + patt or P(char)\n      end\n   end\n   if #ascii_chars > 0 then\n      patt = patt and S(concat(ascii_chars)) + patt or S(concat(ascii_chars))\n   end\n   return patt\nend\n\nelpatt.S = S_unicode\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.U(n, m)\n   n = n or 1\n   return rep(utf8_char, n, m)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.split(str, sep)\n  sep = P(sep)\n  local elem = C((1 - sep)^0)\n  local patt = Ct(elem * (sep * elem)^0)   -- make a table capture\n  return patt:match(str)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cs = assert(lpeg.Cs)\nfunction elpatt.gsub(str, patt, repl)\n   patt = P(patt)\n   if repl then\n      patt = patt / repl\n   end\n   patt = Cs((patt + 1)^0)\n   return patt:match(str)\nend\n\n\n\n\nreturn elpatt\n\n",
name = "espalier/elpatt",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "66874b127b44837ba9c69d22c690136344e1ab42931b4a178b0f9842d938691d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L   = require \"lpeg\"\nlocal s = require \"status:status\" ()\nlocal Carg, Cc, Cp, P = L.Carg, L.Cc, L.Cp, L.P\n\n\n\nlocal Err = require \"espalier/node\" : inherit()\nErr.id = \"ERROR\"\n\n\n\n\n\n\n\n\n\nfunction Err.toLua(err)\n  local line, col = err:linePos(err.first)\n  s:halt(\"ERROR at line: \" .. line .. \" col: \" .. col)\nend\n\n\n\n\n\n\n\n\nlocal function parse_error(pos, name, msg, patt, str)\n   local message = msg or name or \"Not Otherwise Specified\"\n   s:verb(\"Parse Error: \", message)\n   local errorNode =  setmetatable({}, Err)\n   errorNode.first =  pos\n   errorNode.last  =  #str -- See above\n   errorNode.msg   =  message\n   errorNode.name  =  name\n   errorNode.str   =  str\n   errorNode.rest  =  string.sub(str, pos)\n   errorNode.patt  =  patt\n\n   return errorNode\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Err.Err(name, msg, patt)\n  return Cp() * Cc(name) * Cc(msg) * Cc(patt) * Carg(1) / parse_error\nend\n\nErr.E = Err.Err\n\nfunction Err.EOF(name, msg)\n  return -P(1) + Err.Err(name, msg), Cp()\nend\n\nreturn Err\n\n",
name = "espalier/error",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "5746ed2066e569f481a69ee4fe0ba20f3ba29e980e618f70f502547e445f8058",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit then\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fromString(g_str)\n   local maybe_lua, err = loadstring(g_str)\n   if maybe_lua then\n      return maybe_lua()\n   else\n      s : halt (\"cannot make function:\\n\" .. err)\n   end\nend\n\nlocal function _toFunction(maybe_grammar)\n   if type(maybe_grammar) == \"string\" then\n      return _fromString(maybe_grammar)\n   elseif type(maybe_grammar) == \"table\" then\n      -- we may as well cast it to string, since it might be\n      -- and sometimes is a Phrase class\n      return _fromString(tostring(maybe_grammar))\n   end\nend\n\nlocal P = assert(L.P)\n\n\n\n\n\nlocal function ʤ(inn)\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function qoph(In, template, metas)\n      g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\n\nend\n\n\n\n\nlocal function dji(In, bottle)\n   local template = bottle.template, bottle.metas,\n                                     bottle.pre, bottle.post\n   local function define(template, metas, pre, post)\n   if type(template) ~= \"function\" then\n      -- see if we can coerce it\n      template = _toFunction(template)\n   end\n\n   local metas = refineMetas(bottle.metas or {})\n   local grammar = qoph(In, template, metas)\n   local pre, post = bottle.pre, bottle.post\n\n   local function parse(str, start, finish)\n      local sub_str, begin = str, 1\n      local offset = start and start - 1 or 0\n      if start and finish then\n         sub_str = sub(str, start, finish)\n      end\n      if start and not finish then\n         begin = start\n         offset = 0\n      end\n      if pre then\n         str = pre(str)\n         assert(type(str) == \"string\")\n      end\n\n      local match = L.match(grammar, sub_str, begin, str, metas, offset)\n      if match == nil then\n         return nil\n      elseif type(match) == \'number\' then\n         return sub(sub_str, 1, match)\n      end\n      if post then\n        match = post(match)\n      end\n      match.complete = match.last == #sub_str + offset\n      return match\n   end\n\n   return parse, grammar\nend\nend\n\n\n\nreturn dji\n\n",
name = "espalier/dji",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "b2b19ca0c6546edef4b7780df123559cb3bbd150ce412b959c78731cf7afd084",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.angry   = false\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal compact = assert(require \"core/table\" . compact)\nlocal Node = require \"espalier/node\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal assert = assert\nlocal string = assert(string)\nlocal sub = assert(string.sub)\nlocal remove = assert(table.remove)\nlocal VER = sub(assert(_VERSION), -4)\nlocal _G = assert(_G)\nlocal error = assert(error)\nlocal pairs = assert(pairs)\nlocal next = assert(next)\nlocal type = assert(type)\nlocal tostring = assert(tostring)\nlocal setmeta = assert(setmetatable)\nif VER == \" 5.1\" then\n   local setfenv = assert(setfenv)\n   local getfenv = assert(getfenv)\nend\n\n\n\n\n\n\n\n\nlocal function make_ast_node(id, first, t, last, str, metas, offset)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   t.first = first + offset\n   t.last  = last + offset - 1\n   t.str   = str\n   if metas[id] then\n      local meta = metas[id]\n      if type(meta) == \"function\" then\n        t.id = id\n        t = meta(t, offset)\n      else\n        t = setmeta(t, meta)\n      end\n      assert(t.id, \"no id on Node\")\n   else\n      t.id = id\n      setmeta(t, metas[1])\n   end\n\n   if not t.parent then\n      t.parent = t\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local top, touched = #t, false\n   for i = 1, top do\n      local cap = t[i]\n      if type(cap) ~= \"table\" or not cap.isNode then\n         touched = true\n         t[i] = nil\n      else\n         cap.parent = t\n      end\n   end\n   if touched then\n      compact(t, top)\n   end\n\n\n\n\n\n\n\n\n\n   -- post conditions\n   assert(t.isNode, \"failed isNode: \" .. id)\n   assert(t.str, \"no string on node\")\n   assert(t.parent, \"no parent on \" .. t.id)\n   return t\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cp = L.Cp\nlocal Cc = L.Cc\nlocal Ct = L.Ct\nlocal arg1_str = L.Carg(1)\nlocal arg2_metas = L.Carg(2)\nlocal arg3_offset = L.Carg(3)\n\n\n\n\n\n\nlocal function nodemaker(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\nlocal function define(func, g, e, definer)\n   return definer(func, g, e)\nend\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit then\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fromString(g_str)\n   local maybe_lua, err = loadstring(g_str)\n   if maybe_lua then\n      return maybe_lua()\n   else\n      s : halt (\"cannot make function:\\n\" .. err .. \"\\n\" .. g_str)\n   end\nend\n\nlocal function _toFunction(maybe_grammar)\n   if type(maybe_grammar) == \"string\" then\n      return _fromString(maybe_grammar)\n   elseif type(maybe_grammar) == \"table\" then\n      -- we may as well cast it to string, since it might be\n      -- and sometimes is a Phrase class\n      return _fromString(tostring(maybe_grammar))\n   end\nend\n\nlocal P = assert(L.P)\n\nlocal function new(grammar_template, metas, pre, post)\n   if type(grammar_template) ~= \"function\" then\n      -- see if we can coerce it\n      grammar_template = _toFunction(grammar_template)\n   end\n\n   local metas = metas or {}\n   metas = refineMetas(metas)\n   local grammar = define(grammar_template, nil, metas, nodemaker)\n\n   local function parse(str, start, finish)\n      local sub_str, begin = str, 1\n      local offset = start and start - 1 or 0\n      if start and finish then\n         sub_str = sub(str, start, finish)\n      end\n      if start and not finish then\n         begin = start\n         offset = 0\n      end\n      if pre then\n         str = pre(str)\n         assert(type(str) == \"string\")\n      end\n\n      local match = L.match(grammar, sub_str, begin, str, metas, offset)\n      if match == nil then\n         return nil\n      elseif type(match) == \'number\' then\n         return sub(sub_str, 1, match)\n      end\n      if post then\n        match = post(match)\n      end\n      match.complete = match.last == #sub_str + offset\n      return match\n   end\n\n   return parse, grammar\nend\n\n\n\nreturn new\n\n",
name = "espalier/grammar",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "176b4cb59e474387f2411bf1df7e08dbe4b6d034d8276be528f15ef9971fa62d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal t = {}\n\nlocal dot_header = [=[\ndigraph lpegNode {\n\nnode [fontname=Helvetica]\nedge [style=dashed]\n\n]=]\n\nlocal dot_footer = [=[\n\n}\n]=]\n\nlocal leaf_font  = \"Inconsolata\"\nlocal leaf_color = \"Gray\"\n\nlocal function sanitize_string(str)\n   -- filter \\ and \"\n   local phrase = str:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\'\"\', \'\\\\\"\')\n   if phrase:sub(-1,-1) == \"\\n\" then\n      return phrase:sub(1, -2)\n   else\n      return phrase\n   end\nend\n\nlocal function ast_to_label(ast, leaf_count)\n   -- nodes need unique names, so we append a leaf_count and increment it\n   local label      = ast.id.. \"_\" .. leaf_count \n   local label_line = label .. \" [label=\\\"\"\n      .. sanitize_string(ast:dotLabel()) .. \"\\\"]\\n\"\n   return label, label_line, leaf_count + 1\nend\n\nlocal function list_from_table(tab)\n   local table_list = \"\"\n   for _,v in ipairs(tab) do\n      table_list = table_list..\" \"..v\n   end\n   return table_list\nend\n\nlocal function value_to_label(value, leaf_count)\n   -- Generates a name and label for a leaf node.\n   -- Returns these with an incremented leaf_count.\n   local value = sanitize_string(value)\n   local name  = \"leaf_\"..leaf_count\n   local label = \" [color=\"..leaf_color..\",shape=rectangle,fontname=\"\n         ..leaf_font..\",label=\\\"\"..value..\"\\\"]\\n\"\n\n   return name, label, leaf_count + 1\nend\n\n\n\n\n\n\n\n\n\nlocal function dot_ranks(ast, phrase, leaf_count, ast_label)\n   local leaf_count = leaf_count or 0\n\n   -- Add the node we\'re working on\n   if ast.isNode then\n      local label = \"\"\n      local label_line = \"\"\n      local child_labels = {}\n      local child_label_lines = {}\n\n      -- Handle anonymous nodes\n      if not ast_label then\n         label, label_line, leaf_count = ast_to_label(ast, leaf_count)\n         phrase = phrase .. label_line .. \"\\n\\n\"\n      else \n         label = ast_label \n      end\n\n      -- Document child nodes\n      for i,v in ipairs(ast) do\n         -- assemble labels and label lines for all child nodes\n         if v.isNode then\n            child_labels[i], child_label_lines[i], leaf_count = \n               ast_to_label(v, leaf_count)\n         end\n      end\n\n      local child_list = list_from_table(child_labels)\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..label..\" -> {\"..child_list..\"}\\n\"\n         phrase = phrase..\"{rank=same;\"..list_from_table(child_labels)..\"}\\n\\n\"\n      end\n\n      -- Concatenate child label lines\n      for _, v in ipairs(child_label_lines) do\n         phrase = phrase..v..\"\\n\"\n      end\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..\"\\n\"\n      end\n\n      local leaf_val = nil\n\n      if ast.val then\n         leaf_val = ast.val\n      elseif ast.toValue then\n         leaf_val = ast:toValue()\n      end\n\n      -- Document value of leaf nodes\n      if (not ast[1]) and leaf_val then\n         local name = \"\" ; local val_label = \"\"\n         name, val_label, leaf_count = value_to_label(leaf_val, leaf_count)\n         phrase = phrase..label..\" -> \"..name..\"\\n\"\n         phrase = phrase..name..\" \"..val_label\n      end\n\n      local separator = \"// END RANK \" .. label .. \"\\n\\n\"\n      phrase = phrase .. separator\n\n      -- Execute recursively for all nodes\n      for i, v in ipairs(ast) do\n         if v.isNode  then\n            phrase, leaf_count = dot_ranks(v, phrase, leaf_count, child_labels[i])\n         end\n      end\n   end\n\n   return phrase, leaf_count\nend\n\n\n\n\n\nfunction t.dot(ast)\n   local phrase = dot_header\n\n   return  dot_ranks(ast, phrase) .. dot_footer\nend\n\nreturn t\n\n",
name = "espalier/dot",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "5be162bd3c36106e9bbf3711e66a3823d4fd6b73ec901a0530e264f5ba2fc442",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\n\n\n\n\n\n\n\n\n\n\n\nlocal Lex = meta {}\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal KW = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal OP = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\\\"\'[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (letter^1 + P\"_\"^1)\n               * (letter + digit + P\"_\")^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)\n\n\n\nreturn { lua = { number      = number,\n                 digit       = digit,\n                 symbol      = symbol,\n                 comment     = comment,\n                 string      = string_short,\n                 string_long = string_long,\n                 WS          = WS,\n                 terminal    = terminal,\n                 keyword     = KW,\n                 operator    = OP },\n         digit  = digit,\n         number = number,\n         string = { str        = string_short,\n                    single     = single_str,\n                    double     = double_str,\n                    str_escape = str_esc },\n         higit   = higit,\n         hex     = _hexadecimal,\n         decimal = _decimal,\n         letter  = { latin = letter } }\n\n",
name = "espalier/lexemes",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "484faa1390bb14550f22cd17533caf9ec5bce61373b07eceeb934008d0f6d5a7",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal yield = assert(coroutine.yield, \"uses coroutines\")\nlocal wrap = assert(coroutine.wrap)\n--local sub, find = assert(string.sub, \"uses string\"), assert(string.find)\nlocal setmeta, getmeta = assert(setmetatable), assert(getmetatable)\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal a = require \"anterm:anterm\"\nlocal c_bw = require \"singletons/color\" . no_color\nlocal core = require \"core:core\"\n--local Phrase = require \"singletons/phrase\"\nlocal dot = require \"espalier/dot\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = {}\nNode.__index = Node\nNode.isNode = Node\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.bustCache(node)\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toLua(node)\n  s:halt(\"No toLua method for \" .. node.id)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.strTag(node, c)\n   c = c or c_bw\n   return c.bold(node.id) .. \"    \"\n      .. c.number(node.first) .. \"-\" .. c.number(node.last)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.strExtra(node, c)\n   return \"\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _truncate(str, base_color, c)\n   local phrase;\n\n   if #str > 56 then\n       --  Truncate in the middle\n       local pre, post = str:sub(1, 26), str:sub(-26, -1)\n       phrase = base_color(pre)\n                     .. c.bold(\"………\") .. base_color(post)\n   else\n       phrase = base_color(str)\n   end\n   return phrase\n           : gsub(\"\\n\", \"◼︎\")\n           : gsub(\"[ ]+\", c.greyscale(\"␣\")\n           .. base_color())\nend\n\nfunction Node.strLine(node, c)\n   c = c or c_bw\n   local phrase =  \"\"\n   phrase = phrase .. node:strTag(c)\n   if node[1] then\n      phrase = phrase .. \" \" .. node:strExtra(c) .. \"   \"\n               .. _truncate(node:span(), c.greyscale, c) .. \"\\n\"\n   else\n      local val = node.str:sub(node.first, node.last)\n      phrase = phrase .. \"    \" .. _truncate(val, c.string, c)  .. \"\\n\"\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toString(node, depth, c, limit)\n   depth = depth or 0\n   if limit and depth >= limit then\n      return \"\"\n   end\n   local line =  node:strLine(c)\n   local phrase = \"\"\n   if tostring(line) ~= \"\" then\n      phrase = phrase .. (\"  \"):rep(depth)\n      phrase = phrase .. line\n   end\n   for _, twig in ipairs(node) do\n      if (twig.isNode) then\n         phrase = phrase .. twig:toString(depth + 1, c, limit)\n      end\n   end\n   return phrase\nend\n\n\n\nlocal function __tostring(node)\n   if not node.str then\n      return \"Node\"\n   end\n   return tostring(node:toString())\nend\n\nNode.__tostring = __tostring\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nlocal function __repr(node, phrase, c)\n   local node__repr = tostring(node:toString(0, c))\n   return lines(node__repr)\nend\n\nNode.__repr = __repr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.span(node)\n   return node.str:sub(node.first, node.last)\nend\n\n\n\n\n\n\n\n\n\nfunction Node.bounds(node)\n   return node.first, node.last\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.len(node)\n    return 1 + node.last - node.first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gap(left, right)\n  assert(left.last, \"no left.last\")\n  assert(right.first, \"no right.first\")\n  assert(right.last, \"no right.last\")\n  assert(left.first, \"no left.first\")\n  if left.first >= right.last then\n    local left, right = right, left\n  elseif left.last > right.first then\n    s:halt(\"overlapping regions or str issue\")\n  end\n  local gap = left - right - 1\n  if gap >= 0 then\n    return gap\n  else\n    s:halt(\"some kind of situation where gap is \" .. tostring(gap))\n  end\n\n  return nil\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.dotLabel(node)\n  return node.id\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.label(node)\n   return node.id\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toMarkdown(node)\n  if not node[1] then\n    return sub(node.str, node.first, node.last)\n  else\n    s:halt(\"no toMarkdown for \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\nfunction Node.dot(node)\n  return dot.dot(node)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.toValue(node)\n  if node.__VALUE then\n    return node.__VALUE\n  end\n  if node.str then\n    return node.str:sub(node.first,node.last)\n  else\n    s:halt(\"no str on node \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _root(node)\n   if node.parent == node then\n      return node\n   end\n   return _root(node.parent)\nend\n\nNode.root = _root\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.next(node, pred)\n   assert(pred, \':next needs a predicate at the moment\')\n   return node:select(pred)()\nend\n\n\n\n\n\n\n\nfunction Node.walkPost(node)\n    local function traverse(ast)\n        if not type(ast) == \'table\' and ast.isNode then return nil end\n\n        for _, v in ipairs(ast) do\n            if type(v) == \'table\' and v.isNode then\n              traverse(v)\n            end\n        end\n        yield(ast)\n    end\n\n    return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.walkBreadth(node)\n   local function traverse(ast, depth)\n      for i = 1, #ast do\n         yield(ast[i], depth, i)\n      end\n      for j= 1, #ast do\n         traverse(ast[j], depth + 1)\n      end\n   end\n\n   return wrap(function() traverse(node, 1) end)\nend\n\n\n\n\n\n\n\n\nfunction Node.walk(node)\n  local function traverse(ast)\n    if not type(ast) == \'table\' and ast.isNode then return nil end\n    yield(ast)\n    for _, v in ipairs(ast) do\n      if type(v) == \'table\' and v.isNode then\n        traverse(v)\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function qualifies(ast, pred)\n    if type(pred) == \'string\' then\n       if type(ast) == \'table\'\n        and ast.id and ast.id == pred then\n          return true\n       else\n          return false\n       end\n    elseif type(pred) == \'function\' then\n       return pred(ast)\n    else\n       s:halt(\"cannot select on predicate of type \" .. type(pred))\n    end\n end\n\nlocal remove = assert(table.remove)\n\nfunction Node.select(node, pred)\n   -- build up all the nodes that match\n   local matches = {}\n   local function traverse(ast)\n      -- depth-first, right to left\n      if type(ast) == \'table\' and ast.isNode then\n         for i = #ast, 1, -1 do\n            traverse(ast[i])\n         end\n      end\n      if qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n   traverse(node)\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _take(node, pred)\n   if qualifies(node, pred) then\n      return node\n   end\n   for _, twig in ipairs(node) do\n      local took = _take(twig, pred)\n      if took then\n         return took\n      end\n   end\n   return nil\nend\n\nNode.take = _take\n\n\n\n\n\n\n\n\n\nfunction Node.selectFrom(node, pred, index)\n   index = index or node.last\n   assert(type(index) == \'number\', \"index must be a number\")\n   -- build up all the nodes that match\n   local matches = {}\n\n   local function traverse(ast)\n      -- depth-first, right to left\n      for i = #ast, 1, -1 do\n        if ast[i].last >= index then\n            traverse(ast[i])\n        end\n      end\n      if ast.first > index and qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n\n   traverse(node:root())\n\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.selectBack(node, pred)\n   -- reject any node after this\n   local boundary = node.first\n   -- set up a function which moonwalks the tree\n   local function moonwalk(ast)\n      -- depth first, right to left, starting with peers of the node\n      for i = #ast, 1, -1 do\n         local suspect = ast[i]\n         -- don\'t check anything if ast[i].first >= boundary\n         if suspect.first < boundary then\n            -- candidate\n            moonwalk(suspect)\n         end\n      end\n      if ast.first < boundary and qualifies(ast, pred) then\n         yield(ast)\n      end\n   end\n   return wrap(function() return moonwalk(node:root()) end)\nend\n\n\n\n\n\n\n\n\n\nfunction Node.hasParents(node, ...)\n   if node.parent == node then return false end -- roots don\'t have parents.\n   local rents = {}\n   for i = 1, select(\'#\', ...) do\n      rents[select(i, ...)] = true\n   end\n   local parent = node.parent\n   repeat\n      if rents[parent.id] then\n         return true\n      end\n      parent = parent.parent\n   until parent == parent.parent -- root\n\n   return false\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.rootDistance(node)\n   if node == node.parent then return 1 end\n   local count, parent = 1, node.parent\n   repeat\n      count = count + 1\n      parent = parent.parent\n   until parent == parent.parent\n   return count\nend\n\n\n\n\n\n\n\n\nfunction Node.tokens(node)\n  local function traverse(ast)\n    for node in Node.walk(ast) do\n      if not node[1] then\n        yield(node:toValue())\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nfunction Node.lines(node)\n  return lines(node:span())\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal linepos = assert(require \"qor:core\" .string .linepos)\n\nfunction Node.linePos(node)\n   -- unfortunately we return twice as much info as we normally need \'just\n   -- in case\'\n   local line_first, col_first = linepos(node.str, node.first)\n   local line_last, col_last = linepos(node.str, node.last)\n   return line_first, col_first, line_last, col_last\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _lastLeaf(node)\n  if #node == 0 then\n    return node\n  else\n    return _lastLeaf(node[#node])\n  end\nend\n\nNode.lastLeaf = _lastLeaf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gather(node, pred)\n  local gathered = {}\n  for ast in node:select(pred) do\n    gathered[#gathered + 1] = ast\n  end\n\n  return gathered\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction Node.clone(node)\n   return cloneinstance(node)\nend\n\n\n\n\n\n\n\n\n\nlocal function _pluck(node, str, offset, parent)\n   local clone = setmetatable({}, getmetatable(node))\n   parent = parent or clone\n   for k, v in pairs(node) do\n      if type(k) == \"number\" then\n        clone[k] = _pluck(v, str, offset, clone)\n      elseif k == \"first\" or k == \"last\" then\n        clone[k] = v + offset\n      elseif k == \"parent\" then\n        clone.parent = parent\n      else\n        clone[k] = v\n      end\n   end\n   clone.str = str\n   return clone\nend\n\nfunction Node.pluck(node)\n   local str = node:span()\n   local offset = - node.first + 1\n   local plucked = _pluck(node, str, offset)\n--   assert(plucked.first == 1)\n   return plucked\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal inbounds = assert(require \"core:math\" . inbounds)\nlocal insert = assert(table.insert)\n\nlocal function _offsetBy(node, str, offset, dupes)\n   if dupes[node] then return end\n   node.str = str\n   node.first = node.first + offset\n   node.last = node.last + offset\n   dupes[node] = true\n   node:bustCache()\n   for i = 1, #node do\n      _offsetBy(node[i], str, offset, dupes)\n   end\nend\n\nlocal function _applyGraft(node, branch, index, insertion, replace)\n   local branch = cloneinstance(branch)\n   if replace then\n      assert(node[insertion].first == index,\n             \"illegal replacement: index is \" .. index .. \" but first of \"\n             .. node.id .. \", \'\" .. node:span() .. \"\', is \" .. node.first)\n   end\n   -- create new string\n   local str = \"\"\n   if replace then\n      str = sub(node.str, 1, index - 1)\n            .. branch.str .. sub(node.str, node[insertion].last + 1)\n   else\n      str = sub(node.str, 1, index - 1) .. branch.str .. sub(node.str, index)\n   end\n   -- calculate offset for first and last adjustment\n   local offset\n   if replace then\n      -- difference between new span and old (could be negative)\n      local old_span = node[insertion].last - node[insertion].first + 1\n      offset = #branch.str - old_span\n   else\n      offset = #branch.str\n   end\n   -- avoid offsetting nodes more than once by keeping a dupes collection:\n   local dupes = {}\n\n   -- offset the branch clone to the new index\n   _offsetBy(branch, str, index - 1, dupes)\n   -- now graft\n   branch.parent = node\n   if replace then\n      node[insertion] = branch\n   else\n      insert(node, insertion, branch)\n   end\n   -- - all parents must be adjusted on .last += offset\n   -- - all left peers of any parent get strings replaced, no adjustment\n   -- - any right peers of any parent must be adjusted by offset\n   local walking = true\n   local parent = node\n   local child = node[insertion]\n   repeat\n      if parent.parent == parent then\n         -- this is the root\n         walking = false\n      end\n      dupes[parent] = true\n      parent.last = parent.last + offset\n      parent.str = str\n      local on_left = true\n      for i, sibling in ipairs(parent) do\n         if on_left and sibling ~= child then\n            -- (only) replace the string\n            _offsetBy(sibling, str, 0, dupes)\n         elseif sibling == child then\n            on_left = false\n          -- we\'ve offset this already\n         else\n            _offsetBy(sibling, str, offset, dupes)\n         end\n      end\n      child = parent\n      parent = parent.parent\n   until not walking\n\nend\n\nlocal function graft(node, branch, index, replace)\n   assert(type(index) == \'number\', \"index must be a number\")\n   if #node == 0 then\n     -- we can\'t graft onto a token\n     local line, col = node:linePos()\n     error(\"can\'t graft in the middle of token \" .. node.id\n           .. \"at line: \" .. line .. \", col: \" .. col .. \", index: \" .. index)\n   end\n   -- search for a graft point at index\n   -- we can graft anywhere between node.first and node[1].first:\n   if inbounds(index, node.first, node[1].first) then\n      return _applyGraft(node, branch, index, 1, replace)\n   -- same for node[#node].last + 1 and node.last + 1:\n   elseif inbounds(index, node[#node].last + 1, node.last + 1) then\n      return _applyGraft(node, branch, index, #node + 1, replace)\n   end\n   -- we either find a gap, or a sub-node we should search through.\n   -- first we look for gaps:\n   for i = 2, #node do\n      if inbounds(index, node[i - 1].last + 1, node[i].first) then\n         return _applyGraft(node, branch, index, i, replace)\n      end\n   end\n   -- now, check for compatible subnodes:\n   for _, twig in ipairs(node) do\n     if inbounds(index, twig.first + 1, twig.last) then\n        return graft(twig, branch, index, replace)\n     end\n   end\n   -- here we\'re just stuck: bad index is likely\n   error(\"unable to graft \" .. branch.id .. \" onto \" .. node.id\n         .. \"\'\" .. node:span().. \"\'\" .. \" at index \" .. index\n         .. \". #node.str == \" .. #node.str)\nend\n\nfunction Node.graft(node, branch, index)\n   return graft(node, branch, index)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.replace(node, branch, index)\n   return graft(node, branch, index, true)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.isValid(node)\n  assert(node.id, \"node must have an id\")\n  assert(node.isNode == Node, \"isNode flag must be Node metatable, id: \"\n         .. node.id .. \" \" .. tostring(node))\n  assert(node.first, \"node must have first\")\n  assert(type(node.first) == \"number\", \"node.first must be of type number\")\n  assert(node.last, \"node must have last\")\n  assert(type(node.last) == \"number\", \"node.last must be of type number\")\n  assert(node.str, \"node must have str\")\n  assert(type(node.str) == \"string\",  \"str must be string\")\n  assert(getmetatable(node), \"node must have a metatable: \" .. node.id)\n  assert(node.parent and node.parent.isNode == Node,\n         \"node must have parent: \" .. node.id)\n  assert(type(node:span()) == \"string\", \"span() must yield string\")\n  return true\nend\n\n\n\n\n\n\n\n\nlocal function _validate(node)\n   node:isValid()\n   for _, twig in ipairs(node) do\n      assert(twig.parent == node, \"illegal parent \" .. twig.parent.id\n             .. \" should be a \" .. node.id)\n      _validate(twig)\n   end\n   return true\nend\nNode.validate = _validate\n\n\n\n\n\n\n\n\n\nlocal function _isCompact(node, breaks)\n   local is_compact = true\n   local subCompact\n   if #node > 0 then\n      -- node.first must match first of subnode\n      local first_match = node.first == node[1].first\n      if not first_match then\n        -- register the \'break\'\n        local line, col = node:linePos()\n        insert(breaks.pre, {node.id, node[1].first - node.first,\n                            line, col,\n                            node.str:sub(node.first, node[1].first - 1)})\n      end\n      is_compact = is_compact and first_match\n      for i = 2, #node do\n        -- check gap between subNodes\n        local left, right = node[i-1].last, node[i].first\n        local inter_match = left == right - 1\n        if not inter_match then\n           local _, __, line, col =  node[i-1]:linePos()\n           insert(breaks.inter, {node[i-1].id, i, node[i].id,\n                                 right - left - 1, line, col + 1,\n                                 node.str:sub(left + 1, right - 1)})\n        end\n        is_compact = is_compact and inter_match\n        -- run isCompact recursively\n        subCompact = _isCompact(node[i-1], breaks)\n        is_compact = is_compact and subCompact\n      end\n      -- test last node\n      subCompact = _isCompact(node[#node], breaks)\n      is_compact = is_compact and subCompact\n      -- node.last must match last of subnode\n      local last_match = node.last == node[#node].last\n      if not last_match then\n        local _, __, line, col = node[#node]:linePos()\n        insert(breaks.post, {node.id, node.last - node[#node].last,\n                             line, col + 1,\n                             node.str:sub(node[#node].last + 1, node.last)})\n      end\n      is_compact = is_compact and last_match\n   end\n   return is_compact\nend\n\nfunction Node.isCompact(node)\n   local breaks = { pre = {}, inter = {}, post = {} }\n   local is_compact = _isCompact(node, breaks)\n   return is_compact, breaks\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.inherit(node, id)\n  local Meta = setmeta({}, node)\n  Meta.__index = Meta\n  local _repr, _tostring = __repr, __tostring\n  local node_M = getmetatable(node)\n  if node_M then\n    _repr = node_M.__repr\n    _tostring = node_M.__tostring\n  end\n  Meta.__repr = _repr\n  Meta.__tostring = _tostring\n  if id then\n    Meta.id = id\n  end\n  return Meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.export(_, mod, constructor)\n  mod.__call = constructor\n  return setmeta({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn Node\n\n",
name = "espalier/node",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "0525346176a568e2440bd8ecb41f9cd354dc666c5facd728087c538be0422bec",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier/elpatt\"\nlocal P, R, V = L.P, L.R, L.V\nlocal Grammar = require \"espalier:espalier/grammar\"\nlocal pegMetas = require \"espalier:espalier/pegmeta\"\n\n\n\n\n\n\nlocal function pegylator(_ENV)\n   START \"rules\"\n   ---[[\n   SUPPRESS (\"enclosed\", \"form\",\n            \"element\" , \"WS\",\n            \"elements\", \"allowed_repeated\",\n            \"allowed_prefixed\", \"allowed_suffixed\", \"allowed_referred\",\n            \"simple\", \"compound\", \"prefixed\", \"suffixed\",\n            \"referred\", \"named_suffix\", \"back_referred\", \"equal_referred\",\n            \"greater_equal_referred\", \"greater_referred\",\n            \"lesser_equal_referred\", \"lesser_referred\",\n            \"pel\", \"per\" )\n   --]]\n   local comment_m  = -P\"\\n\" * P(1)\n   local comment_c =  comment_m^0\n   local letter = R\"AZ\" + R\"az\"\n   local valid_sym = letter + P\"-\" + P\"_\"\n   local digit = R\"09\"\n   local sym = valid_sym + digit\n   local symbol = letter * (sym)^0\n   local d_string = P \"\\\"\" * (P \"\\\\\" * P(1) + (1 - P \"\\\"\"))^0 * P \"\\\"\"\n   local h_string = P \"`\" * (P \"\\\\\" * P(1) + (1 - P \"`\"))^0 * P \"`\"\n   local s_string = P \"\'\" * (P \"\\\\\" * P(1) + (1 - P \"\'\"))^0 * P \"\'\"\n   local range_match =  -P\"-\" * -P\"\\\\\" * -P\"]\" * P(1)\n   local range_capture = (range_match + P\"\\\\-\" + P\"\\\\]\" + P\"\\\\\")^1\n   local range_c  = range_capture^1 * P\"-\" * range_capture^1\n   local set_match = -P\"}\" * -P\"\\\\\" * P(1)\n   local set_c    = (set_match + P\"\\\\}\" + P\"\\\\\")^1\n   local some_num_c =   digit^1 * P\"..\" * digit^1\n                +   (P\"+\" + P\"-\")^0 * digit^1\n\n\n   rules   =  V\"rule\"^1\n   rule    =  V\"lhs\" * V\"rhs\"\n\n\n   lhs     =  V\"WS\" * V\"pattern\" * V\"WS\" * (P\"=\" + \":=\" + P\"<-\" + P\"←\")\n   rhs     =  V\"form\" * V\"WS\"\n\n   pattern =  symbol\n           +  V\"hidden_pattern\"\n           +  V\"ws\"\n\n   hidden_pattern =  P\"`\" * symbol * P\"`\"\n                  +  P\"`_`\"\n\n   -- SUPPRESSED\n   form    =  V\"element\" * V\"elements\"\n\n   element  =   -V\"lhs\" * V\"WS\"\n            *  ( V\"simple\"\n            +    V\"compound\")\n\n   elements  =  V\"choice\"\n             +  V\"cat\"\n             +  P\"\"\n   -- /SUPPRESSED\n\n   choice =  V\"WS\" * P\"/\" * V\"form\"\n   cat =  V\"WS\" * V\"form\"\n\n   -- SUPPRESSED\n   compound =  V\"group\"\n          +  V\"enclosed\"\n          +  V\"hidden_match\"\n   -- /SUPPRESSED\n\n   group   =  V\"WS\" * V\"pel\"\n           *  V\"WS\" * V\"form\" * V\"WS\"\n           *  V\"per\"\n\n   hidden_match =  V\"WS\" * P\"``\"\n                *  V\"WS\" * V\"form\" * V\"WS\"\n                *  P\"``\"\n   -- SUPPRESSED\n   pel     = P \"(\"\n   per     = P \")\"\n\n   simple   =  V\"repeated\"\n            +  V\"named\"\n            +  V\"prefixed\"\n            +  V\"suffixed\"\n            +  V\"atom\"\n            +  V\"number\"\n\n   enclosed =  V\"literal\"\n            +  V\"hidden_literal\"\n            +  V\"set\"\n            +  V\"range\"\n\n   prefixed =  V\"not_predicate\"\n            +  V\"and_predicate\"\n\n   suffixed =  V\"zero_or_more\"\n            +  V\"one_or_more\"\n            +  V\"optional\"\n\n   allowed_prefixed =  V\"suffixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n   allowed_suffixed =  V\"prefixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n\n   allowed_repeated =  V\"prefixed\"\n                    +  V\"suffixed\"\n                    +  V\"compound\"\n                    +  V\"atom\"\n                    +  V\"number\"\n\n   -- /SUPPRESSED\n\n   not_predicate = P\"!\" * V\"WS\" * V\"allowed_prefixed\"\n   and_predicate = P\"&\" * V\"WS\" * V\"allowed_prefixed\"\n\n   literal =  d_string\n           +  s_string\n\n   hidden_literal =  h_string\n\n           set =  P\"{\" * set_c^1 * P\"}\"\n\n       range   =  P\"[\" * V\"range_start\" * P\"-\" * V\"range_end\" * P\"]\"\n   range_start = range_capture\n   range_end   = range_capture\n\n    zero_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"*\"\n     one_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"+\"\n        optional =  V\"allowed_suffixed\" * V\"WS\" * P\"?\"\n        repeated =  V\"allowed_repeated\" * V\"WS\" * P\"%\" * V\"number_repeat\"\n           named =  V\"allowed_repeated\" * V\"WS\" * V\"named_suffix\"\n\n   named_suffix  =  P\"@\" * ( V\"named_match\"\n                           + V\"back_referred\"\n                           + V\"equal_referred\"\n                           + V\"greater_equal_referred\"\n                           + V\"greater_referred\"\n                           + V\"lesser_equal_referred\"\n                           + V\"lesser_referred\" )\n\n   back_referred   =  P\"(\" * V\"back_reference\" * P\")\"\n   equal_referred  =  P\"(#\" * V\"equal_reference\" * P\")\"\n   greater_equal_referred = P\"(>=\" * V\"gte_reference\" * P\")\"\n   greater_referred = P\"(>\" * V\"gt_reference\" * P\")\"\n   lesser_equal_referred = P\"(<=\" * V\"lte_reference\" * P\")\"\n   lesser_referred = P\"(<\" * V\"lt_reference\" * P\")\"\n\n   named_match     = symbol\n   back_reference  = symbol\n   equal_reference = symbol\n   gte_reference   = symbol\n   gt_reference    = symbol\n   lte_reference   = symbol\n   lt_reference    = symbol\n\n   number_repeat =  some_num_c\n\n   comment  =  P\";\" * comment_c\n\n   atom =  V\"ws\" + symbol\n\n   number = P\"-\"^-1 * digit^1\n\n   WS = (V\"comment\" + V\"dent\" + P\' \' + P\'\\t\' + P\'\\r\')^0\n\n   dent = P\"\\n\" * (P\"\\n\" + P\" \")^0\n\n   ws = P\"_\"\nend\n\n\n\n\nlocal PegGrammar = Grammar(pegylator, pegMetas)\n\n\n\nlocal function new(peg_str, metas, pre, post)\n   local peg_node = PegGrammar(peg_str)\n   if not peg_node then return nil end\n   local ok;\n   ok, peg_node.parse, peg_node.grammar = pcall(Grammar,peg_node:toLpeg(),\n                                              metas, pre, post)\n   if not ok then\n      peg_node.parse, peg_node.grammar = nil, nil\n   end\n   peg_node.metas = metas\n   return peg_node\nend\n\n\n\nreturn new\n\n",
name = "espalier/peg",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "d8e6523907410d91f8655efe2e7c53159a64f675eb7b21d94adb4b05b03bd799",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Grammar = require \"espalier:espalier/grammar\"\nlocal Seer   = require \"espalier:espalier/recognize\"\nlocal Phrase = require \"singletons/phrase\"\nlocal core = require \"qor:core\" -- #todo another qor\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal lines = assert(core.string.lines)\nlocal ok, lex = pcall(require, \"helm:helm/lex\")\nif not ok then\n   lex = function(repr, window, c) return tostring(repr) end\nelse\n   local lua_thor = lex.lua_thor\n   lex = function(repr, window, c)\n            local toks = lua_thor(tostring(repr))\n            for i, tok in ipairs(toks) do\n              toks[i] = tok:toString(c)\n            end\n            return lines(concat(toks))\n         end\nend\n\n\n\n\n\n\nlocal Peg, peg = Node : inherit()\nPeg.id = \"peg\"\n\n\n\n\n\n\n\n\n\nlocal PegPhrase = Phrase : inherit ({__repr = lex})\n\n\n\n\n\n\nlocal nl_map = { rule = true }\nlocal function _toSexpr(peg, depth)\n   depth = depth or 0\n   local sexpr_line = { (\" \"):rep(depth), \"(\" } -- Phrase?\n   local name = peg.name or peg.id\n   insert(sexpr_line, name)\n   insert(sexpr_line, \" \")\n   for _, sub_peg in ipairs(peg) do\n      local _toS = sub_peg.toSexpr or _toSexpr\n      insert(sexpr_line, _toS(sub_peg))\n      insert(sexpr_line, \" \")\n   end\n   remove(sexpr_line)\n   insert(sexpr_line, \")\")\n   if nl_map[name] then\n      insert(sexpr_line, \"\\n\")\n   end\n\n   return concat(sexpr_line)\nend\n\nPeg.toSexpr = _toSexpr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __repr(repr, phrase, c)\n   return _toSexpr(repr[1])\nend\n\nlocal ReprMeta = { __repr = __repr,\n                   __tostring = __repr }\nReprMeta.__index = ReprMeta\n\nlocal function newRepr(peg)\n   local repr = setmetatable({}, ReprMeta)\n   repr[1] = peg\n   return repr\nend\n\n\n\nfunction Peg.toSexprRepr(peg)\n   return newRepr(peg)\nend\n\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nfunction Peg.toLpeg(peg)\n   local phrase = PegPhrase \"\"\n   for _, sub in ipairs(peg) do\n      phrase = phrase .. sub:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal PegMetas = Peg : inherit()\nPegMetas.id = \"pegMetas\"\n\n\n\n\n\n\n\n\n\n\n\nlocal Rules = PegMetas : inherit \"rules\"\n\n\n\n\n\n\n\n\n\n\n\nlocal function _normalize(str)\n   return (str:gsub(\"%-\", \"%_\"))\nend\n\n\n\n\n\n\n\nfunction Rules.__call(rules, str, start, finish)\n   if not rules.parse then\n      rules.parse, rules.grammar = Grammar(rules:toLpeg())\n   end\n   return rules.parse(str, start, finish)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = PegPhrase ([[\n--local L = assert(require \"espalier:espalier/elpatt\")\nlocal L = assert(require \"lpeg\")\nlocal P, V, S, R = L.P, L.V, L.S, L.R\nlocal C, Cg, Cb, Cmt = L.C, L.Cg, L.Cb, L.Cmt\n]])\n\n\n\nlocal backref_rules = {\n   back_reference = [[\nlocal function __EQ_EXACT(s, i, a, b)\n   return a == b\nend\n]],\n   equal_reference = [[\nlocal function __EQ_LEN(s, i, a, b)\n   return #a == #b\nend\n]],\n   gte_reference = [[\nlocal function __GTE_LEN(s, i, a, b)\n   return #a >= #b\nend\n]],\n   gt_reference = [[\nlocal function __GT_LEN(s, i, a, b)\n   return #a > #b\nend\n]],\n   lte_reference = [[\nlocal function __LTE_LEN(s, i, a, b)\n   return #a <= #b\nend\n]],\n   lt_reference = [[\nlocal function __LT_LEN(s, i, a, b)\n   return #a < #b\nend\n]]\n}\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function _suppressHiddens(peg_rules)\n   local hiddens = {}\n   for hidden_patt in peg_rules : select \"hidden_pattern\" do\n      local normal = _normalize(hidden_patt:span():sub(2,-2))\n      insert(hiddens, normal)\n   end\n   if #hiddens == 0 then\n      -- no hidden patterns\n      return nil\n   end\n   local len = 14\n   local phrase = PegPhrase \"   \" .. \"SUPPRESS\" .. \" \" .. \"(\"\n   for i, patt in ipairs(hiddens) do\n      phrase = phrase .. \"\\\"\" .. patt .. \"\\\"\"\n      len = len + #patt + 2\n      if i < #hiddens then\n         phrase = phrase .. \",\" .. \" \"\n         if len > 80 then\n            phrase = phrase .. \"\\n\" .. (\" \"):rep(14)\n            len = 14\n         end\n      end\n   end\n   return phrase .. \")\" .. \"\\n\\n\"\nend\n\nfunction Rules.toLpeg(peg_rules, extraLpeg)\n   local phrase = PegPhrase()\n   -- Add matching functions if those rules are used\n   for rule, fn_str in pairs(backref_rules) do\n       if peg_rules:select(rule)() then\n          phrase = phrase .. fn_str\n       end\n   end\n   phrase = phrase .. \"\\n\"\n   -- the first rule should have an atom:\n   -- peg_rules[1]   -- this is the first rule\n   local grammar_patt = peg_rules : select \"rule\" ()\n                         : select \"pattern\" ()\n   local grammar_name = grammar_patt:span()\n   -- the root pattern can conceivably be hidden:\n   if grammar_name:sub(1,1) == \"`\" then\n      grammar_name = grammar_name:sub(2,-2)\n   end\n   grammar_name = _normalize(grammar_name)\n   local grammar_fn  = \"_\" .. grammar_name ..\"_fn\"\n   phrase = phrase .. \"local function \" .. grammar_fn .. \"(_ENV)\\n\"\n   phrase = phrase .. \"   \" .. \"START \" .. \"\\\"\" .. grammar_name .. \"\\\"\\n\"\n   -- Build the SUPPRESS function here, this requires finding the\n   -- hidden rules and suppressing them\n   local suppress = _suppressHiddens(peg_rules)\n   if suppress then\n      phrase = phrase .. suppress\n   end\n   -- add initial indentation:\n   phrase = phrase .. \"\\n\"\n   --\n   -- stick everything else in here...\n   ---[[\n   for rule in peg_rules : select \"rule\" do\n      phrase = phrase .. rule:toLpeg()\n   end\n   --]]\n   phrase = phrase .. (extraLpeg or \"\")\n   phrase = phrase .. \"\\nend\\n\\n\"\n   local appendix = PegPhrase \"return \" .. grammar_fn .. \"\\n\"\n   return _PREFACE .. phrase .. appendix\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rules.toGrammar(rules, metas, pre, post, extraLpeg, header)\n   metas = metas or {}\n   header = header or \"\"\n   local rule_str = rules:toLpeg(extraLpeg)\n   rule_str = header .. rule_str\n   rules.parse, rules.grammar = Grammar(rule_str, metas, pre, post)\n   return rules.parse\nend\n\n\n\n\n\n\n\n\nfunction Rules.toSeer(rules, metas)\n   metas = metas or {}\n   local rule_str = rules:toLpeg()\n   rules.see = Seer(rule_str, metas)\n   return rules.see\nend\n\n\n\n\n\n\n\n\nfunction Rules.allParsers(rules)\n   local allGrammars = {}\n   for rule in rules :select \"rule\" do\n      allGrammars[rule:ruleName()] = rule:toPeg():toGrammar()\n   end\n   return allGrammars\nend\n\n\n\n\n\n\n\n\n\nfunction Rules.getRule(rules, name)\n   for rule in rules :select \"rule\" do\n      if rule:ruleName() == _normalize(name) then\n         return rule\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\nfunction Rules.subPeg(rules, name)\n   local _rule = rules:getRule(name)\n   if not _rule then return nil end\n   return _rule:toPeg()\nend\n\n\n\n\n\n\nlocal Rule = PegMetas : inherit \"rule\"\n\nlocal function _pattToString(patt)\n   local is_hidden = patt : select \"hidden_pattern\" ()\n   if is_hidden then\n      return is_hidden:span():sub(2, -2)\n   else\n      return patt:span()\n   end\nend\n\n\n\nfunction Rule.ruleName(rule)\n   return _normalize(_pattToString(rule:select \"pattern\" ()))\nend\n\n\n\nlocal format = assert(string.format)\n\nfunction Rule.ruleString(rule)\n   return format(\"%q\", rule:ruleName())\nend\n\n\n\nfunction Rule.toLpeg(rule)\n   local patt = rule:ruleString()\n   local phrase = \"_ENV[\" .. patt .. \"] = \"\n   return phrase .. rule:select \"rhs\" () : toLpeg ()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _peg_str_memo = setmetatable({}, { __mode = \'kv\' })\n\nlocal lines = assert(core.string.lines)\n\nfunction Rule.toPegStr(rule)\n   local rules = rule:root()\n   local rule_name = rule:ruleName()\n   local metas = rules.metas or {}\n   local new_metas = {metas[1], [rule_name] = metas[rule_name]}\n\n   local name_rule, name_atoms = unpack(_peg_str_memo[rules] or {})\n   if not name_rule then\n      -- make the rules map\n      name_rule, name_atoms = {}, {}\n      for _rule in rules :select \"rule\" do\n         local _rule_name = _rule:ruleName()\n         local atoms = {}\n         name_rule[_rule_name] = _rule\n         name_atoms[_rule_name] = atoms\n         for atom in _rule :select \"rhs\" () :select \"atom\" do\n             insert(atoms, (_normalize(atom:span())))\n         end\n      end\n      -- and memoize it\n      _peg_str_memo[rules] = pack(name_rule, name_atoms)\n   end\n\n   local peg_str = {}\n   local dupes = { rule = true }\n   -- add the start rule\n   insert(peg_str, rule:span())\n\n   local function _rulesFrom(atoms)\n      for _, atom in ipairs(atoms) do\n         local _rule = name_rule[atom]\n         new_metas[atom] = metas[atom]\n         if _rule and not dupes[_rule] then\n            insert(peg_str, _rule:span())\n            dupes[_rule] = true\n            _rulesFrom(name_atoms[atom])\n         end\n      end\n   end\n\n   _rulesFrom(name_atoms[rule_name])\n\n   local function rfn() return concat(peg_str, \"\\n\") end\n   local function __repr()\n      return lines(rfn())\n   end\n\n   return setmetatable({}, { __repr = __repr, __tostring = rfn }),\n          new_metas\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal _Peg;\n\nfunction Rule.toPeg(rule)\n   _Peg = _Peg or require \"espalier:espalier/peg\"\n   local str, _M = rule:toPegStr()\n   return _Peg(tostring(str), _M)\nend\n\n\n\n\nfunction Rule.toSexpr(rule)\n   local phrase = \"(rule \" .. rule:ruleName()\n   for _, twig in ipairs(rule :select \"rhs\"()) do\n      phrase = phrase .. \" \" .. twig:toSexpr()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rhs = PegMetas : inherit \"rhs\"\n\nfunction Rhs.toLpeg(rhs)\n   local phrase = PegPhrase()\n   for _, twig in ipairs(rhs) do\n      phrase = phrase .. \" \" .. twig:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Choice = PegMetas : inherit \"choice\"\n\nfunction Choice.toLpeg(choice)\n   local phrase = PegPhrase \"+\"\n   for _, sub_choice in ipairs(choice) do\n      phrase = phrase .. \" \" .. sub_choice:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Cat = PegMetas : inherit \"cat\"\n\nfunction Cat.toLpeg(cat)\n   local phrase = PegPhrase \"*\"\n   for _, sub_cat in ipairs(cat) do\n      phrase = phrase .. \" \" .. sub_cat:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Group = PegMetas : inherit \"group\"\n\nfunction Group.toLpeg(group)\n   local phrase = PegPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. \" \" .. sub_group:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Not_predicate = PegMetas : inherit \"not_predicate\"\n\nfunction Not_predicate.toLpeg(not_pred)\n   local phrase = PegPhrase \"-(\"\n   for _, sub_not_pred in ipairs(not_pred) do\n      phrase = phrase .. sub_not_pred:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\nlocal And_predicate = PegMetas : inherit \"and_predicate\"\n\nfunction And_predicate.toLpeg(and_predicate)\n   local phrase = PegPhrase \"#\"\n   for _, sub_and_predicate in ipairs(and_predicate) do\n      phrase = phrase .. \" \" .. sub_and_predicate:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\nlocal Literal = PegMetas : inherit \"literal\"\n\nfunction Literal.toLpeg(literal)\n   return PegPhrase \"P\" .. literal:span()\nend\n\n\n\n\n\n\nlocal Set = PegMetas : inherit \"set\"\n\nfunction Set.toLpeg(set)\n   return PegPhrase(\"S\\\"\".. set:span():sub(2,-2) .. \"\\\"\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Range = PegMetas : inherit \"range\"\n\n\n\nfunction Range.toLpeg(range)\n   local phrase = PegPhrase \"R\\\"\"\n   phrase = phrase .. range : select \"range_start\" () : span()\n   return phrase .. range : select \"range_end\" () : span() .. \"\\\" \"\nend\n\n\n\n\n\nlocal Zero_or_more = PegMetas : inherit \"zero_or_more\"\n\nfunction Zero_or_more.toLpeg(zero_or_more)\n   local phrase = PegPhrase()\n   for _, sub_zero in ipairs(zero_or_more) do\n      phrase = phrase .. \" \" .. sub_zero:toLpeg()\n   end\n   return phrase .. \"^0\"\nend\n\n\n\n\n\n\nlocal One_or_more = PegMetas : inherit \"one_or_more\"\n\nfunction One_or_more.toLpeg(one_or_more)\n   local phrase = PegPhrase()\n   for _, sub_more in ipairs(one_or_more) do\n      phrase = phrase .. \" \" .. sub_more:toLpeg()\n   end\n   return phrase .. \"^1\"\nend\n\n\n\n\n\n\nlocal Optional = PegMetas : inherit \"optional\"\n\nfunction Optional.toLpeg(optional)\n   local phrase = PegPhrase()\n   for _, sub_optional in ipairs(optional) do\n      phrase = phrase .. \" \" .. sub_optional:toLpeg()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Repeated = PegMetas : inherit \"repeated\"\n\nfunction Repeated.toLpeg(repeated)\n   local phrase = PegPhrase \"\"\n   local condition = repeated[1]:toLpeg():intern()\n   local times = repeated[2]:span()\n      -- match at least times - 1 and no more than times\n   phrase = phrase .. \"#\" .. condition .. \"^\" .. times\n               .. \" * \" .. condition .. \"^-\" .. PegPhrase(times)\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nlocal Named = PegMetas : inherit \"named\"\n\nfunction Named.toLpeg(named)\n   local phrase = PegPhrase \"\"\n   local condition = named[1]:toLpeg():intern()\n   if named[2].id == \"named_match\" then\n     -- make a capture group\n     phrase = phrase .. \"Cg(\" .. condition .. \",\'\" .. named[2]:span()\n               .. PegPhrase \"\')\"\n   elseif named[2].id == \"back_reference\" then\n     -- make a back reference with equality comparison\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_EXACT)\"\n   elseif named[2].id == \"equal_reference\" then\n     -- make a back reference, compare by length\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GTE_LEN)\"\n   elseif named[2].id == \"gt_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GT_LEN)\"\n   elseif named[2].id == \"lte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LTE_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LT_LEN)\"\n   else\n      error(\"unexpected back reference, id \" .. tostring(named[2].id))\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Comment = PegMetas : inherit \"comment\"\n\nfunction Comment.toSexpr(comment)\n   return \"\"\nend\n\nfunction Comment.toLpeg(comment)\n   local phrase = PegPhrase \"--\"\n   return phrase .. comment:span():sub(2)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Atom = PegMetas : inherit \"atom\"\n\nfunction Atom.toLpeg(atom)\n   local phrase = PegPhrase \"V\"\n   phrase = phrase .. \"\\\"\" .. _normalize(atom:span()) .. \"\\\"\"\n   return phrase\nend\n\n\n\n\n\nfunction Atom.toSexpr(atom)\n   return \"(symbol \" .. _normalize(atom:span()) .. \")\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Number = PegMetas : inherit \"number\"\n\nfunction Number.toLpeg(number)\n   local phrase = PegPhrase \"P(\"\n   return phrase .. number:span() .. \")\"\nend\n\n\n\n\n\n\n\n\n\nlocal Dent = PegMetas : inherit \"dent\"\n\nfunction Dent.toLpeg(dent)\n   return dent:span()\nend\n\nfunction Dent.strLine(dent)\n   return \"\"\nend\n\n\n\n\n\n\nlocal Whitespace = PegMetas : inherit \"WS\"\n\nfunction Whitespace.toLpeg(whitespace)\n   return PegPhrase(whitespace:span())\nend\n\n\n\nreturn { Peg,\n         rules   = Rules,\n         rule    = Rule,\n         rhs     = Rhs,\n         comment = Comment,\n         choice  = Choice,\n         cat     = Cat,\n         group   = Group,\n         atom    = Atom,\n         number  = Number,\n         set     = Set,\n         range   = Range,\n         literal = Literal,\n         zero_or_more  = Zero_or_more,\n         one_or_more   = One_or_more,\n         not_predicate = Not_predicate,\n         and_predicate = And_predicate,\n         optional  = Optional,\n         repeated  = Repeated,\n         named     = Named,\n         WS        = Whitespace,\n         dent      = Dent }\n\n",
name = "espalier/pegmeta",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "298a4ead58b63e061bdb67b11177189ab3153ef7bf392179d399720bf8cdc1e7",
binary = "\n\n\n\n\nlocal core = require \"qor:core\"\n\n\n\nlocal Peg_M = require \"espalier:espalier/pegmeta\"\n\n\n\n\n\n\n\n\n\n\nlocal P_ENV = setmetatable({}, { __index = getfenv(1) })\n\nsetfenv(1, P_ENV)\nassert(getmetatable) -- sanity check\n\n\n\nlocal upper = assert(string.upper)\n\nfor name, category in pairs(Peg_M) do\n  if name == \'WS\' then\n     -- special case... meh\n     P_ENV.Whitespace = category:inherit(category.id)\n  elseif type(name) == \'string\' then\n     local up_name = upper(name:sub(1,1)) .. name:sub(2)\n     P_ENV[up_name] = category:inherit(category.id)\n  end\n  -- no action for [1] which we are about to inherit and call Peg\nend\n-- another sanity check\nassert(Rules)\n\n\n\n\n\n\n\n\n\n\n\nlocal _Peg = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal LITERAL, BOUNDED, REGULAR, RECURSIVE = 0, 1, 2, 3\n\nlocal NO_LEVEL = -1 -- comment and indentation type rules\n\n\n\n\n\n\nlocal POWER = { \'bounded\', \'regular\', \'recursive\',\n                [0] =\'literal\',\n                [-1] = \'no_level\',\n                [-2] = \'ERROR_NO_LEVEL_ASSIGNED\' }\n\n\n\n\n\n\n\n\n\n\nlocal function _literal(combi)\n   return LITERAL, \'literal\'\nend\n\nlocal function _bounded(combi)\n   return BOUNDED, \'bounded\'\nend\n\nlocal function _regular(combi)\n   return REGULAR, \'regular\'\nend\n\nlocal function _no_level(combi)\n   return NO_LEVEL, \'no_level\'\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _Peg.powerLevel(peg)\n   local pow = -2\n   for _, twig in ipairs(peg) do\n      local level = twig:powerLevel()\n      pow = (tonumber(level) > tonumber(pow)) and level or pow\n   end\n   return pow, POWER[pow]\nend\n\n\n\n\n\n\n\n\nfor var, val in pairs(P_ENV) do\n   for k, v in pairs(_Peg) do\n      val[k] = v\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rules.powerMap(rules, map)\n   map = map or {}\n   local nyi_map = {}\n   local this_map = {}\n   this_map[1], this_map[2], this_map[3] = rules.id, rules:powerLevel()\n   insert(map, this_map)\n   for _, twig in ipairs(rules) do\n      local kids, bad_kids =  twig:powerMap()\n      for __, v in ipairs(kids) do\n         if v[2] == \'NaN\' then\n            insert(nyi_map, v)\n         else\n            insert(map, v)\n         end\n      end\n      for __, v in ipairs(bad_kids) do\n         insert(nyi_map, v)\n      end\n   end\n   return map, nyi_map\nend\n\n\n\n\n\n\n\n\nlocal compact = assert(core.table.compact)\n\nlocal function _atomsIn(rule)\n   local names = {}\n   for atom in rule :select \'rhs\'() :select \'atom\' do\n      insert(names, _normalize(atom:span()))\n   end\n   -- deduplicate\n   local seen, top = {}, #names\n   for i, sym in ipairs(names) do\n      if seen[sym] then\n         names[i] = nil\n      end\n      seen[sym] = true\n   end\n   compact(names, top)\n   return names\nend\n\nfunction Rules.analyse(rules)\n   local analysis = {}\n   rules.analysis = analysis\n   local name_to_symbols = {}\n   local name_to_rule = {}\n   analysis.symbols = name_to_symbols\n   analysis.rules = name_to_rule\n\n   -- map rules to the rules needed to match them\n   local start_rule = rules :select \'rule\' ()\n   local start_name = start_rule:ruleName()\n   local names_called = _atomsIn(start_rule)\n   name_to_symbols[start_name] = names_called\n   name_to_rule[start_name] = start_rule\n   name_to_rule[1] = start_rule\n   for rule in rules :select \'rule\' do\n      if rule ~= start_rule then\n         local name = rule:ruleName()\n         local names_called = _atomsIn(rule)\n         name_to_symbols[name] = names_called\n         name_to_rule[name] = rule\n      end\n   end\n   local name_to_power = {}\n   analysis.powers = name_to_power\n\n   -- get power levels for base rules\n   for name, symbols in pairs(name_to_symbols) do\n      if #symbols == 0 then\n         name_to_power[name] = name_to_rule[name]:powerLevel()\n      end\n   end\n\n   return analysis.powers\nend\n\nRules.analyze = Rules.analyse -- i18nftw\n\n\n\n\n\n\n\n\n\nfunction Rule.powerLevel(rule)\n   return rule :select \'rhs\' () :powerLevel()\nend\n\n\n\n\nRange.powerLevel = _bounded\n\n\n\n\nZero_or_more.powerLevel = _regular\n\n\n\nOne_or_more.powerLevel = _regular\n\n\n\nComment.powerLevel = _no_level\n\n\n\nNumber.powerLevel = _literal\n\n\n\nDent.powerLevel = _no_level\n\n\n\nWhitespace.powerLevel = _no_level\n\n\n\n\nfunction Named.powerLevel(named)\n   return named[1]:powerLevel()\nend\n\n\n\n\n\n\nSet.powerLevel = _bounded\n\n\n\n\n\n\n\nLiteral.powerLevel = _literal\n\n\n\n\n\n\n\n\n\n\nlocal PegMiddle = {}\n\nfor k, v in pairs(P_ENV) do\n   PegMiddle[v.id] = v\nend\n\n\n\nreturn PegMiddle\n\n",
name = "espalier/pegmiddleware",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "d7529a2f6243e114a04cf8067e7fb9d2fe7effbd1d6ea45292e3676bf7fdd8e9",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function nodemaker(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\n\n\nlocal function nodemaker(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = getfenv(func)\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             onsuppress(g, name, val)\n          else\n             g[ name ] = oncapture / withcapture\n          end\n       end })\n\n\n   setfenv(func, env)\n   func(env)\n   -- vav will not let rules get to qoph in this state:\n   -- assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function make_ast_node(id, first, t, last, str, metas, offset)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   t.first = first + offset\n   t.last  = last + offset - 1\n   t.str   = str\n   if metas[id] then\n      local meta = metas[id]\n      if type(meta) == \"function\" then\n        t.id = id\n        t = meta(t, offset)\n      else\n        t = setmeta(t, meta)\n      end\n      assert(t.id, \"no id on Node\")\n   else\n      t.id = id\n      setmeta(t, metas[1])\n   end\n\n   if not t.parent then\n      t.parent = t\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local top, touched = #t, false\n   for i = 1, top do\n      local cap = t[i]\n      if type(cap) ~= \"table\" or not cap.isNode then\n         touched = true\n         t[i] = nil\n      else\n         cap.parent = t\n      end\n   end\n   if touched then\n      compact(t, top)\n   end\n\n\n\n\n\n\n\n\n\n   -- post conditions\n   assert(t.isNode, \"failed isNode: \" .. id)\n   assert(t.str, \"no string on node\")\n   assert(t.parent, \"no parent on \" .. t.id)\n   return t\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cp = L.Cp\nlocal Cc = L.Cc\nlocal Ct = L.Ct\nlocal arg1_str = L.Carg(1)\nlocal arg2_metas = L.Carg(2)\nlocal arg3_offset = L.Carg(3)\n\n\n\n\n\n\nlocal function nodemaker(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\nlocal function define(func, g, e, definer)\n   return definer(func, g, e)\nend\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit then\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n",
name = "espalier/qoph",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "809e55d8da3377583c52605c0ea0704eeee248f617018f8f7e318d43eb43871a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.angry   = false\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal compact = assert(require \"core/table\" . compact)\nlocal Node = require \"espalier/node\"\n\n\n\nlocal L = require \"lpeg\"\nlocal assert = assert\nlocal string = assert(string)\nlocal sub = assert(string.sub)\nlocal remove = assert(table.remove)\nlocal VER = sub(assert(_VERSION), -4)\nlocal _G = assert(_G)\nlocal error = assert(error)\nlocal pairs = assert(pairs)\nlocal next = assert(next)\nlocal type = assert(type)\nlocal tostring = assert(tostring)\nlocal setmeta = assert(setmetatable)\nif VER == \" 5.1\" then\n   local setfenv = assert(setfenv)\n   local getfenv = assert(getfenv)\nend\n\n\n\n\n\n\n\nlocal setmeta = setmetatable\n\nlocal function recognizer(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n             g[ name ] = val\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\n\n\n\nlocal function define(definer, func, g, e)\n   return definer(func, g, e)\nend\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit then\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fromString(g_str)\n   local maybe_lua, err = loadstring(g_str)\n   if maybe_lua then\n      return maybe_lua()\n   else\n      s : halt (\"cannot make function:\\n\" .. err)\n   end\nend\n\nlocal function _toFunction(maybe_grammar)\n   if type(maybe_grammar) == \"string\" then\n      return _fromString(maybe_grammar)\n   elseif type(maybe_grammar) == \"table\" then\n      -- we may as well cast it to string, since it might be\n      -- and sometimes is a Phrase class\n      return _fromString(tostring(maybe_grammar))\n   end\nend\n\nlocal P = assert(L.P)\n\nlocal function new(grammar_template, metas, pre, post)\n   if type(grammar_template) ~= \"function\" then\n      -- see if we can coerce it\n      grammar_template = _toFunction(grammar_template)\n   end\n\n   local metas = metas or {}\n   metas = refineMetas(metas)\n   local grammar = define(recognizer, grammar_template, nil, metas)\n\n   local function parse(str, start, finish)\n      local sub_str, begin = str, 1\n      local offset = start and start - 1 or 0\n      if start and finish then\n         sub_str = sub(str, start, finish)\n      end\n      if start and not finish then\n         begin = start\n         offset = 0\n      end\n      if pre then\n         str = pre(str)\n         assert(type(str) == \"string\")\n      end\n\n      local match = L.match(grammar, sub_str, begin, str, metas, offset)\n      if match == nil then\n         return nil\n      elseif type(match) == \'number\' then\n         return match\n      end\n      if post then\n        match = post(match)\n      end\n      match.complete = match.last == #sub_str + offset\n      return match\n   end\n\n   return parse, grammar\nend\n\n\n\nreturn new\n\n",
name = "espalier/recognize",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "883255db98c5d92fab4cfcdb76af3ff0bb13d57676d5a62965cb659a91b2925e",
binary = "\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\nlocal input = \"\"\nwhile true do\n   local newline = io.stdin:read()\n   if newline == nil or string.byte(newline) == 17 then\n      os.exit(0)\n   end\n   input = input .. newline .. \"\\n\"\n   local res, err = loadstring(input)\n   if res then\n      res_tab = res()\n      if type(res_tab) == table and res_tab.grammar and res_tab.input then\n         local ok, peg = pcall(Peg, res_tab.grammar)\n         if ok then\n            local output = {grammar = peg:toString()}\n            local parse = peg:toGrammar()\n            local tree\n            ok, tree = pcall(parse, res_tab.input)\n            if ok then\n               output.tree = tree:toString()\n            end\n            io.stdout:write(output.grammar .. \"\\n\\n\")\n            if output.tree then\n               io.stdout:write(output.tree)\n            end\n         end\n      else\n         io.stdout:write \"must return a table with grammar and input fields\"\n      end\n      input = \"\"\n   end\nend\n\n",
name = "espalier/serve",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "43e24383a77247a454c73fb2c05febbdaf17f39aff7739ac77629e3754a7fdbf",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Set = require \"qor:core/set\"\nlocal Deque = require \"deque:deque\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function comparator(precedence, right_assoc)\n   local function higher(op1, op2)\n      local id1, id2 = op1.id, op2.id\n      if (precedence[id1] > precedence[id2])\n         or (precedence[id1] == precedence[id2]\n             and not right_assoc[id2]) then\n         return true\n      else\n         return false\n      end\n   end\n\n   return higher\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\nlocal Stack_idx = {}\n\nfunction Stack_idx.push(stack, val)\n   insert(stack, val)\nend\n\nfunction Stack_idx.pop(stack, num)\n   if num then\n      local values = {}\n      for i = 1, num do\n         values[i] =  remove(stack)\n      end\n      return unpack(values)\n   else\n      return remove(stack)\n   end\nend\n\nlocal Stack_M = { __index = Stack_idx }\n\nlocal function Stack()\n   return setmetatable({}, Stack_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function shunter(precedence, unary, higher, link)\n\n   local function shunt(expr)\n      local stack = Stack()\n      local out   = Deque()\n      for _, elem in ipairs(expr) do\n         -- operations have precedence, values and groups don\'t\n         local prec = precedence[elem.id]\n         if precedence[elem.id] then\n            local shunting = true\n            while shunting do\n               if #stack == 0 or unary[elem.id] then\n                  stack:push(elem)\n                  shunting = false\n               else\n                  local top = stack[#stack]\n                  if higher(top, elem) then\n                     out:push(stack:pop())\n                  else\n                     stack:push(elem)\n                     shunting = false\n                  end\n               end\n            end\n         else\n            out:push(elem)\n         end\n      end\n      while #stack > 0 do\n         out:push(stack:pop())\n      end\n      local phrase = {}\n      for elem in out:peekAll() do\n         insert(phrase, elem:span())\n      end\n      expr.RPN = table.concat(phrase, \" \")\n      return out\n   end\n\n   return shunt\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function linker(is_operator, unary, Metas)\n   local function link(out, expr)\n      local stack = Stack()\n      for elem in out:popAll() do\n         if is_operator[elem.id] then\n            local id = elem.id\n            local child = setmetatable({ id = id,\n                                         str = expr.str }, Metas[id])\n            if unary[id] then\n               child[1] = stack:pop()\n               child.first, child.last = elem.first, child[1].last\n               child[1].parent = child\n            else\n               local right, left = stack:pop(2)\n               child[1], child[2] = assert(left),\n                                    assert(right)\n               right.parent, left.parent = child, child\n               child.first, child.last = left.first, right.last\n            end\n            stack:push(child)\n         else\n            stack:push(elem)\n         end\n      end\n      if #stack ~= 1 then\n         expr.RPN = expr.RPN .. \"bad stack (\" .. #stack .. \")\"\n         return expr\n      end\n      local result = stack:pop()\n      result.RPN = expr.RPN\n      return result\n   end\n\n   return link\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(cfg)\n   local precedence = assert(cfg.precedence)\n   local right_assoc = Set(assert(cfg.right_assoc))\n   local unary = Set(assert(cfg.unary))\n\n   -- Set up the metatables\n   local _Twig = cfg[1]\n   local id = cfg[2]\n   local Twig, Expr;\n   if id then\n      Expr = _Twig :inherit(id)\n   else\n      Expr = _Twig\n   end\n   if _Twig then\n      Twig = _Twig\n   else\n      Twig = Node\n   end\n\n   local Metas = {}\n   for id in pairs(precedence) do\n      Metas[id] = Twig:inherit(id)\n   end\n\n   local higher = comparator(precedence, right_assoc)\n\n   local link = linker(precedence, unary, Metas)\n   local shunt = shunter(precedence, unary, higher, link)\n\n   local function Expression(expr)\n      -- no need to shunt #expr == 1\n      if #expr == 1 then\n         return setmetatable(expr, Expr)\n      end\n      local out = shunt(expr)\n      local _expr = { link(out, expr),\n                id    = expr.id,\n                str   = expr.str,\n                first = expr.first,\n                last  = expr.last }\n\n      return setmetatable(_expr, Expr)\n   end\n\n   return Expression, Metas, Expr\nend\n\n\n\nreturn new\n\n",
name = "espalier/shunter",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "e8d276333dd63f7f0628cc5c076dba6dc24127e1e8f0661f32fb47b3e65532a6",
binary = "\n\n\n\n\nlocal sqlite_bits = require \"espalier:espalier/grammars/sqlite\"\nlocal Vav = require \"espalier:vav\"\n\n\n\nreturn Vav(sqlite_bits[1])\n\n",
name = "espalier/sqlish",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "7e23b063d40ab0fbd7c4a742757bc622249de38da585d7cde6d0aa0540b6ccba",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg = require \"espalier:espalier/peg\"\n\nlocal function subgrammar(grammar, meta, errstring)\n   if type(grammar) == \'string\' then\n      -- try to coerce to Peg fn\n      grammar = Peg(grammar)\n   end\n   meta = meta or Node\n   return function (t)\n      local match = grammar(t.str, t.first, t.last)\n      if match then\n         if match.last == t.last then\n            return match\n         else\n            match.should_be = match.id\n            match.id = \"INCOMPLETE\"\n            return match\n         end\n      end\n      if errstring then\n         t.errstring = errstring\n         t.should_be = t.id\n         t.id        = \"NOMATCH\"\n      end\n      return setmetatable(t, meta)\n   end\nend\n\nreturn subgrammar\n\n",
name = "espalier/subgrammar",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "87f84b422ea4d9f8c973fea7ba064ea121b8bf079f630ff235fb949c642fc1ce",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = use(\"qor:core\", \"cluster:cluster\")\n\nlocal pegpeg = use \"espalier:peg/pegpeg\"\nlocal Metis = use \"espalier:peg/metis\"\n\n\n\n\n\n\nlocal VavPeg = use \"espalier:peg\" (pegpeg, Metis) . parse\n\n\n\n\n\n\nlocal Grammar = use \"espalier:espalier/grammar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Vav, Vav_M = cluster.order()\n\nVav.pegparse = VavPeg\n\n\ncluster.construct(new,\n   function(_new, vav, peh)\n     vav.grammar = VavPeg(peh)\n     if vav.grammar then\n        vav.grammar :hoist()\n        vav.synth = vav.grammar :synthesize()\n     else\n        vav.failedParse = true\n     end\n     vav.peh = peh\n     -- we\'ll have checks here\n\n      return vav\n   end)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Vav.constrain(vav)\n   return vav.synth:constrain()\nend\n\n\n\n\n\n\nfunction Vav.anomalies(vav)\n   return vav.synth:anomalies()\nend\n\n\n\n\n\n\n\n\nfunction Vav.dji(vav)\n   if not vav.lpeg_engine then\n      vav.lpeg_engine = vav.synth :toLpeg() :string()\n   end\n   -- we need more than this, notably the metis, but.\n   vav.parse, vav.pattern = Grammar(vav.lpeg_engine)\n   return vav.parse\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Vav.try(vav, rule)\n   local synth = vav.synth\n   if not synth.calls then\n      synth:analyze()\n   end\n\n   local anomalous = synth:anomalies()\n   if anomalous and anomalous.missing then\n      synth:makeDummies()\n   elseif not rule then\n      return vav:dji()\n   end\n   if rule then\n      local peh = synth:pehFor(rule)\n      local ruleVav = new(peh)\n      return ruleVav :try(), ruleVav\n   end\n   vav.peh_dummy = vav.peh .. vav.synth.dummy_rules\n   vav.dummy = new(vav.peh_dummy)\n   vav.test_engine = vav.dummy.synth :toLpeg() :string()\n   vav.test_parse, vav.test_pattern = Grammar(vav.test_engine)\n   return vav.test_parse\nend\n\n\n\nreturn new\n\n",
name = "espalier/vav",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "18621216537187580128744bb3a69aa33a4819801f73b271add90baee3b28c33",
binary = "\n\n\n\n\nlocal core, cluster = use(\"qor:core\", \"cluster:cluster\")\nlocal Feed = use \"text:formfeed\"\nlocal Set = core.set\n\n\n\n\n\n\n\nlocal function idx(tab, key)\n   rawset(tab, key, {})\n   return tab[key]\nend\n\nlocal M = setmetatable({}, {__index = idx})\n\n\n\n\n\nlocal _PREFACE = [[\n-- Automatically Generated by Espalier\n\nlocal L = assert(require \"lpeg\")\nlocal P, V, S = L.P, L.V, L.S\nlocal R = L.R\nlocal C, Cg, Cb, Cmt = L.C, L.Cg, L.Cb, L.Cmt\n\n]]\n\n\n\nlocal backref_rules = {\n   back_refer = [[\nlocal function __EQ_EXACT(s, i, a, b)\n   return a == b\nend\n\n]],\n   eq_refer = [[\nlocal function __EQ_LEN(s, i, a, b)\n   return #a == #b\nend\n\n]],\n   gte_refer = [[\nlocal function __GTE_LEN(s, i, a, b)\n   return #a >= #b\nend\n\n]],\n   gt_refer = [[\nlocal function __GT_LEN(s, i, a, b)\n   return #a > #b\nend\n\n]],\n   lte_refer = [[\nlocal function __LTE_LEN(s, i, a, b)\n   return #a <= #b\nend\n\n]],\n   lt_refer = [[\nlocal function __LT_LEN(s, i, a, b)\n   return #a < #b\nend\n\n]],\n}\n\n\n\n\n\n\nlocal  concat =  assert(table.concat)\n\nlocal function suppressHiddens(grammar, feed)\n   local hiddens = {}\n   for hidden in grammar :filter \'suppressed\' do\n      insert(hiddens, hidden :take \'rule_name\' . token)\n   end\n   if #hiddens == 0 then\n      -- no hidden patterns\n      return nil\n   end\n   feed:newLine()\n   feed:push(\"SUPPRESS\", \" \", \"(\")\n   feed:indent()\n   for i, patt in ipairs(hiddens) do\n      feed:push(\'\"\' .. patt .. \'\"\')\n      if i < #hiddens then\n         feed:push(\",\", \" \")\n      end\n   end\n   feed:push(\")\")\n   feed:dedent()\n   feed:newLine()\n   feed:newLine()\nend\n\n\n\nfunction M.grammar.toLpeg(grammar, extraLpeg)\n   local feed = Feed ()\n   insert(feed, _PREFACE)\n   -- reserve extra space at [2] for backref rules\n   local preface = {}\n   insert(feed, \"\")\n   feed.preface = preface\n   local start = grammar :take \'rule_name\' . token\n   local grammar_fn  = \"_\" .. start ..\"_fn\"\n   feed :push(\"local function \", grammar_fn, \"(_ENV)\")\n        :indent(3)\n        :newLine()\n        :push(\"START\", \"\", \"\'\" .. start .. \"\'\")\n        :newLine()\n   -- Build the SUPPRESS function here, this requires finding the\n   -- hidden rules and suppressing them\n   suppressHiddens(grammar, feed)\n\n   -- aggregate rules into the feed\n   for rule in grammar :filter \'rule\' do\n      rule:toLpeg(feed)\n   end\n\n   -- splice in backref functions if needed\n   local pre = {\"\"}\n   for _, backref in ipairs(preface) do\n      push(pre, backref_rules[backref])\n   end\n   feed[2] = concat(pre)\n\n   feed :dedent() :push \"end\" :newLine(2)\n        :push(\"return\", \" \", grammar_fn) :newLine()\n\n   return feed\nend\n\n\n\n\n\n\nfunction M.rule.toLpeg(rule, feed)\n   local token = \'\"\' .. assert(rule :take \'rule_name\' . token) .. \'\"\'\n   feed :push(\"_ENV\", \"[\", token, \"]\", \" \", \"=\", \" \")\n        :indent() :nudge(1)\n   rule :take \'rhs\' :toLpeg(feed)\n\n   feed :dedent() :newLine(2)\nend\n\n\n\nfunction M.rhs.toLpeg(rhs, feed)\n   assert(#rhs == 1, \"more than one child on rhs?\")\n   rhs[1]:toLpeg(feed)\nend\n\n\n\n\n\n\nfunction M.cat.toLpeg(rule, feed)\n   for i, element in ipairs(rule) do\n      feed:push(\"\")\n      element:toLpeg(feed)\n      if i < #rule then\n         feed:push(\"\", \"*\", \"\")\n      end\n   end\n   feed:push(\"\")\nend\n\n\n\nfunction M.alt.toLpeg(rule, feed)\n   for i, element in ipairs(rule) do\n      feed:push(\"\")\n      element:toLpeg(feed)\n      if i < #rule then\n         feed:push(\"\", \"+\", \"\")\n      end\n   end\n   feed:push(\"\")\nend\n\n\n\n\n\n\nfunction M.group.toLpeg(group, feed)\n   feed :push(\"\", \"(\") :indent()\n   assert(#group == 1, \"group has other than one child\")\n   group[1]:toLpeg(feed)\n   feed:push(\")\", \"\") :dedent()\nend\n\n\n\n\n\n\nfunction M.name.toLpeg(name, feed)\n   feed:push(\"\", \'V\"\' .. name.token .. \'\"\', \"\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Prefix = Set {\'and\', \'not\'}\nlocal Suffix = Set {\'zero_plus\', \'one_plus\', \'optional\', \'repeat\'}\nlocal Backref = Set {\'backref\'}\n\nlocal Surrounding = Prefix + Suffix + Backref\n\nlocal backrefBegin, backrefEnd\n\nfunction M.element.toLpeg(elem, feed)\n   local part, backref = elem[1], elem[2]\n\n   -- backrefs enclose everything including lookahead prefixes\n   if false then\n      backrefBegin(backref, feed)\n   end\n\n   if elem[\'and\'] then\n         feed:push(\"\", \"#\")\n   elseif elem[\'not\'] then\n         feed:push(\"\", \"-\", \"(\") :indent()\n   end\n\n   part:toLpeg(feed)\n\n   if elem.zero_plus then\n      feed:cling(\"^0\")\n   elseif elem.one_plus then\n      feed:cling(\"^1\")\n   elseif elem.optional then\n      feed:cling(\"^-1\")\n   elseif elem[\'repeat\'] then\n      -- handle this case\n   end\n\n\n   if elem[\'not\'] then\n      feed :push(\")\") :dedent()\n   end\n\n   if false then\n      backrefEnd(backref, feed)\n   end\n   feed:push(\"\")\nend\n\n\n\n\nfunction backrefBegin()\n\nend\n\nfunction backrefEnd()\n\nend\n\n\n\n\n\n\nfunction M.literal.toLpeg(literal, feed)\n   feed:push(\"\", \"P\" .. literal.token, \"\")\nend\n\n\n\n\n\n\nfunction M.number.toLpeg(number, feed)\n   feed:push(\"\", number.token, \"\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction M.set.toLpeg(set, feed)\n   feed:push(\"\", \'S\"\' .. set.value ..\'\"\',  \"\")\nend\n\n\n\nfunction M.range.toLpeg(range, feed)\n   feed:push(\"\", \'R\"\' .. range.from_char, range.to_char .. \'\"\', \"\")\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal upper = string.upper\nfunction M.rule.toPikchr(rule)\n   local feed = Feed()\n   feed:push [[\n     debug_label_color = 1\n     linerad = 10px\n     linewid *= 0.5\n     $h = 0.21\n     circle radius 10%\n]]\n   feed:push(upper(rule.token) .. \":\", \"\")\n   feed:push(\"[\", \"\", \"oval\", \"\", \'\"\' .. rule.token .. \'\"\', \"\", \"fit\")\n   feed:push(\"\", \"]\")\n   feed:newLine()\n   return feed:view()\nend\n\n\n\n\nreturn M\n\n",
name = "peg/codegen",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "4fcce0c9e72b6ab0b20a120d683d4d75097c64965abe935a5591e0a1b4201505",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = use \"lpeg\"\nlocal core, cluster = use(\"qor:core\", \"cluster:cluster\")\nlocal table = core.table\n\n\n\nlocal NodeQoph = {}\n\n\n\n\n\n\n\n\n\n\nlocal Cp = L.Cp\nlocal Cc = L.Cc\nlocal Ct = L.Ct\nlocal Carg = L.Carg\n\nNodeQoph.capturePattern = {\'name\', Cp, \'capture\', Cp,\n                           {Carg, 1}, {Carg, 2}, {Carg, 3}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compact = assert(table.compact)\n\nfunction NodeQoph.oncapture(class, first, capture, last, str, metas, offset)\n   t.first = first + offset\n   t.last  = last + offset - 1\n   t.str   = str\n   if metas[class] then\n      local meta = metas[class]\n      if type(meta) == \"function\" then\n        t.class = class\n        t = meta(t, offset)\n      else\n        t = setmeta(t, meta)\n      end\n      assert(t.class, \"no class on Node\")\n   else\n      t.class = class\n      setmeta(t, metas[1])\n   end\n\n   if not t.parent then\n      t.parent = t\n   end\n\n   local top, touched = #t, false\n   for i = 1, top do\n      local cap = t[i]\n      if type(cap) ~= \"table\" or not cap.isNode then\n         touched = true\n         t[i] = nil\n      else\n         cap.parent = t\n      end\n   end\n   if touched then\n      compact(t, top)\n   end\n   -- post conditions\n   assert(t.isNode, \"failed isNode: \" .. class)\n   assert(t.str, \"no string on node\")\n   assert(t.parent, \"no parent on \" .. t.class)\n   return t\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal ltype = assert(L.type)\nlocal V, P = L.V, L.P\n\nlocal function makeBuilder(Qoph, engine, ...)\n   -- these defaults should result in a \'pure\' recognizer\n   local capture_patt, oncapture = Qoph.capture_patt or {P(true)},\n                                   Qoph.oncapture\n   local _env = Qoph.env or {}\n   local g = {}\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = V,\n      P = P }\n\n    setmetatable(env_index, { __index = _env })\n\n    setmetatable(env, {\n       __index = env_index,\n       __newindex = function( _, name, capture )\n          if suppressed[name] then\n             g[name] = capture\n             return\n          end\n\n          local patt = P \"\"\n          for _, pattern in ipairs(capture_patt) do\n             -- special cases\n             if pattern == \'name\' then\n                patt = patt * Cc(name)\n             elseif pattern == \'capture\' then\n                patt = patt * Ct(value)\n             elseif type(pattern) == \'function\' then\n                patt = patt * pattern()\n             elseif ltype(pattern) == \'pattern\' then\n                patt = patt * pattern\n             elseif type(pattern) == \'table\' then\n                patt = patt * pattern[1](unpack(pattern, 2))\n             end\n             if oncapture then\n                g[name] = patt / oncapture\n             else\n                g[name] = patt\n             end\n          end\n       end })\n\n   return function(func)\n      setfenv(func, env )\n      func( env )\n      assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n      return g\n   end\nend\n\n\n\n\n\n\n\nreturn {NodeQoph = NodeQoph, makeBuilder = makeBuilder }\n\n",
name = "peg/node",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "aba6fdd7681d05d36ab370424abafa76a034a50adec392d98c7ce47902aaa537",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--\n-- PegDebug -- A debugger for LPeg expressions and processing\n-- Copyright 2014 Paul Kulchenko\n--\n\nlocal lpeg = require \"lpeg\"\n\nlocal Cmt = lpeg.Cmt\nlocal Cp  = lpeg.Cp\nlocal P   = lpeg.P\n\nlocal pegdebug = {\n  _NAME = \"pegdebug\",\n  _VERSION = 0.41,\n  _COPYRIGHT = \"Paul Kulchenko\",\n  _DESCRIPTION = \"Debugger for LPeg expressions and processing\",\n}\n\nfunction pegdebug.trace(grammar, opts)\n  opts = opts or {}\n  local serpent = opts.serializer\n    or pcall(require, \"serpent\") and require(\"serpent\").line\n    or pcall(require, \"mobdebug\") and require(\"mobdebug\").line\n    or nil\n  local function line(s) return (string.format(\"%q\", s):gsub(\"\\\\\\n\", \"\\\\n\")) end\n  local function pretty(...)\n    if serpent then return serpent({...}, {comment = false}):sub(2,-2) end\n    local res = {}\n    for i = 1, select(\'#\', ...) do\n      local v = select(i, ...)\n      local tv = type(v)\n      res[i] = tv == \'number\' and v or tv == \'string\' and line(v) or tostring(v)\n    end\n    return table.concat(res, \", \")\n  end\n  local level = 0\n  local start = {}\n  local print = print\n  if type(opts.out) == \'table\' then\n    print = function(...) table.insert(opts.out, table.concat({...}, \"\\t\")) end\n  end\n  for k, p in pairs(grammar) do\n    local enter = Cmt(P(true), function(s, p, ...)\n        start[level] = p\n        if opts[\'+\'] ~= false then\n          print((\" \"):rep(level)..\"+\", k, p, line(s:sub(p,p)))\n        end\n        level = level + 1\n        return true\n      end)\n    local leave = Cmt(P(true), function(s, p, ...)\n        level = level - 1\n        if opts[\'-\'] ~= false then\n          print((\" \"):rep(level)..\"-\", k, p)\n        end\n        return true\n      end) * (P(1) - P(1))\n    local eq = Cmt(P(true), function(s, p, ...)\n        level = level - 1\n        if opts[\'=\'] ~= false then\n          print((\" \"):rep(level)..\"=\", k, start[level]..\'-\'..(p-1), line(s:sub(start[level],p-1)))\n        end\n        return true\n      end)\n    if k ~= 1 and (not opts.only or opts.only[k]) then\n      if opts[\'/\'] ~= false\n      and (type(opts[\'/\']) ~= \'table\' or opts[\'/\'][k] ~= false) then\n        -- Cp() is needed to only get captures (and not the whole match)\n        p = Cp() * p / function(pos, ...)\n            print((\" \"):rep(level)..\"/\", k, pos, select(\'#\', ...), pretty(...))\n            return ...\n          end\n      end\n      grammar[k] = enter * p * eq + leave\n    end\n  end\n  return grammar\nend\n\nreturn pegdebug\n\n",
name = "peg/pegdebug",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "8f7bc18d97d287253ae9f05c26ebe6c9f7aba07b5894b2f8a6b050042c351927",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pegpeg = [[\n           `peg`  ←   grammar / pattern\n\n         grammar  ←  (rule_sep rule)+ (_ -1 / Error)\n\n         pattern  ←  _ rhs (-1 / Error)\n\n            rule  ←  lhs rhs\n\n     `rule-sep`   ←   _ ; pragma lines go here\n\n             lhs  ←  (suppressed / rule-name) _ into _\n             rhs  ←  alt\n\n      suppressed  ←  \"`\" rule-name \"`\"\n       rule-name  ←  symbol\n          `into`  ←  \":=\" / \"←\" / \"<-\" / \"=\"\'\'\n        `symbol`  ←  letter (letter / digit /  {-_})*\n                  /   \"_\"\n\n             alt  ←  cat (_ \"/\" _ cat)*\n             cat  ←  element (_ element)*\n\n         element  ←  prefix? part suffix? backref?\n\n        `prefix`  ←  (and / not) _\n        `suffix`  ←  zero-plus / one-plus / optional / repeat\n        `part`    ←  name !(_ into)\n                  /   literal\n                  /   group\n                  /   set-capture\n                  /   range\n                  /   number\n\n\n\n             and  ←  \"&\"\n             not  ←  \"!\"\n\n       zero-plus  ←  _ \"*\"\n        one-plus  ←  _ \"+\"\n        optional  ←  _ \"?\"\n          repeat  ←  _ \"%\" _ slice\n\n         backref  ←  \"@\" _ ( reference\n                            / back-refer\n                            / eq-refer\n                            / gte-refer\n                            / gt-refer\n                            / lte-refer\n                            / lt-refer )\n\n            name  ←  symbol\n         literal  ←  single-string / double-string\n           group  ←  \"(\" _ alt _ \")\"\n   `set-capture`  ←  \"{\" set \"}\"\n             set  ←  (!(\"}\" / \"\\n\") codepoint)*\n           range  ←  \"[\" range-start \"-\" range-end \"]\"\n          number  ←  EOS / integer\n\n           slice  ←  integer-range / integer\n         integer  ←  digit+\n         `digit`  ←  [0-9]\n\n      back-refer  ←  \"(\"   reference  \")\"\n        eq-refer  ←  \"(#\"  reference  \")\"\n       gte-refer  ←  \"(>=\" reference  \")\"\n        gt-refer  ←  \"(>\"  reference  \")\"\n       lte-refer  ←  \"(<=\" reference  \")\"\n        lt-refer  ←  \"(<\"  reference  \")\"\n       reference  ←  symbol\n\n `single-string`  ←  \"\'\" (escaped / !\"\'\" utf8)* \"\'\"\n `double-string`  ←  \'\"\' (escaped / !\'\"\' utf8)* \'\"\'\n\n\n       codepoint  ←   utf8\n     range-start  ←  escaped / codepoint\n       range-end  ←  escaped / codepoint\n `integer-range`  ←  integer \"..\" integer\n\n        `letter`  ←  [A-Z] / [a-z]\n      ; every Lua escape except \\⏎\n      `escaped`  ←  \"\\\\\" ( ( {abfnrtv}\n                           / \"\'\"\n                           / \'\"\'\n                           / \"\\\\\" )\n                         / digit digit? digit? ; digit%1..3\n                         / \"x\" higit higit )\n\n    `hex-escape`  ←  \"\\\\\" {Xx} higit higit\n         `higit`  ←  digit / [A-F] / [a-f]\n\n             EOS  ←  \"-1\"\n\n\n             `_`  ←  (comment / dent / WS)*\n       `comment`  ←  \";\" (!\"\\n\" utf8)*\n          `dent`  ←  \"\\n\" { \\t}*\n            `WS`  ←  { \\t\\r}\n\n          `utf8`  ←  [\\x00-\\x7f]\n                  /  [\\xc2-\\xdf] [\\x80-\\xbf]\n                  /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n                  /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n\n           Error  ←  1+\n]]\n\n\nreturn pegpeg\n\n",
name = "peg/pegpeg",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "118e5361d213e74a82b80bb4baa02679607ccb5a7b4df77ede009e193c5c357c",
binary = "\n\n\n\n\n\n\n\n\nlocal Phrase  = require \"singletons/phrase\"\nlocal Stator  = require \"singletons/stator\"\nlocal dot     = require \"espalier/dot\"\nlocal elpatt  = require \"espalier/elpatt\"\nlocal Node    = require \"espalier/node\"\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg  = require \"espalier/peg\"\n\nlocal ortho8600 = require \"espalier/grammars/ortho-8600\"\n\nlocal dot_grammar  = require \"espalier/grammars/dot\"\n\nlocal lua_grammar  = require \"espalier/grammars/lua\"\n\n\n\nlocal lisp_grammar = require \"espalier/grammars/microlisp\"\n\nlocal date_grammar = require \"espalier/grammars/date\"\n\nlocal luatoken_grammar = require \"espalier/grammars/luatoken\"\n\nlocal lexemes = require \"espalier/lexemes\"\n\nlocal grammars = { ortho8600 = ortho8600,\n                   dot       = dot_grammar,\n                   lua       = lua_grammar,\n                   lisp      = lisp_grammar,\n                   date      = date_grammar,\n                   luatoken  = luatoken_grammar }\n\nreturn { dot      = dot,\n         elpatt   = elpatt,\n         node     = Node,\n         lex      = lexemes,\n         peg      = Peg,\n         phrase   = Phrase,\n         grammar  = Grammar,\n         grammars = grammars,\n         stator   = Stator }\n\n",
name = "espalier",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "df9bc77d55bb80624793f453aff01898ea7c81d406fbca009937bc68e414fe0b",
binary = "\n\n\nlocal Vav = require \"espalier:vav\"\nlocal mlisp = require \"scry:lua-peg\"\n\nreturn Vav(mlisp)\n\n",
name = "vavrig",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
  { 
branch = "qoph-combinator",
hash = "86a66e63e1e0b12f617b5421ba9a2764c882d44c7e0f6e2c29fbfe0c2be8733b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Grammar = require \"espalier:espalier/grammar\"\nlocal core = require \"qor:core\" -- #todo another qor\nlocal cluster = require \"cluster:cluster\"\nlocal table = core.table\nlocal Set = core.set\nlocal Deque = require \"deque:deque\"\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nlocal function normalize(str)\n   return gsub(str, \"%-\", \"%_\")\nend\n\n\n\n\n\n\n\n\nlocal Q = {}\n\n\n\n\n\n\n\n\n\n\n\nQ.nofail = Set {\'zero_plus\', \'optional\'}\n\n\n\n\n\n\n\n\nQ.predicate = Set {\'and\', \'not\'}\n\n\n\n\n\n\n\n\n\n\n\nQ.failsucceeds = Set {\'not\'}\n\n\n\n\n\n\n\n\nQ.nullable = Q.predicate + Q.nofail\n\n\n\n\n\n\nQ.compound = Set {\'cat\', \'alt\'}\n\n\n\n\n\n\n\n\nQ.terminal = Set {\'literal\', \'set\', \'range\', \'number\'}\n\n\n\n\n\n\n\n\n\n\n\nQ.unbounded = Set { \'zero_plus\', \'one_plus\' }\n\n\n\n\n\nlocal Prop = {}\nfor trait, classSet in pairs(Q) do\n   for class in pairs(classSet) do\n      Prop[class] = Prop[class] or {}\n      insert(Prop[class], trait)\n   end\nend\nfor class, array in pairs(Prop) do\n   Prop[class] = Set(array)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = Node :inherit()\n\n\n\n\nlocal function __index(metabuild, key)\n   local M = Twig :inherit(key)\n   metabuild[key] = M\n   return metabuild[key]\nend\n\n\n\nlocal M = setmetatable({Twig}, {__index = __index})\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Syndex, SynM = cluster.order()\n\nlocal function builder(_new, synth, node, i)\n   synth.up = i\n   synth.o = node.first\n   synth.node = node\n   node.synth = synth\n   synth.line, synth.col = node:linePos()\n   -- this is just for reading purposes in helm\n   -- add a feature to the lens to allow this through\n   synth.class = _new.class\n   if Q.terminal[synth.class] then\n      synth.token = node:span()\n   end\n   return synth\nend\n\ncluster.construct(new, builder)\n\n\n\n\n\n\n\n\nlocal suppress = Set {\n   \'parent\',\n   \'line\',\n   ---[[DBG]] --[=[\n   \'constrained\',\n   \'constrained_by_rule\',\n   \'constrained_by_fixed_point\',\n   \'references\',\n   \'compound\',\n   --]=]\n   \'peh\',\n   \'o\',\n   \'col\',\n   \'up\',\n   \'node\'\n}\nlocal _lens = { hide_key = suppress,\n                depth = math.huge }\nlocal Syn_repr = require \"repr:lens\" (_lens)\n\nSynM.__repr = Syn_repr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction SynM.__eq(syn1, syn2)\n   -- different classes or unequal lengths always neq\n   if (syn1.class ~= syn2.class)\n      or (#syn1 ~= #syn2) then\n         return false\n   end\n   -- two tokens?\n   if (#syn1 == 0) and (#syn2 == 0) then\n      -- same length?\n      if syn1:stride() ~= syn2:stride() then\n         return false\n      end\n      local str1, str2 = syn1.node.str, syn2.node.str\n      local o1, o2 = syn1.o, syn2.o\n      local same = true\n      for i = 0, syn1:stride() - 1 do\n         local b1, b2 = byte(str1, i + o1), byte(str2, i + o2)\n         if b1 ~= b2 then\n            same = false\n            break\n         end\n      end\n      return same\n   end\n   -- two leaves with the same number of children\n   local same = true\n   for i = 1, #syn1 do\n      if not syn1[i] == syn2[i] then\n         same = false\n         break\n      end\n   end\n   return same\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal newSes, metaSes =  {}, {}\n\nlocal function makeGenus(class)\n   local _new, Class, Class_M = cluster.genus(new)\n   cluster.extendbuilder(_new, true)\n   newSes[class] = _new\n   metaSes[class] = Class\n   Class.class = class\n   for quality, set in pairs(Q) do\n      if set[class] then\n         Class[quality] = true\n      end\n   end\n   return _new, Class, Class_M -- we ignore the metatable. until we dont\'.\nend\n\nlocal function newSynth(node, i)\n   local class = node.id\n   local _new, Class = newSes[class]\n   if not _new then\n      _new, Class = makeGenus(class)\n   end\n   return _new(node, i)\nend\n\n\n\n\n\n\nlocal function Syn_index(Syn, class)\n   local meta, _ = metaSes[class]\n   if not meta then\n      _, meta = makeGenus(class)\n      Syn[class] = meta\n   end\n   return meta\nend\n\nlocal Syn = setmetatable({Syndex}, {__index = Syn_index })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syndex.pathName(synth)\n   local phrase, stack = {}, {synth.class}\n   local parent = synth.parent\n   while parent ~= parent.parent do\n      insert(stack, parent.class)\n      parent = parent.parent\n   end\n   while #stack > 0 do\n      insert(phrase, remove(stack))\n      insert(phrase, \"/\")\n   end\n   phrase[#phrase] = \":\"\n   insert(phrase, synth.token or \"none\")\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nfunction Syndex.parentRule(synth)\n   if synth.class == \'rule\' then return nil, \'this is a rule\' end\n   if synth.class == \'grammar\' then return nil, \'this is a grammar\' end\n   local parent = synth.parent\n   while parent ~= parent.parent do\n      if parent.class == \'rule\' then\n         return parent\n      else\n         parent = parent.parent\n      end\n   end\n   return nil, \'mistakes were made (new tree structure?)\'\nend\n\n\n\nfunction Syndex.withinRule(synth)\n   local rule, why = synth:parentRule()\n   if not rule then\n      return nil, why\n   end\n   return rule.token\nend\n\n\n\n\n\n\nlocal walk = require \"gadget:walk\"\n\nlocal depth, filter, reduce = assert(walk.depth),\n                              assert(walk.filter),\n                              assert(walk.reduce)\n\nSyndex.walk = depth\n\nlocal classfilter = {}\n\nlocal function filterer(class)\n   local F = classfilter[class]\n   if not F then\n      classfilter[class] = function(node)\n                        return node.class == class\n                     end\n      F = classfilter[class]\n   end\n   return F\nend\n\nlocal curry = assert(core.fn.curry)\n\nlocal function setfilter(set, node)\n   return set[node.class]\nend\n\nfunction _filter(synth, pred)\n   if type(pred) == \'string\' then\n      return filter(synth, filterer(pred))\n   elseif type(pred) == \'table\' then\n      -- presume a Set\n      return filter(synth, curry(pred))\n   else\n      return filter(synth, pred)\n   end\nend\nSyndex.filter = _filter\n\nfunction Syndex.take(synth, pred)\n   for syn in _filter(synth, pred) do\n      return syn\n   end\nend\n\nfunction Syndex.reduce(synth, pred)\n   if type(pred) == \'string\' then\n      return reduce(synth, filterer(pred))\n   else\n      return reduce(synth, pred)\n   end\nend\n\n\n\n\nfunction Syndex.span(synth)\n   return synth.node:span()\nend\n\n\n\n\nfunction Syndex.stride(synth)\n   return node.last - node.first + 1\nend\n\n\n\n\nfunction Syndex.nameOf(synth)\n   return synth.name or synth.class\nend\n\n\n\n\n\nfunction Syndex.left(syn)\n   return syn.parent[syn.up + 1]\nend\n\nfunction Syndex.right(syn)\n   return syn.parent[syn.up - 1]\nend\n\n\n\n\n\n\n\n\n\n\nSyndex.synthesize = cluster.ur.pass\nSyndex.analyze = cluster.ur.pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SpecialSnowflake = Set {\'set\', \'range\', \'name\',\n                               \'number\', \'literal\', \'rule_name\'}\n\nlocal function extraSpecial(node, synth)\n   local c = synth.class\n   if c == \'range\' then\n      synth.from_char, synth.to_char = node[1]:span(), node[2]:span()\n   elseif c == \'set\' then\n      synth.value = node:span()\n   elseif c == \'name\' or c == \'rule_name\' then\n      synth.token = normalize(node:span())\n   else\n      synth.token = node:span()\n   end\nend\n\n\n\n\nlocal analyzeElement;\n\n-- note: better lenses obviate this\nlocal allpairs = table.allpairs\n\nlocal s = use \"status:status\" ()\ns.verbose = false\n\nlocal function _synth(node, parent_synth, i)\n   local synth = newSynth(node, i)\n   s:verb(\"synthesizing %s\", node.id)\n   synth.parent = parent_synth or synth\n   ---[[ we copy the flags so I can see them in helm :/\n   for key, value in allpairs(synth) do\n      if type(value) == \'boolean\' then\n         synth[key] = value\n      end\n   end --]]\n   if SpecialSnowflake[synth.class] then\n      extraSpecial(node, synth)\n   end\n   for i, twig in ipairs(node) do\n      synth[i] = _synth(twig, synth, i)\n   end\n   -- elements\n   if synth.class == \'element\' then\n      analyzeElement(synth)\n   end\n   if synth.class == \'rule\' then\n      synth.token = assert(synth :take \'rule_name\' . token)\n   end\n   return synth\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Prefix = Set {\'and\', \'not\'}\nlocal Suffix = Set {\'zero_plus\', \'one_plus\', \'optional\', \'repeat\'}\nlocal Backref = Set {\'backref\'}\n\nlocal Surrounding = Prefix + Suffix + Backref\n\n\n\nfunction analyzeElement(elem)\n   local prefixed, backrefed  = Prefix[elem[1].class],\n                                Backref[elem[#elem].class]\n   local suffixed;\n   if backrefed then\n      suffixed = Suffix[elem[#elem-1].class]\n   else\n      suffixed = Suffix[elem[#elem].class]\n   end\n   local modifier = { prefix = false,\n                      suffix = false,\n                      backref = false, }\n\n   local part\n\n   if prefixed then\n      modifier.prefix = elem[1]\n      part = elem[2]\n   else\n      part = elem[1]\n   end\n\n   if backrefed and suffixed then\n      modifier.backref = elem[#elem]\n      modifier.suffix  = elem[#elem - 1]\n   elseif suffixed then\n      modifier.suffix = elem[#elem]\n   elseif backrefed then\n      modifier.backref = elem[#elem]\n   end\n   assert(part and (not Surrounding[part.class]),\n          \"weirdness encountered analyzing element\")\n   for _, mod in pairs(modifier) do\n      if mod then\n         elem[mod.class] = true\n         local traits = Prop[mod.class]\n         if traits then\n            for trait in pairs(traits) do\n               elem[trait] = true\n            end\n         end\n      end\n   end\n   -- strip now-extraneous information\n   for i = 1, #elem do\n      elem[i] = nil\n   end\n   elem[1] = part\n   if backrefed then\n      elem[2] = modifier.backref\n   end\nend\n\n\n\n\n\n\n\n\nlocal codegen = require \"espalier:peg/codegen\"\n\nfor class, mixin in pairs(codegen) do\n   for trait, method in pairs(mixin) do\n      Syn[class][trait] = method\n   end\nend\n\n\n\n\n\n\n\n\nlocal Hoist = Set {\'element\', \'alt\', \'cat\'}\n\n\n\n\n\n\n\n\n\n\nfunction M.grammar.hoist(grammar)\n   if grammar.hoisted then return grammar end\n   for i, rule in ipairs(grammar) do\n      rule:hoist()\n   end\n   grammar.hoisted = true\n\n   return grammar\nend\n\nfunction Twig.hoist(twig)\n   if #twig == 0 then return twig end\n   for i, ast in ipairs(twig) do\n      if #ast == 1 and Hoist[ast.id] then\n         twig[i] = ast[1]:hoist()\n      else\n         ast:hoist()\n      end\n   end\n   -- this makes zero sense but I\'m missing hoists somehow\n   for i, ast in ipairs(twig) do\n      if #ast == 1 and Hoist[ast.id] then\n         twig[i] = ast[1]:hoist()\n      else\n         ast:hoist()\n      end\n   end\n   return twig\nend\n\n\n\nfunction M.grammar.synthesize(grammar)\n   grammar.start = grammar :take \'rule\'\n   local synth = _synth(grammar)\n   ---[[DBG]] synth.Prop = Prop\n   s:verb(\"synthesized %s\", synth.class)\n   synth.peh = grammar.peh\n   grammar.synth = synth --- this is useful, ish, at least in helm\n   return synth\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sort, nonempty = table.sort, assert(table.nonempty)\n\nfunction Syn.grammar.collectRules(grammar)\n   -- our containers:\n   local nameSet, nameMap = Set {}, {} -- #{token*}, token => {name*}\n   local dupe, surplus, missing = {}, {}, {} -- {rule*}, {rule*}, {token*}\n   local ruleMap = {}   -- token => synth\n   local ruleCalls = {} -- token => {name*}\n   local ruleSet = Set {}   -- #{rule_name}\n\n   for name in grammar :filter \'name\' do\n      -- #Todo: this is probably the second time this happens?\n      -- this, and the second one with rule_name, can be changed to\n      -- asserts, then removed\n      local token = assert(name.token)\n      nameSet[token] = true\n      local refs = nameMap[token] or {}\n      insert(refs, name)\n      nameMap[token] = refs\n   end\n\n   local start_rule = grammar :take \'rule\'\n\n   for rule in grammar :filter \'rule\' do\n      local token = assert(rule.token)\n      rule.references = nameMap[token]\n      ruleSet[token] = true\n      if ruleMap[token] then\n         -- lpeg uses the *last* rule defined so we do likewise\n         ruleMap[token].duplicate = true\n         insert(dupe, ruleMap[token])\n      end\n      ruleMap[token] = rule\n      if not nameSet[token] then\n         --  While it is valid to refer to the top rule, it isn\'t noteworthy\n         --  when a grammar does not.\n         --  Rules which are not findable from the start rule aren\'t part of\n         --  the grammar, and are therefore surplus\n         if rule ~= start_rule then\n            rule.surplus = true\n            insert(surplus, rule)\n         end\n      end\n      -- build call graph\n      local calls = {}\n      ruleCalls[token] = calls\n      for name in rule :filter \'name\' do\n         local tok = normalize(name:span())\n         insert(calls, tok)\n      end\n   end\n\n   -- account for missing rules (referenced but not defined)\n   for name in pairs(nameSet) do\n      if not ruleMap[name] then\n         insert(missing, name)\n      end\n   end\n   sort(missing)\n\n   return { nameSet   =  nameSet,\n            nameMap   =  nameMap,\n            ruleMap   =  ruleMap,\n            ruleCalls =  ruleCalls,\n            ruleSet   =  ruleSet,\n            dupe      =  nonempty(dupe),\n            surplus   =  nonempty(surplus),\n            missing   =  nonempty(missing), }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function partition(ruleCalls, callSet)\n   local base_rules = Set()\n   for name, calls in pairs(ruleCalls) do\n      if #calls == 0 then\n         base_rules[name] = true\n         callSet[name] = nil\n      end\n   end\n\n   local rule_order = {base_rules}\n   local all_rules, next_rules = base_rules, Set()\n   local TRIP_AT = 512\n   local relaxing, trip = true, 1\n   while relaxing do\n      trip = trip + 1\n      for name, calls in pairs(callSet) do\n         local based = true\n         for call in pairs(calls) do\n            if not all_rules[call] then\n               based = false\n            end\n         end\n         if based then\n            next_rules[name] = true\n            callSet[name] = nil\n         end\n      end\n      if #next_rules == 0 then\n         relaxing = false\n      else\n         insert(rule_order, next_rules)\n         all_rules = all_rules + next_rules\n         next_rules = Set()\n      end\n\n      if trip > TRIP_AT then\n         relaxing = false\n         error \"512 attempts to relax rule order, something is off\"\n      end\n   end\n\n   return rule_order, callSet\nend\n\n\n\n\n\n\n\n\n\nlocal clone1 = assert(table.clone1)\n\nlocal function _callSet(ruleCalls)\n   local callSet = {}\n   for name, calls in pairs(ruleCalls) do\n      callSet[name] = Set(clone1(calls))\n   end\n   return callSet\nend\n\n\n\nfunction Syn.grammar.callSet(grammar)\n   local collection = grammar.collection or grammar:collectRules()\n   return _callSet(collection.ruleCalls)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function setFor(tab)\n   return Set(clone1(tab))\nend\n\nlocal function graphCalls(grammar)\n   local collection = assert(grammar.collection)\n   local ruleCalls, ruleMap = assert(collection.ruleCalls),\n                               assert(collection.ruleMap)\n   local regulars = assert(collection.regulars)\n\n   -- go through each layer and build the full dependency tree for regular\n   -- rules\n   local regSets = {}\n\n   -- first set of rules have no named subrules\n   -- which we call \'final\'\n   local depSet = regulars[1]\n   for name in pairs(depSet) do\n      ---[[DBG]] ruleMap[name].final = true\n      regSets[name] = Set {}\n   end\n   -- second tier has only the already-summoned direct calls\n   depSet = regulars[2] or {}\n   for name in pairs(depSet) do\n      regSets[name] = setFor(ruleCalls[name])\n   end\n   -- the rest is set arithmetic\n   for i = 3, #regulars do\n      depSet = regulars[i]\n      for name in pairs(depSet) do\n         local callSet = setFor(ruleCalls[name])\n         for _, called in ipairs(ruleCalls[name]) do\n            callSet = callSet + regSets[called]\n         end\n         regSets[name] = callSet\n      end\n   end\n\n   --  the regulars collected, we turn to the recursives and roll \'em up\n   local recursive = assert(collection.recursive)\n   local recurSets = {}\n\n   -- make a full recurrence graph for one set\n   local function oneGraph(name, callSet)\n      local recurSet = callSet + {}\n      -- start with known subsets\n      for elem in pairs(callSet) do\n         local subSet = regSets[elem] or recurSets[elem]\n         if subSet then\n            recurSet = recurSet + subSet\n         end\n      end\n      -- run a queue until we\'re out of names\n      local shuttle = Deque()\n      for elem in pairs(recurSet) do\n         shuttle:push(elem)\n      end\n      for elem in shuttle:popAll() do\n         for _, name in ipairs(ruleCalls[elem] or {}) do\n            if not recurSet[name] then\n               shuttle:push(name)\n               recurSet[name] = true\n            end\n         end\n      end\n\n      recurSets[name] = recurSet\n   end\n\n   for name, callSet in pairs(recursive) do\n      oneGraph(name, callSet)\n   end\n   local allCalls = clone1(regSets)\n   for name, set in pairs(recurSets) do\n      allCalls[name] = set\n   end\n   return allCalls, regSets, recurSets\nend\n\n\n\n\n\n\nlocal function trimRecursive(recursive, ruleMap)\n   for rule, callset in pairs(recursive) do\n      for elem in pairs(callset) do\n         if (not ruleMap[elem])\n            or (not ruleMap[elem].recursive) then\n            callset[elem] = nil\n         end\n      end\n   end\n\n   return recursive\nend\n\n\n\n\n\n\n\n\nfunction Syn.grammar.analyze(grammar)\n   grammar.collection = grammar:collectRules()\n   local coll = assert(grammar.collection)\n\n   local regulars, recursive = partition(coll.ruleCalls, grammar:callSet())\n   local ruleMap = assert(coll.ruleMap)\n   for name in pairs(recursive) do\n      ruleMap[name].recursive = true\n   end\n   coll.regulars, coll.recursive = regulars, trimRecursive(recursive, ruleMap)\n   coll.calls = graphCalls(grammar)\n   if coll.missing then\n      grammar:makeDummies()\n   end\n\n   -- we\'ll switch to using these directly\n   for k, v in pairs(coll) do\n      grammar[k] = v\n   end\n\n\n   return grammar:anomalies()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syn.grammar.anomalies(grammar)\n   local coll = grammar.collection\n   if not coll then return nil, \"collectRules first\" end\n   if not (grammar.missing or grammar.surplus or grammar.dupe) then\n      return nil, \"no anomalies detected\"\n   else\n      return { missing = grammar.missing,\n               surplus = grammar.surplus,\n               dupe   = grammar.dupe }\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal find, gsub = string.find, string.gsub\n\nlocal function dumbRule(name, pad, patt)\n   return   name .. \"  <-  \" .. pad .. patt .. pad .. \"\\n\"\nend\n\nfunction Syn.grammar.makeDummies(grammar)\n   if not grammar.collection then\n      return nil, \'no analysis has been performed\'\n   end\n   local missing = grammar.missing\n   if (not missing) or #missing == 0 then\n      return nil, \'no rules are missing\'\n   end\n   local dummy_str, pad = {\"\\n\\n\"}, \" \"\n   if grammar.ruleMap[\'_\'] then\n      pad = \" _ \"\n   end\n   for _, name in ipairs(missing) do\n      local patt;\n      if find(name, \"_\") then\n         patt = \'\"\' .. (gsub(name, \"_\", \'\" {-_} \"\') .. \'\"\')\n      else\n         patt = \'\"\' .. name .. \'\"\'\n      end\n      insert(dummy_str, dumbRule(name, pad, patt))\n   end\n   grammar.dummy_rules = concat(dummy_str)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syn.grammar.pehFor(grammar, rule)\n   if not grammar.collection then\n      grammar:collectRules()\n   end\n\n   local calls, ruleMap, missing = grammar.calls,\n                                   grammar.ruleMap,\n                                   grammar.missing\n   local phrase =  {}\n   insert(phrase, ruleMap[rule]:span())\n\n   local shuttle = Deque()\n   shuttle :push(calls[rule])\n   local added = {rule = true}\n   for call_set in shuttle :popAll() do\n      for rule_name in pairs(call_set) do\n         if not added[rule_name] then\n            added[rule_name] = true\n            if ruleMap[rule_name] then\n               insert(phrase, ruleMap[rule_name]:span())\n               shuttle :push(calls[rule_name])\n            end\n         end\n      end\n   end\n\n   return concat(phrase, \"\\n\\n\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syndex.constrain(synth, coll)\n   for i, elem in ipairs(synth) do\n      elem:constrain(coll)\n   end\n   synth.base_constraint_rule = true\n   synth.constrained = true\nend\n\n\n\n\n\n\n\n\n\nlocal function queuetate(node)\n   if node == false then return false end\n   return node:pathName()\nend\n\n\n\n\n\n\n\n\n\n\nlocal function queueUp(shuttle, node)\n   if node.on then return end\n   node.on = true\n   shuttle:push(node)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal BAIL_AT = 16384\n\n\n\nlocal mutate = assert(table.mutate)\n\nfunction Syn.grammar.constrain(grammar)\n   local coll;\n   if grammar.collection then\n      coll = grammar.collection\n   else\n      grammar:analyze()\n      coll = assert(grammar.collection)\n   end\n   if grammar:anomalies() then\n      return nil, \"can\'t constrain imperfect grammar (yet)\", grammar:anomalies()\n   end\n\n   local regulars, ruleMap = coll.regulars, coll.ruleMap\n   local nameMap = coll.nameMap\n   coll.nameQ = Deque()\n   local shuttle = Deque()\n   coll.shuttle = shuttle\n   local seen = {}\n   for i, tier in ipairs(regulars) do\n      for name in pairs(tier) do\n         coll.nameQ:push(name)\n         ruleMap[name]:constrain(coll)\n         seen[name] = true\n      end\n      for name_str in pairs(tier) do\n         if not nameMap[name_str] then\n            error(\"missing from nameMap: \" .. name_str)\n         end\n         for _, name in ipairs(nameMap[name_str]) do\n            ---[[DBG]] name.seen_at = i\n            name:constrain(coll)\n         end\n      end\n   end\n   for rule in grammar :filter \'rule\' do\n      -- should be redundant to include the rules already in\n      -- seen above\n      if not seen[rule.token] then\n         queueUp(shuttle, rule)\n      end\n   end\n   local bail = 0\n   for node in shuttle:popAll() do\n      if type(node) == \'table\' then\n         ---[[DBG]] node.popped = node.popped and node.popped + 1 or 1\n         node.on = nil\n         bail = bail + 1\n         node:constrain(coll)\n         if bail > BAIL_AT then\n            grammar.had_to_bail = true\n            grammar.no_constraint = {}\n            for rule in grammar :filter \'rule\' do\n               if not rule.constrained then\n                  grammar.no_constraint[rule.token] = rule\n               end\n            end\n\n            mutate(shuttle, queuetate)\n            break\n         end\n      else\n         -- bad shape?\n         local ts = require \"repr:repr\".ts_color\n         local bare = require \"valiant:replkit\".bare\n         error((\n            \"weird result %s from queue %s\")\n                :format(tostring(node), ts(bare(shuttle))))\n      end\n   end\n   grammar.nodes_seen = bail\n   grammar.had_to_bail = not not grammar.had_to_bail\nend\n\n\n\n\n\n\n\n\nfunction Syn.rule.constrain(rule, coll)\n   local rhs = assert(rule :take \'rhs\')\n   assert(#rhs == 1, \"bad arity on RHS\")\n   local body = rhs[1]\n   body:constrain(coll)\n   if body.constrained then\n      rule.constrained = true\n      rhs.constrained = true\n   else\n      queueUp(coll.shuttle, rule)\n   end\n   rule:propagateConstraints(coll)\nend\n\n\n\n\n\n\n\n\nfunction Syn.rule.propagateConstraints(rule, coll)\n   if rule.references then -- could be the start rule\n      for _, ref in ipairs(rule.references) do\n         ref:constrain(coll)\n         -- this should only be necessary on change\n         -- we make sure the rule is looked at again\n         if ref.changed then\n            local rule = ref:parentRule()\n            queueUp(coll.shuttle, rule)\n         end\n      end\n   end\nend\n\n\n\n\n\n\nlocal function termConstrain(terminal)\n   terminal.constrained = true\nend\n\nfor class in pairs(Q.terminal) do\n   Syn[class].constrain = termConstrain\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syn.cat.constrain(cat, coll)\n   local locked;\n   local gate;\n   local idx;\n   local again;\n   local terminal = true\n   local nofail = true\n   local nullable = true\n   for i, sub in ipairs(cat) do\n      -- reset our conditions because we routinely do this several times\n      sub.lock, sub.dam, sub.gate, sub.gate_lock = nil, nil, nil, nil\n\n      sub:constrain(coll)\n\n      if not sub.constrained then\n         again = true\n      end\n\n      if (not sub.nullable) or sub.predicate then\n         idx = i\n         gate = sub\n         if (not locked) then\n            sub.lock = true\n            locked = true\n         else\n            sub.dam = true\n         end\n      end\n\n      if sub.terminal or sub.predicate then\n         terminal = terminal and true\n      else\n         terminal = false\n      end\n\n      if sub.unbounded then\n         cat.unbounded = true\n      end\n      nofail = nofail and sub.nofail\n      nullable = nullable and sub.nullable\n   end\n\n   cat.terminal = terminal or nil\n   cat.nofail   = nofail or nil\n   cat.nullable = nullable or nil\n   cat.constrained = not again\n\n   if gate then\n      gate.dam = nil\n      if gate.lock then\n         gate.gate_lock = true\n         gate.lock = nil\n      else\n         gate.gate = true\n         -- look for other unfailable /terminal/ rules\n         -- at-most-one unbounded gate at the end\n         if not gate.unbounded then\n            for i = idx-1, 1, -1 do\n               local sub = cat[i]\n               if not sub.terminal then break end\n               sub.gate = true\n               sub.dam = nil\n            end\n         end\n      end\n   else\n      locked = false -- right? lock but no gate = not locked\n   end\n\n   if locked then\n      cat.locked = true\n   end\nend\n\n\n\nfunction Syn.alt.constrain(alt, coll)\n   local nofail, nullable = nil, nil\n   local again;\n   local locked = true\n   local terminal = true\n   for _, sub in ipairs(alt) do\n      sub:constrain(coll)\n      if not sub.constrained then\n         again = true\n      end\n      if sub.unbounded then\n         alt.unbounded = true\n      end\n      terminal = terminal and sub.terminal\n\n      nofail = nofail or sub.nofail\n      nullable = nullable or sub.nullable\n      locked = locked and sub.locked\n   end\n   alt.nofail      = nofail\n   alt.nullable    = nullable\n   alt.terminal    = terminal or nil\n   alt.locked      = locked   or nil\n   alt.constrained = not again\nend\n\n\n\n\n\n\n\nfunction Syn.element.constrain(element, coll)\n   -- ??\n   local again;\n   for _, sub in ipairs(element) do\n      sub:constrain(coll)\n      if not sub.constrained then\n         again = true\n      end\n   end\n   element.constrained = not again\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Trait = Set {\'locked\', \'predicate\', \'nullable\', \'terminal\',\n                   \'unbounded\', \'compound\', \'failsucceeds\', \'nofail\',\n                   \'recursive\', \'self_recursive\'}\n\nlocal function copyTraits(rule, name)\n   local changed = false\n   for trait, state in pairs(rule) do\n      if Trait[trait] then\n         local differs = name[trait] ~= state\n         changed = changed or differs\n         name[trait] = state\n      end\n   end\n   local body = rule :take \'rhs\' [1]\n   for trait, state in pairs(body) do\n      if Trait[trait] then\n         local differs = name[trait] ~= state\n         changed = changed or differs\n         name[trait] = state\n      end\n   end\n   if body.constrained then\n      name.constrained = true\n      name.constrained_by_rule = true\n   else\n      name.constrained_by_rule = false\n   end\n\n   return changed\nend\n\n\n\n\n\n\n\n\nlocal FIX_POINT = 1\n\n\n\n\nfunction Syn.name.constrain(name, coll)\n   if name.constrained then return end\n   local token = assert(name.token)\n   local rule = assert(coll.ruleMap[token])\n   local self_ref = token == name:withinRule()\n   if self_ref then\n      rule.self_recursive = true\n      rule.unbounded = true\n      if name.seen_self then\n         name.seen_self = nil\n      else\n         name.seen_self = true\n         queueUp(coll.shuttle, rule)\n         return\n      end\n   end\n   local changed = copyTraits(rule, name)\n   ---[[DBG]] name.changed = changed\n   if not changed then\n      name.no_change = name.no_change and name.no_change + 1 or 1\n      if name.no_change > FIX_POINT then\n         ---[[DBG]] --[[\n         name.no_change = nil --]]\n         name.constrained_by_rule = nil\n         name.constrained_by_fixed_point = true\n         name.constrained = true\n      end\n   end\n   if not name.constrained then\n      queueUp(coll.shuttle, rule)\n   else ---[[DBG]] --[[\n      name.no_change = nil -- no longer relevant --]]\n   end\nend\n\n\n\n\n\n\nfunction Syn.repeated.constrain(repeated, coll)\n   local range = repeated :take \'integer_range\'\n   if not range then return end\n   local start = tonumber(range[1])\n   if start == 0 then\n      repeated.nofail = true\n      repeated.nullable = true\n   end\n   repeated.constrained = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn M\n\n",
name = "peg/metis",
vc_hash = "2d1f916c525a228858b29d7dceb2dc9538309fd0\n",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "esquilite",
    repo = "",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "master",
hash = "9849380641389389e7e1f4cd3e04cab27a5ccc1fa6068d490638776925b64691",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migrate(conn, migration, ...)\n   if type(migration) == \'function\' then\n      migration(conn, ...)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, ...)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nlocal format = assert(string.format)\nlocal open = assert(sql.open)\n\nlocal function boot(conn, migrations)\n   version = #migrations\n   conn = type(conn) == \'string\' and open(conn) or conn\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         migrate(conn, migrations[i])\n      end\n      conn:exec \"COMMIT;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n   elseif user_version > version then\n      error(format(\"Error: helm.sqlite is version %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn { migrate = migrate,\n         boot    = boot }\n",
name = "esquilite",
vc_hash = "f5296aca44675155bfb46a9969605306af0ae876",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/fs.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "fs",
    repo = "git@gitlab.com:special-circumstance/fs.git\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "fs-2",
hash = "3bb53e031441c46b1d417524bfff2281730d92f742a0107983565d4bbdea2d28",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal bridge = require \"bridge\"\nlocal cluster = require \"cluster:cluster\"\nlocal idest = assert(cluster.idest)\n\nlocal s = require \"status:status\" ()\nlocal Response = require \"cluster:response\"\n\nlocal sh = require \"lash:lash\"\n\nlocal Path = require \"fs:fs2/path\"\nlocal File = require \"fs:fs2/file\"\n\n\n\nlocal new, Dir, Dir_M = cluster.order()\n\n\n\ncluster.construct(new, function(_new, dir, path)\n   if type(path) == \'string\' then\n      path = Path(path)\n   end\n\n   if idest(Path, path) then\n      if path.no_stat or path.does_not_exist then\n         dir.no_stat = path.no_stat\n         dir.does_not_exist = path.does_not_exist\n      elseif path._stat then\n         if path._stat.type ~= \'directory\' then\n            return nil, tostring(path) .. \" is a \" .. path._stat.type\n         end\n      end\n      dir.path = path\n   else\n      error(\"can\'t make a file from the given \" .. type(path))\n   end\n\n   return dir\nend)\n\n\n\n\n\n\n\n\nfunction Dir.exists(dir, refresh)\n   local stat = dir.path:stat(refresh)\n   if stat and stat.type == \'directory\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction Dir.isPrivate(dir)\n   local base = dir.path:basename()\n   return sub(base, 1, 1) == \'.\'\nend\n\n\n\n\n\n\nfunction Dir.basename(dir)\n   return dir.path:basename()\nend\n\n\n\n\n\n\nfunction Dir.parentDir(dir)\n   local parent = dir.path:dirPath()\n   if parent then\n      return new(parent)\n   elseif tostring(dir.path) == \"/\" then\n      return nil, \"directory is root\"\n   end\n\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Dir.stat(dir, refresh)\n   return dir.path:stat(refresh)\nend\n\n\n\n\n\n\n\n\nlocal opendir, readdir, closedir = assert(uv.fs_opendir),\n                                   assert(uv.fs_readdir),\n                                   assert(uv.fs_closedir)\n\nlocal yield = assert(coroutine.yield)\n\n\n\n\n\n\n\n\nlocal function genGen(filter)\n   -- generate the generator:\n   local function generate(dir)\n      local path = tostring(dir.path)\n\n      local fs_t, err = opendir(path)\n      if not fs_t then\n         return nil, err\n      end\n\n      if bridge.green then\n         local response = Response()\n         --  if we tail-call the iterator, our yield point is \'safe\' but we\n         --  can\'t yield it again\n         --  kind of fun to tail-call straight into the next callback\n         local yield_ok = true\n         local function itergreen()\n            readdir(fs_t, function(err, ret)\n               if err then\n                  err(err)\n               end\n               if not ret then\n                  closedir(fs_t)\n                  return response:respond(nil)\n               end\n\n               local obj = filter(path .. \"/\" ..ret[1].name, ret[1].type)\n               if obj then\n                  yield_ok = true\n                  return response:respond(obj)\n               else\n                  yield_ok = false\n                  return itergreen()\n               end\n            end)\n            if yield_ok then\n               return yield(response)\n            end\n         end\n\n         return itergreen\n      else\n         local fs_t, err = opendir(path)\n         if not fs_t then\n            return nil, err\n         end\n         local function itergray()\n            local ret = readdir(fs_t)\n            if not ret then\n               closedir(fs_t)\n               return nil\n            end\n            local obj = filter(path .. \"/\" .. ret[1].name, ret[1].type)\n            if obj then\n               return obj\n            else\n               return itergray()\n            end\n         end\n\n         return itergray\n      end\n   end\n\n   -- and return\n   return generate\nend\n\n\n\n\n\n\n\n\nDir.all = genGen(function(name, obj_type)\n   if obj_type == \'file\' then\n      return File(name)\n   elseif obj_type == \'directory\' then\n      return new(name)\n   else\n      return nil\n   end\nend)\n\n\n\n\n\n\n\n\n\n\nDir.allFiles = genGen(function(name, obj_type)\n   if obj_type == \'file\' then\n      return File(name)\n   else\n      return nil\n   end\nend)\n\n\n\n\n\n\n\n\nDir.files = genGen(function(name, obj_type)\n   if obj_type == \'file\' then\n      local priv = Path(name, \'no-stat\'):isPrivate()\n      if not priv then\n         return File(name)\n      end\n   else\n      return nil\n   end\nend)\n\n\n\n\n\n\n\n\nDir.dirs = genGen(function(name, obj_type)\n   if obj_type == \'directory\' then\n      local priv = Path(name, \'no-stat\'):isPrivate()\n      if not priv then\n         return new(name)\n      end\n   else\n      return nil\n   end\nend)\n\n\n\n\n\n\nDir.alldirs = genGen(function(name, obj_type)\n   if obj_type == \'directory\' then\n      return new(name)\n   else\n      return nil\n   end\nend)\n\n\n\n\n\n\n\n\nlocal fstat = uv.fs_stat\nDir.allstats = genGen(function(name)\n   return fstat(name)\nend)\n\n\n\n\n\n\n\nfunction Dir_M.__eq(a, b)\n   return a.path == b.path\nend\n\n\n\n\n\nreturn new\n\n",
name = "fs2/directory",
vc_hash = "99551b018ad74f63c09ad64ab3f2b3590516d675\n",
},
  { 
branch = "fs-2",
hash = "198c94f85879ee6273200e83ed177b620ebbd5e92e375b20f11190bda6315b9f",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Response = require \"cluster:response\"\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal s = require \"status:status\" ()\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal idest = assert(cluster.idest)\n\nlocal Path = require \"fs:fs2/path\"\nlocal running, resume, yield = assert(coroutine.running),\n                               assert(coroutine.resume),\n                               assert(coroutine.yield)\n\n\n\nlocal new, File, File_M = cluster.order()\n\n\n\ncluster.construct(new, function(_new, file, path)\n   if type(path) == \'string\' then\n      path = Path(path)\n   end\n   file.fs2file = true\n   if idest(Path, path) then\n      if path.no_stat or path.does_not_exist then\n         file.no_stat = path.no_stat\n         file.does_not_exist = path.does_not_exist\n      elseif path._stat then\n         if path._stat.type ~= \'file\' then\n            return nil, tostring(path) .. \" is a \" .. path._stat.type\n         end\n      end\n      file.path = path\n   else\n      error(\"can\'t make a file from the given \" .. type(path))\n   end\n\n   return file\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction File.exists(file, refresh)\n   local stat = file.path:stat(refresh)\n   if stat then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction File.isPrivate(file)\n   return file.path:isPrivate()\nend\n\n\n\n\n\n\n\n\nfunction File.basename(file)\n   return file.path:basename()\nend\n\n\n\n\n\n\n\n\n\nfunction File.barename(file)\n   return file.path:barename()\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction File.ext(file)\n   return file.path:ext()\nend\n\n\n\n\n\n\n\nfunction File.stat(file, refresh)\n   return file.path:stat(refresh)\nend\n\n\n\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\n\nfunction File.read(file)\n   local path = tostring(file.path)\n   local green = bridge.green\n   if not green then\n      -- this can use luv and probably should.\n      local f = io.open(path, \"r\")\n      if not f then\n         return nil, \"cannot open for read: \" .. path\n      end\n      local content = f:read(\"*a\")\n      f:close()\n      return content\n   else\n      local response = Response()\n\n      local function onopen(err, fd)\n         s:verb(\"entered open callback: %s\", path)\n         if err then\n            s:complain(\"failed to open %s: %s\", path, err)\n            local err_str = \"error opening \" .. path .. \": \" .. err\n            return response:respond(nil, err_str)\n         end\n         local stat, err = uv.fs_stat(path)\n         if not stat then\n            s:complain(\"failed to stat %s\", path)\n            local err_str = \"error statting file: \" .. err\n            return response:respond(nil, err_str)\n         end\n\n         local function  onread(err, content)\n            s:verb(\"reading file\")\n            if err then\n               s:complain(\"failed to read %s: %s\", path, err)\n               local err_str = \"error reading \" .. path .. \": \" .. err\n               response:respond(nil, err_str)\n            end\n            uv.fs_close(fd)\n            return response:respond(content)\n         end\n         -- rejoin the threadpool onread\n         uv.fs_read(fd, stat.size, 0, onread)\n      end\n\n      s:verb(\"opening %s\", path)\n                                          -- 292 == 0444 == -r--r--r--\n      local fs_t = uv.fs_open(path, \"r\", 292, onopen)\n      response.handle = fs_t\n\n      return yield(response)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function _withMode(flags)\n   return function (file, doc)\n      local path = tostring(file.path)\n      if bridge.green then\n         -- 416 == 0640 == -rw-r-----\n         uv.fs_open(path, flags, 416, function(err, fd)\n            if err then\n               error(\"unable to open for write: \" .. path)\n            end\n            uv.fs_write(fd, tostring(doc), -1, function()\n               uv.fs_close(fd)\n            end)\n         end)\n      else\n         local f = io.open(path, flags)\n         if not f then\n            error(\"cannot open for write: \" .. path)\n         end\n         f:write(tostring(doc))\n         f:close()\n      end\n   end\nend\n\nFile.write = _withMode \"w\"\nFile.append = _withMode \"a\"\n\n\n\n\n\n\n\n\nfunction File.__eq(a, b)\n   return a.path == b.path\nend\n\n\n\n\nreturn new\n\n",
name = "fs2/file",
vc_hash = "99551b018ad74f63c09ad64ab3f2b3590516d675\n",
},
  { 
branch = "fs-2",
hash = "5a442fe513f0ba628b17a1ab95089c2384dda3832784fde166fc2a5d5647f616",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal cluster = require \"cluster:cluster\"\nlocal core = require \"qor:core\"\nlocal table = core.table\nlocal string = core.string\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:peg\"\n\n\nlocal path_peg = [[\n  `path`  ←  (abs-path / rel-path) -1 / bad-path\nabs-path  ←  div segment? (div segment?)*\nrel-path  ←  (home / parent / this / name) (div segment?)*\n          / segment (div segment?)*\n\n\n     div  ←  \"/\"\n\n `segment`  ←  parent / this / name\n      home  ←  \"~\" !name\n\n    parent  ←  \"..\" !name\n      this  ←  \".\" !name\n      name  ←  (!(div / \"\\0\") 1)+\n\n  bad-path  ←  1+\n]]\n\n\nlocal pathparser  = Peg(path_peg) . parse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal USER_HOME = uv.os_homedir()\n\n\n\n\n\n\n\nlocal split = assert(string.split)\n\nlocal function decorate(ast)\n   -- find final segment, home directory and so on\n   if ast.id == \'bad_path\' then\n      return ast\n   end\n   local leaf = ast[#ast]\n   if leaf.id == \'name\' then\n      leaf.bare, leaf.ext = split(leaf:span(), \"%.\")\n   end\n   return ast\nend\n\n\n\n\n\n\nlocal function pathparse(str)\n   return decorate(pathparser(str))\nend\n\n\n\n\n\n\n\n\nlocal new, Path, Path_M = cluster.order()\n\n\n\n\nlocal fstat, lstat, realpath = assert(uv.fs_stat),\n                               assert(uv.fs_lstat),\n                               assert(uv.fs_realpath)\n\n\n\n\n\n\n\n\n\n\n\ncluster.construct(new, function(_new, path, str, no_stat)\n   local ast = pathparse(str)\n   path.input = { str = str, ast = ast }\n   local home_path = ast :take \'home\'\n   if home_path then\n      -- we don\'t care about any intermediate between\n      -- this and real_path, do we?\n      str = USER_HOME .. str:sub(2)\n   end\n   if no_stat then\n      path.no_stat = true\n      path.str = str\n      path.ast = ast\n      return path\n   end\n   local real_path, _, why = realpath(str)\n   if not real_path then\n      path.str = str\n      path.ast = path.input.ast\n      path.does_not_exist = why\n   else\n      path._stat = fstat(str)\n      path.str   = real_path\n      path.ast   = pathparse(real_path)\n   end\n\n   return path\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path_M.__tostring(path)\n  return path.str\nend\n\n\n\n\n\n\n\n\n\n\nfunction Path_M.__eq(a, b)\n   if a.no_stat and b.no_stat then\n      return a.str == b.str\n   elseif a._stat and b._stat then\n      return a._stat.ino == b._stat.ino\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction Path.stat(path, refresh)\n   if refresh then\n      path._stat = fstat(path.str)\n   end\n   return path._stat\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone, mutate, concat = assert(table.clone1),\n                              assert(table.mutate),\n                              assert(table.concat)\nlocal remove = assert(table.remove)\n\nfunction Path.dirPath(path)\n   if tostring(path) == \"/\" then\n      return nil, \"path is filesystem root \'/\'\"\n   end\n\n   local path, span = clone(path.ast), path.ast.span\n   remove(path)\n   mutate(path, span)\n   return new(concat(path))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction Path.isPrivate(path)\n   local base = path:basename()\n   return sub(base, 1, 1) == \'.\'\nend\n\n\n\n\n\n\n\n\nfunction Path.ext(path)\n   local leaf = path.ast[#path.ast]\n   if leaf.id == \'name\' then\n      return (assert(leaf.ext, \"ast undecorated with extension!\"))\n   end\nend\n\n\n\n\n\n\nfunction Path.basename(path)\n   local leaf = assert(path.ast[#path.ast], \"missing leaf?\")\n   if leaf.id == \'name\' then\n      return leaf:span()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.barename(path)\n   if path.id == \'bad_parse\' then\n      return \"\", \"bad path string\"\n   end\n   local leaf = assert(path.ast[#path.ast], \"missing leaf?\")\n   if leaf.id == \'name\' then\n      return (assert(leaf.bare, \"ast undecorated with bare name!\"))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
name = "fs2/path",
vc_hash = "99551b018ad74f63c09ad64ab3f2b3590516d675\n",
},
  { 
branch = "fs-2",
hash = "ebc161dd569ae1e19b571c9305472478a2eabf072e46ad41e1f9e80441afc9f4",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal bridge = require \"bridge\"\n\n\n\nlocal Response = require \"cluster:response\"\n\nlocal yield, resume = assert(coroutine.yield), assert(coroutine.resume)\n\nlocal function statGen(stat_fn)\n   local function _stat(path)\n      if bridge.green then\n         local response = Response()\n\n         local function onstat(err, stats)\n            if err then\n               return response:respond(nil, err)\n            else\n               return response:respond(stats)\n            end\n         end\n\n         stat_fn(path, onstat)\n         return yield(response)\n      else\n         return stat_fn(path)\n      end\n   end\n\n   return _stat\nend\n\n\n\nlocal Stat = { fstat = statGen(uv.fs_fstat),\n               lstat = statGen(uv.fs_lstat),\n               stat  = statGen(uv.fs_stat), }\n\n\n\nreturn Stat\n\n",
name = "fs2/stat",
vc_hash = "99551b018ad74f63c09ad64ab3f2b3590516d675\n",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "gadget",
    repo = "git@gitlab.com:bridgetools/gadget.git\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "drain",
hash = "11d3f84cfecdb2fd2e59d35312f0e73db90fdfc937e667c0ccfc4d3b8b1794d0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal string = core.string\nlocal Deque = require \"deque:deque\"\n\n\n\nlocal Cachebox = core.cluster.meta {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal CACHE_LIMIT = 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal iscallable = assert(core.fn.iscallable)\nlocal string = assert(core.string)\n\nlocal function new(construct, reset, limit, close)\n   assert(iscallable(construct), \"#1 must be callable\")\n   if not (iscallable(reset) or string(reset)) then\n      assert(reset == false, \"you probably want to reset, pass false to skip\")\n   end\n   local cache = {}\n   cache.construct = construct\n   cache.reset = reset\n   cache.limit = limit or CACHE_LIMIT\n   cache.closewith = close\n   cache.queue = Deque()\n   return setmetatable(cache, Cachebox)\nend\n\nCachebox.idEst = new\n\n\n\n\n\n\n\n\n\nlocal function call_by(instance, method)\n   if string(method) then\n      return instance[method](instance)\n   else\n      return method(instance)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Cachebox.done(cache, instance)\n   if cache.reset then\n      call_by(instance, cache.reset)\n   end\n   cache.queue:push(instance)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Cachebox.take(cache, ...)\n   if #cache.queue == 0 then\n      return cache.construct(...)\n   elseif #cache.queue < cache.limit then\n       return cache.queue:pop()\n   else\n      repeat\n         if cache.closewith then\n            call_by(cache.queue:pop(), cache.closewith)\n         else\n            cache.queue:pop()\n         end\n      until #cache.queue <= cache.limit\n\n      return cache.queue:pop()\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function nope()\n   error(\"attempt to call a method on a closed cachebox\")\nend\n\nfunction Cachebox.close(cache)\n   if cache.closewith then\n      for val in cache.queue:popAll() do\n         call_by(val, cache.closewith)\n      end\n   end\n   cache.take, cache.done, cache.close = nope, nope, nope -- muppet moment\nend\n\n\n\nreturn new\n\n",
name = "cachebox",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "bd981fd8b5bfca219ec132fc577c3c6d621ed55b2e4caf387d3e21fe5460c45a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\nlocal new, Stack, Stack_M = cluster.order()\n\n\n\n\n\n\n\n\nlocal function builder(_new, stack) --> , ...? push right?\n   stack.n = 0\n   -- hold stack? probably.\n   stack.floor = 0 -- no underflow stacks\n   -- other config things for sure.\n   return stack\nend\ncluster.construct(new, builder)\n\n\n\n\n\n\nfunction Stack.push(stack, a, ...)\n   stack.n = stack.n + 1\n   stack[stack.n] = a\n   if ... then\n      stack:push(...)\n   end\nend\n\n\n\n\n\n\n\n\nlocal max  = assert(math.max)\n\nfunction Stack.pop(stack, how_many)\n   assert((type(how_many) == \'number\' and how_many > 0) or how_many == nil,\n          \"bad argument to pop, expected positive number or nil\")\n   how_many = how_many or 1\n   if how_many == 1 then\n      local top = stack[stack.n]\n      stack.n = max(stack.n - 1, 0) -- we can GC stacks later\n      return top\n   else\n      return stack:pop(), stack:pop(how_many - 1)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function dup(stack)\n   stack:push(stack[stack.n])\n   return stack\nend\n\n\n\nlocal function swap(stack)\n   if stack.n < 2 then return stack end\n   local a, b = stack[stack.n], stack[stack.n - 1]\n   stack[stack.n], stack[stack.n -1] = b, a\n   return stack\nend\n\nlocal function drop(stack)\n   stack.n = max(stack.n, 0)\n   return stack\nend\n\n\n\nlocal op = {dup = dup, swap = swap, drop = drop}\n\nfunction Stack_M.__index(stack, key)\n   if op[key] then\n      return op[key](stack)\n   else\n      local got = rawget(stack, key)\n      if not got then\n         got = Stack[key]\n      end\n      return got\n   end\nend\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
name = "chuck",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "2425f1dac0c730082ca229e50f60f4ece62d4214e0ffe0f1ac09748cbe08ca38",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal function drain(source, ms, sink, ...)\n   -- dispose of literal data immediately\n   if type(sink) == \'string\' or type(sink) == \'number\' then\n      source(sink, ...)\n      return true\n   end\n\n   -- idle or timer?\n   local with_delay;\n   if (not ms) or ms == 0 then\n      with_delay = false\n   else\n      assert(type(ms) == \'number\', \"#2 ms must be number or nil\")\n      with_delay = true\n   end\n   -- run once immediately\n   local more = sink(source(...))\n   if not more then\n      return true\n   end\n\n   if with_delay then\n      local drain = uv.new_timer()\n      drain:start(ms, ms, function()\n         more = sink(source())\n         if not more then\n            drain:stop()\n         end\n      end)\n      return false, drain\n   else\n      local drain = uv.new_idle()\n      drain:start(function()\n         more = sink(source())\n         if not more then\n            drain:stop()\n         end\n      end)\n      return false, drain\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn drain\n\n",
name = "drain",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "8e2a4bd9db48d3251ae3542005d670c58a43e9001be6c8499110774ab3027558",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----------------------------------------------------------------------------\n-- Provides functions for diffing text.\n--\n-- (c) 2007, 2008  Yuri Takhteyev (yuri@freewisdom.org)\n-- (c) 2007 Hisham Muhammad\n--\n-- License: MIT/X, see http://sputnik.freewisdom.org/en/License\n-----------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal Deque = require \"deque:deque\"\n\n\n\n\n\n\n\n\n\n\n\n-----------------------------------------------------------------------------\n-- Split a string into elements.  (Adapted from Gavin Kistner\'s split on\n-- http://lua-users.org/wiki/SplitJoin.\n--\n-- @param text           A string to be split.\n-- @param separator      [optional] the separator pattern (defaults to any\n--                       white space - %s+).\n-- @param skip_separator [optional] don\'t include the sepator in the results.\n-- @return               A list of elements.\n-----------------------------------------------------------------------------\nlocal function split(text, separator, skip_separator)\n   separator = separator or \"%s+\"\n   local parts = {}\n   local start = 1\n   local split_start, split_end = text:find(separator, start)\n   while split_start do\n      insert(parts, text:sub(start, split_start-1))\n      if not skip_separator then\n         insert(parts, text:sub(split_start, split_end))\n      end\n      start = split_end + 1\n      split_start, split_end = text:find(separator, start)\n   end\n   if text:sub(start)~=\"\" then\n      insert(parts, text:sub(start) )\n   end\n   return parts\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal take = assert(table.new)\n\n\n\n\n\n\nlocal function costBasis(left, right)\n   local m = #left\n   local n = #right\n\n   -- Build\n   local Cost = take(m+3, 0)\n   local max = math.max\n   for i = -1, m+2 do\n      Cost[i] = take(n+3, 0)\n      for j = -1, n+2 do\n         Cost[i][j] = 0\n      end\n   end\n   for i = 1, m+1 do\n      for j = 1, n+1 do\n         if left[i-1] == right[j-1] then\n            Cost[i+1][j+1] = Cost[i][j] + 1\n         else\n            Cost[i+1][j+1] = max(Cost[i][j], Cost[i][j+1])\n         end\n      end\n   end\n   return Cost\nend\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\nlocal IN = \"+\"\nlocal OUT  = \"-\"\nlocal SAME = \"=\"\nlocal SWAP = \"!\"\n\nlocal function put(diff, element, state)\n   if state == SAME then\n      insert(diff, element)\n   else\n      insert(diff, {state, element})\n   end\nend\n\nlocal function same(diff, element)\n   if element then\n      put(diff, element, SAME)\n   end\nend\n\nlocal function topof(diff)\n   local top = diff[#diff]\n   if type(top) == \'string\' then\n      return SAME\n   elseif not top then\n      return nil\n   else\n      return diff[#diff][1]\n   end\nend\n\nlocal function swap(diff, element)\n   local top = diff[#diff]\n   top[1] = SWAP\n   top[3] = top[2]\n   top[2] = element\nend\n\nlocal function ins(diff, element)\n   if topof(diff) == OUT then\n      swap(diff, element)\n   else\n      put(diff, element, IN)\n   end\nend\n\nlocal function del(diff, element)\n   if topof(diff) == IN then\n      swap(diff, element)\n   else\n      put(diff, element, OUT)\n   end\nend\n\nlocal function buildDiff(diff, Cost, old, new, i, j)\n   if i >= 1 and j >= 1 and old[i] == new[j] then\n      same(diff, old[i])\n      return buildDiff(diff, Cost, old, new, i-1, j-1)\n   else\n      if j >= 1 and (i == 0 or Cost[i][j-1] >= Cost[i-1][j]) then\n         ins(diff, new[j])\n         return buildDiff(diff, Cost, old, new, i, j-1)\n      elseif i >= 1 and (j == 0 or Cost[i][j-1] < Cost[i-1][j]) then\n         del(diff, old[i])\n         return buildDiff(diff, Cost, old, new, i-1, j)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal compact = assert(core.table.compact)\n\nlocal max = assert(math.max)\nlocal function narrow(old, new, pre, post)\n   while old[#old] and old[#old] == new[#new] do\n      local element = remove(old)\n      remove(new)\n      post:push(element)\n   end\n   local some = false\n   local oldtop, newtop = #old, #new\n   for i = 1, max(oldtop, newtop) do\n      if old[i] == new[i] then\n         some = true\n         local element = new[i]\n         old[i], new[i] = nil, nil\n         pre:push(element)\n      else\n         break\n      end\n   end\n   if some then\n      compact(old, oldtop)\n      compact(new, newtop)\n   end\n   return pre, post\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone1 = assert(core.table.clone1)\nlocal ceil = assert(math.ceil)\n\nlocal function table_diff(old, new, mutate)\n   local diff = {}\n   local prefix, suffix = Deque(), Deque()\n   -- narrow if \'worthwhile\', 18x18 is just a guess\n   -- this is knocked out until I have a session which fixes the requisite\n   -- invariants\n   if true then\n   --if #old + #new > 36 and (old[1] == new[1] or old[#old] == new[#new]) then\n      if not mutate then\n         old, new = clone1(old, new)\n      end\n      narrow(old, new, prefix, suffix)\n      for element in suffix:popAll() do\n         same(diff, element)\n      end\n   end\n\n   buildDiff(diff, costBasis(old, new), old, new, #old + 1, #new + 1)\n\n   -- Put the prefix in at the end\n   for element in prefix:popAllRight() do\n      same(diff, element)\n   end\n\n   local half, top = ceil(#diff / 2), #diff\n   for down = 1, half do\n      local up = top - down + 1\n      local base = diff[down]\n      diff[down] = diff[up]\n      diff[up] = base\n   end\n   return diff\nend\n\n\n\nlocal function string_diff(old, new, separator)\n   assert(old); assert(new)\n   new = split(new, separator); old = split(old, separator)\n   return table_diff(old, new, \'mutate\')\nend\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal del, old, ins, new = a.red, a.magenta, a.green, a.cyan\nlocal lines = assert(core.string.lines)\nlocal concat = assert(table.concat)\n\nlocal function __repr(diff)\n   local repr = {}\n   for i, v in ipairs (diff) do\n      if type(v) == \'string\' then\n         insert(repr, v)\n      elseif type(v) == \'table\' then\n         local which, left, right = v[1], v[2], v[3]\n         if which == IN then\n            insert(repr, ins(left))\n         elseif which == OUT then\n            insert(repr, del(left))\n         elseif which == SWAP then\n            insert(repr, old(left))\n            insert(repr, new(assert(right)))\n         else\n            error(\"bad state! \" .. tostring(which))\n         end\n      end\n   end\n   return lines(concat(repr))\nend\n\nlocal _M = {__repr = __repr}\n\n\n\nlocal function repr_diff(old, new, separator)\n   local diff = string_diff(old, new, separator)\n   return setmetatable(diff, _M)\nend\n\n\n\nreturn { string = string_diff,\n          table = table_diff,\n          repr  = repr_diff, }\n\n",
name = "diff",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "8a7e341987e469e2a02903e9842c10e5d6b4e85f8894f0094a0a515e56490b78",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal RECURSION_DEPTH = 255\n\n\n\n\n\n\nlocal meta = require \"core:core/cluster\" . Meta\n\nlocal table = require \"core:core/table\"\nlocal fn  = require \"core:core/fn\"\n\nlocal weak = require \"core:core/meta\" . weak\n\nlocal Deque = require \"deque:deque\"\n\nlocal create, yield, resume = assert(coroutine.create),\n                              assert(coroutine.yield),\n                              assert(coroutine.resume)\n\nlocal getmetatable = assert(debug.getmetatable)\n\nlocal note = require \"status:annotate\"\n\n\n\n\n\n\n\n\n\nlocal Finder = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(tab, name, key, parent, cfg)\n   tab = tab or {}\n\n   local _M;\n   if cfg and cfg.genus then\n      _M = cfg.genus\n   elseif parent and parent.genus then\n      _M = parent.genus\n   else\n      _M = Finder\n   end\n\n   local finder = setmetatable({}, _M)\n   finder.subject = assert(type(tab) == \'table\' and tab, \"#1 must be a table\" .. debug.traceback())\n   finder.genus = _M\n   finder.name = name\n   finder.key = key or name\n   if parent then\n      -- having a parent and being an environment are /maybe/ orthogonal\n      finder.parent = parent\n      finder.is_env = false\n      finder.depth = parent.depth + 1\n      finder.note =  parent.note\n      if cfg then\n         if cfg.note_this then\n            finder.note(cfg.note_this)\n         end\n         if cfg.genus == Finder then\n            finder.note(\"this is the weird one configured to use Finder\")\n         end\n      end\n      finder.kids = nil -- lazily created as a weak table holding finder refs\n   else\n      finder.is_env = true\n      finder.depth = 0\n      finder.note = note()\n   end\n   assert(finder.depth < RECURSION_DEPTH, \"bailing at 256 nested calls\")\n   return finder\nend\n\nFinder.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Finder.specialize(finder, cfg)\n   cfg = cfg or {}\n   local Species = meta(finder.genus)\n\n   for k, v in pairs(cfg) do\n      Species[k] = v\n   end\n\n   -- we return a constructor, not the metatable.\n   local _cfg = { genus  = Species, -- so like bison bison\n                   is_cfg = true }   -- or gorilla gorilla gorilla\n\n   return function(tab, name, key, parent) -- here all week folks\n      return new(tab, name, key, parent, _cfg) -- don\'t forget to tip your waitress\n   end, -- well\n      Species -- could come in handy\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _antis = weak \'k\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function trawlTable(finder, target, name, dupes)\n   local subject = assert(finder.subject, \"finder is missing its subject\")\n   finder.count = finder.count + 1\n\n   if dupes[subject] then\n      return finder:duplicate(target)\n   end\n\n   if finder:subjectIsTarget(target) then\n      finder:foundSubjectIs(target)\n   end\n\n   dupes[subject] = true\n   local seen = _antis[finder.subject]\n   if not seen then\n      seen = weak \'kv\'\n      _antis[finder.subject] = seen\n   end\n   if seen[target] then\n      -- we can use the key from last time\n      finder:seen(target, seen[target])\n   else\n      finder:newtarget(target)\n   end\n\n   -- these are lazily built if a finder reports back\n   local seen_by = finder.seen_by\n   if seen_by and seen_by[target] then\n      local _find = seen_by[target]\n      finder:findWith(seen_by[target], target, dupes)\n   end\n\n   finder:askMetafinder(target, dupes)\n\n   for key, val in finder:walkTable() do\n      if (not seen[val]) then\n         finder.count = finder.count + 1\n         seen[val] = key -- cache\n         finder:examine(key, val, target, dupes)\n\n         if finder:shouldTrawl(key, val, target, dupes) then\n            -- we finish our walk first.  Canonically, this creates a child\n            -- Finder for the \'trawlable\' (here, a table), to ask about the\n            -- object during :callKids().\n            finder:spawn(key, val, target, dupes)\n         end\n      end\n   end\n\n   -- breadth-first search is optimistic here\n   for val, find in finder:callKids() do\n      finder:askChild(find, target, dupes)\n      finder.count = finder.count + find.count\n   end\n\n   finder:afterKids(target)\n\n   return nil\nend\n\nfunction Finder.__call(finder, target, dupes)\n   finder.count = 0\n   return trawlTable(finder, target, finder.name, dupes)\nend\n\n\n\n\n\n\n\n\nfunction Finder.nameFor(finder, target)\n   return tostring(target)\nend\n\n\n\n\nfunction Finder.subjectIsTarget(finder, target)\n   return finder.subject == target\nend\n\n\n\n\n\n\n\nfunction Finder.askMetafinder(finder, target, dupes)\n   if finder.metafinder then\n      finder.note(\"finder %s has metafinder %s\",\n                   finder.name, finder.metafinder.name)\n      finder.metafinder(target, dupes)\n      finder.count = finder.count + finder.metafinder.count\n      return\n   end\n   -- otherwise we\'re looking for a metatable\n   local _M = getmetatable(finder.subject)\n   if _M then\n      -- this should be its own method but first we get it working\n      finder.metafinder = finder:metaFinder(_M)\n      finder.metafinder.is_metafinder = true\n      finder.metafinder(target, dupes)\n      finder.count = finder.count + finder.metafinder.count\n   end\nend\n\n\n\n\n\n\nfunction Finder.examine(finder, key, val, target, dupes)\n   if val == target then\n      finder:found(target, key)\n   end\nend\n\n\n\n\n\n\nlocal has_idEst = assert(table.hasfield.idEst)\n\nfunction Finder.shouldTrawl(finder, key, val, target)\n   if not (type(val) == \'table\') then return false end\n\n   -- *carefully* avoid Finders we might run into\n   local idEst = has_idEst(val)\n\n   if (not idEst) or idEst ~= new then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Finder.findWith(finder, _find, target, dupes)\n   _find(target, dupes)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Finder.walkTable(finder) -- tab not passed in base implementation\n   local key, val = nil, nil\n   return function()\n      key, val =  next(finder.subject, key)\n      return key, val\n   end\nend\n\n\n\n\n\n\nfunction Finder.callKids(finder, target)\n   local kids = finder.kids or {}\n   return pairs(kids)\nend\n\n\n\n\n\n\n\n\n\nfunction Finder.spawn(finder, key, val)\n   finder.kids = finder.kids or weak \'k\'\n   local _find = finder.kids[val]\n   if not _find then\n      finder.kids[val] = finder:child(key, val)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Finder.askChild(finder, child, target, dupes)\n   child(target, dupes)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Finder.child(finder, key, val, name)\n   name = name or finder:nameFor(key)\n   return new(val, name, key, finder)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Metafinder;\n\nfunction Finder.metaFinder(finder, _M)\n   Metafinder = Metafinder or require \"gadget:metafinder\"\n\n   local name = \"⟨\" .. (finder.name or \"\") .. \"⟩\"\n   _M = assert(_M or getmetatable(finder.subject))\n\n   local metafinder = Metafinder(_M, name, nil, finder)\n\n   finder.note(\"created %s metafinder for finder %s\",\n               metafinder.name, finder.name)\n\n   return metafinder\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat, clear, insert  = assert(table.concat),\n                               assert(table.clear),\n                               assert(table.insert)\n\nfunction Finder.report(finder, target, key)\n   local deque = Deque()\n   if key then\n      deque:push(finder:nameFor(key))\n   end\n   deque:push(finder.name)\n   local parent = finder.parent\n   while parent do\n      -- we know we\'ve seen this one\n      parent.seen_by = parent.seen_by or weak \'k\'\n      parent.seen_by[target] = finder\n      if not parent.is_env then\n         deque:push(parent.name)\n      end\n      parent = parent.parent\n   end\n   --flippy floppy\n   local phrase = {}\n   for name in deque:popAllRight() do\n      insert(phrase, name)\n   end\n   yield({concat(phrase, \".\"), finder.name, finder.count})\n   yield(finder.note)\nend\n\n\n\n\n\n\n\n\n\nFinder.seen = Finder.report\n\n\n\n\n\n\n\n\n\nFinder.found = Finder.report\n\n\n\n\n\n\n\n\nfunction Finder.foundSubjectIs(finder, target)\n   finder:report(target, nil)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mu = fn.no_op\n\nFinder.duplicate = mu\nFinder.newtarget = mu\nFinder.afterKids = mu\n\n\n\nreturn new\n\n",
name = "finder",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "56162ec0134a4d041da1ff7a17e550790d7adf6b07045b87c0ec1017fae978bd",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core:core/cluster\" . Meta\nlocal fn = require  \"core:core/fn\"\n\nlocal create, yield, resume = assert(coroutine.create),\n                              assert(coroutine.yield),\n                              assert(coroutine.resume)\nlocal clear, insert = assert(table.clear), assert(table.insert)\n\nlocal Finder = require \"gadget:finder\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Gatherer = meta {}\n\n\n\n\n\n\n\n\n\nlocal function new(subject, name, _Finder, _trawler)\n   _Finder = _Finder or Finder\n   local gatherer = setmetatable({}, Gatherer)\n   local finder = Finder(subject, name)\n   gatherer.trawler = _trawler or getmetatable(finder).__call\n   gatherer.finder = finder\n   gatherer.reports = {}\n   return gatherer\nend\n\nGatherer.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function pasaran(fn, a, b, c)\n   return fn(a, b, c)\nend\n\nlocal iscallable = assert(fn.iscallable)\n\n\n\n\n\n\n\n\n\nlocal function gatherReports(gatherer, target, ...)\n   local bail = gatherer:setup(target, ...)\n   if bail then\n      return nil, bail, \"bailed\"\n   end\n-- continued!\n\n\n\n\n\n\n   local finder = gatherer:prepareFinder()\n   local trawl = gatherer:prepareTrawler()\n\n   local rez = type(trawl) == \'thread\' and resume\n               or iscallable(trawl)    and pasaran\n               or error(\"can\'t trawl with \" .. tostring(trawl))\n\n\n\n\n\n\n   local ok, report = gatherer:viewFirst(rez(trawl, finder, target, {}))\n   if not ok then\n      return nil, report, \"dead on first view\"\n   end\n\n\n\n\n\n\n   local done = false\n   while not done do\n      done, ok, report = gatherer:view(rez(trawl))\n      if not ok then\n         return nil, report, \"dead on view\", gatherer.finder.note\n      end\n   end\n\n\n\n\n\n   return gatherer:after()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Gatherer.setup(gatherer)\n   clear(gatherer.reports)\n   return nil\nend\n\n\n\n\n\n\n\n\nfunction Gatherer.prepareFinder(gatherer)\n   gatherer.finder.count = 0\n   return gatherer.finder\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Gatherer.prepareTrawler(gatherer)\n   return create(gatherer.trawler)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Gatherer.viewFirst(gatherer, ok, report)\n   gatherer:view(ok, report)\n   return ok, report\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Gatherer.view(gatherer, ok, report)\n   if ok then\n      insert(gatherer.reports, report)\n      return not not report, ok, report\n   elseif report == \'cannot resume dead coroutine\' then\n      return nil\n   else\n      return ok, report\n   end\nend\n\n\n\n\n\n\n\n\nfunction Gatherer.after(gatherer)\n   return unpack(gatherer.reports)\nend\n\n\n\n\n\n\n\n\n\nfunction Gatherer.__call(gatherer, target, ...)\n   return gatherReports(gatherer, target, ...)\nend\n\n\n\n\nreturn new\n\n",
name = "gatherer",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "01435fd7c8b36d1490bff1722394a683319c04d975609980d912fb9a5ccc496b",
binary = "\n\n\n\n\n\nlocal Finder = require \"gadget:finder\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\n\n\n\n\n\n\n\n\nlocal _find, super = Finder(), {}\nlocal _Find = getmetatable(_find)\n\nfor field, value in pairs(getmetatable(_find)) do\n   super[field] = value\nend\n\n\n\n\n\n\nlocal new, Metafinder = _find:specialize()\n\n\n\n\n\n\n\n\n\n\n\nMetafinder.is_metafinder = true\n\n\n\n\n\n\n\n\n\nMetafinder.duplicate = super.duplicate\n\n\n\n\n\n\n\n\n\nlocal debug = assert(core.debug)\nlocal getinfo, getupvalue = assert(debug.getinfo), assert(debug.getupvalue)\nlocal insert = assert(table.insert)\n\nlocal reverse = assert(core.table.reverse)\n\nlocal yield = assert(coroutine.yield)\n\n\nfunction Metafinder.examine(metafinder, key, val, target, dupes)\n   -- dumb place to put it but we\'re debugging ¯\\_(ツ)_/¯\n   if not(metafinder.subject == getmetatable(metafinder.parent.subject)) then\n      local name = {metafinder.name}\n      local rent = metafinder.parent\n      while rent do\n         insert(name, rent.name)\n         rent = rent.parent\n      end\n      local report = table.concat(reverse(name), \".\")\n      yield(\"metafinder named \" .. metafinder.name .. \" is messed up: \" .. report)\n      yield(debug.reprtrace())\n      yield(metafinder)\n\n\n   end\n   assert(dupes)\n   local note = metafinder.note\n   if key == \'__index\' and type(val) == \'function\' then\n      -- cache check as per usual\n      if metafinder.for_idx and metafinder.for_idx[val] then\n         note(\"found an upvalue finder in %s\", metafinder.name)\n         for _, upfind in ipairs(metafinder.for_idx[val]) do\n             upfind(target, dupes)\n         end\n      end\n\n      -- reasonable chance that the nearest upvalue of the function is the\n      -- table, or rather, that the nearest table-containing upvalue is the\n      -- closed-over table.\n      local info = getinfo(val, \'u\')\n      note(\"%d upvalues for idx fn of %s\", info.nups, metafinder.name)\n      -- what we care about is nups, \'number of upvalues\'\n      if info and info.nups > 0 then\n         for i = info.nups, 1, -1 do\n            local name, upval = getupvalue(val, i)\n            if type(upval) == \'table\' then\n               note(\"%s making a sub-finder for %s\", metafinder.name, name)\n               -- This odd looking call creates an ordinary Finder which has a\n               -- metafinder as a parent. This isn\'t a composable way of doing\n               -- it, and it needs to be.\n               --\n               local upfinder = Finder(upval, \"↑\"..name, nil, metafinder,\n                                        { genus = _Find,\n                                          note_this = \"created from _examine\" })\n               assert(upfinder.genus == _Find)\n               metafinder.for_idx = metafinder.for_idx or {}\n               metafinder.for_idx[val] = metafinder.for_idx[val] or {}\n               insert(metafinder.for_idx[val],  upfinder)\n               upfinder(target, dupes)\n            end\n         end\n      end\n   end\nend\n\n\n\n\n\nfunction Metafinder.child(metafinder, key, val, name)\n   name = name or metafinder:nameFor(key)\n   return Finder(val, name, key, metafinder,\n                 { genus = _Find })\nend\n\n\n\nreturn new\n\n",
name = "metafinder",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "dc7fa180167fc4536823d2a50591c2c29164a50205822249068077ab05c22cb7",
binary = "\n\n\n\n\n\n\n\n\n\nlocal getupvalue, getlocal, getmetatable = assert(debug.getupvalue),\n                                           assert(debug.getlocal),\n                                           assert(debug.getmetatable)\n\nlocal function hunt(fn, _M)\n   local i = 1\n   local done = false\n   print \"   upvalues:\"\n   repeat\n      local name, value = getupvalue(fn, i)\n      print(\"     seen name \" .. tostring(name))\n      if not name then\n         done = true\n      elseif value == _M then\n         return name\n      end\n      i = i + 1\n   until done\nend\n\n\n\n\nlocal function lesserOf(maybe_name, name)\n   if maybe_name then\n      if not name then\n         return maybe_name\n      elseif maybe_name < name then\n         -- this really won\'t happen often\n         -- we should probably return a Set of all\n         -- unique names in fact.\n         return maybe_name\n      end\n   else\n      return name\n   end\nend\n\nlocal function nameForM(_M)\n   local name, idx = nil, nil\n   print \"scanning metatable\"\n   for key, value in pairs(_M) do\n      if type(value) == \'function\' then\n         print(\"  for fn \" .. tostring(key))\n         local maybe_name = hunt(value, _M)\n         name = lesserOf(maybe_name, name)\n      elseif key == \'__index\' and type(value) == \'table\' then\n         idx = value\n      end\n   end\n   if idx then\n      -- We want to find names for idx as well, it\'s often the right name\n      -- (in cluster this is routine)\n      -- A rewrite once the core logic is tested will be called for.\n\n      print \"scanning index\"\n      for key, value in pairs(idx) do\n         if type(value) == \'function\' then\n            print(\"  for fn \" .. tostring(key))\n            local maybe_name = hunt(value, _M)\n            name = lesserOf(maybe_name, name)\n            maybe_name = hunt(value, idx)\n            name = lesserOf(maybe_name, name)\n         end\n      end\n   end\n   return name\nend\n\n\n\nreturn nameForM\n\n",
name = "metaname",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "ea6f3f7af2864e9d7e6edaf58cc5d460f86fa474c937d81b972516ed0dff646c",
binary = "\n\n\n\n\n\nlocal framer = {}\n\n\n\nlocal getlocal = assert(debug.getlocal)\n\nlocal function locals(level)\n   local locals, count = {}, 1\n   local name, val;\n   repeat\n      name, val = getlocal(level, count)\n      if name then\n         locals[count] = { [name] = val }\n      end\n      count = count + 1\n   until not name\n\n   return locals\nend\n\nframer.locals = locals\n\n\n\nlocal getupvalue = assert(debug.getupvalue)\n\nlocal function upvals(fn)\n   local upvals, count = {}, 1\n   local name, val;\n   repeat\n      name, val = getupvalue(fn, count)\n      if name then\n         upvals[count] = { [name] = val }\n      end\n      count = count + 1\n   until not name\n\n   return upvals\nend\n\nframer.upvals = upvals\n\n\n\nlocal getinfo = assert(debug.getinfo)\n\nlocal function frame(level)\n   level = level or 1\n   local frames = {}\n   local frame;\n   repeat\n      frame = getinfo(level, \'nSlufL\')\n      if frame and frame.what == \'Lua\' then\n         frame.locals = locals(level)\n         if frame.func then\n            frame.upvals = upvals(frame.func)\n            -- frame.fenv = getfenv(frame.func)\n         end\n      end\n      frames[level] = frame\n      level = level + 1\n   until not frame\n\n   return frames\nend\n\nframer.frame = frame\n\n\n\nreturn framer\n\n",
name = "framer",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
  { 
branch = "drain",
hash = "8096581403743630e8cc603f10eabe26b97b6a8e6687db7be8f8d0c6d5b2ee9a",
binary = "\n\n\n\n\n\n\n\nlocal walk = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\nlocal function slide(work, c)\n   -- drop level\n   remove(work)\n   remove(c)\n   -- base case (might not happen?)\n   if #work == 0 then\n      return nil\n   end\n   -- re-index\n   c[#c] = c[#c] + 1\n   local sibling = work[#work][c[#c]]\n\n   if not sibling then\n      slide(work, c)\n   else\n      insert(work, sibling)\n      insert(c, 1)\n   end\nend\n\nlocal function dnext(st)\n   local work, count = st[1], st[2]\n   local top = work[#work]\n   -- no top means we\'re done\n   if not top then return nil end\n   if #top > 0 then\n      -- drop\n      insert(work, top[1])\n      insert(count, 1)\n      return top\n   else\n      -- slide\n      slide(work, count)\n      return top\n   end\nend\n\nfunction walk.depth(tree)\n   return dnext, {{tree}, {1}}\nend\n\n\n\n\n\n\n\n\nlocal function _filter(st)\n   local node = true\n   while node do\n      node = dnext(st)\n      if node and st[3](node) then\n         return node\n      end\n   end\nend\n\nlocal function filter(tree, predicate)\n   assert(predicate, \"a predicate must be provided\")\n   return _filter, {{tree}, {1}, predicate}\nend\n\nwalk.filter = filter\n\n\n\n\n\n\nfunction walk.reduce(node, pred)\n   local captures = {}\n   for cap in filter(node, pred) do\n      insert(captures, cap)\n   end\n   return captures\nend\n\n\n\n\nreturn walk\n\n",
name = "walk",
vc_hash = "08b5b575bb7aacab9da1899e3e8fcfc88d66e036\n",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/ggg.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "ggg",
    repo = "git@gitlab.com:special-circumstance/ggg.git\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "4cae61ae6ba4cdbe7d921daf2fa457fff2b755bc0f6ec02bd8ad5c15365644bc",
binary = "\n\n\n\n\n\n\n\n\nlocal Phrase = require \"singletons/phrase\"\nlocal Node = require \"espalier/node\"\nlocal L = require \"lpeg\"\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal format = assert(string.format)\nlocal c_map = {a.fg(1), a.fg(2), a.fg(3), a.fg(4), a.fg(5), a.fg(6)}\nlocal function _G__repr(ggg)\n   local count = 0\n   local g_match = function(str)\n      local match = str\n      if str == \"(\" then\n         count = count + 1\n      end\n      if c_map[count] then\n         match = c_map[count](str)\n      end\n      if str == \")\" then\n         count = count - 1\n      end\n      return match\n   end\n   return tostring(ggg):gsub(\"[%(%)]\", g_match)\nend\nlocal GGGPhrase = Phrase:inherit{ __repr = _G__repr }\n\n\n\n\n\nlocal GGGMetas = Node : inherit \"ggg_metas\"\n\nfunction GGGMetas.toHammer(ggg_metas)\n   error (\"not yet implemented: \" .. ggg_metas.id)\nend\n\nfunction GGGMetas.normalize(ggg_metas)\n   return ggg_metas:span()\nend\n\nfunction GGGMetas.toParseIR(ggg_metas)\n   local phrase = \"(\" .. ggg_metas.id .. GGGPhrase \" \"\n   if #ggg_metas == 0 then\n      return phrase .. \")\"\n   end\n   for i = 1, #ggg_metas - 1 do\n      phrase = phrase .. ggg_metas[i]:toParseIR() .. \" \"\n   end\n   return phrase .. ggg_metas[#ggg_metas] : toParseIR() .. \")\"\nend\n\n\n\n\n\n\nlocal GGG  = { GGGMetas,\n   ggg       = GGGMetas : inherit \"ggg\",\n   rule      = GGGMetas : inherit \"rule\",\n   lhs       = GGGMetas : inherit \"lhs\",\n   rhs       = GGGMetas : inherit \"rhs\",\n   cat       = GGGMetas: inherit \"cat\",\n   regchoice = GGGMetas : inherit \"regchoice\",\n   pegchoice = GGGMetas : inherit \"pegchoice\",\n   alt       = GGGMetas : inherit \"alt\",\n   group     = GGGMetas : inherit \"group\",\n   action    = GGGMetas : inherit \"action\",\n   negativelook = GGGMetas : inherit \"negativelook\",\n   positivelook = GGGMetas : inherit \"positivelook\",\n   negativereg  = GGGMetas : inherit \"negativereg\",\n   many      = GGGMetas : inherit \"many\",\n   oneormore = GGGMetas : inherit \"oneormore\",\n   optional  = GGGMetas : inherit \"optional\",\n   lazymany  = GGGMetas : inherit \"lazymany\",\n   lazyoneormore = GGGMetas : inherit \"lazyoneormore\",\n   range     = GGGMetas : inherit \"range\",\n   wildcard  = GGGMetas : inherit \"wildcard\",\n   binary    = GGGMetas : inherit \"binary\",\n   hex       = GGGMetas : inherit \"hex\",\n   base64    = GGGMetas : inherit \"base64\",\n   litstring = GGGMetas : inherit \"litstring\",\n   litchar      = GGGMetas : inherit \"litchar\",\n   symbol    = GGGMetas : inherit \"symbol\",\n   indent    = GGGMetas : inherit \"indent\",\n}\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = GGGPhrase [[\nlocal h = require \"ggg:hammer\"\nlocal hlib = require \"ggg:hlib\"\n\n]]\n\nfunction GGG.ggg.toHammer(ggg, actions)\n   local phrase = GGGPhrase \"\"\n   actions = actions and (\"--ACTIONS\\n\" .. actions) or \"\"\n   local first_name = ggg : select \"lhs\" () : span()\n   for lhs in ggg:select \"lhs\" do\n      phrase = phrase .. \"local \" .. lhs:span() .. \" = h.indirect()\\n\"\n   end\n   for i, rule in ipairs(ggg) do\n      if rule.toHammer then\n         phrase = phrase .. rule:toHammer()\n      end\n   end\n   phrase = phrase .. \"\\n\" .. \"return \" .. first_name\n   return _PREFACE .. actions .. \"\\n--BODY\\n\" .. phrase\nend\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParser(ggg, actions)\n   actions = actions or \"\"\n   local p_str= actions .. \"\\n\" .. tostring(ggg:toHammer(actions))\n   ggg.parser = loadstring(p_str)()\n   return function(str)\n      return ggg.parser:parse(str)\n   end, GGGPhrase(p_str)\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParseIR(ggg)\n   local phrase = GGGPhrase \"(grammar (rules (\"\n   for _, v in ipairs(ggg) do\n      phrase = phrase .. v:toParseIR() .. \" \"\n   end\n   return phrase .. \")))\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.__call(ggg, str)\n   if not ggg.parser then\n      ggg.parser = loadstring(tostring(ggg:toHammer()))()\n   end\n   return ggg.parser:parse(str)()\nend\n\n\n\n\n\n\nfunction GGG.rule.toHammer(rule)\n   return \"h.bind_indirect(\" .. rule:select \"lhs\" () : span()\n          .. \", \" .. rule:select \"rhs\" () : toHammer() .. GGGPhrase \")\\n\"\nend\n\n\n\n\n\n\nfunction GGG.lhs.toParseIR(lhs)\n   return lhs:span()\nend\n\n\n\n\n\n\nfunction GGG.rhs.toHammer(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toHammer() .. \" \"\n   end\n\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.rhs.toParseIR(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toParseIR()\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.cat.toHammer(cat)\n   local phrase = cat[1]:toHammer()\n   return phrase .. \" * \" .. cat[2]:toHammer()\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.alt.toHammer(alt)\n   local phrase = alt[1]:toHammer()\n   return phrase .. \" + \" .. alt[2]:toHammer()\nend\n\nGGG.pegchoice.toHammer = GGG.alt.toHammer\nGGG.regchoice.toHammer = GGG.alt.toHammer\n\n\n\n\n\n\nfunction GGG.group.toHammer(group)\n   local phrase = GGGPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. sub_group:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.action.toHammer(action)\n   local phrase = GGGPhrase \"/ \"\n   return phrase .. action[1]:span()\nend\n\n\n\n\n\n\nfunction GGG.positivelook.toHammer(poslook)\n   local phrase = GGGPhrase \"#\"\n   for _, sub_look in ipairs(poslook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.negativelook.toHammer(neglook)\n   -- use () to force unary minus\n   local phrase = GGGPhrase \"(-\"\n   for _, sub_look in ipairs(neglook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.many.toHammer(many)\n   local phrase = GGGPhrase \"\"\n   for _, sub_many in ipairs(many) do\n      phrase = phrase .. sub_many:toHammer()\n   end\n   return phrase .. \"^0\"\nend\nGGG.lazymany.toHammer = GGG.many.toHammer\n\n\n\n\nfunction GGG.oneormore.toHammer(more)\n   local phrase = GGGPhrase \"\"\n   for _, sub_more in ipairs(more) do\n      phrase = phrase .. sub_more:toHammer()\n   end\n   return phrase .. \"^1\"\nend\nGGG.lazyoneormore.toHammer = GGG.oneormore.toHammer\n\n\n\nfunction GGG.optional.toHammer(optional)\n   local phrase = GGGPhrase \"\"\n   for _, sub_option in ipairs(optional) do\n      phrase = phrase .. sub_option:toHammer()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\nfunction GGG.range.toHammer(range)\n   local phrase = GGGPhrase \"hlib.from_range(\"\n   phrase = phrase .. \"\'\" .. range[1]:normalize()\n            .. \"\', \'\" .. range[2]:normalize()\n   return phrase .. \"\')\"\nend\n\n\n\n\n\n\nfunction GGG.wildcard.toHammer(wildcard)\n   local phrase = GGGPhrase \"hlib.from_wildcard(\'\"\n   phrase = phrase .. wildcard:span():sub(2) .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.symbol.toHammer(symbol)\n   return GGGPhrase(symbol:span())\nend\n\n\n\n\n\n\nGGG.symbol.toParseIR = GGG.symbol.toHammer\n\n\n\n\n\n\n\n\n\nlocal P, match = L.P, L.match\nlocal wrapper = (P\'\"\' + P\"«\"^1 * (P\" \" * #P\"«\")^-1) + P\'\"\'\nlocal sub = assert(string.sub)\n\n\nfunction GGG.litstring.toHammer(str)\n   local phrase = GGGPhrase \'h.token(\"\'\n   local span = str:span()\n   local begin = match(wrapper, span)\n   if not begin then\n      error \"didn\'t match the beginning of the literal string for some weird reason\"\n   end\n   phrase = phrase .. sub(span, begin, -begin) .. \'\") \'\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nlocal esc_map = { [\'\\t\'] = \'\\\\t\',\n                  [\'\\n\'] = \'\\\\n\',\n                  [\'\\\\\'] = \'\\\\\\\\\',\n                  [\'\"\'] = \'\\\\\"\' }\nlocal SPACE, TILDE = \' \', \'~\'\nlocal byte, format = assert(string.byte), assert(string.format)\n\nlocal lit_start = L.P(\"«\")^1 * (\" \" * #(L.P\"«\"))^-1\n\nfunction GGG.litstring.toAscii(litstring)\n   local span = litstring:span()\n   local cut = L.match(lit_start, span)\n   return span :sub(cut, -cut) :gsub(\'.\', function(char)\n      if esc_map[char] then\n         return esc_map[char]\n      end\n      if char >= SPACE and char <= TILDE then\n         return char\n      else\n         return format(\"\\\\x%02x\", byte(char))\n      end\n   end)\nend\n\n\n\n\n\n\nfunction GGG.litstring.toParseIR(litstring)\n   return \"(literal \" .. litstring:toAscii() .. GGGPhrase \")\"\nend\n\n\n\n\n\nfunction GGG.litchar.toHammer(char)\n   local phrase =  GGGPhrase \"h.token(\"\n   phrase = phrase  .. format(\"%q\", char:select \"utf8\" ():span()) .. \")\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.litchar.normalize(char)\n   return \"¢\" .. char:select\"utf8\"():span()\nend\n\n\n\n\n\n\nfunction GGG.binary.toHammer(binary)\n   local phrase = GGGPhrase \"hlib.from_binary(\'\"\n   phrase = phrase .. binary:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.binary.toParseIR(binary)\n   return \"(literal \" .. binary:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\nfunction GGG.hex.toHammer(hex)\n   local phrase = GGGPhrase \"hlib.from_hex(\'\"\n   phrase = phrase .. hex:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\nfunction GGG.hex.toParseIR(hex)\n   return \"(literal \" .. hex:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\n\nfunction GGG.base64.toHammer(base64)\n   local phrase = GGGPhrase \"hlib.from_base64(\'\"\n   phrase = phrase .. base64:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.base64.toParseIR(base64)\n   local phrase = GGGPhrase \'(literal (base64 \"\'\n   phrase = phrase .. base64:span():sub(3) -- £ is two bytes wide\n   return phrase .. \'\"))\'\n\nend\n\n\n\n\n\n\n\nfunction GGG.indent.toHammer(indent)\n   return indent:span()\nend\n\n\n\n\n\n\nfunction GGG.indent.toParseIR(indent)\n   return \"\"\nend\n\n\n\n\n\n\n\nreturn {GGG, GGGPhrase}\n\n",
name = "gggmeta",
vc_hash = "fb30425b351644577d90ab7ac669e75fdcf0778a\n",
},
  { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "9a0771a918c3e6967b11aaaa42d150301d36cfe2179fc8b0a10a33f8d578bcc9",
binary = "\n\n\n\n\n\nlocal ffi = require(\"ffi\")\nffi.cdef[[\ntypedef enum HParserBackend_ {\n  PB_MIN = 0,\n  PB_PACKRAT = PB_MIN, // PB_MIN is always the default.\n  PB_REGULAR,\n  PB_LLk,\n  PB_LALR,\n  PB_GLR,\n  PB_MAX = PB_GLR\n} HParserBackend;\n\ntypedef enum HTokenType_ {\n  TT_NONE = 1,\n  TT_BYTES = 2,\n  TT_SINT = 4,\n  TT_UINT = 8,\n  TT_SEQUENCE = 16,\n  TT_RESERVED_1, // reserved for backend-specific internal use\n  TT_ERR = 32,\n  TT_USER = 64,\n  TT_MAX\n} HTokenType;\n\ntypedef struct HBytes_ {\n  const uint8_t *token;\n  size_t len;\n} HBytes;\n\ntypedef struct HArena_ HArena ; // hidden implementation\n\ntypedef struct HCountedArray_ {\n  size_t capacity;\n  size_t used;\n  HArena * arena;\n  struct HParsedToken_ **elements;\n} HCountedArray;\n\ntypedef struct HParsedToken_ {\n  HTokenType token_type;\n  union {\n    HBytes bytes;\n    int64_t sint;\n    uint64_t uint;\n    double dbl;\n    float flt;\n    HCountedArray *seq; // a sequence of HParsedToken\'s\n    void *user;\n  };\n  size_t index;\n  size_t bit_length;\n  char bit_offset;\n} HParsedToken;\n\ntypedef struct HParseResult_ {\n  const HParsedToken *ast;\n  int64_t bit_length;\n  HArena * arena;\n} HParseResult;\n\ntypedef struct HParserVtable_ HParserVtable;\ntypedef struct HCFChoice_ HCFChoice;\n\ntypedef struct HParser_ {\n  const HParserVtable *vtable;\n  HParserBackend backend;\n  void* backend_data;\n  void *env;\n  HCFChoice *desugared;\n} HParser;\n\ntypedef struct HAllocator_ HAllocator;\n\ntypedef HParsedToken* (*HAction)(const HParseResult *p, void* user_data);\ntypedef bool (*HPredicate)(HParseResult *p, void* user_data);\ntypedef HParser* (*HContinuation)(HAllocator *mm__, const HParsedToken *x, void *env);\n\nHParseResult* h_parse(const HParser* parser, const uint8_t* input, size_t length);\nHParser* h_token(const uint8_t *str, const size_t len);\nHParser* h_ch(const uint8_t c);\nHParser* h_ch_range(const uint8_t lower, const uint8_t upper);\nHParser* h_int_range(const HParser *p, const int64_t lower, const int64_t upper);\nHParser* h_bits(size_t len, bool sign);\nHParser* h_int64();\nHParser* h_int32();\nHParser* h_int16();\nHParser* h_int8();\nHParser* h_uint64();\nHParser* h_uint32();\nHParser* h_uint16();\nHParser* h_uint8();\nHParser* h_whitespace(const HParser* p);\nHParser* h_left(const HParser* p, const HParser* q);\nHParser* h_right(const HParser* p, const HParser* q);\nHParser* h_middle(const HParser* p, const HParser* x, const HParser* q);\nHParser* h_action(const HParser* p, const HAction a, void* user_data);\nHParser* h_in(const uint8_t *charset, size_t length);\nHParser* h_not_in(const uint8_t *charset, size_t length);\nHParser* h_end_p();\nHParser* h_nothing_p();\nHParser* h_sequence(HParser* p, ...);\nHParser* h_choice(HParser* p, ...);\nHParser* h_permutation(HParser* p, ...);\nHParser* h_butnot(const HParser* p1, const HParser* p2);\nHParser* h_difference(const HParser* p1, const HParser* p2);\nHParser* h_xor(const HParser* p1, const HParser* p2);\nHParser* h_many(const HParser* p);\nHParser* h_many1(const HParser* p);\nHParser* h_repeat_n(const HParser* p, const size_t n);\nHParser* h_optional(const HParser* p);\nHParser* h_ignore(const HParser* p);\nHParser* h_sepBy(const HParser* p);\nHParser* h_sepBy1(const HParser* p);\nHParser* h_epsilon_p();\nHParser* h_length_value(const HParser* length, const HParser* value);\nHParser* h_attr_bool(const HParser* p, HPredicate pred, void* user_data);\nHParser* h_and(const HParser* p);\nHParser* h_not(const HParser* p);\nHParser* h_indirect(const HParser* p);\nvoid h_bind_indirect(HParser* indirect, const HParser* inner);\nHParser* h_with_endianness(char endianness, const HParser* p);\nHParser* h_put_value(const HParser* p, const char* name);\nHParser* h_get_value(const char* name);\nHParser* h_bind(const HParser *p, HContinuation k, void *env);\n\nint h_compile(HParser* parser, HParserBackend backend, const void* params);\n\nstatic const uint8_t BYTE_BIG_ENDIAN = 0x1;\nstatic const uint8_t BIT_BIG_ENDIAN = 0x2;\nstatic const uint8_t BYTE_LITTLE_ENDIAN = 0x0;\nstatic const uint8_t BIT_LITTLE_ENDIAN = 0x0;\n]]\nlocal h = ffi.load(\"hammer\")\n\nlocal function helper(a, n, b, ...)\n  if   n == 0 then return a\n  else             return b, helper(a, n-1, ...) end\nend\nlocal function append(a, ...)\n  return helper(a, select(\'#\', ...), ...)\nend\n\n-- Exponents do a lot of heavy lifting in Lpeg,\n-- which is the overloading template we\'re going to follow\nlocal function __pow(rule, power)\n  assert(type(power) == \"number\")\n  if power == 0 then\n    return h.h_many(rule)\n  elseif power == 1 then\n    return h.h_many1(rule)\n  elseif power == -1 then\n    return h.h_optional(rule)\n  end\nend\n\n\nlocal mt = {\n  __index = {\n    parse = function(p, str) return h.h_parse(p, str, #str) end,\n  },\n  __add = function(left, right)\n    return h.h_choice(left, right)\n  end,\n  __mul = function(left, right)\n    return h.h_sequence(left, right)\n  end,\n  __pow = __pow,\n  __len = function(rule)\n    return h.h_and(rule)\n  end,\n  __unm = function(rule)\n    return h.h_not(rule)\n  end,\n  __sub = function(left, right)\n    return h.h_sequence(left, h.h_not(right))\n  end,\n  -- Lpeg doesn\'t use modulus, let\'s use it for n number of\n  -- repetitions\n  __mod = function(rule, reps)\n    assert(type(reps) == \"number\")\n    return h.h_repeat_n(rule, reps)\n  end,\n  __div = function(rule, cb)\n    return h.h_action(rule, cb, nil)\n  end\n}\n\nlocal hammer = {}\nhammer.parser = ffi.metatype(\"HParser\", mt)\n\nlocal counted_array\n\n\n\nlocal function _castCountedArray(array)\n    if array == nil then return nil end\n    if array.elements == nil then return nil end\n    local ret = {}\n    for i = 0, tonumber(array.used) do\n       ret[#ret+1] = array.elements[i]()\n    end\n    if #ret == 1 and type(ret[1]) == \"table\" then\n       return ret[1]\n    end\n    if #ret == 0 then\n       return nil\n    end\n    return ret\nend\n\nlocal arr_mt = {\n  __index = function(table, key)\n    return table.elements[key]\n  end,\n  __len = function(table) return table.used end,\n  __ipairs = function(table)\n    local i, n = -1, #table\n    return function()\n      i = i + 1\n      if i < n then\n        return i, table.elements[i]\n      end\n    end\n  end,\n  __call = _castCountedArray,\n}\ncounted_array = ffi.metatype(\"HCountedArray\", arr_mt)\n\nlocal bytes_mt = {\n  __call = function(self)\n    local ret = \"\"\n    for i = 0, tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.len)))-1\n      do ret = ret .. string.char(self.token[i])\n    end\n    return ret\n  end\n}\nlocal byte_string = ffi.metatype(\"HBytes\", bytes_mt)\n\nlocal result_mt = {\n   __call = function(self)\n      if self == nil then return nil end\n      return self.ast()\n   end\n}\n\nlocal parse_result = ffi.metatype(\"HParseResult\", result_mt)\n\nlocal token_types = ffi.new(\"HTokenType\")\n\n\nlocal parsed_token\nlocal tok_mt = {\n  __call = function(self)\n     if self == nil then return nil end\n     if self.token_type == ffi.C.TT_BYTES then\n       return self.bytes()\n     elseif self.token_type == ffi.C.TT_SINT then\n       return tonumber(ffi.cast(\"intptr_t\", ffi.cast(\"void *\", self.sint)))\n     elseif self.token_type == ffi.C.TT_UINT then\n       return tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.uint)))\n     elseif self.token_type == ffi.C.TT_SEQUENCE then\n       return self.seq()\n     end\n     return nil\n  end\n}\nparsed_token = ffi.metatype(\"HParsedToken\", tok_mt)\n\nfunction hammer.token(str)\n  return h.h_token(str, #str)\nend\nfunction hammer.ch(c)\n  if type(c) == \"number\" then\n    return h.h_ch(c)\n  else\n    return h.h_ch(c:byte())\n  end\nend\nfunction hammer.ch_range(lower, upper)\n  if type(lower) == \"number\" and type(upper) == \"number\" then\n    return h.h_ch_range(lower, upper)\n  -- FIXME this is really not thorough type checking\n  else\n    return h.h_ch_range(lower:byte(), upper:byte())\n  end\nend\nfunction hammer.int_range(parser, lower, upper)\n  return h.h_int_range(parser, lower, upper)\nend\nfunction hammer.bits(len, sign)\n  return h.h_bits(len, sign)\nend\nfunction hammer.int64()\n  return h.h_int64()\nend\nfunction hammer.int32()\n  return h.h_int32()\nend\nfunction hammer.int16()\n  return h.h_int16()\nend\nfunction hammer.int8()\n  return h.h_int8()\nend\nfunction hammer.uint64()\n  return h.h_uint64()\nend\nfunction hammer.uint32()\n  return h.h_uint32()\nend\nfunction hammer.uint16()\n  return h.h_uint16()\nend\nfunction hammer.uint8()\n  return h.h_uint8()\nend\nfunction hammer.whitespace(parser)\n  return h.h_whitespace(parser)\nend\nfunction hammer.left(parser1, parser2)\n  return h.h_left(parser1, parser2)\nend\nfunction hammer.right(parser1, parser2)\n  return h.h_right(parser1, parser2)\nend\nfunction hammer.middle(parser1, parser2, parser3)\n  return h.h_middle(parser1, parser2, parser3)\nend\n-- There could also be an overload of this that doesn\'t\n-- bother with the env pointer, and passes it as NIL by\n-- default, but I\'m not going to deal with overloads now.\nfunction hammer.action(parser, action, user_data)\n  local cb = ffi.cast(\"HAction\", action)\n  return h.h_action(parser, cb, user_data)\nend\nfunction hammer.in_(charset)\n  local cs = ffi.new(\"const unsigned char[\" .. #charset .. \"]\", charset)\n  return h.h_in(cs, #charset)\nend\nfunction hammer.not_in(charset)\n  return h.h_not_in(charset, #charset)\nend\nfunction hammer.end_p()\n  return h.h_end_p()\nend\nfunction hammer.nothing_p()\n  return h.h_nothing_p()\nend\nfunction hammer.sequence(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_sequence(parser, parsers)\nend\nfunction hammer.choice(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_choice(parser, parsers)\nend\nfunction hammer.permutation(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_permutation(parser, parsers)\nend\nfunction hammer.butnot(parser1, parser2)\n  return h.h_butnot(parser1, parser2)\nend\nfunction hammer.difference(parser1, parser2)\n  return h.h_difference(parser1, parser2)\nend\nfunction hammer.xor(parser1, parser2)\n  return h.h_xor(parser1, parser2)\nend\nfunction hammer.many(parser)\n  return h.h_many(parser)\nend\nfunction hammer.many1(parser)\n  return h.h_many1(parser)\nend\nfunction hammer.repeat_n(parser, n)\n  return h.h_repeat_n(parser, n)\nend\nfunction hammer.optional(parser)\n  return h.h_optional(parser)\nend\nfunction hammer.ignore(parser)\n  return h.h_ignore(parser)\nend\nfunction hammer.sepBy(parser)\n  return h.h_sepBy(parser)\nend\nfunction hammer.sepBy1(parser)\n  return h.h_sepBy1(parser)\nend\nfunction hammer.epsilon_p()\n  return h.h_epsilon_p()\nend\nfunction hammer.length_value(length, value)\n  return h.h_length_value(length, value)\nend\nfunction hammer.attr_bool(parser, predicate, user_data)\n  local cb = ffi.cast(\"HPredicate\", predicate)\n  return h.h_attr_bool(parser, cb, user_data)\nend\nfunction hammer.and_(parser)\n  return h.h_and(parser)\nend\nfunction hammer.not_(parser)\n  return h.h_not(parser)\nend\nfunction hammer.indirect(parser)\n  return h.h_indirect(parser)\nend\nfunction hammer.bind_indirect(indirect, inner)\n  return h.h_bind_indirect(indirect, inner)\nend\nfunction hammer.with_endianness(endianness, parser)\n  return h.h_with_endianness(endianness, parser)\nend\nfunction hammer.put_value(parser, name)\n  return h.h_put_value(parser, name)\nend\nfunction hammer.get_value(name)\n  return h.h_get_value(name)\nend\nfunction hammer.bind(parser, continuation, env)\n  local cb = ffi.cast(\"HContinuation\", continuation)\n  return h.h_bind(parser, cb, env)\nend\n\nfunction hammer.compile(parser, backend, params)\n  return h.h_compile(parser, backend, params)\nend\n\nhammer.BYTE_BIG_ENDIAN = 0x1;\nhammer.BIT_BIG_ENDIAN = 0x2;\nhammer.BYTE_LITTLE_ENDIAN = 0x0;\nhammer.BIT_LITTLE_ENDIAN = 0x0;\nreturn hammer\n\n",
name = "hammer",
vc_hash = "fb30425b351644577d90ab7ac669e75fdcf0778a\n",
},
  { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "fe68dfcedcd1c06ab4b3eb4d342d19f6e020b98fffe24482368ef77a7f87abbc",
binary = "\n\n\n\n\n\n\n\n\nlocal h = require \"ggg:hammer\"\nlocal utf8 = require \"lua-utf8\"\n\n\n\n\n\n\nlocal hlib = {}\n\n\n\n\n\n\nlocal sub = utf8.sub\n\n\nfunction hlib.from_range(head, tail)\n   local first = sub(head,1,1)\n   if first == \"¢\" then\n      -- character range\n      return h.ch_range(sub(head,2), sub(tail, 2))\n   elseif first == \"0\" then\n      -- binary or hex\n      local hnum, tnum = tonumber(head), tonumber(tail)\n      assert(hnum <= tnum, \"hnum cannot be greater than tnum\")\n      if tnum <= 255 then\n         return h.int_range(h.uint8(), hnum, tnum)\n      elseif tnum <= 65535 then\n         return h.int_range(h.unit16(), hnum, tnum)\n      elseif tnum <= 4294967295 then\n         return h.int_range(h.uint32(), hnum, tnum)\n      else\n         -- actually only 53 bits of range, for the usual reasons...\n         -- this will probably do something dumb like segfault if coerced into\n         -- a float\n         return h.int_range(h.uint64(), hnum, tnum)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction hlib.pR_toTok(hParseResult)\n   return ffi.cast(\"HParsedToken *\", hParseResult.ast)\nend\n\n\n\n\n\nfunction hlib.from_binary(bin)\n   error \"NYI: from_binary\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction hlib.from_hex(hex)\n   assert(type(hex) == \"string\")\n   -- trim off the 0x\n   local hex = hex:sub(3)\n   -- our c style hex escaped string\n   local esc = \"\"\n   -- c hex string escapes ought to occur in two\'s, append 0 in case where hex digits are odd.\n   if #hex % 2 ~= 0 then\n      hex = hex .. \"0\"\n   end\n   -- by twos, take our hex digits and cast them to the decimal equivalent which we then\n   -- cast back into a string to get a hex string literal.\n   -- i know, this seems gross but it actually works afaict!\n   for i = 1, #hex, 2 do\n       -- TODO: enforce valid hex values\n       esc = esc .. string.char(tonumber(hex:sub(i, i + 1), 16))\n   end\n   return h.token(esc)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction hlib.from_wildcard(wildcard)\n   local pattern = wildcard:sub(2)\n   local _, bytes = pattern:gsub(\"#\", \"\")\n   local _, bits = pattern:gsub(\",\", \"\")\n   bytes = bytes * 8\n   return h.bits(bytes + bits, false) -- unsigned case not used, possibly not even semantically meaningful with GGG wildcards\nend\n\n\n\n\n\n\nfunction hlib.from_base64(base64)\n   error \"NYI: from_base64\"\nend\n\n\n\n\nreturn hlib\n\n",
name = "hlib",
vc_hash = "fb30425b351644577d90ab7ac669e75fdcf0778a\n",
},
  { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "319d4679d1a55a81b883a365e4ff518bc671f3fe236ef6da7467efef702423d6",
binary = "\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal GGG_M = require \"ggg:gggmeta\"\n\n\n\nlocal GGG_str = [[\nggg   ← rule+\nrule  ← _ lhs _ sep _ rhs _ \";\" _ ; ws after `;` to denote inline comments\n`sep` ← \":=\" / \"=\" / \":\"\nlhs ← letter symbol-valid*\n\nrhs    ← rulexpr\n`rulexpr` ← operations+ / element\n\n`operations` ←  regchoice / pegchoice / alt / cat / action\n\ncat ← element _ rulexpr\nregchoice ← element _ \"|\" _ rulexpr\npegchoice ← element _ \"/\" _ rulexpr\nalt      ← element _ \"¦\" _ rulexpr\naction   ← \"[\" _ rulexpr _ atom _ \"]\"\n\n`element`  ← simple / group\ngroup ← \"(\" _ rulexpr _ \")\" _\n\n`simple` ← prefixed / suffixed / atom\n\n`prefixed` ← negativelook / positivelook / negativereg\nnegativelook ← \"¿\" _ allowed-prefixed\npositivelook ← \"?\" _ allowed-prefixed\nnegativereg  ← \"!\" _ allowed-prefixed\n`allowed-prefixed` ← group / suffixed / atom\n\n`suffixed` ← many / oneormore / optional / lazymany / lazyoneormore\nmany       ← allowed-suffixed _ \"*\"\noneormore  ← allowed-suffixed _ \"+\"\noptional   ← allowed-suffixed _ \"±\"\nlazymany   ← allowed-suffixed _ \"\\\\*\"\nlazyoneormore ← allowed-suffixed _ \"\\\\+\"\n`allowed-suffixed` ← group / prefixed / atom\n\n`atom`   ← range / wildcard\n         / binary / hex / base64 / litstring / litchar\n         / symbol\n\nbinary   ← \"0b\" (\"0\"/\"1\")+\nhex      ← \"0x\" ([0-9]/[A-F]/[a-f])+\nbase64   ← (\"£\"/\"$$\") ([A-Z]/[a-z]/[0-9]/\"+\"/\"-\")+ (\"==\"/\"=\")?\n\nlitstring ← \"«\"+@lit-c (litstring / !(\"»\"+@(#lit-c)) 1)* \"»\"+@(#lit-c)\n          / jankstring\n`jankstring` ← \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' 1))* \'\"\'\nlitchar  ← (\"¢\"/\"\\\\\\\\\") utf8\nutf8 ← 1 ; this should actually match utf8...\n\n\nrange      ← binary \"..\" binary\n           / hex \"..\" hex\n           / litchar \"..\" litchar\nwildcard   ← \"~\" (\"#\"/\",\"/\"0\"/\"1\")+\n\n`_`  ← comment / indent / { \\t}*\n`comment` ← { \\t}* (linecomment / blockcomment)+\n`linecomment` ← \"//\" (!(\"\\r\"? \"\\n\") 1)* indent\n`blockcomment` ← \"</\" (!\"\\\\>\" 1)* \"\\\\>\" indent\nindent ← (\"\\r\"? \"\\n\") { \\t}*\nsymbol ← letter symbol-valid*\n`letter` ← [a-z] / [A-Z]\n`symbol-valid` ← letter / digit / \"_\"\n`digit` ← [0-9]\n]]\n\n\n\n\n\nlocal GGG_peg = Peg(GGG_str)\nGGG_peg:toGrammar(GGG_M[1])\n\n\n\n\nreturn GGG_peg\n\n",
name = "ggg",
vc_hash = "fb30425b351644577d90ab7ac669e75fdcf0778a\n",
},
  { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "fab1048a995b536214489191c84dee6122d251928b5f62ee199339173583e518",
binary = "\n\n\n\n\n\n\n\n\nlocal GGG = require \"ggg:ggg\"\nlocal GGG_M = require \"ggg:gggmeta\"\nlocal Peg = require \"espalier/peg\"\n\n\n\n\n\n\n\n\nlocal ggg_json = [[\n  json := ws element ;\n  bool := «true» ¦ «false» ;\n  object := ¢{ ws ¢} ¦ ¢{ members ¢} ;\n  members := member (¢, member)* ;\n  member := ws str ws ¢: element ;\n  elements := element (¢, element)* ;\n  element := ws value ws ;\n  value := object ¦ array ¦ str ¦ bool ¦ «null» ;\n  array := ¢[ ws ¢] ¦ ¢[ elements ¢] ;\n  str := ¢\" (¿¢\" chars)* ¢\" ;\n  chars := ascii ;\n  ascii := 0x21..0x21 ¦ 0x23..0x2e ¦ 0x30..0x5b ¦ 0x5d..0x7e ;\n  ws := 0x00..0x20* ;\n]]\n\n\n\n\nlocal not_used = [[\n  json := ws element ;\n  bool := «true» ¦ «false» ;\n  object := ¢{ ws ¢} ¦ ¢{ members ¢} ;\n  members := member (¢, member)* ;\n  member := ws str ws ¢: element ;\n  elements := element (¢, element)* ;\n  element := ws value ws ;\n  value := object ¦ array ¦ str ¦ bool ¦ «null» ;\n  array := ¢[ ws ¢] ¦ ¢[ elements ¢] ;\n  str := ¢\" (¿¢\" chars)* ¢\" ;\n  chars := ascii ¦ escaped ;\n  ascii := 0x21..0x21 ¦ 0x23..0x2e ¦ 0x30..0x5b ¦ 0x5d..0x7e ;\n  escaped := ¢\\ ( (¢\\ ¦ ¢\" ¦ ¢/ ¦ ¢b ¦ ¢f ¦ ¢n ¦ ¢r ¦ ¢t) ¦ unicode) ;\n  unicode := ¢u hex hex hex hex ;\n  hex := 0x30..0x39 ¦ 0x41..0x46 ¦ 0x61..0x66 ; \n  ws := 0x00..0x20* ;\n]]\n\n\nreturn GGG(ggg_json)\n\n",
name = "grammars/json",
vc_hash = "fb30425b351644577d90ab7ac669e75fdcf0778a\n",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/helm.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "helm",
    repo = "https://gitlab.com/special-circumstance/femto\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "migration-7",
hash = "6585f807fe2592da047b9255606a53b3dea22ec0f1bda8143619815d217a0c81",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal Window = require \"window:window\"\nlocal Deque = require \"deque:deque\"\nlocal Message = require \"actor:message\"\n\nlocal table = core.table\n\n\n\n\nlocal Agent = meta {}\n\n\n\n\n\n\n\n\nlocal coro = assert(core.thread.nest \'actor\')\nlocal yield = assert(coro.yield)\n\nfunction Agent.send(agent, msg)\n   return yield(Message(msg))\nend\n\n\n\n\n\n\n\n\nfunction Agent.checkTouched(agent)\n   local touched = agent.touched\n   agent.touched = false\n   return touched\nend\n\n\n\n\n\n\n\n\nfunction Agent.bufferCommand(agent, name, ...)\n   local msg = pack(...)\n   msg.method = name\n   agent.buffer_commands:push(msg)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Agent.contentsChanged(agent)\n   agent.touched = true -- #deprecated\n   agent:bufferCommand(\"clearCaches\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor _, scroll_fn in ipairs{\n   \"scrollTo\", \"scrollBy\",\n   \"scrollUp\", \"scrollDown\",\n   \"pageUp\", \"pageDown\",\n   \"halfPageUp\", \"halfPageDown\",\n   \"scrollToTop\", \"scrollToBottom\",\n   \"ensureVisible\"\n} do\n   Agent[scroll_fn] = function(agent, ...)\n      agent:bufferCommand(scroll_fn, ...)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Agent.evtScrollUp(agent, evt)\n   agent:scrollUp(evt.num_lines)\nend\nfunction Agent.evtScrollDown(agent, evt)\n   agent:scrollDown(evt.num_lines)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal addall = assert(table.addall)\nfunction Agent.mergeWindowConfig(cfg_a, cfg_b)\n   for cat, props in pairs(cfg_b) do\n      cfg_a[cat] = cfg_a[cat] or {}\n      addall(cfg_a[cat], props)\n   end\n   return cfg_a\nend\n\nfunction Agent.windowConfiguration(agent)\n   return {\n      field = { touched = true },\n      fn = {\n         buffer_value = function(agent, window, field)\n            return agent:bufferValue()\n         end,\n         commands = function(agent, window, field)\n            return agent.buffer_commands\n         end\n      },\n      closure = { checkTouched = true }\n   }\nend\n\nfunction Agent.window(agent)\n   return Window(agent, agent:windowConfiguration())\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Agent._init(agent)\n   agent.buffer_commands = Deque()\nend\n\nfunction Agent.__call(agent_class)\n   local agent_M = getmetatable(agent_class)\n   local agent = setmetatable({}, agent_M)\n   agent:_init()\n   return agent\nend\n\n\n\n\nreturn core.cluster.constructor(Agent)\n\n",
name = "helm/agent/agent",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "850c19f99c6d0aa36c5d1bfdd5c6eccfdeae25079625e241136613bbf57aa6a5",
binary = "\n\n\n\n\n\n\nlocal c = assert(require \"singletons:color\" . color)\nlocal input_event = require \"anterm:input-event\"\nlocal table = core.table\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal InputEchoAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nlocal STAT_ICON = \"◉ \"\n\nlocal reprs_by_type = {}\n\nfunction reprs_by_type.mouse(event)\n   local subtype\n   if event.scrolling then\n      subtype = tostring(event.num_lines) .. \" lines\"\n   else\n      if event.pressed then\n         if event.moving then\n            subtype = \"drag\"\n         else\n            subtype = \"press\"\n         end\n      else\n         if event.moving then\n            subtype = \"move\"\n         else\n            subtype = \"release\"\n         end\n      end\n   end\n   return (\'%s (%s: %s,%s)\'):format(\n      c.userdata(STAT_ICON .. input_event.serialize(event)),\n      subtype,\n      a.cyan(event.col),\n      a.cyan(event.row))\nend\n\nfunction reprs_by_type.paste(event)\n   local result\n   -- #todo handle escaping of special characters in pasted data\n   if #event.text < 20 then\n      result = \"PASTE: \" .. event.text\n   else\n      result = (\"PASTE(%d): %s...\"):format(#event.text, event.text:sub(1, 17))\n   end\n   return a.green(STAT_ICON .. result)\nend\n\nfunction reprs_by_type.keypress(event)\n   local color = a.green\n   if event.command == \"NYI\" then\n      color = a.red\n   -- #todo this is a mostly-accurate but terrible way to distinguish named keys\n   -- We will have problems with UTF-8 if nothing else, and...just no\n   elseif #event.key > 1 then\n      color = a.magenta\n   elseif event.modifiers ~= 0 then\n      color = a.blue\n   end\n   return color(STAT_ICON .. input_event.serialize(event))\nend\n\nlocal echo_M = {}\nfunction echo_M.__repr(event)\n   local event_str = reprs_by_type[event.type](event)\n   if event.command then\n      event_str = event_str .. \': \' .. event.command\n   end\n   return event_str\nend\n\n\n\n\n\n\nlocal clone = assert(table.clone)\nfunction InputEchoAgent.update(echo, event, command)\n   echo.subject = clone(event)\n   echo.subject.command = command\n   setmetatable(echo.subject, echo_M)\n   echo:contentsChanged()\nend\n\n\n\n\n\n\nfunction InputEchoAgent.bufferValue(echo)\n   return echo.subject and { n = 1, echo.subject } or { n = 0 }\nend\n\n\n\n\nreturn core.cluster.constructor(InputEchoAgent)\n\n",
name = "helm/agent/input-echo",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "85975159237e547333bf68d90be73e15184a6d606464a5aa6beeed64037a065b",
binary = "\n\n\n\n\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal EditAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nlocal math = core.math\nlocal string = core.string\nlocal table = core.table\nlocal lines = assert(string.lines)\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal Codepoints = require \"singletons:codepoints\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.contentsChanged(agent)\n   Agent.contentsChanged(agent)\n   agent.contents_changed = true\nend\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.setLexer(agent, lex_fn)\n   if agent.lex ~= lex_fn then\n      agent.lex = lex_fn\n      agent:bufferCommand(\"clearCaches\")\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.currentPosition(agent)\n   local row, col = agent.cursor:rowcol()\n   return agent[row], col, row\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clamp, inbounds = assert(math.clamp), assert(math.inbounds)\nlocal Point = require \"anterm:point\"\nfunction EditAgent.setCursor(agent, rowOrTable, col)\n   local row\n   if type(rowOrTable) == \"table\" then\n      row, col = rowOrTable.row, rowOrTable.col\n   else\n      row = rowOrTable\n   end\n   row = row or agent.cursor.row\n   assert(inbounds(row, 1, #agent))\n   agent:openRow(row)\n   if col then\n      assert(inbounds(col, 1, #agent[row] + 1))\n      -- Explicit horizontal motion, forget any remembered horizontal position\n      agent.desired_col = nil\n   else\n      -- Remember where we were horizontally before clamping\n      agent.desired_col = agent.desired_col or agent.cursor.col\n      col = clamp(agent.desired_col, nil, #agent[row] + 1)\n   end\n   agent.cursor = Point(row, col)\n   agent.cursor_changed = true\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.cursorIndex(agent)\n   local index = agent.cursor.col\n   for row = agent.cursor.row - 1, 1, -1 do\n      index = index + #agent[row] + 1\n   end\n   return index\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(table.clone)\nfunction EditAgent.beginSelection(agent)\n   agent.mark = clone(agent.cursor)\nend\n\n\n\n\n\n\n\n\nfunction EditAgent.clearSelection(agent)\n   if agent:hasSelection() then\n      agent.cursor_changed = true\n   end\n   agent.mark = nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.hasSelection(agent)\n   if not agent.mark then return false end\n   if agent.mark.row == agent.cursor.row\n      and agent.mark.col == agent.cursor.col then\n      agent.mark = nil\n      return false\n   else\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.selectionStart(agent)\n   if not agent:hasSelection() then return nil end\n   local c, m = agent.cursor, agent.mark\n   if m.row < c.row or\n      (m.row == c.row and m.col < c.col) then\n      return m.col, m.row\n   else\n      return c.col, c.row\n   end\nend\n\nfunction EditAgent.selectionEnd(agent)\n   if not agent:hasSelection() then return nil end\n   local c, m = agent.cursor, agent.mark\n   if m.row > c.row or\n      (m.row == c.row and m.col > c.col) then\n      return m.col, m.row\n   else\n      return c.col, c.row\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.openRow(agent, row_num)\n   if row_num < 1 or row_num > #agent then\n      return nil\n   end\n   if type(agent[row_num]) == \"string\" then\n      agent[row_num] = Codepoints(agent[row_num])\n   end\n   return agent[row_num], row_num\nend\n\n\n\n\n\n\n\n\n\n\nlocal slice = assert(table.slice)\nfunction EditAgent.nl(agent)\n   line, cur_col, cur_row = agent:currentPosition()\n   -- split the line\n   local first = slice(line, 1, cur_col - 1)\n   local second = slice(line, cur_col)\n   agent[cur_row] = first\n   insert(agent, cur_row + 1, second)\n   agent:contentsChanged()\n   agent:setCursor(cur_row + 1, 1)\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.tab(agent)\n   agent:paste(\"   \")\nend\n\n\n\n\n\n\n\n\n\nlocal inverse = assert(table.inverse)\nlocal _openers = { [\"(\"] = \")\",\n                   [\'\"\'] = \'\"\',\n                   [\"\'\"] = \"\'\",\n                   [\"{\"] = \"}\",\n                   [\"[\"] = \"]\"}\nlocal _closers = inverse(_openers)\n\nlocal function _should_insert(line, cursor, frag)\n   return not (frag == line[cursor] and _closers[frag])\nend\n\nlocal function _should_pair(line, cursor, frag)\n   -- Only consider inserting a pairing character if this is an \"opener\"\n   if not _openers[frag] then return false end\n   -- Translate end-of-line to the implied newline\n   local next_char = line[cursor] or \"\\n\"\n   -- Insert a pair if we are before whitespace, or the next char is a\n   -- closing brace--that is, a closing character that is different\n   -- from its corresponding open character, i.e. not a quote\n   return next_char:match(\"%s\") or\n      _closers[next_char] and _closers[next_char] ~= next_char\nend\n\nfunction EditAgent.insert(agent, frag)\n   local line, cur_col = agent:currentPosition()\n   if _should_insert(line, cur_col, frag) then\n      if _should_pair(line, cur_col, frag) then\n         insert(line, cur_col, _openers[frag])\n      end\n      insert(line, cur_col, frag)\n      agent:contentsChanged()\n   end\n   agent:setCursor(nil, cur_col + 1)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\nlocal collect, splice = assert(table.collect), assert(table.splice)\nfunction EditAgent.paste(agent, frag)\n   frag = frag:gsub(\"\\t\", \"   \")\n   local frag_lines = collect(lines, frag)\n   for i, frag_line in ipairs(frag_lines) do\n      if i > 1 then agent:nl() end\n      local codes = Codepoints(frag_line)\n      local line, cur_col, cur_row = agent:currentPosition()\n      splice(line, cur_col, codes)\n      agent:setCursor(nil, cur_col + #codes)\n   end\n   agent:contentsChanged()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal deleterange = assert(table.deleterange)\nfunction EditAgent.killSelection(agent)\n   if not agent:hasSelection() then\n      -- #todo communicate that there was nothing to do somehow,\n      -- without falling through to the next command in the keymap\n      return\n   end\n   agent:contentsChanged()\n   local start_col, start_row = agent:selectionStart()\n   local end_col, end_row = agent:selectionEnd()\n   if start_row == end_row then\n      -- Deletion within a line, just remove some chars\n      deleterange(agent[start_row], start_col, end_col - 1)\n   else\n      -- Grab both lines--we\'re about to remove the end line\n      local start_line, end_line = agent[start_row], agent[end_row]\n      deleterange(agent, start_row + 1, end_row)\n      -- Splice lines together\n      for i = start_col, #start_line do\n         start_line[i] = nil\n      end\n      for i = end_col, #end_line do\n         insert(start_line, end_line[i])\n      end\n   end\n   -- Cursor always ends up at the start of the formerly-selected area\n   agent:setCursor(start_row, start_col)\n   -- No selection any more\n   agent:clearSelection()\nend\n\n\n\n\n\n\n\n\nlocal function _delete_for_motion(motionName)\n   return function(agent, ...)\n      agent:beginSelection()\n      agent[motionName](agent, ...)\n      return agent:killSelection()\n   end\nend\n\nfor delete_name, motion_name in pairs({\n   killForward = \"right\",\n   killToEndOfLine = \"endOfLine\",\n   killToBeginningOfLine = \"startOfLine\",\n   killToEndOfWord = \"rightWordAlpha\",\n   killToBeginningOfWord = \"leftWordAlpha\"\n}) do\n   EditAgent[delete_name] = _delete_for_motion(motion_name)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _is_paired(a, b)\n   -- a or b might be out-of-bounds, and if a is not a brace and b is nil,\n   -- we would incorrectly answer true, so check that both a and b are present\n   return a and b and _openers[a] == b\nend\n\nfunction EditAgent.killBackward(agent, disp)\n   disp = disp or 1\n   local line, cur_col, cur_row = agent:currentPosition()\n   -- Only need to check the character immediately to the left of the cursor\n   -- since if we encounter paired braces later, we will delete the\n   -- closing brace first anyway\n   if _is_paired(line[cur_col - 1], line[cur_col]) then\n      agent:right()\n      disp = disp + 1\n   end\n   agent:beginSelection()\n   agent:left(disp)\n   agent:killSelection()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.left(agent, disp)\n   disp = disp or 1\n   local line, new_col, new_row = agent:currentPosition()\n   new_col = new_col - disp\n   while new_col < 1 do\n      line, new_row = agent:openRow(new_row - 1)\n      if not new_row then\n         agent:setCursor(nil, 1)\n         return false\n      end\n      new_col = #line + 1 + new_col\n   end\n   agent:setCursor(new_row, new_col)\n   return true\nend\n\nfunction EditAgent.right(agent, disp)\n   disp = disp or 1\n   local line, new_col, new_row = agent:currentPosition()\n   new_col = new_col + disp\n   while new_col > #line + 1 do\n      _, new_row = agent:openRow(new_row + 1)\n      if not new_row then\n         agent:setCursor(nil, #line + 1)\n         return false\n      end\n      new_col = new_col - #line - 1\n      line = agent[new_row]\n   end\n   agent:setCursor(new_row, new_col)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.up(agent)\n   if agent:openRow(agent.cursor.row - 1) then\n      agent:setCursor(agent.cursor.row - 1, nil)\n      return true\n   -- Move to beginning\n   elseif agent.cursor.col > 1 then\n      agent:setCursor(nil, 1)\n      return true\n   end\n   -- Can\'t move at all\n   return false\nend\n\nfunction EditAgent.down(agent)\n   if agent:openRow(agent.cursor.row + 1) then\n      agent:setCursor(agent.cursor.row + 1, nil)\n      return true\n   else\n      local row_len = #agent[agent.cursor.row]\n      -- Move to end\n      if agent.cursor.col <= row_len then\n         agent:setCursor(nil, row_len + 1)\n         return true\n      end\n   end\n   -- Can\'t move at all\n   return false\nend\n\n\n\n\n\n\nfunction EditAgent.startOfLine(agent)\n   agent:setCursor(nil, 1)\nend\n\nfunction EditAgent.endOfLine(agent)\n   agent:setCursor(nil, #agent[agent.cursor.row] + 1)\nend\n\n\n\n\n\n\n\n\nfunction EditAgent.startOfText(agent)\n   agent:setCursor(1, 1)\nend\n\nfunction EditAgent.endOfText(agent)\n   agent:openRow(#agent)\n   agent:setCursor(#agent, #agent[#agent] + 1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal match = assert(string.match)\n\nfunction EditAgent.scanFor(agent, pattern, reps, forward)\n   local change = forward and 1 or -1\n   reps = reps or 1\n   local found_other_char, moved = false, false\n   local line, cur_col, cur_row = agent:currentPosition()\n   local search_pos, search_row = cur_col, cur_row\n   local search_char\n   local epsilon = forward and 0 or -1\n   while true do\n      local at_boundary = (forward and search_pos > #line)\n                       or (not forward and search_pos == 1)\n      search_char = at_boundary and \"\\n\" or line[search_pos + epsilon]\n      if not match(search_char, pattern) then\n         found_other_char = true\n      elseif found_other_char then\n         reps = reps - 1\n         if reps == 0 then break end\n         found_other_char = false\n      end\n      if at_boundary then\n         -- break out on agent boundaries\n         if search_row == (forward and #agent or 1) then break end\n         line, search_row = agent:openRow(search_row + change)\n         search_pos = forward and 1 or #line + 1\n      else\n         search_pos = search_pos + change\n      end\n      moved = true\n   end\n\n   return moved, search_pos - cur_col, search_row - cur_row\nend\n\n\n\n\n\n\n\n\nfunction EditAgent.leftToBoundary(agent, pattern, reps)\n   local line, cur_col, cur_row = agent:currentPosition()\n   local moved, colΔ, rowΔ = agent:scanFor(pattern, reps, false)\n   if moved then\n      agent:setCursor(cur_row + rowΔ, cur_col + colΔ)\n      return true\n   else\n      return false\n   end\nend\n\nfunction EditAgent.rightToBoundary(agent, pattern, reps)\n   local line, cur_col, cur_row = agent:currentPosition()\n   local moved, colΔ, rowΔ = agent:scanFor(pattern, reps, true)\n   if moved then\n      agent:setCursor(cur_row + rowΔ, cur_col + colΔ)\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.firstNonWhitespace(agent)\n   local line = agent[agent.cursor.row]\n   local new_col = 1\n   while new_col <= #line do\n      if match(line[new_col], \'%S\') then\n         agent:setCursor(nil, new_col)\n         return true\n      end\n      new_col = new_col + 1\n   end\n   return false\nend\n\n\n\n\n\n\nfunction EditAgent.leftWordAlpha(agent, reps)\n   return agent:leftToBoundary(\'%W\', reps)\nend\n\nfunction EditAgent.rightWordAlpha(agent, reps)\n   return agent:rightToBoundary(\'%W\', reps)\nend\n\nfunction EditAgent.leftWordWhitespace(agent, reps)\n   return agent:leftToBoundary(\'%s\', reps)\nend\n\nfunction EditAgent.rightWordWhitespace(agent, reps)\n   return agent:rightToBoundary(\'%s\', reps)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.replaceToken(agent, frag)\n   local cursor_token\n   for _, token in ipairs(agent:tokens(agent.cursor.row)) do\n      if token.cursor_offset then\n         cursor_token = token\n         break\n      end\n   end\n   agent:right(cursor_token.total_disp - cursor_token.cursor_offset)\n   agent:killBackward(cursor_token.total_disp)\n   agent:paste(frag)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.transposeLetter(agent)\n   local line, cur_col, cur_row = agent:currentPosition()\n   if cur_col == 1 then return false end\n   if cur_col == 2 and #line == 1 then return false end\n   local left, right = cur_col - 1, cur_col\n   if cur_col == #line + 1 then\n      left, right = left - 1, right - 1\n   end\n   local stash = line[right]\n   line[right] = line[left]\n   line[left] = stash\n   agent:setCursor(nil, right + 1)\n   agent:contentsChanged()\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.shouldEvaluate(agent)\n   -- Most agents are one line, so we always evaluate from\n   -- a one-liner, regardless of cursor location.\n   local linum = #agent\n   if linum == 1 then\n      return true\n   end\n   local _, cur_col, cur_row = agent:currentPosition()\n   -- Evaluate if we are at the end of the first or last line (the default\n   -- positions after scrolling up or down in the history)\n   if (cur_row == 1 or cur_row == linum) and cur_col > #agent[cur_row] then\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.update(agent, str)\n   str = str or \"\"\n   local i = 1\n   for line in lines(str) do\n      agent[i] = line\n      i = i + 1\n   end\n   for j = i, #agent do\n      agent[j] = nil\n   end\n   agent:contentsChanged()\n   agent:endOfText()\n   return agent\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.clear(agent)\n   agent:update(\"\")\n   agent :send { to = \"agents.results\", method = \"clear\" }\n   agent :send { to = \"hist\", method = \"toEnd\" }\nend\n\n\n\n\n\n\n\n\nlocal function cat(l)\n   if l == nil then\n      return \"\"\n   elseif type(l) == \"string\" then\n      return l\n   elseif type(l) == \"table\" then\n      return concat(l)\n   else\n      error(\"called private fn cat with type\" .. type(l))\n   end\nend\n\nfunction EditAgent.contents(agent)\n   local closed_lines = {}\n   for k, v in ipairs(agent) do\n      closed_lines[k] = cat(v)\n   end\n   return concat(closed_lines, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.isEmpty(agent)\n   return #agent == 1 and #agent[1] == 0\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.continuationLines(agent)\n   return #agent - 1\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.tokens(agent, row)\n   if row then\n      local cursor_col = agent.cursor.row == row\n         and agent.cursor.col or 0\n      return agent.lex(cat(agent[row]), cursor_col)\n   else\n      return agent.lex(agent:contents(), agent:cursorIndex())\n   end\nend\n\n\n\n\n\n\n\n\nfunction EditAgent.bufferValue(agent)\n   local answer = {}\n   for i, line in ipairs(agent) do\n      answer[i] = cat(line)\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\nfunction EditAgent.windowConfiguration(agent)\n   return agent.mergeWindowConfig(Agent.windowConfiguration(), {\n      field = { cursor = true },\n      closure = { cursorIndex = true,\n                  tokens = true }\n   })\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditAgent.selfInsert(agent, evt)\n   return agent:insert(evt.key)\nend\n\n\n\n\n\n\n\n\nfunction EditAgent.evtPaste(agent, evt)\n   agent:paste(evt.text)\nend\n\n\n\n\n\n\nfunction EditAgent._init(agent)\n   Agent._init(agent)\n   agent[1] = \"\"\n   agent:setCursor(1, 1)\n   agent.contents_changed = false\n   agent.cursor_changed = false\nend\n\n\n\n\nreturn core.cluster.constructor(EditAgent)\n\n",
name = "helm/agent/edit",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "9a6ee2d4944da2492a8e7584312a981aaae2abc783ba0444c1fa890ab5fc9b29",
binary = "\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal ModalAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\n\n\n\nlocal DialogModel = meta {}\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal ceil = assert(math.ceil)\nlocal breakascii = assert(require \"core:string/print\" . breakascii)\n\nlocal function _buttonTextFrom(button)\n   local button_text = button.text\n      :gsub(\'&([^&])\', function(ch) return a.underline(ch) end, 1)\n      :gsub(\'&&\', \'&\')\n   button_text = \'[ \' .. button_text .. \' ]\'\n   if button.default then\n      return a.bold(button_text)\n   else\n      return button_text\n   end\nend\n\nlocal function _buttonWidthFrom(button)\n   -- Four chars for the leading \'[ \' and trailing \' ]\'\n   return 4 + #button.text:gsub(\'&(.)\', \'%1\')\nend\n\nlocal function _buttonAndSpaceInfo(model)\n   local buttons_width, spaces_count = 0, 0\n   -- First, figure out how much space we need to fill\n   for i, button in ipairs(model.buttons) do\n      if button.text then\n         buttons_width = buttons_width + _buttonWidthFrom(button)\n         if i ~= 1 then\n            -- For space between buttons\n            buttons_width = buttons_width + 1\n         end\n      elseif button.space then\n         spaces_count = spaces_count + 1\n      end\n   end\n   return buttons_width, spaces_count\nend\n\nfunction DialogModel.__repr(model, window, c)\n   local phrase = {}\n   local wrapped_text = breakascii(model.text, 40)\n   insert(phrase, wrapped_text)\n   insert(phrase, \"\\n\\n\")\n   local buttons_width, spaces_count = _buttonAndSpaceInfo(model)\n   local space_remaining = window.width - buttons_width\n   for i, button in ipairs(model.buttons) do\n      if button.text then\n         if i ~= 1 then insert(phrase, \" \") end\n         insert(phrase, _buttonTextFrom(button))\n      elseif button.space then\n         local spaces = ceil(space_remaining / spaces_count)\n         insert(phrase, (\" \"):rep(spaces))\n         space_remaining = space_remaining - spaces\n         spaces_count = spaces_count - 1\n      end\n   end\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nlocal max = assert(math.max)\nlocal Point = require \"anterm:point\"\n\nfunction DialogModel.requiredExtent(model)\n   local _, text_height, text_width = breakascii(model.text, 40)\n   local buttons_width, spaces_count = _buttonAndSpaceInfo(model)\n   -- Ensure that any flexible-space element is at least one space wide\n   local button_row_width = buttons_width + spaces_count\n   -- Add two lines for a blank line and the button row\n   return Point(text_height + 2, max(text_width, button_row_width))\nend\n\n\n\n\n\n\n\n\n\nlocal button_styles = {\n   yes_no_cancel = {\n      { value = \"cancel\", text = \"&Cancel\", cancel = true },\n      { space = true },\n      { value = \"no\", text = \"&No\" },\n      { value = \"yes\", text = \"&Yes\", default = true }\n   }\n}\n\nfunction ModalAgent.update(agent, text, button_style)\n   local model = setmetatable({}, DialogModel)\n   model.text = text\n   if type(button_style) == \"string\" then\n      button_style = button_styles[button_style]\n   end\n   model.buttons = button_style\n   agent.subject = model\n   agent:contentsChanged()\nend\n\n\n\n\n\n\n\n\nfunction ModalAgent.show(agent, ...)\n   agent:update(...)\n   agent :send { method = \"pushMode\", \"modal\" }\nend\n\n\n\n\n\n\n\n\nfunction ModalAgent.close(agent, value)\n   agent.subject.value = value\n   agent :send { method = \"popMode\" }\nend\n\n\n\n\n\n\n\n\nfunction ModalAgent.answer(agent)\n   return agent.subject and agent.subject.value\nend\n\n\n\n\n\n\nfunction ModalAgent.bufferValue(agent)\n   return agent.subject and { n = 1, agent.subject } or { n = 0 }\nend\n\n\n\n\n\n\nlocal function _shortcutFrom(button)\n   local shortcut_decl = button.text and button.text:match(\'&([^&])\')\n   return shortcut_decl and shortcut_decl:lower()\nend\n\nlocal function _acceptButtonWhere(agent, fn)\n   for _, button in ipairs(agent.subject.buttons) do\n      if fn(button) then\n         return agent:close(button.value)\n      end\n   end\nend\n\nfunction ModalAgent.letterShortcut(agent, event)\n   local key = event.key:lower()\n   return _acceptButtonWhere(agent, function(button)\n      return _shortcutFrom(button) == key\n   end)\nend\n\nfunction ModalAgent.cancel(agent)\n   return _acceptButtonWhere(agent, function(button) return button.cancel end)\nend\n\nfunction ModalAgent.acceptDefault(agent, event)\n   return _acceptButtonWhere(agent, function(button) return button.default end)\nend\n\n\n\nreturn core.cluster.constructor(ModalAgent)\n\n",
name = "helm/agent/modal",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "bcf9d1882250edb916a08968159d9e687cc708211a283bfbfd181d769366ecc8",
binary = "\n\n\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal PromptAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nfunction PromptAgent.update(agent, prompt_char)\n   agent.prompt_char = prompt_char\n   agent:contentsChanged()\nend\n\n\n\n\n\n\n\n\n\n\nfunction PromptAgent.checkTouched(agent)\n   -- #todo .touched propagation is weird, we can\'t :checkTouched()\n   -- on the EditAgent because we\'ll clear stuff prematurely\n   -- All of this should be replaced by a handler for an action sent\n   -- by the EditAgent (which would replace onTxtbufChanged() as well)\n   agent.touched = agent.touched or agent :send { to = \"agents.edit\", field = \"touched\" }\n   return Agent.checkTouched(agent)\nend\n\n\n\n\n\n\nfunction PromptAgent.bufferValue(agent)\n   local continuation_lines = agent :send { to = \"agents.edit\",\n                                          method = \"continuationLines\" }\n   return agent.prompt_char .. \" \" .. (\"\\n...\"):rep(continuation_lines)\nend\n\n\n\n\nreturn core.cluster.constructor(PromptAgent)\n\n",
name = "helm/agent/prompt",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "5fe571c4c83bceefaeb7914a2e5a2c2590693d1cf278ffa4fd7660bf63b7aa99",
binary = "\n\n\n\n\nlocal table = core.table\n\nlocal Agent = require \"helm:agent/agent\"\nlocal PagerAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nfunction PagerAgent.update(agent, str)\n   agent.str = str\n   agent:contentsChanged()\nend\n\nfunction PagerAgent.clear(agent)\n   agent:update(nil)\nend\n\n\n\n\n\n\n\n\nfunction PagerAgent.activate(agent)\n   agent :send { method = \"pushMode\", \"page\" }\nend\nfunction PagerAgent.quit(agent)\n   agent :send { method = \"popMode\" }\nend\n\n\n\n\n\n\nfunction PagerAgent.bufferValue(agent)\n   -- #todo we should work with a Rainbuf that does word-aware wrapping\n   -- and accepts a string directly, rather than abusing Resbuf\n   return { n = 1, agent.str }\nend\n\n\n\n\nreturn core.cluster.constructor(PagerAgent)\n\n",
name = "helm/agent/pager",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "dced9cc320bf3dc0a9110b0f1d895dc50b017eaf110b99e2cafe59bac5c20763",
binary = "\n\n\n\n\n\n\n\n\nlocal EditAgent = require \"helm:agent/edit\"\nlocal ResultsAgent = require \"helm:agent/results\"\n\nlocal math = core.math\nlocal assert = assert(core.fn.assertfmt)\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal ReviewAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.update(agent, run)\n   agent.subject = run\n   agent:setInitialSelection()\n   agent:_updateResultsAgent()\n   -- Update any EditAgents we have without creating any more\n   for index in pairs(agent.edit_agents) do\n      agent:_updateEditAgent(index)\n   end\n   agent:contentsChanged()\nend\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent._updateEditAgent(agent, index)\n   local edit_agent = agent.edit_agents[index]\n   if edit_agent then\n      edit_agent:update(agent.subject[index].line)\n   end\nend\n\nfunction ReviewAgent._updateResultsAgent(agent)\n   local results_agent = agent.results_agent\n   if results_agent then\n      local premise = agent:selectedPremise()\n      local result = premise and (premise.new_result or premise.old_result)\n      results_agent:update(result)\n      -- #todo scroll offset of the Resbuf needs to be reset at this point\n      -- we have some serious thinking to do about how changes are\n      -- communicated to the buffer\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.selectionChanged(agent)\n      agent:_updateResultsAgent()\n      agent:contentsChanged()\n      agent:bufferCommand(\"ensureSelectedVisible\")\nend\n\n\n\n\n\n\n\n\nlocal clamp = assert(math.clamp)\nfunction ReviewAgent.selectIndex(agent, index)\n   index = #agent.subject == 0\n      and 0\n      or clamp(index, 1, #agent.subject)\n   if index ~= agent.selected_index then\n      agent.selected_index = index\n      agent:selectionChanged()\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.selectNextWrap(agent)\n   local new_idx = agent.selected_index < #agent.subject\n      and agent.selected_index + 1\n      or 1\n   return agent:selectIndex(new_idx)\nend\nfunction ReviewAgent.selectPreviousWrap(agent)\n   local new_idx = agent.selected_index > 1\n      and agent.selected_index - 1\n      or #agent.subject\n   return agent:selectIndex(new_idx)\nend\n\n\n\n\n\n\nfunction ReviewAgent.selectedPremise(agent)\n   return agent.subject[agent.selected_index]\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.toggleSelectedState(agent)\n   local new_status = agent.status_cycle_map[agent:selectedPremise().status]\n   return agent:setSelectedState(new_status)\nend\n\nfunction ReviewAgent.reverseToggleSelectedState(agent)\n   local new_status = agent.status_reverse_map[agent:selectedPremise().status]\n   return agent:setSelectedState(new_status)\nend\n\n\n\n\n\n\n\n\nfunction ReviewAgent.setSelectedState(agent, state)\n   local premise = agent:selectedPremise()\n   if premise.status == state then return end\n   assert(agent.status_cycle_map[state], \"Cannot change to invalid status %s\", state)\n   premise.status = state\n   agent:contentsChanged()\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _swap_premises(agent, index_a, index_b)\n   local premise_a = agent.subject[index_a]\n   local premise_b = agent.subject[index_b]\n\n   agent.subject[index_a] = premise_b\n   premise_b.ordinal = index_a\n   agent:_updateEditAgent(index_a)\n\n   agent.subject[index_b] = premise_a\n   premise_a.ordinal = index_b\n   agent:_updateEditAgent(index_b)\n\n   agent:contentsChanged()\nend\n\nfunction ReviewAgent.movePremiseUp(agent)\n   if agent.selected_index == 1 then\n      return false\n   end\n   _swap_premises(agent, agent.selected_index, agent.selected_index - 1)\n   -- Maintain selection of the same premise after the move\n   -- Will never wrap because we disallowed moving the first premise up\n   agent:selectPreviousWrap()\n   return true\nend\n\nfunction ReviewAgent.movePremiseDown(agent)\n   if agent.selected_index == #agent.subject then\n      return false\n   end\n   _swap_premises(agent, agent.selected_index, agent.selected_index + 1)\n   agent:selectNextWrap()\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.bufferValue(agent)\n   return agent.subject\nend\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.windowConfiguration(agent)\n   return agent.mergeWindowConfig(Agent.windowConfiguration(), {\n      field = { selected_index = true },\n      closure = { selectedPremise = true,\n                  editWindow = true,\n                  resultsWindow = true }\n   })\nend\n\n\n\n\n\n\n\n\nlocal inbounds = assert(math.inbounds)\nlocal lua_thor = assert(require \"helm:lex\" . lua_thor)\nfunction ReviewAgent.editWindow(agent, index)\n   assert(inbounds(index, 1, #agent.subject))\n   if not agent.edit_agents[index] then\n      agent.edit_agents[index] = EditAgent()\n      agent.edit_agents[index].lex = lua_thor\n      agent:_updateEditAgent(index)\n   end\n   return agent.edit_agents[index]:window()\nend\n\n\n\n\n\n\n\n\n\n\nfunction ReviewAgent.resultsWindow(agent)\n   return agent.results_agent:window()\nend\n\n\n\n\n\n\n\nfunction ReviewAgent._init(agent)\n   Agent._init(agent)\n   agent.selected_index = 0\n   agent.edit_agents = {}\n   agent.results_agent = ResultsAgent()\n   agent.status_cycle_map = {}\n   agent.status_reverse_map = {}\n   for i, this_status in ipairs(agent.valid_statuses) do\n      local prev_status = i == 1\n         and agent.valid_statuses[#agent.valid_statuses]\n         or agent.valid_statuses[i - 1]\n      local next_status = i == #agent.valid_statuses\n         and agent.valid_statuses[1]\n         or agent.valid_statuses[i + 1]\n      agent.status_cycle_map[this_status] = next_status\n      agent.status_reverse_map[this_status] = prev_status\n   end\nend\n\n\n\n\nreturn core.cluster.constructor(ReviewAgent)\n\n",
name = "helm/agent/review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "e966f306e84ad8e007b2ff2c6505538bc7c5c850a1288004a53f78a66bfb3bab",
binary = "\n\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm:selection_list\"\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal ResultListAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\n\n\n\nfor _, method_name in ipairs{\"selectNext\", \"selectPrevious\",\n                    \"selectNextWrap\", \"selectPreviousWrap\",\n                    \"selectFirst\", \"selectIndex\", \"selectNone\"} do\n   ResultListAgent[method_name] = function(agent, ...)\n      if agent.last_collection then\n         agent.last_collection[method_name](agent.last_collection, ...)\n         agent:contentsChanged()\n         agent:bufferCommand(\"ensureVisible\", agent.last_collection.selected_index)\n      end\n   end\nend\n\n\n\n\n\nfunction ResultListAgent.selectedItem(agent)\n   return agent.last_collection and agent.last_collection:selectedItem()\nend\n\n\n\n\n\n\n\n\nfunction ResultListAgent.quit(agent)\n   agent:selectNone()\n   agent :send { method = \"popMode\" }\nend\n\n\n\n\n\n\nfunction ResultListAgent.bufferValue(agent)\n   return agent.last_collection and { n = 1, agent.last_collection }\nend\n\n\n\n\n\n\nlocal function _toLastCollection(agent, window, field, ...)\n   local lc = agent.last_collection\n   return lc and lc[field](lc, ...) -- i.e. lc:<field>(...)\nend\n\nfunction ResultListAgent.windowConfiguration(agent)\n   -- #todo super is hella broken, grab explicitly from the right superclass\n   return agent.mergeWindowConfig(Agent.windowConfiguration(agent), {\n      closure = {\n         selectedItem = _toLastCollection,\n         highlight = _toLastCollection\n      }\n   })\nend\n\n\n\n\nreturn core.cluster.constructor(ResultListAgent)\n\n",
name = "helm/agent/result-list",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "66a027e88f38bbe1a4a7dafeb035435c14c1e67bf2862bc699dd101ed8a136e9",
binary = "\n\n\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal ResultsAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nfunction ResultsAgent.update(agent, result)\n   agent.result = result\n   agent:contentsChanged()\nend\n\nfunction ResultsAgent.clear(agent)\n   agent:update(nil)\nend\n\n\n\n\n\n\nfunction ResultsAgent.bufferValue(agent)\n   return agent.result or { n = 0 }\nend\n\n\n\n\n\n\n\n\n\nfunction ResultsAgent.clearOnFirstKey(agent)\n   if agent :send { to = \"agents.edit\", method = \"isEmpty\" } then\n      agent:clear()\n   end\n   return false\nend\n\n\n\n\nreturn core.cluster.constructor(ResultsAgent)\n\n",
name = "helm/agent/results",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "f96cf24db7ca32b29d9c193c774b4cc8792f0b576b40b32614b453371b702f15",
binary = "\n\n\n\n\n\n\n\nlocal table = core.table\n\n\n\n\nlocal ResultListAgent = require \"helm:agent/result-list\"\nlocal SearchAgent = meta(getmetatable(ResultListAgent))\n\n\n\n\n\n\n\n\nfunction SearchAgent.update(agent)\n   local frag = agent :send { to = \"agents.edit\", method = \"contents\" }\n   if agent.last_collection\n      and agent.last_collection.lit_frag == frag then\n      return\n   end\n   -- #todo most people would need to refer to \'modeS.hist\' here,\n   -- but this happens to be dispatched *by* modeS directly. Need\n   -- more intelligent cooperation between modeS and Maestro\n   agent.last_collection = agent :send { to = \"hist\", method = \"search\", frag }\n   agent:contentsChanged()\nend\n\n\n\n\n\n\nfunction SearchAgent.acceptAtIndex(agent, selected_index)\n   local search_result = agent.last_collection\n   if search_result and #search_result > 0 then\n      selected_index = selected_index or search_result.selected_index\n      if selected_index == 0 then selected_index = 1 end\n      local idx = search_result.cursors[selected_index]\n      local line, result = agent :send { idx,\n                                         to = \"hist\",\n                                         method = \"index\",\n                                         n = 1 }\n      agent :send { to = \"agents.edit\", method = \"update\", line }\n      agent :send { to = \"agents.results\", method = \"update\", result }\n   end\n   agent:quit()\nend\n-- If no argument is passed this happily falls through\nSearchAgent.acceptSelected = SearchAgent.acceptAtIndex\n\n\n\n\n\n\n\n\n\nfunction SearchAgent.activateOnFirstKey(agent)\n   if agent :send { to = \"agents.edit\", method = \"isEmpty\" } then\n      agent :send { method = \"pushMode\", \"search\" }\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction SearchAgent.acceptFromNumberKey(agent, evt)\n   agent:acceptAtIndex(tonumber(evt.key))\nend\n\n\n\n\n\n\n\n\nfunction SearchAgent.userCancel(agent)\n   if agent:selectedItem() then\n      agent:selectNone()\n   else\n      agent:quit()\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction SearchAgent.quitIfNoSearchTerm(agent)\n   if agent :send { to = \"agents.edit\", method = \"isEmpty\" } then\n      agent:quit()\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\nreturn core.cluster.constructor(SearchAgent)\n\n",
name = "helm/agent/search",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "92aceace99cec04bb05c60ea078b3000663832fe57a538f3a56e0488e6d6d0da",
binary = "\n\n\n\n\n\n\n\n\nlocal table = core.table\n\n\n\n\nlocal ReviewAgent = require \"helm:agent/review\"\nlocal RunReviewAgent = meta(getmetatable(ReviewAgent))\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nfunction RunReviewAgent.setInitialSelection(agent)\n   if #agent.subject == 0 then\n      insert(agent.subject, { line = \"\", status = \"insert\" })\n   end\n   agent.selected_index = 1\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRunReviewAgent.valid_statuses = { \"keep\", \"insert\", \"trash\" }\nRunReviewAgent.was_inserting = false\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _updateAgentsAfterSelected(agent)\n   for i = agent.selected_index, #agent.subject do\n      agent:_updateEditAgent(i)\n   end\n   agent:_updateResultsAgent()\nend\n\nfunction RunReviewAgent.insertLine(agent)\n   insert(agent.subject, agent.selected_index, { line = \"\", status = \"insert\" } )\n   _updateAgentsAfterSelected(agent)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\nfunction RunReviewAgent.cancelInsertion(agent)\n   if agent:selectedPremise().status ~= \"insert\"\n      -- Don\'t remove an \"insert\" premise if it\'s the very last one\n      or #agent.subject == 1 then\n         return\n   end\n\n   remove(agent.subject, agent.selected_index)\n   -- Remove the *last* EditAgent iff there is one,\n   -- then update the others to preserve bindings\n   agent.edit_agents[#agent.subject + 1] = nil\n   agent:bufferCommand(\"editAgentRemoved\", #agent.subject + 1)\n   _updateAgentsAfterSelected(agent)\n   agent.was_inserting = true\nend\n\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.setSelectedState(agent, state)\n   local premise = agent:selectedPremise()\n   if premise.status == state then return end\n   -- Any status change clears the `was_inserting` flag, *except* canceling\n   -- out of insertion, which sets it instead. Save it locally and clear it\n   -- before deciding what to do, that way it can just be *re*-set in the\n   -- one case that needs it.\n   local was_inserting = agent.was_inserting\n   agent.was_inserting = false\n   if state == \"insert\" then\n      if was_inserting then\n         -- #todo this is dependent on only having two non-insert statuses,\n         -- if there were more, we would need to know the intended\n         -- cycle direction, so this would need to become an assertion failure\n         -- and we would have to handle this in overrides of\n         -- :[reverse]ToggleSelectedState\n         state = premise.status == \"keep\" and \"trash\" or \"keep\"\n         ReviewAgent.setSelectedState(agent, state)\n      else\n         agent:insertLine()\n      end\n   else\n      -- Need to explicitly check here because we don\'t want to change another\n      -- premise\'s status when canceling out of insertion. Setting the flag\n      -- means the change will occur the *next* time tab is pressed\n      if premise.status == \"insert\" then\n         agent:cancelInsertion()\n      else\n         ReviewAgent.setSelectedState(agent, state)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.selectionChanged(agent)\n   agent.was_inserting = false\n   ReviewAgent.selectionChanged(agent)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.selectIndex(agent, index)\n   agent:cancelInsertion()\n   ReviewAgent.selectIndex(agent, index)\nend\nfunction RunReviewAgent.selectNextWrap(agent)\n   agent:cancelInsertion()\n   ReviewAgent.selectNextWrap(agent)\nend\nfunction RunReviewAgent.selectPreviousWrap(agent)\n   agent:cancelInsertion()\n   ReviewAgent.selectPreviousWrap(agent)\nend\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.editInsertedLine(agent)\n   if agent:selectedPremise().status ~= \"insert\" then\n      return false\n   end\n   agent :send { method = \"pushMode\", \"edit_line\"}\nend\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.cancelInsertEditing(agent)\n   agent:cancelInsertion()\n   agent :send { to = \"agents.edit\", method = \"clear\" }\n   agent :send { method = \"popMode\" }\nend\n\n\n\n\n\n\n\n\nfunction RunReviewAgent.acceptInsertion(agent)\n   local line = agent :send { to = \"agents.edit\", method = \"contents\" }\n   if line:find(\"^%s*$\") then\n      agent:cancelInsertEditing()\n      return\n   end\n   agent :send { to = \"agents.edit\", method = \"clear\" }\n   local premise = agent:selectedPremise()\n   premise.line = line\n   -- Switch out the status without going through the usual channels\n   -- so that we don\'t remove the newly-added premise in the process\n   premise.status = \"keep\"\n   agent:_updateEditAgent(agent.selected_index)\n   agent:selectNextWrap()\n   send { method = \"popMode\" }\nend\n\n\n\n\n\n\n\n\nlocal Deque = require \"deque:deque\"\nfunction RunReviewAgent.evalAndResume(agent)\n   -- Clear out any insertion-in-progress\n   agent:cancelInsertion()\n   local to_run = Deque()\n   for _, premise in ipairs(agent.subject) do\n      if premise.status == \"keep\" then\n         to_run:push(premise.line)\n      end\n   end\n   agent :send { to = \"agents.status\", method = \"update\", \"default\" }\n   agent :send { method = \"pushMode\", \"nerf\" }\n   agent :send { method = \"rerun\", to_run }\nend\n\n\n\n\nreturn core.cluster.constructor(RunReviewAgent)\n\n",
name = "helm/agent/run-review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "1fce1aa9344c5b47516f68b5faf59c6915a62b910a29b79032b078bd170cb0c0",
binary = "\n\n\n\n\n\nlocal Agent = require \"helm:agent/agent\"\nlocal StatusAgent = meta(getmetatable(Agent))\n\n\n\n\n\n\nlocal status_lines = {\n   default            = \"an repl, plz reply uwu 👀\",\n   quit               = \"exiting repl, owo... 🐲\",\n   restart            = \"restarting an repl ↩️\",\n   session_review     = \'reviewing session \"%s\"\',\n   run_review_initial = \'Press Return to Evaluate, Tab/Up/Down to Edit\',\n   run_review         = \'Press M-e to Evaluate\' }\nstatus_lines.new_session = status_lines.default .. \' (recording \"%s\")\'\n\n\n\n\n\n\n\n\n\n\nfunction StatusAgent.update(stat, status_name, ...)\n   stat.status_name = status_name\n   stat.format_args = pack(...)\n   stat:contentsChanged()\nend\n\n\n\n\n\n\nfunction StatusAgent.bufferValue(stat)\n   return status_lines[stat.status_name]:format(unpack(stat.format_args))\nend\n\n\n\n\n\n\nfunction StatusAgent._init(agent)\n   Agent._init(agent)\n   agent.status_name = \'default\'\n   agent.format_args = { n = 0 }\nend\n\n\n\n\nreturn core.cluster.constructor(StatusAgent)\n\n",
name = "helm/agent/status",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "707c35969c0bfd4aa3b44e30b66dbff61d1c675d09b26d1668749adbcf8d3f1b",
binary = "\n\n\n\n\n\n\n\nlocal table = core.table\n\nlocal math = core.math\nlocal table = core.table\n\n\n\n\nlocal ReviewAgent = require \"helm:agent/review\"\nlocal SessionAgent = meta(getmetatable(ReviewAgent))\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nfunction SessionAgent.setInitialSelection(agent)\n   agent.selected_index = #agent.subject == 0 and 0 or 1\nend\n\n\n\n\n\n\n\n\nfunction SessionAgent.selectIndex(agent, i)\n   ReviewAgent.selectIndex(agent, i)\n   local premise = agent:selectedPremise()\n   agent :send { to = \"agents.edit\",\n                 method = \"update\",\n                 premise and premise.title }\nend\n\n\n\n\n\n\n\n\n\nSessionAgent.valid_statuses = {\n   \"ignore\", \"accept\", \"reject\", \"trash\"\n}\n\n\n\n\n\n\n\n\n\n\n\nfunction SessionAgent.editSelectedTitle(agent)\n   agent :send { method = \"pushMode\", \"edit_title\" }\nend\n\nfunction SessionAgent.cancelTitleEditing(agent)\n   agent :send { method = \"popMode\" }\nend\n\n\n\n\n\n\n\n\nfunction SessionAgent.acceptTitleUpdate(agent)\n   local new_title = agent :send { to = \"agents.edit\", method = \"contents\" }\n   agent:selectedPremise().title = new_title\n   agent:selectNextWrap()\n   agent:cancelTitleEditing()\nend\n\n\n\n\n\n\nfunction SessionAgent.promptSaveChanges(agent)\n   local sesh_title = agent.subject.session_title\n   agent :send { to = \"agents.modal\", method = \"show\",\n      \'Save changes to the session \"\' .. sesh_title .. \'\"?\',\n      \"yes_no_cancel\" }\nend\n\n\n\n\nreturn core.cluster.constructor(SessionAgent)\n\n",
name = "helm/agent/session",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "35b4f3bf707a34daba8c2d1428c992fe41980c8d50d6f34812bf716a18f51f46",
binary = "\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm:selection_list\"\nlocal names = require \"repr:names\"\nlocal table = core.table\nlocal string = core.string\nlocal insert, sort = assert(table.insert), assert(table.sort)\n\n\n\n\nlocal ResultListAgent = require \"helm:agent/result-list\"\nlocal SuggestAgent = meta(getmetatable(ResultListAgent))\n\n\n\n\n\n\n\n\n\n\n\n\nfunction SuggestAgent.cursorContext(suggest)\n   local lex_tokens = {}\n   -- Ignore whitespace and comments\n   local tokens_from_edit = suggest :send { to = \"agents.edit\",\n                                            method = \"tokens\" }\n   for _, token in ipairs(tokens_from_edit) do\n      if token.color ~= \"no_color\" and token.color ~= \"comment\" then\n         insert(lex_tokens, token)\n      end\n   end\n   -- Find the index of the token containing the cursor\n   local index, context\n   for i, token in ipairs(lex_tokens) do\n      if token.cursor_offset then\n         index = i\n         context = token\n         break\n      end\n   end\n   if not context or context.color ~= \"field\" then\n      -- We\'re in a non-completable token\n      return nil\n   end\n   -- Work backwards from there to determine the dotted path, if any,\n   -- that we are completing within\n   local path = {}\n   local expect_field = false\n   index = index - 1\n   while index > 0 do\n      local path_token = lex_tokens[index]\n      if expect_field then\n         if path_token.color == \"field\" then\n            insert(path, 1, tostring(path_token))\n         else\n            -- If we expected an identifier/field and got something else,\n            -- we\'re likely in a situation like foo[bar].baz, having just\n            -- examined the dot. If the content of the braces is a literal,\n            -- we *could* deal with it anyway, but this is not yet implemented.\n            path = nil\n            break\n         end\n      elseif not tostring(path_token):find(\"^[.:]$\") then\n         -- Expected a . or :, got absolutely anything else, we\'ve finished\n         -- this dotted path.\n         break\n      end\n      expect_field = not expect_field\n      index = index - 1\n   end\n   return context, path\nend\n\n\n\n\n\n\n\n\nlocal function _suggest_sort(a, b)\n   if a.score ~= b.score then\n      return a.score < b.score\n   elseif #a.sym ~= #b.sym then\n      return #a.sym < #b.sym\n   else\n      return a.sym < b.sym\n   end\nend\n\nlocal safeget = assert(table.safeget)\nlocal isidentifier = assert(string.isidentifier)\nlocal hasmetamethod = assert(core.meta.hasmetamethod)\nlocal fuzz_patt = require \"helm:fuzz_patt\"\nlocal Set = core.set\n\nlocal function _candidates_from(complete_against)\n   -- Either no path was provided, or some part of it doesn\'t\n   -- actually exist, fall back to completing against all symbols\n   if complete_against == nil then\n      return names.all_symbols\n   end\n   local count = 0\n   local candidate_symbols = Set()\n   repeat\n      -- Do not invoke any __pairs metamethod the table may have\n      for k, _ in next, complete_against do\n         if type(k) == \'string\' and isidentifier(k) then\n            count = count + 1\n            candidate_symbols[k] = true\n         if count > 500 then\n               return candidate_symbols\n            end\n         end\n      end\n      local index_table = hasmetamethod(\"__index\", complete_against)\n      -- Ignore __index functions, no way to know what they might handle\n      complete_against = type(index_table) == \"table\" and index_table or nil\n   until complete_against == nil\n   return candidate_symbols\nend\n\nlocal function _set_suggestions(suggest, suggestions)\n   suggest.last_collection = suggestions\n   suggest:contentsChanged()\nend\n\n\nfunction SuggestAgent.update(suggest)\n   local context, path = suggest:cursorContext()\n   if context == nil then\n      return _set_suggestions(suggest, nil)\n   end\n\n   -- First, build a list of candidate symbols--those that would be valid\n   -- in the current position.\n   local complete_against\n   if path then\n      complete_against = suggest :send { to = \"valiant\", field = \"eval_env\" }\n      for _, key in ipairs(path) do\n         complete_against = safeget(complete_against, key)\n      end\n      -- If what we end up with isn\'t a table, we can\'t complete against it\n      if type(complete_against) ~= \"table\" then\n         complete_against = nil\n      end\n   end\n   local candidate_symbols = _candidates_from(complete_against)\n\n   -- Now we can actually filter those candidates for whether they match or not\n   local suggestions = SelectionList(tostring(context)\n                                       :sub(1, context.cursor_offset))\n   local match_patt = fuzz_patt(suggestions.frag)\n   local matches = {}\n   for sym in pairs(candidate_symbols) do\n      local score = match_patt:match(sym)\n      if score then\n         insert(matches, { score = score, sym = sym })\n      end\n   end\n   if #matches == 0 then\n      return _set_suggestions(suggest, nil)\n   end\n   sort(matches, _suggest_sort)\n   for _, match in ipairs(matches) do\n      insert(suggestions, match.sym)\n   end\n   _set_suggestions(suggest, suggestions)\nend\n\n\n\n\n\n\n\n\n\n\nfunction SuggestAgent.acceptSelected(agent)\n   local suggestion = agent:selectedItem()\n   agent:quit()\n   if suggestion then\n      agent :send { suggestion,\n                    to = \"agents.edit\",\n                    method = \"replaceToken\" }\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nSuggestAgent.userCancel = SuggestAgent.quit\n\n\n\n\n\n\n\n\n\nfunction SuggestAgent.activateCompletion(agent)\n   if agent.last_collection then\n      agent:selectFirst()\n      agent :send { method = \"pushMode\", \"complete\" }\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction SuggestAgent.acceptAndFallthrough(agent)\n   agent:acceptSelected()\n   return false\nend\nfunction SuggestAgent.quitAndFallthrough(agent)\n   agent:quit()\n   return false\nend\nlocal find = assert(string.find)\nfunction SuggestAgent.acceptOnNonWordChar(agent, event)\n   if find(event.key, \"[^a-zA-Z0-9_]\") then\n      agent:acceptSelected()\n   end\n   return false\nend\n\n\n\n\nreturn core.cluster.constructor(SuggestAgent)\n\n",
name = "helm/agent/suggest",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "628e6f428f4b41c7e679cdfc9d5f07211dabc88761c492ec3596118339772454",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal string = core.string\nlocal math = core.math\nlocal lineGen = assert(require \"repr:repr\" . lineGen)\n\n\n\n\n\n\nlocal Rainbuf = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal lines = assert(string.lines)\nfunction Rainbuf.setExtent(rainbuf, rows, cols)\n   rows = rows or 20\n   cols = cols or 80\n   -- If width is changing, we need a re-render\n   if cols ~= rainbuf.cols then\n      rainbuf:clearCaches()\n   end\n   -- If the number of rows is increasing, may need to adjust our offset\n   -- to avoid blank lines at the bottom. Note that if cols has also changed\n   -- we don\'t know what\'s going on--but rainbuf.more will have also been reset\n   -- so we won\'t try anything\n   if rainbuf.rows and rows > rainbuf.rows and not rainbuf.more then\n      -- #todo actually do the thing\n   end\n   rainbuf.rows = rows\n   rainbuf.cols = cols\nend\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.contentCols(rainbuf)\n   return rainbuf.scrollable and rainbuf.cols - 3 or rainbuf.cols\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clamp = assert(math.clamp)\nfunction Rainbuf.scrollTo(rainbuf, offset, allow_overscroll)\n   if offset < 0 then\n      offset = 0\n   end\n   if offset ~= 0 then\n      -- Try to render the content that will be visible after the scroll\n      rainbuf:composeUpTo(offset + rainbuf.rows)\n      local required_lines_visible = allow_overscroll and 1 or rainbuf.rows\n      local max_offset = clamp(#rainbuf.lines - required_lines_visible, 0)\n      offset = clamp(offset, 0, max_offset)\n   end\n   if offset ~= rainbuf.offset then\n      rainbuf.offset = offset\n      rainbuf:beTouched()\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nfunction Rainbuf.scrollBy(rainbuf, delta, allow_overscroll)\n   return rainbuf:scrollTo(rainbuf.offset + delta, allow_overscroll)\nend\n\n\n\n\n\n\n\n\nfunction Rainbuf.scrollUp(rainbuf, count)\n   count = count or 1\n   return rainbuf:scrollBy(-count)\nend\nfunction Rainbuf.scrollDown(rainbuf, count)\n   count = count or 1\n   return rainbuf:scrollBy(count)\nend\n\nfunction Rainbuf.pageUp(rainbuf)\n   return rainbuf:scrollBy(-rainbuf.rows)\nend\nfunction Rainbuf.pageDown(rainbuf)\n   return rainbuf:scrollBy(rainbuf.rows)\nend\n\nlocal floor = assert(math.floor)\nfunction Rainbuf.halfPageUp(rainbuf)\n   return rainbuf:scrollBy(-floor(rainbuf.rows / 2))\nend\nfunction Rainbuf.halfPageDown(rainbuf)\n   return rainbuf:scrollBy(floor(rainbuf.rows / 2))\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.scrollToTop(rainbuf)\n   return rainbuf:scrollTo(0)\nend\n\nfunction Rainbuf.scrollToBottom(rainbuf, allow_overscroll)\n   rainbuf:composeAll()\n   -- Choose a definitely out-of-range value,\n   -- which scrollTo will clamp appropriately\n   return rainbuf:scrollTo(#rainbuf.lines, allow_overscroll)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.ensureVisible(rainbuf, start_index, end_index)\n   end_index = end_index or start_index\n   local min_offset = clamp(end_index - rainbuf.rows, 0)\n   local max_offset = clamp(start_index - 1, 0)\n   rainbuf:scrollTo(clamp(rainbuf.offset, min_offset, max_offset))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nfunction Rainbuf.composeOneLine(rainbuf)\n   local line = rainbuf:_composeOneLine()\n   if line then\n      insert(rainbuf.lines, line)\n      return true\n   else\n      rainbuf.more = false\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.composeUpTo(rainbuf, line_number)\n   rainbuf:initComposition()\n   while rainbuf.more and #rainbuf.lines <= line_number do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\nfunction Rainbuf.composeAll(rainbuf)\n   rainbuf:initComposition()\n   while rainbuf.more do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.lineGen(rainbuf)\n   rainbuf:initComposition()\n   -- state for iterator\n   local cursor = rainbuf.offset\n   local max_row = rainbuf.offset + rainbuf.rows\n   local function _nextLine()\n      -- Off the end\n      if cursor >= max_row then\n         return nil\n      end\n      cursor = cursor + 1\n      rainbuf:composeUpTo(cursor)\n      local prefix = \"\"\n      if rainbuf.scrollable then\n         -- Use a three-column gutter (which we reserved space for in\n         -- :contentCols()) to display scrolling indicators.\n         -- Up arrows at the top if scrolled down, down arrows at the bottom\n         -- if more is available. Intervening lines get matching left padding\n         if cursor == rainbuf.offset + 1 and rainbuf.offset > 0 then\n            prefix = a.red \"↑↑↑\"\n         elseif cursor == max_row and rainbuf.more then\n            prefix = a.red \"↓↓↓\"\n         else\n            prefix = \"   \"\n         end\n      end\n      return rainbuf.lines[cursor] and prefix .. rainbuf.lines[cursor]\n   end\n   return _nextLine\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.value(rainbuf)\n   local value = rainbuf.source.buffer_value\n   if value == nil then\n      return rainbuf.null_value\n   else\n      return value\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\nfunction Rainbuf.clearCaches(rainbuf)\n   clear(rainbuf.lines)\n   rainbuf.more = true\nend\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.beTouched(rainbuf)\n   rainbuf.touched = true\n   rainbuf:clearCaches()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.checkTouched(rainbuf)\n   if rainbuf.source:checkTouched() then\n      rainbuf:beTouched()\n   end\n   local touched = rainbuf.touched\n   rainbuf.touched = false\n   return touched\nend\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.processQueuedMessages(buf)\n   local had_any = false\n   local msg = buf.source.commands:pop()\n   while msg do\n      buf[msg.method](buf, unpack(msg))\n      had_any = true\n      msg = buf.source.commands:pop()\n   end\n   return had_any\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf._init(rainbuf)\n   rainbuf.offset = 0\n   rainbuf.lines = {}\n   rainbuf.touched = true\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.__call(buf_class, source, cfg)\n   local buf_M = getmetatable(buf_class)\n   local rainbuf = setmetatable({}, buf_M)\n   -- Kinda-hacky detection of something that isn\'t a proper source.\n   -- Wrap it in a dummy table so we can function properly.\n   if not source.checkTouched then\n      source = {\n         buffer_value = source,\n         checkTouched = function() return false end\n      }\n   end\n   rainbuf.source = source\n   rainbuf:_init()\n   for k, v in pairs(cfg or {}) do\n      rainbuf[k] = v\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\n\nRainbuf.is_rainbuf = true\n\n\n\n\nreturn core.cluster.constructor(Rainbuf)\n\n",
name = "helm/buf/rainbuf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "fe2d0492d9a3fdfb6e6cdcb784f07170181cfc36a6880b07d290b07e52047cd8",
binary = "\n\n\n\n\n\n\n\nlocal string = core.string\nlocal lineGen = assert(require \"repr:repr\" . lineGen)\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:buf/rainbuf\"\nlocal Resbuf = meta(getmetatable(Rainbuf))\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\nfunction Resbuf.clearCaches(resbuf)\n   Rainbuf.clearCaches(resbuf)\n   resbuf.reprs = nil\n   resbuf.r_num = nil\nend\n\n\n\n\n\n\n\n\nlocal lines = assert(string.lines)\nfunction Resbuf.initComposition(resbuf)\n   if not resbuf.reprs then\n      resbuf.reprs = {}\n      resbuf.r_num = 1\n      local value = resbuf:value()\n      assert(value.n, \"must have n\")\n      for i = 1, value.n do\n         resbuf.reprs[i] = resbuf.frozen\n            and lines(value[i])\n            or lineGen(value[i], resbuf:contentCols())\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nResbuf.null_value = { n = 0 }\n\nfunction Resbuf._init(resbuf)\n   Rainbuf._init(resbuf)\n   resbuf.frozen = resbuf:value().error\nend\n\n\n\n\n\n\n\n\n\nfunction Resbuf._composeOneLine(resbuf)\n   assert(resbuf.r_num,\n      \"r_num has been niled (missing an :initComposition after :clearCaches?)\")\n   while resbuf.r_num <= #resbuf.reprs do\n      local line = resbuf.reprs[resbuf.r_num]()\n      if line then\n         return line\n      end\n      resbuf.r_num = resbuf.r_num + 1\n   end\n   return nil\nend\n\n\n\n\nreturn core.cluster.constructor(Resbuf)\n\n",
name = "helm/buf/resbuf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "533c2a39960ac6ffd127e5d9ead5a756fc621af59dbccc16158384defcd03f70",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:buf/rainbuf\"\nlocal Resbuf  = require \"helm:buf/resbuf\"\nlocal Txtbuf  = require \"helm:buf/txtbuf\"\n\nlocal Reviewbuf = meta(getmetatable(Rainbuf))\n\nlocal math = core.math\n\n\n\n\n\n\n-- The (maximum) number of rows we will use for the \"line\" (command)\n-- (in case it is many lines long)\nReviewbuf.ROWS_PER_LINE = 4\n-- The (maximum) number of rows we will use for the result of the selected line\nReviewbuf.ROWS_PER_RESULT = 7\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.contentCols(buf)\n   return Rainbuf.contentCols(buf) - 2\nend\n\n\n\n\n\n\n\n\nlocal function _set_resbuf_extent(buf)\n   if buf.resbuf then\n      -- Account for additional padding\n      buf.resbuf:setExtent(buf.ROWS_PER_RESULT, buf:contentCols() - 2)\n   end\nend\n\nlocal function _set_txtbuf_extent(buf, index)\n   if buf.txtbufs[index] then\n      -- As above, but additionally three cells for the icon and space after it\n      buf.txtbufs[index]:setExtent(buf.ROWS_PER_LINE, buf:contentCols() - 5)\n   end\nend\n\nlocal function _resbuf(buf)\n   if not buf.resbuf then\n      buf.resbuf = Resbuf(buf.source.resultsWindow(), { scrollable = true })\n      _set_resbuf_extent(buf)\n   end\n   return buf.resbuf\nend\n\nlocal lua_thor = assert(require \"helm:lex\" . lua_thor)\nlocal function _txtbuf(buf, index)\n   if not buf.txtbufs[index] then\n      buf.txtbufs[index] = Txtbuf(buf.source.editWindow(index), { lex = lua_thor })\n      _set_txtbuf_extent(buf, index)\n   end\n   return buf.txtbufs[index]\nend\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.editAgentRemoved(buf, index)\n   buf.txtbufs[index] = nil\nend\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.setSubExtents(buf)\n   if not (buf.rows and buf.cols) then return end\n   _set_resbuf_extent(buf)\n   -- There\'ll probably never be holes in the txtbufs array, but it doesn\'t\n   -- really matter what order we do this in, so better safe than sorry.\n   for index in pairs(buf.txtbufs) do\n      _set_txtbuf_extent(buf, index)\n   end\nend\n\nfunction Reviewbuf.setExtent(buf, rows, cols)\n   Rainbuf.setExtent(buf, rows, cols)\n   buf:setSubExtents()\nend\n\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.checkTouched(buf)\n   if buf.resbuf and buf.resbuf:checkTouched() then\n      buf:beTouched()\n   end\n   for _, txtbuf in pairs(buf.txtbufs) do\n      if txtbuf:checkTouched() then\n         buf:beTouched()\n      end\n   end\n   return Rainbuf.checkTouched(buf)\nend\n\n\n\n\n\n\n\n\n\n\nlocal clamp = assert(math.clamp)\nfunction Reviewbuf.rowsForSelectedResult(buf)\n   _resbuf(buf):composeUpTo(buf.ROWS_PER_RESULT)\n   return clamp(#_resbuf(buf).lines, 0, buf.ROWS_PER_RESULT)\nend\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\nfunction Reviewbuf.positionOf(buf, index)\n   local position = 1\n   for i = 1, index - 1 do\n      local num_lines = select(2, gsub(buf:value()[i].line, \'\\n\', \'\\n\')) + 1\n      num_lines = clamp(num_lines, 1, buf.ROWS_PER_LINE)\n      position = position + num_lines + 1\n      if i == buf.source.selected_index then\n         position = position + buf:rowsForSelectedResult() + 1\n      end\n   end\n   return position\nend\n\nfunction Reviewbuf.positionOfSelected(buf)\n   return buf:positionOf(buf.source.selected_index)\nend\n\n\n\n\n\n\n\n\nfunction Reviewbuf.ensureSelectedVisible(buf)\n   local start_index = buf:positionOfSelected()\n   local end_index = start_index + buf:rowsForSelectedResult() + 3\n   buf:ensureVisible(start_index, end_index)\nend\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.processQueuedMessages(buf)\n   local had_any = false\n   if buf.resbuf and buf.resbuf:processQueuedMessages() then\n      had_any = true\n   end\n   for _, txtbuf in pairs(buf.txtbufs) do\n      if txtbuf:processQueuedMessages() then\n         had_any = true\n      end\n   end\n   -- Anything from sub-buffers means we need to clear our line cache as well\n   if had_any then\n      buf:clearCaches()\n   end\n   if Rainbuf.processQueuedMessages(buf) then\n      had_any = true\n   end\n   return had_any\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf.clearCaches(buf)\n   Rainbuf.clearCaches(buf)\n   buf._composeOneLine = nil\nend\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\nfunction Reviewbuf.initComposition(buf)\n   buf._composeOneLine = buf._composeOneLine or wrap(\n      function()\n         local success, err = xpcall(function() buf:_composeAll() end,\n                                     debug.traceback)\n         if not success then\n            error(err)\n         end\n      end)\nend\n\n\n\n\n\n\n\n\n\n\nlocal status_icons = {\n   ignore = \"🟡\",\n   accept = \"✅\",\n   reject = \"🚫\",\n   -- iTerm displays the trash-can emoji double-wide,\n   -- but only advances the cursor one cell\n   trash  = \"🗑 \",\n   keep   = \"✅\",\n   insert = \"👉\"\n}\n\nlocal box_light = assert(require \"anterm:box\" . light)\nlocal yield = assert(coroutine.yield)\nlocal c = assert(require \"singletons:color\" . color)\n\nfunction Reviewbuf._composeAll(buf)\n   local function box_line(line_type)\n      return box_light[line_type .. \"Line\"](box_light, buf:contentCols())\n   end\n   for i, premise in ipairs(buf:value()) do\n      yield(box_line(i == 1 and \"top\" or \"spanning\"))\n      -- Render the line (which could actually be multiple physical lines)\n      local line_prefix = status_icons[premise.status] .. \' \'\n      for line in _txtbuf(buf, i):lineGen() do\n         -- Selected premise gets a highlight\n         if i == buf.source.selected_index then\n            line = c.highlight(line)\n         end\n         yield(box_line\"content\" .. line_prefix .. line)\n         line_prefix = \'   \'\n      end\n      -- Selected premise also displays results\n      if i == buf.source.selected_index then\n         yield(box_line\"spanning\")\n         for line in _resbuf(buf):lineGen() do\n            yield(box_line\"content\" .. line)\n         end\n      end\n   end\n   if #buf:value() == 0 then\n      yield(box_line\"top\")\n      yield(box_line\"content\" .. \"No premises to display\")\n   end\n   yield(box_line\"bottom\")\n   buf._composeOneLine = nil\nend\n\n\n\n\n\n\n\n\n\n\nfunction Reviewbuf._init(buf)\n   Rainbuf._init(buf)\n   buf.txtbufs = {}\nend\n\n\n\n\nreturn core.cluster.constructor(Reviewbuf)\n\n",
name = "helm/buf/reviewbuf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "258243aae539598e13a1a3bbdc71258b0dbbcdf895fca7ddea529084fab843a1",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:buf/rainbuf\"\nlocal Stringbuf = meta(getmetatable(Rainbuf))\n\nlocal string = core.string\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Stringbuf.clearCaches(buf)\n   Rainbuf.clearCaches(buf)\n   buf._composeOneLine = nil\nend\n\nlocal lines = assert(string.lines)\nfunction Stringbuf.initComposition(buf)\n   buf._composeOneLine = buf._composeOneLine or lines(buf:value())\nend\n\n\n\n\nreturn core.cluster.constructor(Stringbuf)\n\n",
name = "helm/buf/stringbuf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "ff27ad4a505089c7404a9ece07d96511d5a994b62e4f9802124339b11d5809cb",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:buf/rainbuf\"\nlocal Txtbuf = meta(getmetatable(Rainbuf))\n\n\n\n\n\n\nfunction Txtbuf.clearCaches(txtbuf)\n   Rainbuf.clearCaches(txtbuf)\n   txtbuf.render_row = nil\nend\n\n\n\n\n\n\nfunction Txtbuf.initComposition(txtbuf)\n   txtbuf.render_row = txtbuf.render_row or 1\nend\n\n\n\n\n\n\nlocal c = assert(require \"singletons:color\" . color)\nlocal concat = assert(table.concat)\nfunction Txtbuf._composeOneLine(txtbuf)\n   if txtbuf.render_row > #txtbuf:value() then return nil end\n   local tokens = txtbuf.source.tokens(txtbuf.render_row)\n   local suggestion = txtbuf.suggestions\n      and txtbuf.suggestions:selectedItem()\n   for i, tok in ipairs(tokens) do\n      -- If suggestions are active and one is highlighted,\n      -- display it in grey instead of what the user has typed so far\n      -- Note this only applies once Tab has been pressed, as until then\n      -- :selectedItem() will be nil\n      if suggestion and tok.cursor_offset then\n         tokens[i] = txtbuf.suggestions.highlight(suggestion, txtbuf:contentCols(), c)\n      else\n         tokens[i] = tok:toString(c)\n      end\n   end\n   txtbuf.render_row = txtbuf.render_row + 1\n   return concat(tokens)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.checkTouched(txtbuf)\n   if txtbuf.suggestions and txtbuf.suggestions.touched then\n      txtbuf:beTouched()\n   end\n   return Rainbuf.checkTouched(txtbuf)\nend\n\n\n\n\nreturn core.cluster.constructor(Txtbuf)\n\n",
name = "helm/buf/txtbuf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "065fb21d64a17cd4714df99b717b1c7ba2577a17b10f8e93eac8a97fc1b52c3c",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap(\nparts.set_targets(\"agents.suggest\", parts.list_selection),\nparts.set_targets(\"agents.suggest\", {\n      RETURN          = \"acceptSelected\",\n      ESC             = \"userCancel\",\n      LEFT            = \"acceptAndFallthrough\",\n      PASTE           = \"quitAndFallthrough\",\n      [\"[CHARACTER]\"] = { method = \"acceptOnNonWordChar\", n = 1 }\n}),\nparts.basic_editing,\nparts.global_commands\n)\n\n",
name = "helm/keymap/complete",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "a3244a48ae05e71b0f5fc9ebddd2425db87e2d95b49c0c86e8d282ec15084206",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap(\nparts.set_targets(\"agents.run_review\", {\n   RETURN = \"acceptInsertion\",\n   ESC = \"cancelInsertEditing\",\n   [\"C-q\"] = \"cancelInsertEditing\"\n}),\nparts.set_targets(\"agents.suggest\", {\n   TAB = \"activateCompletion\",\n   [\"S-TAB\"] = \"activateCompletion\"\n}),\nparts.basic_editing,\nparts.global_commands)\n\n",
name = "helm/keymap/edit-line",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "063f9a3f382216c18bed4061be1b44ff2e4cd87a89d7e6b7bb55ca0277a7f6f9",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap(\nparts.set_targets(\"agents.session\", {\n   RETURN = \"acceptTitleUpdate\",\n   TAB = \"acceptTitleUpdate\",\n   ESC = \"cancelTitleEditing\",\n   [\"C-q\"] = \"acceptTitleUpdate\"\n}),\nparts.basic_editing,\nparts.global_commands)\n\n",
name = "helm/keymap/edit-title",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "d317ff990818bec241e53a69fba0c0638cbc0d9be52d2b380f452eba18cead51",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap({\n   ESC = \"cancel\",\n   RETURN = \"acceptDefault\",\n   [\"[CHARACTER]\"] = { method = \"letterShortcut\", n = 1 }\n},\nparts.global_commands\n)\n\n",
name = "helm/keymap/modal",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "639f5b71b7e1ede66af52ed00344802fae6fd45ca74fb337a1e9abdfdd5142cb",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\nreturn Keymap(\n\n\n\n\n\n\n{\n   [\"[CHARACTER]\"] = { to = \"agents.results\", method = \"clearOnFirstKey\" },\n   PASTE           = { to = \"agents.results\", method = \"clearOnFirstKey\" },\n   TAB             = { to = \"agents.suggest\", method = \"activateCompletion\" },\n   [\"S-TAB\"]       = { to = \"agents.suggest\", method = \"activateCompletion\" },\n   [\"/\"]           = { to = \"agents.search\",  method = \"activateOnFirstKey\" },\n   [\"?\"]           = { to = \"modeS\",          method = \"openHelpOnFirstKey\" }\n},\n\n\n\n\n\nparts.set_targets(\"modeS\", {\n   RETURN = \"conditionalEval\",\n   [\"C-RETURN\"] = \"userEval\",\n   [\"S-RETURN\"] = { to = \"\", method = \"nl\" },\n   [\"M-e\"] = \"evalFromCursor\",\n   -- Add aliases for terminals not in CSI u mode\n   [\"C-\\\\\"] = \"userEval\",\n   [\"M-RETURN\"] = { to = \"\", method = \"nl\" }\n}),\n\n\n\n\n\n\n\n{\n   [\"C-b\"] = \"left\",\n   [\"C-f\"] = \"right\",\n   [\"C-n\"] = \"down\",\n   [\"C-p\"] = \"up\",\n   -- #todo sneak this in here, it\'s got nothing\n   -- to do with readline but whatever\n   [\"C-l\"] = \"clear\"\n},\n\n\n\n\n\nparts.basic_editing,\nparts.global_commands,\n\n\n\n\n\nparts.set_targets(\"modeS\", {\n   UP = \"historyBack\",\n   DOWN = \"historyForward\"\n}),\n\n\n\n\n\nparts.set_targets(\"agents.results\", parts.cursor_scrolling)\n\n\n\n)\n\n",
name = "helm/keymap/nerf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "cdcdae032c6fe207ab02d9795592ec970f325a082d2cc0a19a543985d91b8a47",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\nlocal clone = assert(core.table.clone)\nlocal our_bindings = clone(parts.cursor_scrolling)\nfor cmd, shortcuts in pairs{\n   scrollDown     = { \"RETURN\", \"e\", \"j\", \"C-n\", \"C-e\", \"C-j\" },\n   scrollUp       = { \"S-RETURN\", \"y\", \"k\", \"C-y\", \"C-p\", \"C-l\" },\n   pageDown       = { \" \", \"f\", \"C-v\", \"C-f\" },\n   pageUp         = { \"b\", \"C-b\" },\n   halfPageDown   = { \"d\", \"C-d\" },\n   halfPageUp     = { \"u\", \"C-u\" },\n   scrollToBottom = { \"G\", \">\" },\n   scrollToTop    = { \"g\", \"<\" },\n   quit           = { \"q\", \"ESC\" }\n} do\n   for _, shortcut in ipairs(shortcuts) do\n      our_bindings[shortcut] = cmd\n   end\nend\n\n\n\nreturn Keymap(our_bindings, parts.global_commands)\n\n",
name = "helm/keymap/page",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "3f603592833f867efd94f346f9c53ddb8a31c30185251fe6c8536c6fbab27e8f",
binary = "\n\n\n\n\nlocal parts = {}\n\n\n\n\n\n\nparts.cursor_scrolling = {\n   SCROLL_UP   = { method = \"evtScrollUp\",   n = 1 },\n   SCROLL_DOWN = { method = \"evtScrollDown\", n = 1 },\n   UP          = \"scrollUp\",\n   [\"S-UP\"]    = \"scrollUp\",\n   DOWN        = \"scrollDown\",\n   [\"S-DOWN\"]  = \"scrollDown\",\n   PAGE_UP     = \"pageUp\",\n   PAGE_DOWN   = \"pageDown\",\n   HOME        = \"scrollToTop\",\n   END         = \"scrollToBottom\"\n}\n\n\n\n\n\n\n\n\n\n\n\n-- Motions\nparts.basic_editing = {\n   -- Cursor-key motions\n   UP              = \"up\",\n   DOWN            = \"down\",\n   LEFT            = \"left\",\n   RIGHT           = \"right\",\n   HOME            = \"startOfLine\",\n   END             = \"endOfLine\",\n   -- Nerf-specific cursor motions\n   [\"M-LEFT\"]      = \"leftWordAlpha\",\n   [\"M-b\"]         = \"leftWordAlpha\",\n   [\"M-RIGHT\"]     = \"rightWordAlpha\",\n   [\"M-w\"]         = \"rightWordAlpha\",\n   [\"C-a\"]         = \"startOfLine\",\n   [\"C-e\"]         = \"endOfLine\",\n   -- Insertion--probably shared with vril-insert but not vril-normal\n   [\"[CHARACTER]\"] = { method = \"selfInsert\", n = 1 },\n   TAB             = \"tab\",\n   RETURN          = \"nl\",\n   PASTE           = { method = \"evtPaste\", n = 1 },\n   BACKSPACE       = \"killBackward\",\n   DELETE          = \"killForward\",\n   -- Nerf-specific kills\n   [\"M-BACKSPACE\"] = \"killToBeginningOfWord\",\n   [\"M-DELETE\"]    = \"killToEndOfWord\",\n   [\"M-d\"]         = \"killToEndOfWord\",\n   [\"C-k\"]         = \"killToEndOfLine\",\n   [\"C-u\"]         = \"killToBeginningOfLine\",\n   -- Misc editing commands\n   [\"C-t\"]         = \"transposeLetter\",\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparts.list_selection = {\n   TAB = \"selectNextWrap\",\n   DOWN = \"selectNextWrap\",\n   [\"S-DOWN\"] = \"selectNextWrap\",\n   [\"S-TAB\"] = \"selectPreviousWrap\",\n   UP = \"selectPreviousWrap\",\n   [\"S-UP\"] = \"selectPreviousWrap\"\n}\n\n\n\n\n\n\nparts.review_common = {\n   UP = \"selectPreviousWrap\",\n   DOWN = \"selectNextWrap\",\n   TAB = \"toggleSelectedState\",\n   [\"S-TAB\"] = \"reverseToggleSelectedState\",\n   [\"M-UP\"] = \"movePremiseUp\",\n   [\"M-DOWN\"] = \"movePremiseDown\"\n}\n\n\n\n\n\n\n\n\nparts.global_commands = {\n   [\"C-q\"] = { to = \"modeS\", method = \"quitHelm\" }\n}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(core.table.clone)\n\nfunction parts.set_targets(target, bindings)\n   bindings = clone(bindings)\n   for key, action in pairs(bindings) do\n      -- #todo duplicating code in Keymap constructor, should ultimately be\n      -- constructing Messages here but need to think about mutability.\n      if type(action) == \"string\" then\n         action = { method = action, n = 0 }\n      else\n         action = clone(action)\n         action.n = action.n or #action\n      end\n      action.to = action.to or target\n      bindings[key] = action\n   end\n   return bindings\nend\n\n\n\nreturn parts\n\n",
name = "helm/keymap/parts",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "bd089cd4031106ba28f016ceccd06a86c6887fd5fd2c1f3ebe0a494b8205e311",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap(parts.review_common,\n{\n   k = { method = \"setSelectedState\", \"keep\"},\n   n = { method = \"setSelectedState\", \"insert\"},\n   t = { method = \"setSelectedState\", \"trash\"},\n   RETURN = \"editInsertedLine\",\n   [\"C-RETURN\"] = \"evalAndResume\",\n   [\"M-e\"] = \"evalAndResume\"\n},\nparts.set_targets(\"agents.run_review.results_agent\", parts.cursor_scrolling),\nparts.global_commands)\n\n",
name = "helm/keymap/run-review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "531355dcd1f6a2d365bc23d8516c69fcf6e4cb0ffebff6d5f1da9d2c4b95b010",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\nlocal action_bindings = {\n   RETURN = \"acceptSelected\",\n   ESC = \"userCancel\",\n   BACKSPACE = \"quitIfNoSearchTerm\",\n   DELETE = \"quitIfNoSearchTerm\"\n}\nfor i = 1, 9 do\n   action_bindings[\"M-\" .. tostring(i)] = { method = \"acceptFromNumberKey\", n = 1 }\nend\n\n\n\nreturn Keymap(\nparts.set_targets(\"agents.search\", parts.list_selection),\nparts.set_targets(\"agents.search\", action_bindings),\nparts.basic_editing,\nparts.global_commands)\n\n",
name = "helm/keymap/search",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "29c532668f6dfb2650abd9387756564acd1b80627a2e586b04c5504f91229aa5",
binary = "\n\n\nlocal Keymap = require \"helm:keymap\"\nlocal parts = require \"helm:keymap/parts\"\n\n\n\n\nreturn Keymap(parts.review_common,\n{\n   a = { method = \"setSelectedState\", \"accept\"},\n   r = { method = \"setSelectedState\", \"reject\"},\n   i = { method = \"setSelectedState\", \"ignore\"},\n   t = { method = \"setSelectedState\", \"trash\"},\n   RETURN = \"editSelectedTitle\",\n   [\"C-q\"] = \"promptSaveChanges\"\n},\nparts.set_targets(\"agents.session.results_agent\", parts.cursor_scrolling),\nparts.global_commands)\n\n",
name = "helm/keymap/session-review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "7c83e81529cb35262439e91935a6bda0c9e1a601d14e4bde9733163430826a78",
binary = "\n\n\n\n\n\n\n\nlocal a         = require \"anterm:anterm\"\n\nlocal concat         = assert(table.concat)\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\n\n\n\nlocal RagaBase_meta = {}\nlocal RagaBase = setmetatable({}, RagaBase_meta)\n\n\n\n\n\n\nRagaBase.name        = nil                       -- e.g. \"nerf\"\nRagaBase.prompt_char = nil                       -- e.g. \"$\"\nRagaBase.keymap      = nil                       -- e.g. require \"helm:keymap/raga_name\"\nRagaBase.target      = nil                       -- `msg.to` path string, e.g. \"agents.edit\"\nRagaBase.lex         = require \"helm:lex\" . null -- Lexer to use for the command zone\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.getCursorPosition()\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onTxtbufChanged()\n   return\nend\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onCursorChanged()\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onShift()\n   return\nend\n\n\n\n\n\n\n\n\nfunction RagaBase.onUnshift()\n   return\nend\n\n\n\n\nreturn RagaBase\n\n",
name = "helm/raga/base",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "1268be6e5640a61f7e45ccf03b02650eb3fb94b3a1f3c09235452de94ed583b0",
binary = "\n\n\n\n\nlocal table = core.table\nlocal clone, splice = assert(table.clone), assert(table.splice)\nlocal EditBase = require \"helm/raga/edit\"\n\nlocal Complete = clone(EditBase, 2)\n\nComplete.name = \"complete\"\nComplete.prompt_char = \"💬\"\nComplete.keymap = require \"helm:keymap/complete\"\nComplete.lex = require \"helm:lex\" . lua_thor\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Complete.onTxtbufChanged()\n   send { to = \'agents.suggest\', method = \'update\' }\n   if send { to = \'agents.suggest\', field = \'last_collection\' } then\n      send { to = \'agents.suggest\', method = \"selectFirst\" }\n   else\n      send { method = \"popMode\" }\n   end\n   EditBase.onTxtbufChanged()\nend\n\n\n\n\n\n\n\n\n\n\nfunction Complete.onCursorChanged()\n   send { method = \"popMode\" }\n   EditBase.onCursorChanged()\nend\n\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction Complete.getCursorPosition()\n   local point = EditBase.getCursorPosition()\n   local suggestion = send { to = \'agents.suggest\', method = \'selectedItem\' }\n   local tokens = send { to = \'agents.edit\', method = \'tokens\' }\n   if suggestion then\n      for _, tok in ipairs(tokens) do\n         if tok.cursor_offset then\n            point = point + Point(0, #suggestion - tok.cursor_offset)\n            break\n         end\n      end\n   end\n   return point\nend\n\n\n\n\n\n\n\n\nfunction Complete.onShift()\n   send { to = \'agents.suggest\', method = \'selectFirst\' }\nend\n\n\n\n\n\n\n\n\nfunction Complete.onUnshift()\n   send { to = \'agents.suggest\', method = \'selectNone\' }\nend\n\n\n\nreturn Complete\n\n",
name = "helm/raga/complete",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "02b8cdac72e4076e33273d5f4144619c4a976f2eb43efcf12cf9a41cf1624b7a",
binary = "\n\n\n\n\n\n\n\nlocal table = core.table\nlocal clone, splice = assert(table.clone), assert(table.splice)\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal EditLine = clone(EditBase, 2)\nEditLine.name = \"edit_line\"\nEditLine.prompt_char = \"👉\"\nEditLine.keymap = require \"helm:keymap/edit-line\"\nEditLine.lex = require \"helm:lex\" . lua_thor\n\n\n\n\n\n\n\n\nfunction EditLine.onCursorChanged()\n   send { to = \"agents.suggest\", method = \"update\" }\n   EditBase.onCursorChanged()\nend\n\nfunction EditLine.onTxtbufChanged()\n   send { to = \"agents.suggest\", method = \"update\" }\n   EditBase.onTxtbufChanged()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditLine.onShift()\n   send { to = \"zones.suggest\", method = \"show\" }\n   -- #todo this messing directly with the Txtbuf is bad\n   local txtbuf = send { to = \"zones.command\", field = \"contents\" }\n   txtbuf.suggestions = send { to = \"agents.suggest\", method = \"window\" }\nend\n\n\n\n\nreturn EditLine\n\n",
name = "helm/raga/edit-line",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "269de6f23d10c68d29daa7522b4633aa43053ae4c0dbeeca1ef07bce8c4826e3",
binary = "\n\n\n\n\n\n\n\nlocal table = core.table\nlocal clone, splice = assert(table.clone), assert(table.splice)\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal EditTitle = clone(EditBase, 2)\nEditTitle.name = \"edit_title\"\nEditTitle.prompt_char = \"👉\"\nEditTitle.keymap = require \"helm:keymap/edit-title\"\n\nreturn EditTitle\n\n",
name = "helm/raga/edit-title",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "b745a1c37267cceede2438145af4ceaa419ee7a818013f2e8b1fd33cbe3a82ee",
binary = "\n\n\n\n\n\nlocal table = core.table\nlocal clone, insert = assert(table.clone), assert(table.insert)\nlocal RagaBase = require \"helm:helm/raga/base\"\nlocal Txtbuf = require \"helm:buf/txtbuf\"\n\n\n\nlocal EditBase = clone(RagaBase, 2)\nEditBase.target = \"agents.edit\"\n\n\n\n\n\n\n\n\nfunction EditBase.getCursorPosition()\n   local command_origin = send { to = \"zones.command.bounds\", method = \"origin\" }\n   local edit_cursor = send { to = \"agents.edit\", field = \"cursor\" }\n   return command_origin + edit_cursor - 1\nend\n\n\n\n\nreturn EditBase\n\n",
name = "helm/raga/edit",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "22959a7cd9e3e556197a1033af32a0e9885e866793a115fd03171e768bf82985",
binary = "\n\n\n\n\n\nlocal table = core.table\nlocal clone, splice = assert(table.clone), assert(table.splice)\nlocal a = require \"anterm:anterm\"\nlocal RagaBase = require \"helm:raga/base\"\n\n\n\nlocal Modal = clone(RagaBase, 2)\nModal.name = \"modal\"\nModal.prompt_char = \" \"\nModal.keymap = require \"helm:keymap/modal\"\nModal.target = \"agents.modal\"\n\n\n\n\n\n\nfunction Modal.onShift()\n   send { to = \"zones.modal\", method = \"show\" }\nend\n\nfunction Modal.onUnshift()\n   send { to = \"zones.modal\", method = \"hide\" }\nend\n\n\n\nreturn Modal\n\n",
name = "helm/raga/modal",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "696a796b50ff34e5a43b7fe8de57e2fba6269a387aa99058a86955a5c80d61d8",
binary = "\n\n\n\n\nlocal table = core.table\nlocal clone = assert(table.clone)\nlocal RagaBase = require \"helm:raga/base\"\n\n\n\nlocal Page = clone(RagaBase, 2)\n\nPage.name = \"page\"\nPage.prompt_char = \"❓\"\nPage.keymap = require \"helm:keymap/page\"\nPage.target = \"agents.pager\"\n\n\n\n\n\n\n\n\n\nfunction Page.onShift()\n   send { to = \"zones.popup\", method = \"show\" }\nend\nfunction Page.onUnshift()\n   send { to = \"zones.popup\", method = \"hide\" }\nend\n\n\n\nreturn Page\n\n",
name = "helm/raga/page",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "3e0ceb83bee085ea5fce84280b90c1345d065131cd85d7fdbcdc82845b6d6590",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\nlocal table = core.table\nlocal addall, clone, concat, insert, splice = assert(table.addall),\n                                              assert(table.clone),\n                                              assert(table.concat),\n                                              assert(table.insert),\n                                              assert(table.splice)\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\n\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal Nerf = clone(EditBase, 2)\nNerf.name = \"nerf\"\nNerf.prompt_char = \"👉\"\nNerf.keymap = require \"helm:keymap/nerf\"\nNerf.lex = require \"helm:lex\" . lua_thor\n\n\n\n\n\n\n\n\n\nfunction Nerf.onCursorChanged()\n   send { to = \"agents.suggest\", method = \"update\" }\n   EditBase.onCursorChanged()\nend\n\nfunction Nerf.onTxtbufChanged()\n   send { to = \"agents.suggest\", method = \"update\" }\n   EditBase.onTxtbufChanged()\nend\n\n\n\n\n\n\n\n\n\n\nlocal Resbuf = require \"helm:buf/resbuf\"\nfunction Nerf.onShift()\n   EditBase.onShift()\n   -- #todo only if not already a Resbuf?\n   send { method = \"bindZone\",\n      \"results\", \"results\", Resbuf, { scrollable = true }}\n   -- #todo this messing directly with the Txtbuf is bad\n   local txtbuf = send { to = \"zones.command\", field = \"contents\" }\n   txtbuf.suggestions = send { to = \"agents.suggest\", method = \"window\" }\nend\n\n\n\nreturn Nerf\n\n",
name = "helm/raga/nerf",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "9f14b7d728fdf0a462d1ecf708e88ff8a065b8ccc712f88da87524bc28f4838f",
binary = "\n\n\n\n\nlocal clone = assert(core.table.clone)\nlocal RagaBase = require \"helm:raga/base\"\nlocal Reviewbuf = require \"helm:buf/reviewbuf\"\n\n\n\nlocal Review = clone(RagaBase, 2)\n\n\n\n\n\n\n\n\n\n\nfunction Review.onShift()\n   -- Hide the suggestion column so the review interface can occupy\n   -- the full width of the terminal.\n   -- #todo once we are able to switch between REPLing and review\n   -- on the fly, we\'ll need to put this back as appropriate, but I\n   -- think that\'ll come naturally once we have a raga stack.\n   send { to = \"zones.suggest\", method = \"hide\" }\n\n   -- Retrieve the target of the actual concrete raga this is being called for\n   local target = send { to = \"raga\", field = \"target\" }\n\n   -- #todo Replace with detection of if we\'re being\n   -- created for the first time vs. a pop\n   if send { to = \"zones.results.contents\", field = \"idEst\" } ~= Reviewbuf then\n      send { method = \"bindZone\",\n         \"results\", target:gsub(\"^agents.\",\"\"), Reviewbuf, {scrollable = true}}\n   end\nend\n\n\n\nreturn Review\n\n",
name = "helm/raga/review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "252df4c40c97923afc8edf3c57dc3d495de86b128b8ee0bac8073f0433a10e90",
binary = "\n\n\n\n\nlocal clone = assert(core.table.clone)\nlocal Review = require \"helm:raga/review\"\n\n\n\nlocal RunReview = clone(Review, 2)\nRunReview.name = \"run_review\"\nRunReview.prompt_char = \"🟡\"\nRunReview.keymap = require \"helm:keymap/run-review\"\nRunReview.target = \"agents.run_review\"\n\n\n\n\n\n\nfunction RunReview.onShift()\n   -- #todo decide which form to display based on...what? Selection maybe,\n   -- leave nothing selected at first? Gets pretty ugly doing this here\n   -- in that case though...\n   send { to = \"agents.status\", method = \"update\", \"run_review_initial\" }\n\n   Review.onShift()\nend\n\n\n\nreturn RunReview\n\n",
name = "helm/raga/run-review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "5d285754f25234ce3e0612d6698f54d708f991621845cf90185b0932d0da56f0",
binary = "\n\n\n\nlocal table = core.table\nlocal clone, splice = assert(table.clone), assert(table.splice)\nlocal EditBase = require \"helm/raga/edit\"\nlocal Resbuf = require \"helm:buf/resbuf\"\n\nlocal Search = clone(EditBase, 2)\n\nSearch.name = \"search\"\nSearch.prompt_char = \"⁉️\"\nSearch.keymap = require \"helm:keymap/search\"\n\n\n\n\n\n\n\n\nfunction Search.onTxtbufChanged()\n   send { to = \"agents.search\", method = \"update\" }\n   EditBase.onTxtbufChanged()\nend\n\n\n\n\n\n\n\n\n\nfunction Search.onShift()\n   EditBase.onShift()\n   send { to = \"agents.search\", method = \"update\" }\n   -- #todo this messing directly with the Txtbuf is bad\n   local txtbuf = send { to = \"zones.command\", field = \"contents\" }\n   txtbuf.suggestions = send { to = \"agents.search\", method = \"window\" }\n   send { method = \"bindZone\",\n      \"results\", \"search\", Resbuf, { scrollable = true }}\nend\n\n\n\nreturn Search\n\n",
name = "helm/raga/search",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "d874992571729a3fa68fcf201a08f6bc53a26cef2c706d768788b860132d5b5e",
binary = "\n\n\n\n\nlocal clone = assert(core.table.clone)\nlocal Review = require \"helm:raga/review\"\n\n\n\nlocal SessionReview = clone(Review, 2)\nSessionReview.name = \"session_review\"\nSessionReview.prompt_char = \"💬\"\nSessionReview.keymap = require \"helm:keymap/session-review\"\nSessionReview.target = \"agents.session\"\n\n\n\n\n\n\n\n\n\n\nfunction SessionReview.onShift()\n   local session_title = send { to = \"hist.session\", field = \"session_title\" }\n   send { to = \"agents.status\", method = \"update\", \"session_review\", session_title }\n\n   local modal_answer = send { to = \"agents.modal\", method = \"answer\" }\n   if modal_answer then\n      if modal_answer == \"yes\" then\n         send { to = \"hist.session\", method = \"save\" }\n      end\n      if modal_answer ~= \"cancel\" then\n         send { to = \"modeS\", method = \"quitHelm\" }\n      end\n      return\n   end\n\n   local premise = send { to = \"agents.session\", method = \"selectedPremise\" }\n   if not premise then\n      send { to = \"agents.session\", method = \"selectIndex\", 1 }\n      premise = send { to = \"agents.session\", method = \"selectedPremise\" }\n   end\n   send { to = \"agents.edit\", method = \"update\", premise and premise.title}\n\n   Review.onShift()\nend\n\n\n\nreturn SessionReview\n\n",
name = "helm/raga/session-review",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "56ec93fdd6235c4fc1c3889202067af9434e6dd48e52b950358241886bf72194",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L        = require \"lpeg\"\nlocal P, match = L.P, L.match\nlocal Codepoints = require \"singletons/codepoints\"\n\nlocal function fuzz_patt(frag)\n   frag = type(frag) == \"string\" and Codepoints(frag) or frag\n   local patt = P(true)\n   for i = 1 , #frag do\n      local v = frag[i]\n      patt = patt * (P(1) - P(v))^0 * P(v)\n   end\n   return patt\nend\n\nreturn fuzz_patt\n\n",
name = "helm/fuzz_patt",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "17a7319c10b0b5ce7e60f691b08a90f50912b6821c35a6cd330dc1f2b3bce664",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv      = require \"luv\"\n\nlocal bridge = require \"bridge\"\n\nlocal s = require \"status:status\" ()\n\nlocal Session = require \"helm:session\"\nlocal persist_tabulate = require \"repr:persist-tabulate\"\nlocal helm_db = require \"helm:helm-db\"\n\nlocal insert = assert(table.insert)\n\nlocal Deque = require \"deque:deque\"\n\n\n\n\n\n\nlocal Historian = meta {}\nHistorian.HISTORY_LIMIT = 2000\nHistorian.helm_db_home = helm_db.helm_db_home\nHistorian.project = uv.cwd()\n\n\n\n\n\nfunction Historian.createPreparedStatements(historian, helm_db_home)\n   if helm_db_home then\n      historian.helm_db_home = helm_db_home\n   end\n   local stmts = helm_db.historian(historian.helm_db_home)\n   historian.stmts = stmts\n   historian.insert_line = stmts.insert_line\n   historian.insert_repr = stmts.insert_repr\n   historian.insert_result_hash = stmts.insert_result_hash\n   historian.get_results = stmts.get_results\nend\n\n\n\n\n\n\n\n\n\nlocal function sql_insert_errcheck(stmt)\n   local err = stmt:step()\n   stmt:clearbind():reset()\n   if err then\n      error(err)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal math = core.math\nlocal clamp, inbounds = assert(math.clamp), assert(math.inbounds)\n\nfunction Historian.load(historian)\n   local stmts = historian.stmts\n   -- Retrieve project id\n   local proj_val, proj_row = stmts.get_project\n                                      : bind(historian.project)\n                                      : resultset \'i\'\n   if not proj_val then\n      proj_val, proj_row = stmts.insert_project\n                             : bind(historian.project)\n                             : step()\n      -- retry\n      proj_val, proj_row = stmts.get_project\n                                      : bind(historian.project)\n                                      : resultset \'i\'\n      if not proj_val then\n         error \"Could not create project in .bridge\"\n      end\n   end\n   local project_id = proj_val[1][1]\n   historian.project_id = project_id\n\n   -- start the latest run\n   stmts.insert_run_start :bind(project_id) :step()\n   historian.run = { run_id = stmts.lastRowId(), actions = {} }\n\n   -- Retrieve history\n   local number_of_lines = stmts.get_number_of_lines\n                             :bind(project_id):step()[1]\n   if number_of_lines == 0 then\n      return nil\n   end\n   number_of_lines = clamp(number_of_lines, nil, historian.HISTORY_LIMIT)\n   historian.lines_available = number_of_lines\n   local pop_stmt = stmts.get_recent\n                      : bindkv { project = project_id,\n                                 num_lines = number_of_lines }\n   historian.cursor = number_of_lines + 1\n   historian.cursor_start = number_of_lines + 1\n   historian.n = number_of_lines\n   local counter = number_of_lines\n   local idler\n   local function load_one()\n      local res = pop_stmt:step()\n      if not res then\n         if idler then idler:stop() end\n         return nil\n      end\n      historian[counter] = res[2]\n      historian.line_ids[counter] = res[1]\n      -- Results are loaded backwards because that\'s how they\'re accessed\n      counter = counter - 1\n   end\n   -- add one line to ensure we have history on startup\n   load_one()\n   -- idle to populate the rest of the history\n   idler = uv.new_idle()\n   idler:start(load_one)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Historian.loadPreviousRun(historian)\n   local prev_run_id = historian.stmts.get_latest_finished_run\n                                       :bind(historian.project_id)\n                                       :value()\n   local run = {}\n   for _, line_id, line in historian.stmts.get_lines_of_run:bind(prev_run_id):cols() do\n      insert(run, {\n         status = \"keep\",\n         line = line,\n         line_id = line_id,\n         old_result = historian:resultsFor(line_id)\n      })\n   end\n   historian.previous_run = run\nend\n\n\n\n\n\n\n\n\nfunction Historian.loadRecentLines(historian, num_lines)\n   local deque = require \"deque:deque\" ()\n   -- we could duplicate this information off the historian array, if we\n   -- had the patience to wait around for it to populate.\n   --\n   -- We probably should do it that way, actually, but there\'s too much\n   -- handwaving about how runs interact with history already, and this\n   -- works, as blocking code tends to, with minimum fuss.\n   if num_lines > historian.lines_retrieved then\n      s:warn(\"Requested %d lines to rerun, only %d lines available\")\n      num_lines = historian.lines_retrieved\n   end\n   local get_lines = historian.stmts.get_recent\n                : bindkv { project = historian.project_id,\n                           num_lines = num_lines }\n   for _, __, line in get_lines:cols() do\n      deque:push(line)\n   end\n   deque:reverse()\n   return deque\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Historian.loadOrCreateSession(historian, session_title)\n   historian.session = Session(historian.helm_db_home,\n                        historian.project_id,\n                        session_title)\nend\n\n\n\n\n\n\n\n\n\n\nlocal db_result_M = assert(persist_tabulate.db_result_M)\n\nlocal function _wrapResults(results_tostring)\n   local wrapped = { n = #results_tostring }\n   for i = 1, wrapped.n do\n      -- stick the actual string in a table with an __repr that reconstitutes\n      -- the object tree from tokens\n      wrapped[i] = setmetatable({results_tostring[i]}, db_result_M)\n   end\n   return wrapped\nend\n\nfunction Historian.resultsFor(historian, line_id)\n   if historian.result_buffer[line_id] then\n      return historian.result_buffer[line_id]\n   end\n   local stmt = historian.get_results\n   stmt:bindkv {line_id = line_id}\n   local results = stmt :resultset \'i\'\n   if results then\n      results = _wrapResults(results[1])\n   end\n   stmt:reset()\n   -- may as well memoize the database call, while we\'re here\n   historian.result_buffer[line_id] = results\n   return results\nend\n\n\n\n\n\n\n\n\nlocal tabulate_some = assert(persist_tabulate.tabulate_some)\nlocal sha = assert(require \"util:sha\" . shorthash)\nlocal blob = assert(assert(sql, \"sql must be in bridge _G\").blob)\nfunction Historian.persist(historian, line, results)\n   if type(results) ~= \"table\" or results.n == 0 then\n      results = nil\n   end\n   if line == \"\" then\n      -- A blank line can have no results and is uninteresting.\n      return false\n   end\n\n   -- Persist the line of input itself\n   sql_insert_errcheck(\n      historian.insert_line:bindkv { project = historian.project_id,\n                                     line    = blob(line) })\n   local line_id = historian.stmts.lastRowId()\n   historian.result_buffer[line_id] = results\n\n   -- Then the run action indicating it was just evaluated\n   local run_action = { run_id  = historian.run.run_id,\n                        ordinal = #historian.run.actions + 1,\n                        input   = line_id }\n   insert(historian.run.actions, run_action)\n   sql_insert_errcheck(historian.stmts.insert_run_input:bindkv(run_action))\n\n   -- If there are no results, nothing more to persist,\n   -- release our savepoint and don\'t bother starting the idler\n   if not results then\n      return line_id\n   end\n\n   local queue = historian.result_queue\n   local persist_cb = tabulate_some(results)\n   historian.idler = historian.idler or uv.new_idle()\n   local empty = #queue == 0\n   queue:push(pack(persist_cb, line_id, results.n))\n   if empty then\n      historian.idler:start(function()\n         local cb, line_id, n = unpack(queue:peek())\n         local done, results_tostring = cb()\n         if not done then return nil end\n         queue:pop()\n         -- now persist\n         for i = 1, n do\n            local hash = sha(results_tostring[i])\n            sql_insert_errcheck(historian.insert_repr:bind(hash, results_tostring[i]))\n            sql_insert_errcheck(historian.insert_result_hash:bind(line_id, hash))\n         end\n         -- inform the Session that persisted results are available\n         -- #todo this *so badly* needs to be an Action\n         -- Should probably also be called \'resultsPersisted\' since the\n         -- live results are available immediately. We might also want to\n         -- cache the stringified/persisted results alongside the live ones\n         if historian.session then\n            historian.session:resultsAvailable(line_id,\n               _wrapResults(results_tostring))\n         end\n         if #queue == 0 then\n            historian.idler:stop()\n         end\n      end)\n   end\n   return line_id\nend\n\n\n\n\n\n\n\n\nfunction Historian.idling(hist)\n   if #hist.result_queue > 0 then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Historian.append(historian, line, results, success)\n   if line == \"\" then\n      -- don\'t bother\n      return false\n   end\n   if not success then results = nil end\n   local line_id = historian:persist(line, results)\n   historian.n = historian.n + 1\n   historian[historian.n] = line\n   historian.line_ids[historian.n] = line_id\n   -- #todo this should be an Action--actually we should be in a handler for\n   -- one action (e.g. \'evalCompleted\') and issue another (e.g. \'lineStored\')\n   if historian.session then\n      historian.session:append(line_id, line, results)\n   end\n   return true\nend\n\n\n\n\n\n\n\n\nlocal tabulate = persist_tabulate.tabulate\n\nfunction Historian.appendNow(historian, line, results, success)\n   if line == \"\" then\n      -- don\'t bother\n      return false\n   end\n   if (not success) or results.n == 0 then\n      -- we /should/ handle errors here\n      results = nil\n   end\n\n   -- Persist the line of input itself\n   sql_insert_errcheck(\n      historian.insert_line:bindkv { project = historian.project_id,\n                                     line    = blob(line) })\n   local line_id = historian.stmts.lastRowId()\n   historian.result_buffer[line_id] = results\n\n   -- Then the run action indicating it was just evaluated\n   local run_action = { run_id  = historian.run.run_id,\n                        ordinal = #historian.run.actions + 1,\n                        input   = line_id }\n   insert(historian.run.actions, run_action)\n   sql_insert_errcheck(historian.stmts.insert_run_input:bindkv(run_action))\n\n   -- If there are no results, nothing more to persist,\n   -- release our savepoint and don\'t bother starting the idler\n   if not results then\n      return line_id\n   end\n\n   local results_tostring = tabulate(results)\n   for i = 1, results.n do\n      local hash = sha(results_tostring[i])\n      sql_insert_errcheck(historian.insert_repr:bind(hash, results_tostring[i]))\n      sql_insert_errcheck(historian.insert_result_hash:bind(line_id, hash))\n   end\n   -- inform the Session that persisted results are available\n   -- #todo this *so badly* needs to be an Action\n   -- Should probably also be called \'resultsPersisted\' since the\n   -- live results are available immediately. We might also want to\n   -- cache the stringified/persisted results alongside the live ones\n   if historian.session then\n      historian.session:resultsAvailable(line_id,\n         _wrapResults(results_tostring))\n   end\n\n   return line_id\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm/selection_list\"\nlocal fuzz_patt = require \"helm:helm/fuzz_patt\"\n\nfunction Historian.search(historian, frag)\n   if frag == \"\" then\n      return nil\n   end\n   local result = SelectionList(frag, { show_shortcuts = true, cursors = {}})\n   local function try_search()\n      local patt = fuzz_patt(result.frag)\n      local dup = {}\n      for i = historian.n, 1, -1 do\n         local item_str = tostring(historian[i])\n         if not dup[item_str] and patt:match(item_str) then\n            dup[item_str] = true\n            insert(result, item_str)\n            insert(result.cursors, i)\n         end\n      end\n   end\n   try_search()\n   if #result == 0 then\n      result.best = false\n      result.frag = frag:sub(1, -3) .. frag:sub(-1, -1) .. frag:sub(-2, -2)\n      try_search()\n   end\n   return result\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _setCursor(historian, cursor)\n   historian.cursor = cursor\n   local line = historian[cursor]\n   if not line then\n      return nil, nil\n   end\n   local line_id = historian.line_ids[cursor]\n   return line, historian:resultsFor(line_id)\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.delta(historian, delta)\n   return _setCursor(historian,\n                     clamp(historian.cursor + delta, 1, historian.n + 1))\nend\n\nfunction Historian.prev(historian)\n   return historian:delta(-1)\nend\nfunction Historian.next(historian)\n   return historian:delta(1)\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.index(historian, cursor)\n   assert(inbounds(cursor, 1, historian.n))\n   return _setCursor(historian, cursor)\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.atEnd(historian)\n   return historian.cursor > historian.n\nend\n\nfunction Historian.toEnd(historian)\n   historian.cursor = historian.n + 1\nend\n\n\n\n\n\n\n\n\n\n\nfunction Historian.close(historian)\n   historian.stmts.insert_run_finish :bind(historian.run.run_id) :step()\n   if historian.idler then\n      historian.idler:close()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __result_buffer_M = meta {}\nfunction __result_buffer_M.__repr(buf, window, c)\n   return c.alert \"cowardly refusing to print result_buffer to avoid infinite appending\"\nend\n\nlocal function new(helm_db)\n   s.verbose = true\n   local historian = setmetatable({}, Historian)\n   historian.line_ids = {}\n   historian.cursor = 0\n   historian.cursor_start = 0\n   historian.n = 0\n   historian.lines_available = 0\n   historian.result_queue = Deque()\n   historian.result_buffer = setmetatable({}, __result_buffer_M)\n\n   historian:createPreparedStatements(helm_db)\n   historian:load()\n   s.verbose = false\n   return historian\nend\n\nHistorian.idEst = new\n\n\n\nreturn new\n\n",
name = "helm/historian",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "a079e85f74f04370a552ffca994fa6ff75de0767c0ffb7588355d469199b0082",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"cluster:cluster\"\nlocal input_event = require \"anterm:input-event\"\nlocal Message = require \"actor:message\"\n\nlocal clone = assert(core.table.clone)\n\n\n\n\n\n\nlocal new, Keymap, Keymap_M = cluster.genus()\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function is_wildcard_match(wc_evt, evt)\n   if wc_evt.modifiers ~= evt.modifiers then\n      return false\n   end\n   if evt.type == \"keypress\" then\n      local special = input_event.is_special_key(evt.key)\n      if wc_evt.key == \"[CHARACTER]\" and not special\n      or wc_evt.key == \"[SPECIAL]\" and special then\n         return true\n      end\n   end\n   if wc_evt.key == \"[MOUSE]\" and evt.type == \"mouse\" then\n      return true\n   end\n   return false\nend\n\nfunction Keymap_M.__call(keymap, event)\n   local event_string = input_event.serialize(event)\n   local handlers = clone(keymap.bindings[event_string] or {})\n   for _, wc_dict in ipairs(keymap.wildcards) do\n      if is_wildcard_match(wc_dict.pattern, event) then\n         insert(handlers, wc_dict.action)\n      end\n   end\n   return handlers\nend\n\n\n\n\n\n\ncluster.construct(new, function(_, I, ...)\n   I.bindings = {}\n   I.wildcards = {}\n   local declarations = pack(...)\n   for _, decl in ipairs(declarations) do\n      for key, action in pairs(decl) do\n         -- if idest(action, Message) then\n         --    -- #todo be more accomodating here maybe?\n         --    assert(action.to, \"Messages are immutable, specify your `to` ahead of time if you use them.\")\n         if type(action) == \"string\" then\n            -- no arguments to commands specified as just a string\n            action = { method = action, n = 0 }\n         else\n            action = clone(action)\n            -- #todo should convert to Message, mold() would do this for us\n            action.n = action.n or #action\n         end\n         -- #todo but the action ends up being mutated as part of dispatching it,\n         -- so converting to Message makes it blow up.\n         -- action = Message(action)\n         local key_evt = input_event.marshal(key)\n         assert(key_evt, \"Failed to parse event string: \'%s\'\", key)\n         if key_evt.type == \"wildcard\" then\n            insert(I.wildcards, { pattern = key_evt, action = action })\n         else\n            I.bindings[key] = I.bindings[key] or {}\n            insert(I.bindings[key], action)\n         end\n      end\n   end\n   return I\nend)\n\n\n\n\nreturn new\n\n",
name = "helm/keymap",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "a513a845280e96277e0be279bf305a3c8938dc85227e85a76e3b6d2f94e6501f",
binary = "\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\nlocal Lex = {}\n\nlocal core = require \"qor:core\"\nlocal math = core.math\nlocal sub, gsub = assert(string.sub), assert(string.gsub)\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\n\n\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal keyword = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal operator = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\'\\\"[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (-digit * -terminal * P(1))^1\n               * (-terminal * P(1))^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)^1\n\nlocal lua_toks = {comment, keyword, string_long, string_short, number, operator, symbol,\n                  WS, NL, ERR}\n\nlocal color_map = {\n   [keyword] = \"keyword\",\n   [operator] = \"operator\",\n   [number] = \"number\",\n   [symbol] = \"field\",\n   [string_short] = \"string\",\n   [string_long] = \"string\",\n   [comment] = \"comment\",\n   [ERR] = \"error\",\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function chomp_token(lb, start_pos)\n   for _,v in ipairs(lua_toks) do\n      local end_pos = match(v, lb, start_pos)\n      if end_pos ~= nil then\n         return sub(lb, start_pos, end_pos - 1), end_pos, v\n      end\n   end\n   return nil\nend\n\nlocal Token = require \"repr:token\"\nlocal inbounds = assert(math.inbounds)\nlocal instanceof = assert(core.meta.instanceof)\nlocal Txtbuf = require \"helm:buf/txtbuf\"\n\nfunction Lex.lua_thor(code, cursor_index)\n   local toks = {}\n   cursor_index = cursor_index or 0\n   local fixup_cursor = false\n   local pos = 1\n   while pos <= #code do\n      local bite, new_pos, tok_t = chomp_token(code, pos)\n      assert(bite and #bite > 0, \"lua-thor has failed you\")\n      local cfg = { color = color_map[tok_t] or \"no_color\" }\n      if inbounds(cursor_index, pos + 1, new_pos) then\n         -- The cursor should not be considered to be \"within\" a punctuation\n         -- or whitespace token, but rather should be part of the subsequent\n         -- identifier if any, or if not, we will create an empty one\n         if bite:find(\"^[.:]$\")\n            or (bite:find(\"^ +$\") and tostring(toks[#toks]):find(\"^[.:]$\")) then\n            fixup_cursor = true\n         else\n            cfg.cursor_offset = cursor_index - pos\n         end\n      elseif fixup_cursor then\n         fixup_cursor = false\n         if cfg.color ~= \"field\" then\n            insert(toks, Token(\"\", { color = \"field\", cursor_offset = 0 }))\n         else\n            cfg.cursor_offset = 0\n         end\n      end\n      -- Would love to highlight escape sequences in strings,\n      -- but this turns out to be rather difficult...\n      insert(toks, Token(bite, cfg))\n      pos = new_pos\n   end\n   if fixup_cursor then\n      insert(toks, Token(\"\", { color = \"field\", cursor_offset = 0 }))\n   end\n   return toks\nend\n\n\n\n\n\n\nfunction Lex.colorize(str, c)\n   local toks = Lex.lua_thor(str)\n   c = c or require \"singletons:color\" . color\n   for i = 1, #toks do\n      toks[i] = toks[i]:toString(c)\n   end\n   return concat(toks)\nend\n\n\n\n\n\n\n\n\nfunction Lex.null(code, cursor_index)\n   return { Token(code, { color = \"no_color\", cursor_offset = cursor_index - 1 }) }\nend\n\n\n\nreturn Lex\n\n",
name = "helm/lex",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "c493dbd663f0a05748e625bbc3aa0504c194a5f8d53b3b7b60b5d1e6c2f2d2c0",
binary = "\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\nlocal bridge = require \"bridge\"\nlocal Arcivist = require \"sqlun:arcivist\"\n\n\n\n\n\n\nlocal helm_db = {}\n\n\n\n\n\n\nlocal helm_db_home =  (os.getenv \'HELM_HOME\'\n                      or bridge.bridge_home) .. \"/helm/helm.sqlite\"\nhelm_db.helm_db_home = helm_db_home\n\n\n\n\n\n\n\n\n\n\n\nlocal _conns = setmetatable({}, { __mode = \'v\' })\n\n\n\n\n\n\n\n\n\n\n\nlocal function _resolveConn(conn)\n   if conn then\n      if type(conn) == \'string\' then\n         return _conns[conn]\n      else\n         return conn\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\nlocal function _openConn(conn_handle)\n   if not conn_handle then\n      conn_handle = helm_db_home\n   end\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn = helm_db.boot(conn_handle)\n   end\n   assert(conn, \"no conn! \" .. conn_handle)\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_project_table_3 = [[\nCREATE TABLE IF NOT EXISTS project_3 (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\'))\n);\n]]\n\n\n\n\nlocal create_repl_table_3 = [[\nCREATE TABLE IF NOT EXISTS repl_3 (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_result_table = [[\nCREATE TABLE IF NOT EXISTS result (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   line_id INTEGER,\n   repr text NOT NULL,\n   value blob,\n   FOREIGN KEY (line_id)\n      REFERENCES repl (line_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_session_table_4 = [[\nCREATE TABLE IF NOT EXISTS session (\n   session_id INTEGER PRIMARY KEY,\n   title TEXT,\n   project INTEGER,\n   accepted INTEGER NOT NULL DEFAULT 0 CHECK (accepted = 0 or accepted = 1),\n   vc_hash TEXT,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_premise_table = [[\nCREATE TABLE IF NOT EXISTS premise (\n   session INTEGER NOT NULL,\n   line INTEGER NOT NULL,\n   -- ordinal is 1-indexed for Lua compatibility\n   -- \"ordinal\" not \"order\" because SQL\n   ordinal INTEGER NOT NULL CHECK (ordinal > 0),\n   title TEXT,\n   status STRING NOT NULL CHECK (\n      status = \'accept\' or status = \'reject\' or status = \'ignore\' ),\n   PRIMARY KEY (session, ordinal) ON CONFLICT REPLACE\n   FOREIGN KEY (session)\n      REFERENCES session (session_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (line)\n      REFERENCES repl (line_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\nlocal create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n]]\n\nlocal create_session_table = [[\nCREATE TABLE IF NOT EXISTS session (\nsession_id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT,\nproject INTEGER,\n-- These two are line_ids\nstart INTEGER NOT NULL,\nend INTEGER,\ntest BOOLEAN,\nsha TEXT,\nFOREIGN KEY (project)\n   REFERENCES project (project_id)\n   ON DELETE CASCADE );\n]]\n\nlocal create_repl_table = [[\nCREATE TABLE IF NOT EXISTS repl (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhelm_db.HELM_DB_VERSION = 3\n\nlocal migrations = {function() return true end}\nhelm_db.migrations = migrations\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal migration_2 = {\n   create_project_table,\n   create_result_table,\n   create_repl_table,\n   create_session_table\n}\n\ninsert(migrations, migration_2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_3 = {}\n\n\nmigration_3[1] = [[\nUPDATE project\nSET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n]]\n\n\nmigration_3[2] = create_project_table_3\n\n\nmigration_3[3] = [[\nINSERT INTO project_3 (project_id, directory, time)\nSELECT project_id, directory, time\nFROM project;\n]]\n\nmigration_3[4] = [[\nDROP TABLE project;\n]]\n\nmigration_3[5] = [[\nALTER TABLE project_3\nRENAME TO project;\n]]\n\nmigration_3[6] = [[\nUPDATE repl\nSET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n]]\n\n\nmigration_3[7] = create_repl_table_3\n\n\nmigration_3[8] = [[\nINSERT INTO repl_3 (line_id, project, line, time)\nSELECT line_id, project, line, time\nFROM repl;\n]]\n\nmigration_3[8] = [[\nDROP TABLE repl;\n]]\n\nmigration_3[9] = [[\nALTER TABLE repl_3\nRENAME to repl;\n]]\n\n\ninsert(migrations, migration_3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_4 = {}\n\n\nmigration_4[1] = [[\nDROP TABLE session;\n]]\n\n\ninsert(migration_4, create_session_table_4)\ninsert(migration_4, create_premise_table)\n\ninsert(migrations, migration_4)\n\n\n\n\n\n\n\n\nlocal migration_5 = {}\ninsert(migrations, migration_5)\n\n\n\n\n\n\n\n\n\n\n\n\nmigration_5[1] = [[\nALTER TABLE repl RENAME TO input;\n]]\n\n\n\nmigration_5[2] = [[\nCREATE INDEX idx_input_time ON input (time);\n]]\n\n\n\n\n\n\n\nlocal create_session_table_5 = [[\nCREATE TABLE IF NOT EXISTS session_5 (\n   session_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   title TEXT,\n   project INTEGER,\n   accepted INTEGER NOT NULL DEFAULT 0 CHECK (accepted = 0 or accepted = 1),\n   vc_hash TEXT,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\nmigration_5[3] = create_session_table_5\n\n\nmigration_5[4] = [[\nINSERT INTO session_5(title, project, accepted, vc_hash)\nSELECT title, project, accepted, vc_hash FROM session\n;\n]]\n\nmigration_5[5] = [[\nDROP TABLE session;\n]]\n\nmigration_5[6] = [[\nALTER TABLE session_5 RENAME TO session;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_result_table_5 = [[\nCREATE TABLE IF NOT EXISTS result_5 (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   line_id INTEGER,\n   hash text NOT NULL,\n   FOREIGN KEY (line_id)\n      REFERENCES input (line_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (hash)\n      REFERENCES repr (hash)\n);\n]]\n\n\n\n\n\n\n\n\n\n\nlocal create_repr_table = [[\nCREATE TABLE IF NOT EXISTS repr (\n   hash TEXT PRIMARY KEY ON CONFLICT IGNORE,\n   repr BLOB\n);\n]]\n\n\n\nlocal create_repr_hash_idx = [[\nCREATE INDEX repr_hash_idx ON repr (hash);\n]]\n\n\n\n\n\nmigration_5[7] = create_result_table_5\nmigration_5[8] = create_repr_table\nmigration_5[9] = create_repr_hash_idx\n\n\n\n\n\n\n\n\n\nlocal get_old_result_5 = [[\nSELECT result_id, line_id, repr\nFROM result\nORDER BY result_id\n;\n]]\n\n\n\nlocal insert_new_result_5 = [[\nINSERT INTO result_5 (result_id, line_id, hash) VALUES (?, ?, ?);\n]]\n\n\n\nlocal insert_repr_5 = [[\nINSERT INTO repr (hash, repr) VALUES (?, ?);\n]]\n\n\n\n\n\nlocal drop_result_5 = [[\nDROP TABLE result;\n]]\n\nlocal rename_result_5 = [[\nALTER TABLE result_5 RENAME TO result;\n]]\n\n\n\n\n\n\nlocal TRUNCATE_AT = 1048576 * 4 -- 4 MiB is long enough for one repr...\n\nlocal function _truncate_repr(repr)\n   local idx = TRUNCATE_AT\n   if repr:sub(1, 1) == \"\\x01\" then\n      -- If this is a tokenized-format repr, look for the start of\n      -- the next token after the 4MB mark, and stop just before it.\n      -- Theoretically there might not be any such, if the repr is just\n      -- barely over 4MB, in which case we keep the whole thing.\n      idx = repr:find(\"\\x01\", idx, true)\n      if idx then\n         idx = idx - 1\n      end\n   end\n   return repr:sub(1, idx)\nend\n\nmigration_5[10] = function (conn, s)\n   local sha = require \"util:sha\" . shorthash\n   local insert_result = conn:prepare(insert_new_result_5)\n   local insert_repr = conn:prepare(insert_repr_5)\n   s:chat \"Hashing results, this may take awhile...\"\n   local truncated = 0\n   for _, result_id, line_id, repr in conn:prepare(get_old_result_5):cols() do\n      ---[[\n      if #repr > TRUNCATE_AT then\n         s:verb(\"Found a %.2f MiB result!\", #repr / 1048576)\n         truncated = truncated + 1\n         repr = _truncate_repr(repr)\n      end\n      --]]\n      local hash = sha(repr)\n      insert_result :bind(result_id, line_id, hash)\n                    :step()\n      insert_result :clearbind() :reset()\n      insert_repr :bind(hash, repr) :step()\n      insert_repr :clearbind() :reset()\n   end\n   s:chat(\"Truncated %d results\", truncated)\n   s:verb(drop_result_5)\n   s:verb(rename_result_5)\n   conn:exec(drop_result_5)\n   conn:exec(rename_result_5)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_6 = {}\n\ninsert(migrations, migration_6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_table = [[\nCREATE TABLE IF NOT EXISTS run (\n   run_id INTEGER PRIMARY KEY,\n   project INTEGER NOT NULL,\n   start_time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   finish_time DATETIME,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\nlocal create_run_attr_table = [[\nCREATE TABLE IF NOT EXISTS run_attr (\n   run_attr_id INTEGER PRIMARY KEY,\n   run INTEGER,\n   key TEXT,\n   value BLOB,\n   FOREIGN KEY (run)\n      REFERENCES run (run_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_action_table = [[\nCREATE TABLE IF NOT EXISTS run_action (\n   ordinal INTEGER,\n   class TEXT CHECK (length(class) <= 3),\n   input INTEGER,\n   run INTEGER,\n   PRIMARY KEY (run, ordinal) -- ON CONFLICT ABORT?\n   FOREIGN KEY (run)\n      REFERENCES run (run_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (input)\n      REFERENCES input (line_id)\n);\n]]\n\nlocal create_action_attr_table = [[\nCREATE TABLE IF NOT EXISTS action_attr (\n   action_attr_id PRIMARY KEY,\n   run_action INTEGER,\n   key TEXT,\n   value BLOB,\n   FOREIGN KEY (run_action)\n      REFERENCES run_action (run_action_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\nlocal create_error_string_table = [[\nCREATE TABLE IF NOT EXISTS error_string (\n   error_id INTEGER PRIMARY KEY,\n   string TEXT UNIQUE ON CONFLICT IGNORE\n);\n]]\n\n\n\nlocal create_error_string_idx = [[\nCREATE INDEX idx_error_string ON error_string (string);\n]]\n\n\n\n\ninsert(migration_6, create_run_table)\ninsert(migration_6, create_run_attr_table)\ninsert(migration_6, create_run_action_table)\ninsert(migration_6, create_action_attr_table)\ninsert(migration_6, create_error_string_table)\ninsert(migration_6, create_error_string_idx)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_line_table_7 = [[\nCREATE TABLE line (\n   line_id INTEGER PRIMARY KEY,\n   string TEXT UNIQUE NOT NULL,\n   hash TEXT,\n);\n\nCREATE INDEX line_text_id ON line (string);\nCREATE INDEX line_hash_id ON line (hash);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_round_table_7 = [[\nCREATE TABLE round(\n   round_id INTEGER PRIMARY KEY,\n   line INTEGER NOT NULL,\n   response INTEGER NOT NULL,\n   FOREIGN KEY (line)\n      REFERENCES line (line_id)\n   FOREIGN KEY (response)\n      REFERENCES response (response_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_input_table_7 = [[\nCREATE TABLE input_copy(\n   input_id INTEGER PRIMARY KEY,\n   project INTEGER,\n   round INTEGER NOT NULL,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE SET NULL\n   FOREIGN KEY (round)\n      REFERENCES round (round_id)\n)\n-- realistically we should rename this first yeah?\nCREATE INDEX idx_input_time ON input_copy (time) DESC;\n]]\n\n\n\n\n\n\n\n\n\nlocal create_response_table_7 = [[\nCREATE TABLE response(\n   response_id INTEGER PRIMARY KEY\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_result_table_7 = [[\nCREATE TABLE IF NOT EXISTS result_copy (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   response INTEGER NOT NULL,\n   hash TEXT NOT NULL,\n   FOREIGN KEY (response)\n      REFERENCES response (response_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (hash)\n      REFERENCES repr (hash)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_repr_table_7 = [[\nCREATE TABLE repr_copy (\n   hash TEXT PRIMARY KEY ON CONFLICT IGNORE,\n   repr BLOB\n);\n]]\n\n\n\n\n\n\nlocal create_riff_table_7 = [[\nCREATE TABLE riff (\n   riff_id INTEGER PRIMARY KEY,\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_riff_round_table_7 = [[\nCREATE TABLE riff_round(\n   riff_round_id INTEGER PRIMARY KEY,\n   riff INTEGER NOT NULL,\n   ordinal INTEGER NOT NULL CHECK (order > 0),\n   round INTEGER NOT NULL\n   FOREIGN KEY (riff)\n      REFERENCES riff (riff_id)\n   FOREIGN KEY (round)\n      REFERENCES round (round_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_table_7 = [[\nCREATE TABLE run_copy (\n   run_id INTEGER PRIMARY KEY,\n   project INTEGER NOT NULL,\n   start_time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   finish_time DATETIME,\n   -- these are the same unless we are in this run or the run crashed\n   current_riff INTEGER,\n   riff INTEGER,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (riff)\n      REFERENCES riff (riff_id)\n   FOREIGN KEY (current_riff)\n      REFERENCES riff (riff_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_action_table_7 = [[\nCREATE TABLE run_action_copy (\n   ordinal INTEGER NOT NULL,\n   class TEXT CHECK (length(class) <= 3),\n   input INTEGER,\n   run INTEGER NOT NULL,\n   fact LUATEXT,\n   PRIMARY KEY (run, ordinal) -- ON CONFLICT ABORT?\n   FOREIGN KEY (run)\n      REFERENCES run (run_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (input_round)\n      REFERENCES input_round (input_round_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_error_text_table_7 = [[\nCREATE TABLE error_text (\n   error_line_id INTEGER PRIMARY KEY,\n   error TEXT UNIQUE NOT NULL,\n   hash TEXT NOT NULL -- trust me, SQLite: it\'s UNIQUE\n); -- index me\n]]\n\nlocal create_error_table_7 = [[\nCREATE TABLE error(\n   error_id INTEGER PRIMARY KEY,\n   response INTEGER, -- NOT NULL? maybe\n   short INTEGER,\n   error INTEGER NOT NULL,\n   FOREIGN KEY response\n      REFERENCES response (response_id)\n   FOREIGN KEY error_text\n      REFERENCES error_text (error_text_id)\n   FOREIGN KEY short\n      REFERENCES error_text(error_text_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_other_response_table_7 = [[\nCREATE TABLE other_response(\n   other_response_id INTEGER PRIMARY KEY,\n   response INTEGER NOT NULL,\n   category TEXT NOT NULL,\n   FOREIGN KEY response\n      REFERENCES response (response_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_session_table_7 = [[\nCREATE TABLE session_copy (\n   session_id INTEGER PRIMARY KEY,\n   title TEXT,\n   doc INTEGER,\n   doc_hash TEXT,\n   project INTEGER,\n   accepted INTEGER NOT NULL DEFAULT 0 CHECK (accepted = 0 or accepted = 1),\n   riff INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n   FOREIGN KEY (riff)\n      REFERENCES riff (riff_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_premise_table_7 = [[\nCREATE TABLE premise_copy (\n   session_round_id INTEGER PRIMARY KEY,\n   session INTEGER NOT NULL,\n   riff_round INTEGER NOT NULL,\n   premise INTEGER NOT NULL,\n   status STRING NOT NULL CHECK (\n      status = \'accept\' or status = \'watch\' or status = \'ignore\' ),\n   FOREIGN KEY (session)\n      REFERENCES session (session_id)\n   FOREIGN KEY (riff_round)\n      REFERENCES riff_round (riff_round_id)\n   FOREIGN KEY (premise)\n      REFERENCES line (line_id)\n);\n]]\n\n\n\n\n\n\n\nlocal drop_run_attr_7 = [[\nDROP TABLE run_attr;\n]]\n\nlocal drop_action_attr_7 = [[\nDROP TABLE action_attr;\n]]\n\nlocal drop_error_string_7 = [[\nDROP TABLE error_string;\n]]\n\n\n\n\n\n\n\nlocal get_all_and_everthing = [[\nSELECT input.line as line,\n       input.line_id as line_id,\n       input.time as input_time,\n       input.project as project_id,\n       premise.session as session,\n       premise.ordinal as premise_ordinal,\n       premise.title as premise_title,\n       premise.status as premise_status,\n       run_action.run as run_id,\n       run_action.class as run_action_class,\n       run_action.ordinal as run_action_ordinal\n\nFROM input\nLEFT JOIN premise ON premise.line == input.line_id\nLEFT JOIN run_action ON run_action.input == input.line_id\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _prepareStatements(conn, stmts)\n   return function(_, key)\n      if stmts[key] then\n         return conn:prepare(stmts[key])\n      else\n         error(\"Don\'t have a statement \" .. key .. \" to prepare.\")\n      end\n   end\nend\n\nlocal function _readOnly(_, key, value)\n   error (\"can\'t assign to prepared statements table, key: \" .. key\n          .. \" value: \" .. value)\nend\n\nlocal lastRowId = assert(sql.lastRowId)\nfunction _makeProxy(conn, stmts)\n   return setmetatable({ lastRowId = function() return lastRowId(conn) end },\n                       { __index = _prepareStatements(conn, stmts),\n                         __newindex = _readOnly })\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal historian_sql = {}\nhelm_db.historian_sql = historian_sql\n\n\n\n\n\nhistorian_sql.insert_line = [[\nINSERT INTO input (project, line) VALUES (:project, :line);\n]]\n\nhistorian_sql.insert_result_hash = [[\nINSERT INTO result (line_id, hash) VALUES (:line_id, :hash);\n]]\n\nhistorian_sql.insert_repr = [[\nINSERT INTO repr (hash, repr) VALUES (:hash, :repr);\n]]\n\nhistorian_sql.insert_project = [[\nINSERT INTO project (directory) VALUES (?);\n]]\n\nhistorian_sql.insert_run_start = [[\nINSERT INTO run (project) VALUES (:project);\n]]\n\nhistorian_sql.insert_run_finish = [[\nUPDATE run SET finish_time = strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')\nWHERE run.run_id == :run;\n]]\n\nhistorian_sql.insert_run_input = [[\nINSERT INTO run_action (run, ordinal, input)\nVALUES (:run_id, :ordinal, :input);\n]]\n\n\n\n\nhistorian_sql.get_recent = [[\nSELECT CAST (line_id AS REAL), line FROM input\n   WHERE project = :project\n   ORDER BY line_id DESC\n   LIMIT :num_lines;\n]]\n\nhistorian_sql.get_number_of_lines = [[\nSELECT CAST (count(line) AS REAL) from input\n   WHERE project = ?\n;\n]]\n\nhistorian_sql.get_project = [[\nSELECT project_id FROM project\n   WHERE directory = ?;\n]]\n\nhistorian_sql.get_results = [[\nSELECT repr FROM result\nINNER JOIN repr ON repr.hash == result.hash\nWHERE result.line_id = :line_id\nORDER BY result.result_id;\n]]\n\nhistorian_sql.get_lines_of_run = [[\nSELECT run_action.input, input.line FROM run\nINNER JOIN run_action on run_action.run = run.run_id\nINNER JOIN input on input.line_id = run_action.input\nWHERE run.run_id = :run_id\nORDER BY run_action.ordinal;\n]]\n\nhistorian_sql.get_latest_finished_run = [[\nSELECT run_id FROM run\nWHERE project = :project_id\n   AND finish_time IS NOT NULL\nORDER BY run.start_time DESC\nLIMIT 1;\n]]\n\n\n\n\n\n\n\n\n\nfunction helm_db.historian(conn_handle)\n   local conn = _openConn(conn_handle)\n   local hist_proxy = _makeProxy(conn, historian_sql)\n   rawset(hist_proxy, \"savepoint_persist\",\n          function()\n            conn:exec \"SAVEPOINT save_persist\"\n          end)\n   rawset(hist_proxy, \"release_persist\",\n          function()\n             conn:exec \"RELEASE save_persist\"\n          end)\n   rawset(hist_proxy, \"savepoint_restart_session\",\n          function()\n             conn:exec \"SAVEPOINT restart_session\"\n          end)\n   rawset(hist_proxy, \"release_restart_session\",\n          function()\n             conn:exec \"RELEASE restart_session\"\n          end)\n   return hist_proxy\nend\n\n\n\n\n\n\n\n\n\nlocal session_sql = {}\n\n\n\n\n\n\n\n\nsession_sql.insert_session = [[\nINSERT INTO\n   session (title, project, accepted)\nVALUES\n   (:session_title, :project_id, :accepted)\n;\n]]\n\nsession_sql.insert_premise = [[\nINSERT INTO\n   premise (session, ordinal, line, title, status)\nVALUES\n   (:session_id, :ordinal, :line_id, :title, :status)\n;\n]]\n\nsession_sql.truncate_session = [[\nDELETE FROM premise WHERE session = :session_id AND ordinal > :n;\n]]\n\nsession_sql.delete_session_by_id = [[\nDELETE FROM session WHERE session_id = :session_id;\n]]\n\n\n\nsession_sql.insert_line = [[\nINSERT INTO input (project, line, time) VALUES (:project, :line, :time);\n]]\n\n\n\n\nsession_sql.insert_result_hash = historian_sql.insert_result_hash\nsession_sql.insert_repr        = historian_sql.insert_repr\n\n\n\n\n\n\n\n\nsession_sql.update_session = [[\nUPDATE session SET title = :session_title, accepted = :accepted\n   WHERE session_id = :session_id;\n]]\n\n\n\n\nsession_sql.delete_session_by_id = [[\nDELETE FROM session WHERE session_id = :session_id;\n]]\n\nsession_sql.update_accepted_session = [[\nUPDATE session SET accepted = :accepted WHERE session_id = :session_id;\n]]\n\nsession_sql.update_title_session = [[\nUPDATE session SET title = :title WHERE session_id = :session_id;\n]]\n\n\n\nsession_sql.get_session_by_id = [[\nSELECT\n   session.title AS session_title,\n   session.accepted AS session_accepted,\n   session.session_id,\n   session.project,\n   premise.status,\n   premise.title,\n   input.line,\n   input.time,\n   input.line_id\nFROM\n   session\nLEFT JOIN premise ON premise.session = session.session_id\nLEFT JOIN input ON input.line_id = premise.line\nWHERE session.session_id = ?\nORDER BY premise.ordinal\n;\n]]\n\n\n\n\nsession_sql.get_results = [[\nSELECT repr.repr\nFROM result\nINNER JOIN repr ON result.hash = repr.hash\nWHERE result.line_id = ?\nORDER BY result.result_id;\n]]\n\n\n\nsession_sql.get_sessions_for_project = [[\nSELECT title as session_title, accepted, project, vc_hash, session_id\nFROM session\nWHERE session.project = :project_id\nORDER BY session.session_id;\n]]\n\nsession_sql.get_project_by_dir = [[\nSELECT project_id FROM project WHERE directory = ?;\n]]\n\nsession_sql.get_accepted_by_dir = [[\nSELECT title FROM session\nINNER JOIN\n   project ON session.project = project.project_id\nWHERE\n   project.directory = ?\nAND\n   session.accepted = 1\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.get_session_list_by_dir = [[\nSELECT title, accepted, session_id FROM session\nINNER JOIN\n   project ON session.project = project.project_id\nWHERE\n   project.directory = ?\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.count_premises = [[\nSELECT CAST (count(premise.ordinal) AS REAL)\nFROM premise\nWHERE session = :session_id\n;\n]]\n\nsession_sql.get_sessions_from_project = [[\nSELECT\n   session_id,\n   CAST(accepted AS REAL) As accepted\nFROM\n   session\nWHERE\n   project = ?\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.get_sessions_by_project = [[\nSELECT session_id FROM session\nWHERE project = ?\nORDER BY session_id\n;\n]]\n\nsession_sql.get_session_by_project_and_title = [[\nSELECT\n   CAST (session_id AS REAL) AS session_id,\n   CAST (accepted AS REAL) AS accepted\nFROM session\nWHERE project = ? AND title = ?\nORDER BY session_id\n;\n]]\n\nsession_sql.get_premises_for_export = [[\nSELECT\n   CAST (ordinal AS REAL) AS ordinal,\n   premise.title as title,\n   premise.status as status,\n   input.line as line,\n   input.time as time,\n   input.line_id as line_id\nFROM\n   premise\nLEFT JOIN\n   input\nON\n   input.line_id = premise.line\nWHERE\n   premise.session = :session_id\nORDER BY\n   premise.ordinal\n;\n]]\n\n\n\n\nlocal session_get_project_info = [[\nSELECT project_id, directory from project;\n]]\n\nsession_sql.update_premise_line = [[\nUPDATE premise\nSET line = :line\nWHERE\n   session = :session\nAND\n   ordinal = :ordinal\n;\n]]\n\n\nfunction helm_db.session(conn_handle)\n   local conn = _openConn(conn_handle)\n   local stmts =  _makeProxy(conn, session_sql)\n   rawset(stmts, \"get_project_info\",\n          function()\n             return conn:exec(session_get_project_info)\n          end)\n   rawset(stmts, \"beginTransaction\",\n          function()\n             return conn:exec \"BEGIN TRANSACTION;\"\n          end)\n   rawset(stmts, \"commit\",\n          function()\n             return conn:exec \"COMMIT;\"\n          end)\n   return stmts\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal boot = assert(sql.boot)\n\nfunction helm_db.boot(conn_handle)\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn_handle = helm_db_home\n      conn = boot(conn_handle, migrations)\n      _conns[conn_handle] = conn\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\nfunction helm_db.close(conn_handle)\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn = _conns[helm_db_home]\n      conn_handle = helm_db_home\n   end\n   if not conn then return end\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   -- set up an idler to close the conn, so that e.g. busy\n   -- exceptions don\'t blow up the hook\n   local close_idler = uv.new_idle()\n   close_idler:start(function()\n      local success = pcall(conn.close, conn)\n      if not success then\n         return nil\n      else\n         -- we don\'t want to rely on GC to prevent closing a conn twice\n         _conns[conn_handle] = nil\n         close_idler:stop()\n      end\n   end)\nend\n\n\n\n\n\n\n\n\n\n\nfunction helm_db.conn(conn_handle)\n   conn_handle = conn_handle or helm_db_home\n   return _conns[conn_handle]\nend\n\n\n\n\n\n\n\n\nsetmetatable(helm_db, { __newindex = function()\n                                        error \"cannnot assign to helm_db\"\n                                     end })\n\n\n\n\nreturn helm_db\n\n",
name = "helm/helm-db",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "910b2129747f989d9afc5b7b05776c2e63e3ae1650745343b95c110c868c584e",
binary = "\n\n\n\n\n----------------------------------------------------------------------------\n-- LuaJIT profiler.\n--\n-- Copyright (C) 2005-2017 Mike Pall. All rights reserved.\n-- Released under the MIT license. See Copyright Notice in luajit.h\n----------------------------------------------------------------------------\n--\n-- This module is a simple command line interface to the built-in\n-- low-overhead profiler of LuaJIT.\n--\n-- The lower-level API of the profiler is accessible via the \"jit.profile\"\n-- module or the luaJIT_profile_* C API.\n--\n-- Example usage:\n--\n--   luajit -jp myapp.lua\n--   luajit -jp=s myapp.lua\n--   luajit -jp=-s myapp.lua\n--   luajit -jp=vl myapp.lua\n--   luajit -jp=G,profile.txt myapp.lua\n--\n-- The following dump features are available:\n--\n--   f  Stack dump: function name, otherwise module:line. Default mode.\n--   F  Stack dump: ditto, but always prepend module.\n--   l  Stack dump: module:line.\n--   <number> stack dump depth (callee < caller). Default: 1.\n--   -<number> Inverse stack dump depth (caller > callee).\n--   s  Split stack dump after first stack level. Implies abs(depth) >= 2.\n--   p  Show full path for module names.\n--   v  Show VM states. Can be combined with stack dumps, e.g. vf or fv.\n--   z  Show zones. Can be combined with stack dumps, e.g. zf or fz.\n--   r  Show raw sample counts. Default: show percentages.\n--   a  Annotate excerpts from source code files.\n--   A  Annotate complete source code files.\n--   G  Produce raw output suitable for graphical tools (e.g. flame graphs).\n--   m<number> Minimum sample percentage to be shown. Default: 3.\n--   i<number> Sampling interval in milliseconds. Default: 10.\n--\n----------------------------------------------------------------------------\n\n-- Cache some library functions and objects.\nlocal jit = assert(require(\"jit\"))\nassert(jit.version_num == 20100, \"LuaJIT core/library version mismatch\")\nlocal profile = require(\"jit.profile\")\nlocal vmdef = assert(jit and jit.vmdef)\nlocal math = math\nlocal pairs, ipairs, tonumber, floor = pairs, ipairs, tonumber, math.floor\nlocal sort, format = table.sort, string.format\nlocal stdout = io.stdout\nlocal zone -- Load jit.zone module on demand.\n\n-- Output file handle.\nlocal out\n\n------------------------------------------------------------------------------\n\nlocal prof_ud\nlocal prof_states, prof_split, prof_min, prof_raw, prof_fmt, prof_depth\nlocal prof_ann, prof_count1, prof_count2, prof_samples\n\nlocal map_vmmode = {\n  N = \"Compiled\",\n  I = \"Interpreted\",\n  C = \"C code\",\n  G = \"Garbage Collector\",\n  J = \"JIT Compiler\",\n}\n\n-- Profiler callback.\nlocal function prof_cb(th, samples, vmmode)\n  prof_samples = prof_samples + samples\n  local key_stack, key_stack2, key_state\n  -- Collect keys for sample.\n  if prof_states then\n    if prof_states == \"v\" then\n      key_state = map_vmmode[vmmode] or vmmode\n    else\n      key_state = zone:get() or \"(none)\"\n    end\n  end\n  if prof_fmt then\n    key_stack = profile.dumpstack(th, prof_fmt, prof_depth)\n    key_stack = key_stack:gsub(\"%[builtin#(%d+)%]\", function(x)\n      return vmdef.ffnames[tonumber(x)]\n    end)\n    if prof_split == 2 then\n      local k1, k2 = key_stack:match(\"(.-) [<>] (.*)\")\n      if k2 then key_stack, key_stack2 = k1, k2 end\n    elseif prof_split == 3 then\n      key_stack2 = profile.dumpstack(th, \"l\", 1)\n    end\n  end\n  -- Order keys.\n  local k1, k2\n  if prof_split == 1 then\n    if key_state then\n      k1 = key_state\n      if key_stack then k2 = key_stack end\n    end\n  elseif key_stack then\n    k1 = key_stack\n    if key_stack2 then k2 = key_stack2 elseif key_state then k2 = key_state end\n  end\n  -- Coalesce samples in one or two levels.\n  if k1 then\n    local t1 = prof_count1\n    t1[k1] = (t1[k1] or 0) + samples\n    if k2 then\n      local t2 = prof_count2\n      local t3 = t2[k1]\n      if not t3 then t3 = {}; t2[k1] = t3 end\n      t3[k2] = (t3[k2] or 0) + samples\n    end\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Show top N list.\nlocal function prof_top(count1, count2, samples, indent)\n  local t, n = {}, 0\n  for k in pairs(count1) do\n    n = n + 1\n    t[n] = k\n  end\n  sort(t, function(a, b) return count1[a] > count1[b] end)\n  for i=1,n do\n    local k = t[i]\n    local v = count1[k]\n    local pct = floor(v*100/samples + 0.5)\n    if pct < prof_min then break end\n    if not prof_raw then\n      out:write(format(\"%s%2d%%  %s\\n\", indent, pct, k))\n    elseif prof_raw == \"r\" then\n      out:write(format(\"%s%5d  %s\\n\", indent, v, k))\n    else\n      out:write(format(\"%s %d\\n\", k, v))\n    end\n    if count2 then\n      local r = count2[k]\n      if r then\n   prof_top(r, nil, v, (prof_split == 3 or prof_split == 1) and \"  -- \" or\n             (prof_depth < 0 and \"  -> \" or \"  <- \"))\n      end\n    end\n  end\nend\n\n-- Annotate source code\nlocal function prof_annotate(count1, samples)\n  local files = {}\n  local ms = 0\n  for k, v in pairs(count1) do\n    local pct = floor(v*100/samples + 0.5)\n    ms = math.max(ms, v)\n    if pct >= prof_min then\n      local file, line = k:match(\"^(.*):(%d+)$\")\n      if not file then file = k; line = 0 end\n      local fl = files[file]\n      if not fl then fl = {}; files[file] = fl; files[#files+1] = file end\n      line = tonumber(line)\n      fl[line] = prof_raw and v or pct\n    end\n  end\n  sort(files)\n  local fmtv, fmtn = \" %3d%% | %s\\n\", \"      | %s\\n\"\n  if prof_raw then\n    local n = math.max(5, math.ceil(math.log10(ms)))\n    fmtv = \"%\"..n..\"d | %s\\n\"\n    fmtn = (\" \"):rep(n)..\" | %s\\n\"\n  end\n  local ann = prof_ann\n  for _, file in ipairs(files) do\n    local f0 = file:byte()\n    if f0 == 40 or f0 == 91 then\n      out:write(format(\"\\n====== %s ======\\n[Cannot annotate non-file]\\n\", file))\n      break\n    end\n    local fp, err = io.open(file)\n    if not fp then\n      out:write(format(\"====== ERROR: %s: %s\\n\", file, err))\n      break\n    end\n    out:write(format(\"\\n====== %s ======\\n\", file))\n    local fl = files[file]\n    local n, show = 1, false\n    if ann ~= 0 then\n      for i=1,ann do\n   if fl[i] then show = true; out:write(\"@@ 1 @@\\n\"); break end\n      end\n    end\n    for line in fp:lines() do\n      if line:byte() == 27 then\n   out:write(\"[Cannot annotate bytecode file]\\n\")\n   break\n      end\n      local v = fl[n]\n      if ann ~= 0 then\n   local v2 = fl[n+ann]\n   if show then\n     if v2 then show = n+ann elseif v then show = n\n     elseif show+ann < n then show = false end\n   elseif v2 then\n     show = n+ann\n     out:write(format(\"@@ %d @@\\n\", n))\n   end\n   if not show then goto next end\n      end\n      if v then\n   out:write(format(fmtv, v, line))\n      else\n   out:write(format(fmtn, line))\n      end\n    ::next::\n      n = n + 1\n    end\n    fp:close()\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Finish profiling and dump result.\nlocal function prof_finish()\n  if prof_ud then\n    profile.stop()\n    local samples = prof_samples\n    if samples == 0 then\n      if prof_raw ~= true then out:write(\"[No samples collected]\\n\") end\n      return\n    end\n    if prof_ann then\n      prof_annotate(prof_count1, samples)\n    else\n      prof_top(prof_count1, prof_count2, samples, \"\")\n    end\n    prof_count1 = nil\n    prof_count2 = nil\n    prof_ud = nil\n  end\nend\n\n-- Start profiling.\nlocal function prof_start(mode)\n  local interval = \"\"\n  mode = mode:gsub(\"i%d*\", function(s) interval = s; return \"\" end)\n  prof_min = 3\n  mode = mode:gsub(\"m(%d+)\", function(s) prof_min = tonumber(s); return \"\" end)\n  prof_depth = 1\n  mode = mode:gsub(\"%-?%d+\", function(s) prof_depth = tonumber(s); return \"\" end)\n  local m = {}\n  for c in mode:gmatch(\".\") do m[c] = c end\n  prof_states = m.z or m.v\n  if prof_states == \"z\" then zone = require(\"jit.zone\") end\n  local scope = m.l or m.f or m.F or (prof_states and \"\" or \"f\")\n  local flags = (m.p or \"\")\n  prof_raw = m.r\n  if m.s then\n    prof_split = 2\n    if prof_depth == -1 or m[\"-\"] then prof_depth = -2\n    elseif prof_depth == 1 then prof_depth = 2 end\n  elseif mode:find(\"[fF].*l\") then\n    scope = \"l\"\n    prof_split = 3\n  else\n    prof_split = (scope == \"\" or mode:find(\"[zv].*[lfF]\")) and 1 or 0\n  end\n  prof_ann = m.A and 0 or (m.a and 3)\n  if prof_ann then\n    scope = \"l\"\n    prof_fmt = \"pl\"\n    prof_split = 0\n    prof_depth = 1\n  elseif m.G and scope ~= \"\" then\n    prof_fmt = flags..scope..\"Z;\"\n    prof_depth = -100\n    prof_raw = true\n    prof_min = 0\n  elseif scope == \"\" then\n    prof_fmt = false\n  else\n    local sc = prof_split == 3 and m.f or m.F or scope\n    prof_fmt = flags..sc..(prof_depth >= 0 and \"Z < \" or \"Z > \")\n  end\n  prof_count1 = {}\n  prof_count2 = {}\n  prof_samples = 0\n  profile.start(scope:lower()..interval, prof_cb)\n  prof_ud = newproxy(true)\n  getmetatable(prof_ud).__gc = prof_finish\nend\n\n------------------------------------------------------------------------------\n\nlocal function start(mode, outfile)\n  if not outfile then outfile = os.getenv(\"LUAJIT_PROFILEFILE\") end\n  if outfile then\n    out = outfile == \"-\" and stdout or assert(io.open(outfile, \"w\"))\n  else\n    out = stdout\n  end\n  prof_start(mode or \"f\")\nend\n\n-- Public module functions.\nreturn {\n  start = start, -- For -j command line option.\n  stop = prof_finish\n}\n\n\n\n",
name = "helm/ljprof",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "9d7e67b562c0a33b96f09658c4b0094df1d3c86a119ee9c558e3a2db0b92c93a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\n\n\n\n\nlocal lua_statements = [[\nstatement  <-  do-state\n            /  while-state\n            /  repeat-state\n            /  if-state\n            /  for-state\n            /  function-state\n            /  local-function-state\n            /  local-assign-state\n            /  varlist-explist-state\n            /  goto-state\n            /  label-state\n            /  funcl-state\n]]\n\nlocal lua_str = [[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr _ \",\" _ expr _ (\",\" _ expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t _ (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = reprsymbol\n       / !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nreprsymbol = \"$\" ([1-9] [0-9]*)* (\".\" ([a-z]/[A-Z]))*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\n\n\n\n\n\nlocal Lua = Node : inherit \"lua\"\n\nfunction Lua.__tostring(lua)\n   return lua:span()\nend\n\nfunction Lua.toLua(lua)\n   return lua:span()\nend\n\nlocal lua_metas = { lua = Lua }\n\n\n\nreturn Peg(lua_str) : toGrammar(lua_metas)\n\n",
name = "helm/lua-parser",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "21c8ab7ed3fce21e9e32423d07dcf130cae341a77990144058e9f343c6a185b0",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal EditAgent      = require \"helm:agent/edit\"\nlocal InputEchoAgent = require \"helm:agent/input-echo\"\nlocal ModalAgent     = require \"helm:agent/modal\"\nlocal PagerAgent     = require \"helm:agent/pager\"\nlocal PromptAgent    = require \"helm:agent/prompt\"\nlocal ResultsAgent   = require \"helm:agent/results\"\nlocal RunReviewAgent = require \"helm:agent/run-review\"\nlocal SearchAgent    = require \"helm:agent/search\"\nlocal SessionAgent   = require \"helm:agent/session\"\nlocal StatusAgent    = require \"helm:agent/status\"\nlocal SuggestAgent   = require \"helm:agent/suggest\"\n\nlocal assert = assert(core.fn.assertfmt)\nlocal table = core.table\n\nlocal available_ragas = {\n   nerf           = require \"helm:raga/nerf\",\n   search         = require \"helm:raga/search\",\n   complete       = require \"helm:raga/complete\",\n   page           = require \"helm:raga/page\",\n   modal          = require \"helm:raga/modal\",\n   session_review = require \"helm:raga/session-review\",\n   run_review     = require \"helm:raga/run-review\",\n   edit_title     = require \"helm:raga/edit-title\",\n   edit_line      = require \"helm:raga/edit-line\"\n}\n\nlocal cluster = require \"cluster:cluster\"\nlocal Actor = require \"actor:actor\"\n\nlocal assert = assert(core.fn.assertfmt)\nlocal table = core.table\n\n\n\n\n\n\n\nlocal new, Maestro, Maestro_M = cluster.genus(Actor)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Maestro.act(maestro, msg)\n   return pack(maestro:dispatch(msg))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _yield  = assert(core.thread.nest \"actor\" .yield)\n\nfunction Maestro.delegate(maestro, msg)\n   if msg.method == \"pushMode\" or msg.method == \"popMode\" or\n      (msg.to and (msg.to == \"raga\" or msg.to:find(\"^agents%.\"))) then\n      return maestro:act(msg)\n   else\n      return pack(_yield(msg))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clone, concat, insert = assert(table.clone),\n                              assert(table.concat),\n                              assert(table.insert)\n\nlocal function _dispatchOnly(maestro, event)\n   local handlers = maestro.raga.keymap(event)\n   local tried = {}\n   for _, handler in ipairs(handlers) do\n      handler = clone(handler)\n      -- #todo make this waaaaay more flexible\n      if handler.n > 0 and not handler[handler.n] then\n        handler[handler.n] = event\n      end\n      -- #todo using empty-string as a non-nil signpost\n      -- should be able to refactor so this is not needed\n      if (not handler.to) or handler.to == \'\' then\n         handler.to = maestro.raga.target\n      end\n      -- #todo ugh, some way to dump a Message to a representative string?\n      -- #todo also, this is assuming that all traversal is done in `to`,\n      -- without nested messages--bad assumption, in general\n      insert(tried, handler.method or handler.call)\n      if send(handler) ~= false then\n         break\n      end\n   end\n   if #tried == 0 then\n      return nil\n   else\n      return concat(tried, \", \")\n   end\nend\n\nfunction Maestro.eventDispatcher(maestro, event)\n   local command = _dispatchOnly(maestro, event)\n   if maestro.agents.edit.contents_changed then\n      maestro.raga.onTxtbufChanged()\n    -- Treat contents_changed as implying cursor_changed\n    -- only ever fire one of the two events\n   elseif maestro.agents.edit.cursor_changed then\n      maestro.raga.onCursorChanged()\n   end\n   maestro.agents.edit.contents_changed = false\n   maestro.agents.edit.cursor_changed = false\n   return command\nend\n\nfunction Maestro.dispatchEvent(maestro, event)\n   return maestro :task() :eventDispatcher(event)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _shiftMode(maestro, raga_name)\n   -- Stash the current lexer associated with the current raga\n   -- Currently we never change the lexer separate from the raga,\n   -- but this will change when we start supporting multiple languages\n   -- Guard against nil raga or lexer during startup\n   if maestro.raga then\n      maestro.raga.onUnshift()\n   end\n   -- Switch in the new raga and associated lexer\n   maestro.raga = available_ragas[raga_name]\n   maestro.agents.edit:setLexer(maestro.raga.lex)\n   maestro.raga.onShift()\n   -- #todo feels wrong to do this here, like it\'s something the raga\n   -- should handle, but onShift feels kinda like it \"doesn\'t inherit\",\n   -- like it\'s not something you should actually super-send, so there\'s\n   -- not one good place to do this.\n   maestro.agents.prompt:update(maestro.raga.prompt_char)\n   return maestro\nend\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\n\nfunction Maestro.pushMode(maestro, raga)\n   -- There will be at most one previous occurrence as long as nobody breaks\n   -- the rules and messes with the stack outside these methods\n   for i, elem in ipairs(maestro.raga_stack) do\n      if elem == raga then\n         remove(maestro.raga_stack, i)\n         break\n      end\n   end\n   insert(maestro.raga_stack, raga)\n   return _shiftMode(maestro, raga)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Maestro.popMode(maestro)\n   remove(maestro.raga_stack)\n   return _shiftMode(maestro, maestro.raga_stack[#maestro.raga_stack])\nend\n\n\n\n\n\n\ncluster.extendbuilder(new, function(_new, maestro)\n   maestro.agents = {\n      edit       = EditAgent(),\n      input_echo = InputEchoAgent(),\n      modal      = ModalAgent(),\n      pager      = PagerAgent(),\n      prompt     = PromptAgent(),\n      results    = ResultsAgent(),\n      run_review = RunReviewAgent(),\n      search     = SearchAgent(),\n      session    = SessionAgent(),\n      status     = StatusAgent(),\n      suggest    = SuggestAgent(),\n   }\n   -- Raga stack starts out empty, though by first paint we\'ll have\n   -- pushed an initial raga\n   maestro.raga_stack = {}\n   return maestro\nend)\n\n\n\n\nreturn new\n\n",
name = "helm/maestro",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "0b3c7c38f14506e5d66e241b1a618957c165760bc283c6b1762fe0f436439f34",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Historian  = require \"helm:historian\"\nlocal Maestro    = require \"helm:maestro\"\nlocal Zoneherd   = require \"helm:zone\"\n\nlocal Resbuf    = require \"helm:buf/resbuf\"\nlocal Stringbuf = require \"helm:buf/stringbuf\"\nlocal Txtbuf    = require \"helm:buf/txtbuf\"\n\nlocal Actor   = require \"actor:actor\"\nlocal Valiant = require \"valiant:valjr\"\n\nlocal bridge = require \"bridge\"\n\n\n\nlocal cluster = require \"cluster:cluster\"\nlocal s = require \"status:status\"\ns.chatty = true\n\n\n\n\n\n\nlocal new, ModeS, ModeS_M = cluster.genus(Actor)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _stat_M; -- we shouldn\'t need this anyway #todo remove\n\ncluster.extendbuilder(new, function(_new, modeS, max_extent, writer, db)\n   -- Some miscellany to copy and initialize\n   modeS.max_extent = max_extent\n   modeS.write = writer\n   modeS.repl_top = ModeS.REPL_LINE\n\n   -- Create Actors (status isn\'t, but should be)\n   modeS.valiant = Valiant(__G)\n   modeS.hist  = Historian(db)\n   ---[[ This isn\'t how we should handle status,\n   modeS.status = setmetatable({}, _stat_M)\n   rawset(__G, \"stat\", modeS.status)\n   -- so lets make this easy to knock out ]]\n   modeS.zones = Zoneherd(modeS, writer)\n   modeS.maestro = Maestro()\n\n   return modeS\nend)\n\n\n\n\n\n\n\n\n\n\nfunction ModeS._pushMode(modeS, raga)\n   modeS.maestro:pushMode(raga)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.setup(modeS)\n   local initial_raga = \"nerf\"\n   modeS:_agent\'status\':update(\"default\")\n   -- Session-related setup\n   local session_title = bridge.args.new_session or\n                         bridge.args.session\n   if session_title then\n      modeS.hist:loadOrCreateSession(session_title)\n      if bridge.args.new_session then\n         -- Asked to create a session that already exists\n         if modeS.hist.session.session_id then\n            error(\'A session named \"\' .. session_title ..\n                  \'\" already exists. You can review it with br helm -s.\')\n         end\n         modeS:_agent\'status\':update(\"new_session\", session_title)\n      end\n      if bridge.args.session then\n         -- Asked to review a session that doesn\'t exist\n         if not modeS.hist.session.session_id then\n            error(\'No session named \"\' .. session_title ..\n                  \'\" found. Use br helm -n to create a new session.\')\n         end\n         -- If we are loading an existing session, start in review mode\n         initial_raga = \"session_review\"\n         modeS.hist.session:loadPremises()\n      end\n      modeS:_agent\'session\':update(modeS.hist.session)\n   end\n\n   if bridge.args.restart or bridge.args.run then\n      modeS.hist:loadPreviousRun()\n      if bridge.args.run then\n         modeS:_agent\'run_review\':update(modeS.hist.previous_run)\n         initial_raga = \'run_review\'\n      end\n   end\n\n   -- Set up common Agent -> Zone bindings\n   -- Note we don\'t do results here because that varies from raga to raga\n   -- The Txtbuf also needs a source of \"suggestions\" (which might be\n   -- history-search results instead), but that too is raga-dependent\n   modeS:bindZone(\"command\",  \"edit\",       Txtbuf)\n   modeS:bindZone(\"popup\",    \"pager\",      Resbuf,\n                  { scrollable = true })\n   modeS:bindZone(\"prompt\",   \"prompt\",     Stringbuf)\n   modeS:bindZone(\"modal\",    \"modal\",      Resbuf)\n   modeS:bindZone(\"status\",   \"status\",     Stringbuf)\n   modeS:bindZone(\"stat_col\", \"input_echo\", Resbuf)\n   modeS:bindZone(\"suggest\",  \"suggest\",    Resbuf)\n\n   -- Load initial raga. Need to process yielded messages from `onShift`\n   modeS :task() :_pushMode(initial_raga)\n\n   if bridge.args.restart then\n      local deque = require \"deque:deque\" ()\n      for _, premise in ipairs(modeS.hist.previous_run) do\n         deque:push(premise.line)\n      end\n      modeS:rerun(deque)\n   elseif bridge.args.back then\n      modeS:rerun(modeS.hist:loadRecentLines(bridge.args.back))\n   end\n\n   modeS.action_complete = true\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nModeS.idEst = new\n\n\n\n\n\n\nModeS.REPL_LINE = 2\nModeS.PROMPT_WIDTH = 3\n\n\n\n\n\n\n\n\nfunction ModeS.errPrint(modeS, log_stmt)\n   modeS.zones.suggest:replace(log_stmt)\n   modeS:paint()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction ModeS.placeCursor(modeS)\n   local point = modeS.maestro.raga.getCursorPosition()\n   if point then\n      modeS.write(a.jump(point), a.cursor.show())\n   end\n   return modeS\nend\n\n\n\n\n\n\n\n\nfunction ModeS.paint(modeS)\n   modeS.zones:paint(modeS)\n   modeS:placeCursor()\n   return modeS\nend\n\n\n\n\n\n\nfunction ModeS.reflow(modeS)\n   modeS.zones:reflow(modeS)\n   modeS:paint()\n   return modeS\nend\n\n\n\nlocal create, resume, status = assert(coroutine.create),\n                               assert(coroutine.resume),\n                               assert(coroutine.status)\n\n\n\n\nfunction ModeS.delegator(modeS, msg)\n   if msg.method == \"pushMode\" or msg.method == \"popMode\" or\n      (msg.to and (msg.to == \"raga\" or msg.to:find(\"^agents%.\"))) then\n      s:chat(\"sending a message to maestro: %s\", ts(msg))\n      return modeS.maestro(msg)\n   else\n      -- This is effectively modeS:super\'delegate\'(msg)\n      return pack(modeS:dispatch(msg))\n   end\nend\n\nfunction ModeS.delegate(modeS, msg)\n   return modeS :task() :delegator(msg)\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(core.table.clone)\nfunction ModeS.inbox(modeS, msg)\n   if msg.to == \"modeS\" then\n      msg = clone(msg)\n      msg.to = nil\n      return modeS, msg\n   end\n   return modeS\nend\n\n\n\n\n\n\n\n\nfunction ModeS.act(modeS, event)\n   local command;\n   repeat\n      modeS.action_complete = true\n      -- The raga may set action_complete to false to cause the command\n      -- to be re-processed, most likely after a mode-switch\n      -- @atman: this is where quitting breaks if we forbid non-message\n      -- return values in dispatch, not sure why.\n      local commandThisTime = modeS.maestro:dispatchEvent(event)\n      command = command or commandThisTime\n   until modeS.action_complete == true\n   if not command then\n      command = \'NYI\'\n   end\n   -- Inform the input-echo agent of what just happened\n   -- #todo Maestro can do this once action_complete goes away\n   modeS:_agent\'input_echo\':update(event, command)\n   -- Reflow in case command height has changed. Includes a paint.\n   -- Don\'t allow errors encountered here to break this entire\n   -- event-loop iteration, otherwise we become unable to quit if\n   -- there\'s a paint error.\n   local success, err = xpcall(modeS.reflow, debug.traceback, modeS)\n   if not success then\n      io.stderr:write(err, \"\\n\")\n      io.stderr:flush()\n   end\n   collectgarbage()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.tryAgain(modeS)\n   modeS.action_complete = false\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS._agent(modeS, agent_name)\n   return modeS.maestro.agents[agent_name]\nend\n\nModeS.agent = ModeS._agent -- not finishing this right now\n\n\n\n\n\n\n\n\n\nfunction ModeS.quitHelm(modeS)\n   -- #todo it\'s obviously terrible to have code specific to a particular\n   -- piece of functionality in a supervisory class like this.\n   -- To do this right, we probably need a proper raga stack. Then -n could\n   -- push the Review raga onto the bottom of the stack, then Nerf. Quit\n   -- at this point would be the result of the raga stack being empty,\n   -- rather than an explicitly-invoked command, and Ctrl-Q would just pop\n   -- the current raga. Though, a Ctrl-Q from e.g. Search would still want\n   -- to actually quit, so it\'s not quite that simple...\n   local session = modeS.hist.session\n   if _Bridge.args.new_session and #session > 0 then\n      local is_reviewing = false\n      for i, raga in ipairs(modeS.maestro.raga_stack) do\n         if raga == \"session_review\" then\n            is_reviewing = true\n            break\n         end\n      end\n      if not is_reviewing then\n         -- #todo Add the ability to change accepted status of\n         -- the whole session to the review interface\n         session.accepted = true\n         modeS.maestro:pushMode(\"session_review\")\n         return\n      end\n   end\n   -- #todo handle this better--as an event of sorts, maybe?\n   -- @atman: wait, I have an idea!\n   modeS.hist:close()\n   modeS:_agent\'status\':update(\"quit\")\n   modeS.has_quit = true\nend\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.rerunner(modeS, deque)\n   -- #todo this should probably be on a RunAgent/Runner and invoked\n   -- via some queued-Message mechanism, which would also take care of\n   -- putting it in a coroutine. Until then, we do this.\n   modeS:_agent\'edit\':clear()\n   modeS.hist.stmts.savepoint_restart_session()\n   local success, results\n   for line in deque:popAll() do\n      success, results = modeS:eval(line)\n      assert(results ~= \"advance\", \"Incomplete line when restarting session\")\n      modeS.hist:appendNow(line, results, success)\n   end\n   modeS.hist.stmts.release_restart_session()\n   modeS.hist:toEnd()\n   modeS:_agent\'results\':update(results)\nend\n\n\nfunction ModeS.rerun(modeS, deque)\n   modeS :task() :rerunner(deque)\nend\n\n\n\n\n\n\n\n\nlocal rep = assert(string.rep)\nfunction ModeS.openHelp(modeS)\n   modeS:_agent\'pager\':update((\"abcde \"):rep(1000))\n   modeS.maestro:pushMode \"page\"\nend\n\nfunction ModeS.openHelpOnFirstKey(modeS)\n   if modeS:agent\'edit\':isEmpty() then\n      modeS:openHelp()\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.eval(modeS, line)\n   return modeS.valiant(line)\nend\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.userEval(modeS)\n   local line = send { to = \"agents.edit\",\n                       method = \'contents\' }\n   local success, results = modeS:eval(line)\n   s:chat(\"we return from evaluation, success: %s\", success)\n   if not success and results == \'advance\' then\n      send { to = \"agents.edit\", method = \'endOfText\'}\n      return false -- Fall through to EditAgent nl binding\n   else\n      send { to = \'hist\',\n             method = \'append\',\n             line, results, success }\n\n      send { to = \'hist\', method = \'toEnd\' }\n      -- Do this first because it clears the results area\n      -- #todo this clearly means edit:clear() is doing too much, decouple\n      send { to = \"agents.edit\", method = \'clear\' }\n      send { to = \"agents.results\", method = \'update\', results }\n   end\nend\n\nfunction ModeS.conditionalEval(modeS)\n   if send { to = \"agents.edit\",\n             method = \'shouldEvaluate\'} then\n      return modeS:userEval()\n   else\n      return false -- Fall through to EditAgent nl binding\n   end\nend\n\n\n\n\n\n\nfunction ModeS.evalFromCursor(modeS)\n   local top = modeS.hist.n\n   local cursor = modeS.hist.cursor\n   for i = cursor, top do\n      local line = send { to = \"hist\", method = \"index\", i }\n      send { to = \"agents.edit\", method = \"update\", line }\n      modeS:userEval()\n   end\nend\n\n\n\n\n\n\nfunction ModeS.historyBack()\n   -- If we\'re at the end of the history (the user was typing a new\n   -- expression), save it before moving\n   if send { to = \'hist\', method = \'atEnd\' } then\n      local linestash = send { to = \"agents.edit\", method = \"contents\" }\n      send { to = \"hist\", method = \"append\", linestash }\n   end\n   local prev_line, prev_result = send { to = \"hist\", method = \"prev\" }\n   send { to = \"agents.edit\", method = \"update\", prev_line }\n   send { to = \"agents.results\", method = \"update\", prev_result }\nend\n\nfunction ModeS.historyForward()\n   local new_line, next_result = send { to = \"hist\", method = \"next\" }\n   if not new_line then\n      local old_line = send { to = \"agents.edit\", method = \"contents\" }\n      local added = send { to = \"hist\", method = \"append\", old_line }\n      if added then\n         send { to = \"hist\", method = \"toEnd\" }\n      end\n   end\n   send { to = \"agents.edit\", method = \"update\", new_line }\n   send { to = \"agents.results\", method = \"update\", next_result }\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.bindZone(modeS, zone_name, agent_name, buf_class, cfg)\n   local zone = modeS.zones[zone_name]\n   local agent = modeS:_agent(agent_name)\n   zone:replace(buf_class(agent:window(), cfg))\nend\n\n\n\nreturn new\n\n",
name = "helm/modeselektor",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "8bb0ab8aced18bf16c311c7a9bc8cce93bf6bf6cdc9b7bade4b2ca4ecf6962b1",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ffi = require \"ffi\"\nlocal bit = require \"bit\"\nlocal reflect = {}\n\nlocal CTState, init_CTState\nlocal miscmap, init_miscmap\n\nlocal function gc_str(gcref) -- Convert a GCref (to a GCstr) into a string\n  if gcref ~= 0 then\n    local ts = ffi.cast(\"uint32_t*\", gcref)\n    return ffi.string(ts + 4, ts[3])\n  end\nend\n\nlocal typeinfo = rawget(ffi, \"typeinfo\")\n\ntypeinfo = typeinfo or function(id)\n  -- ffi.typeof is present in LuaJIT v2.1 since 8th Oct 2014 (d6ff3afc)\n  -- this is an emulation layer for older versions of LuaJIT\n  local ctype = (CTState or init_CTState()).tab[id]\n  return {\n    info = ctype.info,\n    size = bit.bnot(ctype.size) ~= 0 and ctype.size,\n    sib = ctype.sib ~= 0 and ctype.sib,\n    name = gc_str(ctype.name),\n  }\nend\n\nlocal function memptr(gcobj)\n  return tonumber(tostring(gcobj):match\"%x*$\", 16)\nend\n\ninit_CTState = function()\n  -- Relevant minimal definitions from lj_ctype.h\n  ffi.cdef [[\n    typedef struct CType {\n      uint32_t info;\n      uint32_t size;\n      uint16_t sib;\n      uint16_t next;\n      uint32_t name;\n    } CType;\n\n    typedef struct CTState {\n      CType *tab;\n      uint32_t top;\n      uint32_t sizetab;\n      void *L;\n      void *g;\n      void *finalizer;\n      void *miscmap;\n    } CTState;\n  ]]\n\n  -- Acquire a pointer to this Lua universe\'s CTState\n  local co = coroutine.create(function()end) -- Any live coroutine will do.\n  local uint32_ptr = ffi.typeof(\"uint32_t*\")\n  local G = ffi.cast(uint32_ptr, ffi.cast(uint32_ptr, memptr(co))[2])\n  -- In global_State, `MRef ctype_state` is immediately before `GCRef gcroot[GCROOT_MAX]`.\n  -- We first find (an entry in) gcroot by looking for a metamethod name string.\n  local anchor = ffi.cast(\"uint32_t\", ffi.cast(\"const char*\", \"__index\"))\n  local i = 0\n  while math.abs(tonumber(G[i] - anchor)) > 64 do\n    i = i + 1\n  end\n  -- We then work backwards looking for something resembling ctype_state.\n  repeat\n    i = i - 1\n    CTState = ffi.cast(\"CTState*\", G[i])\n  until ffi.cast(uint32_ptr, CTState.g) == G\n\n  return CTState\nend\n\ninit_miscmap = function()\n  -- Acquire the CTState\'s miscmap table as a Lua variable\n  local t = {}; t[0] = t\n  local tvalue = ffi.cast(\"uint32_t*\", memptr(t))[2]\n  ffi.cast(\"uint32_t*\", tvalue)[ffi.abi\"le\" and 0 or 1] = ffi.cast(\"uint32_t\", ffi.cast(\"uintptr_t\", (CTState or init_CTState()).miscmap))\n  miscmap = t[0]\n  return miscmap\nend\n\n-- Information for unpacking a `struct CType`.\n-- One table per CT_* constant, containing:\n-- * A name for that CT_\n-- * Roles of the cid and size fields.\n-- * Whether the sib field is meaningful.\n-- * Zero or more applicable boolean flags.\nlocal CTs = {[0] =\n  {\"int\",\n    \"\", \"size\", false,\n    {0x08000000, \"bool\"},\n    {0x04000000, \"float\", \"subwhat\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n    {0x00400000, \"long\"},\n  },\n  {\"struct\",\n    \"\", \"size\", true,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"union\", \"subwhat\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"ptr\",\n    \"element_type\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"ref\", \"subwhat\"},\n  },\n  {\"array\",\n    \"element_type\", \"size\", false,\n    {0x08000000, \"vector\"},\n    {0x04000000, \"complex\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"void\",\n    \"\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n  },\n  {\"enum\",\n    \"type\", \"size\", true,\n  },\n  {\"func\",\n    \"return_type\", \"nargs\", true,\n    {0x00800000, \"vararg\"},\n    {0x00400000, \"sse_reg_params\"},\n  },\n  {\"typedef\", -- Not seen\n    \"element_type\", \"\", false,\n  },\n  {\"attrib\", -- Only seen internally\n    \"type\", \"value\", true,\n  },\n  {\"field\",\n    \"type\", \"offset\", true,\n  },\n  {\"bitfield\",\n    \"\", \"offset\", true,\n    {0x08000000, \"bool\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n  },\n  {\"constant\",\n    \"type\", \"value\", true,\n    {0x02000000, \"const\"},\n  },\n  {\"extern\", -- Not seen\n    \"CID\", \"\", true,\n  },\n  {\"kw\", -- Not seen\n    \"TOK\", \"size\",\n  },\n}\n\n-- Set of CType::cid roles which are a CTypeID.\nlocal type_keys = {\n  element_type = true,\n  return_type = true,\n  value_type = true,\n  type = true,\n}\n\n-- Create a metatable for each CT.\nlocal metatables = {\n}\nfor _, CT in ipairs(CTs) do\n  local what = CT[1]\n  local mt = {__index = {}}\n  metatables[what] = mt\nend\n\n-- Logic for merging an attribute CType onto the annotated CType.\nlocal CTAs = {[0] =\n  function(a, refct) error(\"TODO: CTA_NONE\") end,\n  function(a, refct) error(\"TODO: CTA_QUAL\") end,\n  function(a, refct)\n    a = 2^a.value\n    refct.alignment = a\n    refct.attributes.align = a\n  end,\n  function(a, refct)\n    refct.transparent = true\n    refct.attributes.subtype = refct.typeid\n  end,\n  function(a, refct) refct.sym_name = a.name end,\n  function(a, refct) error(\"TODO: CTA_BAD\") end,\n}\n\n-- C function calling conventions (CTCC_* constants in lj_refct.h)\nlocal CTCCs = {[0] =\n  \"cdecl\",\n  \"thiscall\",\n  \"fastcall\",\n  \"stdcall\",\n}\n\nlocal function refct_from_id(id) -- refct = refct_from_id(CTypeID)\n  local ctype = typeinfo(id)\n  local CT_code = bit.rshift(ctype.info, 28)\n  local CT = CTs[CT_code]\n  local what = CT[1]\n  local refct = setmetatable({\n    what = what,\n    typeid = id,\n    name = ctype.name,\n  }, metatables[what])\n\n  -- Interpret (most of) the CType::info field\n  for i = 5, #CT do\n    if bit.band(ctype.info, CT[i][1]) ~= 0 then\n      if CT[i][3] == \"subwhat\" then\n        refct.what = CT[i][2]\n      else\n        refct[CT[i][2]] = true\n      end\n    end\n  end\n  if CT_code <= 5 then\n    refct.alignment = bit.lshift(1, bit.band(bit.rshift(ctype.info, 16), 15))\n  elseif what == \"func\" then\n    refct.convention = CTCCs[bit.band(bit.rshift(ctype.info, 16), 3)]\n  end\n\n  if CT[2] ~= \"\" then -- Interpret the CType::cid field\n    local k = CT[2]\n    local cid = bit.band(ctype.info, 0xffff)\n    if type_keys[k] then\n      if cid == 0 then\n        cid = nil\n      else\n        cid = refct_from_id(cid)\n      end\n    end\n    refct[k] = cid\n  end\n\n  if CT[3] ~= \"\" then -- Interpret the CType::size field\n    local k = CT[3]\n    refct[k] = ctype.size or (k == \"size\" and \"none\")\n  end\n\n  if what == \"attrib\" then\n    -- Merge leading attributes onto the type being decorated.\n    local CTA = CTAs[bit.band(bit.rshift(ctype.info, 16), 0xff)]\n    if refct.type then\n      local ct = refct.type\n      ct.attributes = {}\n      CTA(refct, ct)\n      ct.typeid = refct.typeid\n      refct = ct\n    else\n      refct.CTA = CTA\n    end\n  elseif what == \"bitfield\" then\n    -- Decode extra bitfield fields, and make it look like a normal field.\n    refct.offset = refct.offset + bit.band(ctype.info, 127) / 8\n    refct.size = bit.band(bit.rshift(ctype.info, 8), 127) / 8\n    refct.type = {\n      what = \"int\",\n      bool = refct.bool,\n      const = refct.const,\n      volatile = refct.volatile,\n      unsigned = refct.unsigned,\n      size = bit.band(bit.rshift(ctype.info, 16), 127),\n    }\n    refct.bool, refct.const, refct.volatile, refct.unsigned = nil\n  end\n\n  if CT[4] then -- Merge sibling attributes onto this type.\n    while ctype.sib do\n      local entry = typeinfo(ctype.sib)\n      if CTs[bit.rshift(entry.info, 28)][1] ~= \"attrib\" then break end\n      if bit.band(entry.info, 0xffff) ~= 0 then break end\n      local sib = refct_from_id(ctype.sib)\n      sib:CTA(refct)\n      ctype = entry\n    end\n  end\n\n  return refct\nend\n\nlocal function sib_iter(s, refct)\n  repeat\n    local ctype = typeinfo(refct.typeid)\n    if not ctype.sib then return end\n    refct = refct_from_id(ctype.sib)\n  until refct.what ~= \"attrib\" -- Pure attribs are skipped.\n  return refct\nend\n\nlocal function siblings(refct)\n  -- Follow to the end of the attrib chain, if any.\n  while refct.attributes do\n    refct = refct_from_id(refct.attributes.subtype or typeinfo(refct.typeid).sib)\n  end\n\n  return sib_iter, nil, refct\nend\n\nmetatables.struct.__index.members = siblings\nmetatables.func.__index.arguments = siblings\nmetatables.enum.__index.values = siblings\n\nlocal function find_sibling(refct, name)\n  local num = tonumber(name)\n  if num then\n    for sib in siblings(refct) do\n      if num == 1 then\n        return sib\n      end\n      num = num - 1\n    end\n  else\n    for sib in siblings(refct) do\n      if sib.name == name then\n        return sib\n      end\n    end\n  end\nend\n\nmetatables.struct.__index.member = find_sibling\nmetatables.func.__index.argument = find_sibling\nmetatables.enum.__index.value = find_sibling\n\nfunction reflect.typeof(x) -- refct = reflect.typeof(ct)\n  return refct_from_id(tonumber(ffi.typeof(x)))\nend\n\nfunction reflect.getmetatable(x) -- mt = reflect.getmetatable(ct)\n  return (miscmap or init_miscmap())[-tonumber(ffi.typeof(x))]\nend\n\nreturn reflect\n\n",
name = "helm/reflect",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "54269d6ba74e14032f4a2357ed3ee89eb0ae4b1c81671f012959f3f9d0e9f5eb",
binary = "\n\n\n\n\n\n\n\n\nlocal math = core.math\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\nlocal clamp = assert(math.clamp)\nfunction SelectionList.selectIndex(list, index)\n   -- Handle empty-list case separately as `clamp`\n   -- does not tolerate upper < lower\n   index = #list == 0 and 0 or clamp(index, 1, #list)\n   if index ~= list.selected_index then\n      list.selected_index = index\n      return true\n   else\n      return false\n   end\nend\n\nfunction SelectionList.selectFirst(list)\n   return list:selectIndex(1)\nend\n\nfunction SelectionList.selectNext(list)\n   return list:selectIndex(list.selected_index + 1)\nend\n\nfunction SelectionList.selectPrevious(list)\n   return list:selectIndex(list.selected_index - 1)\nend\n\n\n\n\n\n\n\n\n\n\nfunction SelectionList.selectNextWrap(list)\n   local new_idx = list.selected_index < #list\n      and list.selected_index + 1\n      or 1\n   return list:selectIndex(new_idx)\nend\n\nfunction SelectionList.selectPreviousWrap(list)\n   local new_idx = list.selected_index > 1\n      and list.selected_index - 1\n      or #list\n   return list:selectIndex(new_idx)\nend\n\n\n\n\n\n\n\n\n\nfunction SelectionList.selectNone(list)\n   list.selected_index = 0\nend\n\n\n\n\n\n\n\n\nfunction SelectionList.selectedItem(list)\n   return list[list.selected_index]\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal concat = assert(table.concat)\n\nfunction SelectionList.highlight(list, line, max_disp, c)\n   local frag_index = 1\n   -- Collapse multiple spaces into one for display\n   line = line:gsub(\" +\",\" \")\n   local codes = Codepoints(line)\n   local disp = 0\n   local stop_at\n   for i, char in ipairs(codes) do\n      local char_disp = 1\n      if char == \"\\n\" then\n         char = c.stresc .. \"\\\\n\" .. c.base\n         codes[i] = char\n         char_disp =  2\n      end\n      -- Reserve one space for ellipsis unless this is the\n      -- last character on the line\n      local reserved_space = i < #codes and 1 or 0\n      if disp + char_disp + reserved_space > max_disp then\n         char = c.alert(\"…\")\n         codes[i] = char\n         disp = disp + 1\n         stop_at = i\n         break\n      end\n      disp = disp + char_disp\n      if frag_index <= #list.frag and char == list.frag:sub(frag_index, frag_index) then\n         local char_color\n         -- highlight the last two differently if this is a\n         -- \'second best\' search\n         if not list.best and #list.frag - frag_index < 2 then\n            char_color = c.alert\n         else\n            char_color = c.search_hl\n         end\n         char = char_color .. char .. c.base\n         codes[i] = char\n         frag_index = frag_index + 1\n      end\n   end\n   return c.base(concat(codes, \"\", 1, stop_at)), disp\nend\n\nfunction SelectionList.__repr(list, window, c)\n   assert(c, \"must provide a color table\")\n   if #list == 0 then\n      return c.alert \"No results found\"\n   end\n   local i = 1\n   return function()\n      local line = list[i]\n      local len\n      if line == nil then return nil end\n      line, len = list:highlight(line, window.remains - 4, c)\n      if list.show_shortcuts then\n         local alt_seq = \"    \"\n         if i < 10 then\n            alt_seq = c.bold(\"M-\" .. tostring(i) .. \" \")\n         end\n         line = alt_seq .. line\n         len = len + 4\n      end\n      if i == list.selected_index then\n         line = c.highlight(line)\n      end\n      i = i + 1\n      return line, len\n   end\nend\n\n\n\n\n\n\n\n\n\nnew = function(frag, cfg)\n   local list = setmetatable({}, SelectionList)\n   if frag then\n      list.frag = frag\n      list.lit_frag = frag\n      list.best = true\n   end\n   list.selected_index = 0\n   -- list.n = 0\n   if cfg then\n      for k, v in pairs(cfg) do\n         list[k] = v\n      end\n   end\n   return list\nend\n\n\n\nSelectionList.idEst = new\nreturn new\n\n",
name = "helm/selection_list",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "a841fe46df5a7b10d5a6f7679f6e625d98708c4ef68c0da1952fb6b93b1d27c8",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal table = core.table\n\n\n\n\nlocal helm_db = require \"helm:helm-db\"\nlocal Session = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\nfunction Session.premiseCount(session)\n   local count = 0\n   for _, premise in ipairs(session) do\n      if premise.status == \"accept\" or premise.status == \"reject\" then\n         count = count + 1\n      end\n   end\n   return count\nend\n\n\n\n\n\n\n\nfunction Session.passCount(session)\n   local count = 0\n   for _, premise in ipairs(session) do\n      if premise.status == \"accept\" and premise.same then\n         count = count + 1\n      end\n   end\n   return count\nend\n\n\n\n\n\n\n\n\n\n\nlocal tabulate = assert(require \"repr:persist-tabulate\" . tabulate)\nfunction Session.evaluate(session, valiant, historian)\n   for _, premise in ipairs(session) do\n      local ok, result = valiant(premise.line)\n      -- #todo handle errors here\n\n      -- Avoid empty results\n      if result and result.n > 0 then\n         premise.live_result = result\n         -- #todo have the Historian handle this!\n         premise.new_result = tabulate(result, aG)\n      end\n      if premise.old_result and premise.new_result\n         and #premise.old_result == #premise.new_result then\n         premise.same = true\n         for i = 1, #premise.old_result do\n            if premise.old_result[i] ~= premise.new_result[i] then\n               premise.same = false\n               break\n            end\n         end\n      elseif (not premise.old_result) and (not premise.new_result) then\n         premise.same = true\n      else\n         premise.same = false\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _appendPremise(session, premise)\n   session.n = session.n + 1\n   session[session.n] = premise\nend\n\nfunction Session.loadPremises(session)\n   local stmt = session.stmts.get_session_by_id\n                  :bind(session.session_id)\n   for result in stmt:rows() do\n      -- Left join may produce (exactly one) row with no status value,\n      -- indicating that we have no premises\n      if result.status then\n         local premise = {\n            title = result.title,\n            status = result.status,\n            line = result.line,\n            old_line_id = result.line_id,\n            line_id = result.line_id, -- These will be filled if/when we re-run\n            live_result = nil,\n            old_result = send { to = \"hist\",\n                                method = \"resultsFor\",\n                                result.line_id },\n            new_result = nil\n         }\n         _appendPremise(session, premise)\n      end\n   end\nend\n\n\n\n\n\n\n\n\nfunction Session.append(session, line_id, line, results)\n   -- Require manual approval of all lines by default,\n   -- but do include them in the session, i.e. start with \'ignore\' status\n   local premise = {\n      title = \"\",\n      status = \'ignore\',\n      line = line,\n      old_line_id = nil,\n      line_id = line_id,\n      live_result = results,\n      old_result = nil, -- These will be filled in later once generated\n      new_result = nil\n   }\n   _appendPremise(session, premise)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Session.resultsAvailable(session, line_id, results)\n   for _, premise in ipairs(session) do\n      if premise.line_id == line_id then\n         premise.new_result = results\n         break\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal compact = assert(table.compact)\nfunction Session.save(session)\n   session.stmts.beginTransaction()\n   -- If the session itself hasn\'t been stored yet, do so and retrieve its id\n   if not session.session_id then\n      session.stmts.insert_session:bindkv(session):step()\n      session.session_id = session.stmts.lastRowId()\n   -- Otherwise possibly update its title and accepted status\n   else\n      session.stmts.update_session:bindkv(session):step()\n   end\n   -- First, remove any trashed premises from the session\n   for i, premise in ipairs(session) do\n      if premise.status == \"trash\" then session[i] = nil end\n   end\n   compact(session)\n   -- And now from the DB (the query picks up session.n directly)\n   session.stmts.truncate_session:bindkv(session):step()\n   -- Now insert all of our premises--anything that is already there\n   -- will be replaced thanks to ON CONFLICT REPLACE\n   for i, premise in ipairs(session) do\n      session.stmts.insert_premise\n            :bindkv{ session_id = session.session_id, ordinal = i }\n            :bindkv(premise)\n            :step()\n   end\n   session.stmts.commit()\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal collect = assert(table.collect)\nnew = function(db, project_id, title_or_index, cfg)\n   local session = setmetatable({}, Session)\n   session.stmts = helm_db.session(db)\n   session.project_id = project_id\n   session.n = 0\n   if type(title_or_index) == \"number\" then\n      local stmt = session.stmts.get_sessions_for_project\n      stmt:bind(session.project_id)\n      local results = collect(stmt.rows, stmt)\n      stmt:clearbind():reset()\n      -- An index can only be used when intending to load\n      -- so out-of-bounds is an immediate error\n      if #results < title_or_index then\n         error((\'Cannot load session #%d, only %d available.\')\n                  :format(title_or_index, #results))\n      end\n      local result = results[title_or_index]\n      session.session_id = result.session_id\n      session.session_title = result.session_title\n      session.accepted = result.accepted ~= 0\n   else\n      session.session_title = title_or_index\n      local result = session.stmts.get_session_by_project_and_title\n                        :bind(session.project_id, session.session_title)\n                        :stepkv()\n      if result then\n         session.session_id = result.session_id\n         session.accepted = result.accepted ~= 0\n      end\n   end\n   if cfg then\n      for k, v in pairs(cfg) do\n         session[k] = v\n      end\n   end\n   return session\nend\n\n\n\nSession.idEst = new\nreturn new\n\n",
name = "helm/session",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "2df7b7cdb2055d2be37c9b762653387337458860f792e78249deb4046f783a40",
binary = "\n\n\n\n\n-- This is a generated file. DO NOT EDIT!\n\nreturn {\n\nbcnames = \"ISLT  ISGE  ISLE  ISGT  ISEQV ISNEV ISEQS ISNES ISEQN ISNEN ISEQP ISNEP ISTC  ISFC  IST   ISF   ISTYPEISNUM MOV   NOT   UNM   LEN   ADDVN SUBVN MULVN DIVVN MODVN ADDNV SUBNV MULNV DIVNV MODNV ADDVV SUBVV MULVV DIVVV MODVV POW   CAT   KSTR  KCDATAKSHORTKNUM  KPRI  KNIL  UGET  USETV USETS USETN USETP UCLO  FNEW  TNEW  TDUP  GGET  GSET  TGETV TGETS TGETB TGETR TSETV TSETS TSETB TSETM TSETR CALLM CALL  CALLMTCALLT ITERC ITERN VARG  ISNEXTRETM  RET   RET0  RET1  FORI  JFORI FORL  IFORL JFORL ITERL IITERLJITERLLOOP  ILOOP JLOOP JMP   FUNCF IFUNCFJFUNCFFUNCV IFUNCVJFUNCVFUNCC FUNCCW\",\n\nirnames = \"LT    GE    LE    GT    ULT   UGE   ULE   UGT   EQ    NE    ABC   RETF  NOP   BASE  PVAL  GCSTEPHIOP  LOOP  USE   PHI   RENAMEPROF  KPRI  KINT  KGC   KPTR  KKPTR KNULL KNUM  KINT64KSLOT BNOT  BSWAP BAND  BOR   BXOR  BSHL  BSHR  BSAR  BROL  BROR  ADD   SUB   MUL   DIV   MOD   POW   NEG   ABS   ATAN2 LDEXP MIN   MAX   FPMATHADDOV SUBOV MULOV AREF  HREFK HREF  NEWREFUREFO UREFC FREF  STRREFLREF  ALOAD HLOAD ULOAD FLOAD XLOAD SLOAD VLOAD ASTOREHSTOREUSTOREFSTOREXSTORESNEW  XSNEW TNEW  TDUP  CNEW  CNEWI BUFHDRBUFPUTBUFSTRTBAR  OBAR  XBAR  CONV  TOBIT TOSTR STRTO CALLN CALLA CALLL CALLS CALLXSCARG  \",\n\nirfpm = { [0]=\"floor\", \"ceil\", \"trunc\", \"sqrt\", \"exp\", \"exp2\", \"log\", \"log2\", \"log10\", \"sin\", \"cos\", \"tan\", \"other\", },\n\nirfield = { [0]=\"str.len\", \"func.env\", \"func.pc\", \"func.ffid\", \"thread.env\", \"tab.meta\", \"tab.array\", \"tab.node\", \"tab.asize\", \"tab.hmask\", \"tab.nomm\", \"udata.meta\", \"udata.udtype\", \"udata.file\", \"cdata.ctypeid\", \"cdata.ptr\", \"cdata.int\", \"cdata.int64\", \"cdata.int64_4\", },\n\nircall = {\n[0]=\"lj_str_cmp\",\n\"lj_str_find\",\n\"lj_str_new\",\n\"lj_strscan_num\",\n\"lj_strfmt_int\",\n\"lj_strfmt_num\",\n\"lj_strfmt_char\",\n\"lj_strfmt_putint\",\n\"lj_strfmt_putnum\",\n\"lj_strfmt_putquoted\",\n\"lj_strfmt_putfxint\",\n\"lj_strfmt_putfnum_int\",\n\"lj_strfmt_putfnum_uint\",\n\"lj_strfmt_putfnum\",\n\"lj_strfmt_putfstr\",\n\"lj_strfmt_putfchar\",\n\"lj_buf_putmem\",\n\"lj_buf_putstr\",\n\"lj_buf_putchar\",\n\"lj_buf_putstr_reverse\",\n\"lj_buf_putstr_lower\",\n\"lj_buf_putstr_upper\",\n\"lj_buf_putstr_rep\",\n\"lj_buf_puttab\",\n\"lj_buf_tostr\",\n\"lj_tab_new_ah\",\n\"lj_tab_new1\",\n\"lj_tab_dup\",\n\"lj_tab_clear\",\n\"lj_tab_newkey\",\n\"lj_tab_len\",\n\"lj_gc_step_jit\",\n\"lj_gc_barrieruv\",\n\"lj_mem_newgco\",\n\"lj_math_random_step\",\n\"lj_vm_modi\",\n\"sinh\",\n\"cosh\",\n\"tanh\",\n\"fputc\",\n\"fwrite\",\n\"fflush\",\n\"lj_vm_floor\",\n\"lj_vm_ceil\",\n\"lj_vm_trunc\",\n\"sqrt\",\n\"exp\",\n\"lj_vm_exp2\",\n\"log\",\n\"lj_vm_log2\",\n\"log10\",\n\"sin\",\n\"cos\",\n\"tan\",\n\"lj_vm_powi\",\n\"pow\",\n\"atan2\",\n\"ldexp\",\n\"lj_vm_tobit\",\n\"softfp_add\",\n\"softfp_sub\",\n\"softfp_mul\",\n\"softfp_div\",\n\"softfp_cmp\",\n\"softfp_i2d\",\n\"softfp_d2i\",\n\"lj_vm_sfmin\",\n\"lj_vm_sfmax\",\n\"lj_vm_tointg\",\n\"softfp_ui2d\",\n\"softfp_f2d\",\n\"softfp_d2ui\",\n\"softfp_d2f\",\n\"softfp_i2f\",\n\"softfp_ui2f\",\n\"softfp_f2i\",\n\"softfp_f2ui\",\n\"fp64_l2d\",\n\"fp64_ul2d\",\n\"fp64_l2f\",\n\"fp64_ul2f\",\n\"fp64_d2l\",\n\"fp64_d2ul\",\n\"fp64_f2l\",\n\"fp64_f2ul\",\n\"lj_carith_divi64\",\n\"lj_carith_divu64\",\n\"lj_carith_modi64\",\n\"lj_carith_modu64\",\n\"lj_carith_powi64\",\n\"lj_carith_powu64\",\n\"lj_cdata_newv\",\n\"lj_cdata_setfin\",\n\"strlen\",\n\"memcpy\",\n\"memset\",\n\"lj_vm_errno\",\n\"lj_carith_mul64\",\n\"lj_carith_shl64\",\n\"lj_carith_shr64\",\n\"lj_carith_sar64\",\n\"lj_carith_rol64\",\n\"lj_carith_ror64\",\n},\n\ntraceerr = {\n[0]=\"error thrown or hook called during recording\",\n\"trace too short\",\n\"trace too long\",\n\"trace too deep\",\n\"too many snapshots\",\n\"blacklisted\",\n\"retry recording\",\n\"NYI: bytecode %d\",\n\"leaving loop in root trace\",\n\"inner loop in root trace\",\n\"loop unroll limit reached\",\n\"bad argument type\",\n\"JIT compilation disabled for function\",\n\"call unroll limit reached\",\n\"down-recursion, restarting\",\n\"NYI: unsupported variant of FastFunc %s\",\n\"NYI: return to lower frame\",\n\"store with nil or NaN key\",\n\"missing metamethod\",\n\"looping index lookup\",\n\"NYI: mixed sparse/dense table\",\n\"symbol not in cache\",\n\"NYI: unsupported C type conversion\",\n\"NYI: unsupported C function type\",\n\"guard would always fail\",\n\"too many PHIs\",\n\"persistent type instability\",\n\"failed to allocate mcode memory\",\n\"machine code too long\",\n\"hit mcode limit (retrying)\",\n\"too many spill slots\",\n\"inconsistent register allocation\",\n\"NYI: cannot assemble IR instruction %d\",\n\"NYI: PHI shuffling too complex\",\n\"NYI: register coalescing too complex\",\n},\n\nffnames = {\n[0]=\"Lua\",\n\"C\",\n\"assert\",\n\"type\",\n\"next\",\n\"pairs\",\n\"ipairs_aux\",\n\"ipairs\",\n\"getmetatable\",\n\"setmetatable\",\n\"getfenv\",\n\"setfenv\",\n\"rawget\",\n\"rawset\",\n\"rawequal\",\n\"unpack\",\n\"select\",\n\"tonumber\",\n\"tostring\",\n\"error\",\n\"pcall\",\n\"xpcall\",\n\"loadfile\",\n\"load\",\n\"loadstring\",\n\"dofile\",\n\"gcinfo\",\n\"collectgarbage\",\n\"newproxy\",\n\"print\",\n\"coroutine.status\",\n\"coroutine.running\",\n\"coroutine.isyieldable\",\n\"coroutine.create\",\n\"coroutine.yield\",\n\"coroutine.resume\",\n\"coroutine.wrap_aux\",\n\"coroutine.wrap\",\n\"math.abs\",\n\"math.floor\",\n\"math.ceil\",\n\"math.sqrt\",\n\"math.log10\",\n\"math.exp\",\n\"math.sin\",\n\"math.cos\",\n\"math.tan\",\n\"math.asin\",\n\"math.acos\",\n\"math.atan\",\n\"math.sinh\",\n\"math.cosh\",\n\"math.tanh\",\n\"math.frexp\",\n\"math.modf\",\n\"math.log\",\n\"math.atan2\",\n\"math.pow\",\n\"math.fmod\",\n\"math.ldexp\",\n\"math.min\",\n\"math.max\",\n\"math.random\",\n\"math.randomseed\",\n\"bit.tobit\",\n\"bit.bnot\",\n\"bit.bswap\",\n\"bit.lshift\",\n\"bit.rshift\",\n\"bit.arshift\",\n\"bit.rol\",\n\"bit.ror\",\n\"bit.band\",\n\"bit.bor\",\n\"bit.bxor\",\n\"bit.tohex\",\n\"string.byte\",\n\"string.char\",\n\"string.sub\",\n\"string.rep\",\n\"string.reverse\",\n\"string.lower\",\n\"string.upper\",\n\"string.dump\",\n\"string.find\",\n\"string.match\",\n\"string.gmatch_aux\",\n\"string.gmatch\",\n\"string.gsub\",\n\"string.format\",\n\"table.maxn\",\n\"table.insert\",\n\"table.concat\",\n\"table.sort\",\n\"table.new\",\n\"table.clear\",\n\"io.method.close\",\n\"io.method.read\",\n\"io.method.write\",\n\"io.method.flush\",\n\"io.method.seek\",\n\"io.method.setvbuf\",\n\"io.method.lines\",\n\"io.method.__gc\",\n\"io.method.__tostring\",\n\"io.open\",\n\"io.popen\",\n\"io.tmpfile\",\n\"io.close\",\n\"io.read\",\n\"io.write\",\n\"io.flush\",\n\"io.input\",\n\"io.output\",\n\"io.lines\",\n\"io.type\",\n\"os.execute\",\n\"os.remove\",\n\"os.rename\",\n\"os.tmpname\",\n\"os.getenv\",\n\"os.exit\",\n\"os.clock\",\n\"os.date\",\n\"os.time\",\n\"os.difftime\",\n\"os.setlocale\",\n\"debug.getregistry\",\n\"debug.getmetatable\",\n\"debug.setmetatable\",\n\"debug.getfenv\",\n\"debug.setfenv\",\n\"debug.getinfo\",\n\"debug.getlocal\",\n\"debug.setlocal\",\n\"debug.getupvalue\",\n\"debug.setupvalue\",\n\"debug.upvalueid\",\n\"debug.upvaluejoin\",\n\"debug.sethook\",\n\"debug.gethook\",\n\"debug.debug\",\n\"debug.traceback\",\n\"jit.on\",\n\"jit.off\",\n\"jit.flush\",\n\"jit.status\",\n\"jit.attach\",\n\"jit.util.funcinfo\",\n\"jit.util.funcbc\",\n\"jit.util.funck\",\n\"jit.util.funcuvname\",\n\"jit.util.traceinfo\",\n\"jit.util.traceir\",\n\"jit.util.tracek\",\n\"jit.util.tracesnap\",\n\"jit.util.tracemc\",\n\"jit.util.traceexitstub\",\n\"jit.util.ircalladdr\",\n\"jit.opt.start\",\n\"jit.profile.start\",\n\"jit.profile.stop\",\n\"jit.profile.dumpstack\",\n\"ffi.meta.__index\",\n\"ffi.meta.__newindex\",\n\"ffi.meta.__eq\",\n\"ffi.meta.__len\",\n\"ffi.meta.__lt\",\n\"ffi.meta.__le\",\n\"ffi.meta.__concat\",\n\"ffi.meta.__call\",\n\"ffi.meta.__add\",\n\"ffi.meta.__sub\",\n\"ffi.meta.__mul\",\n\"ffi.meta.__div\",\n\"ffi.meta.__mod\",\n\"ffi.meta.__pow\",\n\"ffi.meta.__unm\",\n\"ffi.meta.__tostring\",\n\"ffi.meta.__pairs\",\n\"ffi.meta.__ipairs\",\n\"ffi.clib.__index\",\n\"ffi.clib.__newindex\",\n\"ffi.clib.__gc\",\n\"ffi.callback.free\",\n\"ffi.callback.set\",\n\"ffi.cdef\",\n\"ffi.new\",\n\"ffi.cast\",\n\"ffi.typeof\",\n\"ffi.typeinfo\",\n\"ffi.istype\",\n\"ffi.sizeof\",\n\"ffi.alignof\",\n\"ffi.offsetof\",\n\"ffi.errno\",\n\"ffi.string\",\n\"ffi.copy\",\n\"ffi.fill\",\n\"ffi.abi\",\n\"ffi.metatype\",\n\"ffi.gc\",\n\"ffi.load\",\n},\n\n}\n\n",
name = "helm/vmdef",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "a3503c7346701cb6083b68e8d8e2dfbf5f2922922fb9228800f92bdc42cbe80a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n   watcher.dir = dir\n   -- default to a recursive watch\n   if recur == nil then\n      recur = true\n   end\n   local fse = uv.new_fs_event()\n   watcher.fse = fse\n   uv.fs_event_start(fse, dir,{recursive = recur},function (err,fname,status)\n      if(err) then\n         print(\"Error \"..err)\n      else\n         local ev = nil\n         for k,v in pairs(status) do\n            ev = k\n         end\n         if ev == \"change\" then\n            watcher:onchange(fname)\n         elseif ev == \"rename\" then\n            watcher:onrename(fname)\n         else\n            print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n         end\n      end\n   end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n\n",
name = "helm/watcher",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "720eb4ed6bfb72fc186ba8000ed96130e9fadc0c9ec2d9e10a0df38762bca10a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal string = core.string\nlocal instanceof = assert(core.meta.instanceof)\n\nlocal Txtbuf = require \"helm:buf/txtbuf\"\nlocal Rainbuf = require \"helm:buf/rainbuf\"\nlocal a = require \"anterm:anterm\"\n\n\n\nlocal Zone = meta {}\nlocal Zoneherd = meta {}\n\n\n\n\n\n\n\n\n\nfunction Zone.height(zone)\n   return zone.bounds:height()\nend\nfunction Zone.width(zone)\n   return zone.bounds:width()\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction Zone.clientBounds(zone)\n   if zone.border then\n      return zone.bounds:insetBy(Point(1,2))\n   else\n      return zone.bounds\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zone.overlaps(zone, other_zone)\n   -- One or both zones may be uninitialized--treat this as nonoverlapping\n   return zone.bounds\n      and other_zone.bounds\n      and zone.bounds:intersects(other_zone.bounds)\nend\n\n\n\n\n\n\n\n\nlocal function update_content_extent(zone)\n   if zone.bounds and zone.contents.is_rainbuf then\n      zone.contents:setExtent(zone:clientBounds():extent():rowcol())\n   end\nend\n\nfunction Zone.replace(zone, contents)\n   zone.contents = contents or \"\"\n   -- #todo shouldn\'t have to do this nearly as often--Zone contents will\n   -- change much less once Window refactoring is done--though this may still\n   -- be the right place to do it\n   update_content_extent(zone)\n   zone:beTouched()\n   return zone\nend\n\n\n\n\n\n\n\n\n\nlocal Rectangle  = require \"anterm/rectangle\"\nfunction Zone.setBounds(zone, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectangle(rect, ...)\n   end\n   rect:assertNotEmpty(\"Zone \'\" .. zone.name .. \"\' must have non-zero area\")\n   if zone.bounds ~= rect then\n      zone.bounds = rect\n      update_content_extent(zone)\n      -- Technically this could be incomplete in the case where we relinquish some cells,\n      -- but as long as every cell is covered by at least one Zone by the time layout is\n      -- complete, the new owner will figure things out.\n      zone:beTouched()\n   end\n   return zone\nend\n\n\n\n\n\n\nfunction Zone.setVisibility(zone, new_visibility)\n   if new_visibility ~= zone.visible then\n      zone.visible = new_visibility\n      zone:beTouched()\n   end\n   return zone\nend\n\nfunction Zone.show(zone)\n   return zone:setVisibility(true)\nend\nfunction Zone.hide(zone)\n   return zone:setVisibility(false)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Zone.beTouched(zone)\n   if zone.touched then return end\n   zone.touched = true\n   for _, other_zone in ipairs(zone.zoneherd) do\n      if zone.z ~= other_zone.z and\n         zone.visible == (other_zone.z > zone.z) and\n         zone:overlaps(other_zone) then\n         other_zone.touched = true\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal box = require \"anterm/box\"\nfunction Zone.paintBorder(zone, write)\n   if zone.border then\n      write(box[zone.border](zone.bounds))\n   end\nend\n\n\n\n\n\n\nfunction Zone.erase(zone, write)\n   write(a.erase.box(zone.bounds))\nend\n\n\n\n\n\n\nlocal function _nl(zone)\n   return a.jump.col(zone:clientBounds().left) .. a.jump.down(1)\nend\n\nlocal lines = assert(string.lines)\nlocal function _writeLines(write, zone)\n   local nl = _nl(zone)\n   local pr_row = zone.bounds.top\n   for line in lines(zone.contents) do\n       write(line, nl)\n       pr_row = pr_row + 1\n       if pr_row > zone.bounds.bottom then\n          break\n       end\n   end\nend\n\nlocal function _renderRainbuf(write, zone)\n   if not zone.contents then\n      return nil\n   end\n   assert(zone.contents.is_rainbuf)\n   local nl = _nl(zone)\n   for line in zone.contents:lineGen(zone:clientBounds():extent():rowcol()) do\n      write(line, nl)\n   end\nend\n\nfunction Zone.paint(zone, write)\n   if not (zone.visible and zone.touched) then\n      return\n   end\n   zone:erase(write)\n   zone:paintBorder(write)\n   if zone.contents then\n      write(a.jump(zone:clientBounds():origin()))\n      -- actually render ze contents\n      if type(zone.contents) == \"string\" then\n         _writeLines(write, zone)\n      else\n         _renderRainbuf(write, zone)\n      end\n   end\n   zone.touched = false\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Zoneherd.addZone(zoneherd, zone)\n   zoneherd[zone.name] = zone\n   zone.zoneherd = zoneherd\n   local insert_index\n   for i, existing in ipairs(zoneherd) do\n      if existing.z > zone.z then\n         insert_index = i\n         break\n      end\n   end\n   if insert_index then\n      insert(zoneherd, insert_index, zone)\n   else\n      insert(zoneherd, zone)\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\n\nlocal function newZone(name, z, debug_mark)\n   local zone = setmetatable({}, Zone)\n   zone.name = name\n   zone.debug_mark = debug_mark\n   zone.z = z\n   zone.visible = true\n   zone.touched = false\n   zone.contents = \'\'\n   return zone\nend\n\nfunction Zoneherd.newZone(zoneherd, name, z, debug_mark)\n   return zoneherd:addZone(newZone(name, z, debug_mark))\nend\n\n\n\n\n\n\nlocal function _zoneOffset(modeS)\n   local width = modeS.max_extent.col\n   if width <= 80 then\n      return 20\n   elseif width <= 100 then\n      return 30\n   elseif width <= 120 then\n      return 40\n   else\n      return 50\n   end\nend\n\n\n\n\n\n\nlocal ceil, floor = assert(math.ceil), assert(math.floor)\n\nfunction Zoneherd.reflow(zoneherd, modeS)\n   local right_col = modeS.max_extent.col - _zoneOffset(modeS)\n   local txt_off = modeS:agent\'edit\':continuationLines()\n   zoneherd.status:setBounds(  1, 1, 1, right_col)\n   zoneherd.stat_col:setBounds(1, right_col + 1,\n                               1, modeS.max_extent.col )\n   zoneherd.prompt:setBounds(  modeS.repl_top,\n                               1,\n                               modeS.repl_top + txt_off,\n                               modeS.PROMPT_WIDTH )\n   zoneherd.command:setBounds( modeS.repl_top,\n                               modeS.PROMPT_WIDTH + 1,\n                               modeS.repl_top + txt_off,\n                               right_col )\n   local results_right\n   if zoneherd.suggest.visible then\n      results_right = right_col\n      zoneherd.suggest:setBounds( modeS.repl_top + 1,\n                                  right_col + 1,\n                                  modeS.max_extent.row,\n                                  modeS.max_extent.col )\n   else\n      results_right = modeS.max_extent.col\n   end\n   zoneherd.results:setBounds( modeS.repl_top + txt_off + 1,\n                               1,\n                               modeS.max_extent.row,\n                               results_right )\n   -- Popup is centered and 2/3 of max width, i.e. from 1/6 to 5/6\n   zoneherd.popup:setBounds(   modeS.repl_top + txt_off + 1,\n                               floor(modeS.max_extent.col / 6),\n                               modeS.max_extent.row,\n                               ceil(modeS.max_extent.col * 5 / 6) )\n   -- Modal is centered vertically and horizontally, with the extent\n   -- determined by the contents. Modal only tells us the client area\n   -- required, we must account for the borders--seems like a good\n   -- division of responsibility.\n   if zoneherd.modal.visible then\n      local modal_extent = modeS:agent\'modal\'.subject:requiredExtent() + Point(2, 4)\n      local margins = ((modeS.max_extent - modal_extent) / 2):floor()\n      zoneherd.modal:setBounds(margins.row, margins.col,\n                               (margins + modal_extent - 1):rowcol())\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zoneherd.paint(zoneherd, modeS)\n   local write = zoneherd.write\n   write(a.cursor.hide(), a.clear())\n   for i, zone in ipairs(zoneherd) do\n      -- Process queued commands from the `source` of our Rainbufs\n      if zone.contents.is_rainbuf then\n         if zone.contents:processQueuedMessages() then\n            zone:beTouched()\n         end\n         -- #deprecated\n         if zone.contents:checkTouched() then\n            zone:beTouched()\n         end\n      end\n   end\n   for i, zone in ipairs(zoneherd) do\n      zone:paint(write)\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\n\nlocal function new(modeS, writer)\n   local zoneherd = setmetatable({}, Zoneherd)\n   zoneherd.write = writer\n   -- make Zones\n   -- correct values are provided by reflow\n   zoneherd:newZone(\"status\", 1, \".\")\n   zoneherd:newZone(\"stat_col\", 1, \"!\")\n   zoneherd:newZone(\"prompt\", 1, \">\")\n   zoneherd:newZone(\"command\", 1, \"$\")\n   zoneherd:newZone(\"results\", 1, \"~\")\n   zoneherd:newZone(\"suggest\", 1, \"%\")\n   zoneherd:newZone(\"popup\", 2, \"^\")\n   zoneherd.popup.visible = false\n   zoneherd.popup.border = \"light\"\n   zoneherd:newZone(\"modal\", 2, \"?\")\n   zoneherd.modal.visible = false\n   zoneherd.modal.border = \"light\"\n\n   return zoneherd\nend\n\n\n\nreturn new\n\n",
name = "helm/zone",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
  { 
branch = "migration-7",
hash = "aa93b3d71f25541d1b6c8c9ff575c549e87ddc341ba9a6cdfbacbcdf0355d837",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n--[[\nprofile = require(\"jit.profile\")\nprofiled = {}\nprofile.start(\"li1\", function(th, samples, vmmode)\n   local d = profile.dumpstack(th, \"pFZ;\", 6)\n   profiled[d] = (profiled[d] or 0) + samples\nend)\n--]]\n\n\n\nassert(true)\nif rawget(_G, \"_Bridge\") then\n   _Bridge.helm = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __G = setmetatable({}, {__index = _G})\n__G.__G = __G\n\n\n\n\n\n\n\n\nlocal function _helm(_ENV)\n\n\n\n\n\nsetfenv(0, __G)\n\nmeta = assert(require \"core:cluster\" . Meta)\ncore = require \"qor:core\"\n-- Keep this local, other modules will do the same as-needed\n-- We need it below for `compact`\nlocal table = core.table\nkit = require \"valiant:replkit\"\njit.vmdef = require \"helm:helm/vmdef\"\njit.p = require \"helm:helm/ljprof\"\nsql = assert(sql, \"sql must be in _G\")\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.chatty = true\ns.verbose = true\ns.boring = false\nts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsend = nil;\ndo\n   local Message = require \"actor:message\"\n   local nest = core.thread.nest \"actor\"\n   local yield = assert(nest.yield)\n\n   send = function (tab)\n      return yield(Message(tab))\n   end\nend\n\n\n\n\n\n\n\nuv = require \"luv\"\nlocal usecolors\nstdout = \"\"\n\n\n\n\n\n\n\n\n\n\nif uv.guess_handle(1) == \'tty\' then\n   stdout = uv.new_tty(1, false)\n   usecolors = true\nelse\n   stdout = uv.new_pipe(false)\n   uv.pipe_open(utils.stdout, 1)\n   usecolors = false\nend\n\n\n\n\n\nlocal function write(...)\n   uv.write(stdout, {...})\nend\n\n\n\nlocal concat = assert(table.concat)\n\nfunction print(...)\n   local n = select(\'#\', ...)\n   local arguments = {...}\n   for i = 1, n do\n      arguments[i] = tostring(arguments[i])\n   end\n   uv.write(stdout, concat(arguments, \"\\t\") .. \"\\n\")\nend\n\n\n\n\n\n\nif uv.guess_handle(0) ~= \'tty\' or\n   uv.guess_handle(1) ~= \'tty\' then\n   -- Bail if we\'re in a pipe\n   error \"stdio must be a tty\"\nend\n\nlocal stdin = uv.new_tty(0, true)\n\n\n\n\n\na = require \"anterm:anterm\"\nlocal Point = require \"anterm:point\"\n\n\n\n\n\n\n\n\n\nlocal autothread = require \"cluster:autothread\"\n\n\n\n\n\n\n\n\nlocal max_col, max_row = stdin:get_winsize()\nlocal max_extent = Point(max_row, max_col)\nmodeS = require \"helm/modeselektor\" (max_extent, write)\n\nautothread(function() modeS:task():setup() end)\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function check_winsize()\n   max_col, max_row = stdin:get_winsize()\n   max_extent = Point(max_row, max_col)\n   if max_extent ~= modeS.max_extent then\n      modeS.max_extent = max_extent\n      -- Mark all zones as touched since we don\'t know the state of the screen\n      -- (some terminals, iTerm for sure, will attempt to reflow the screen\n      -- themselves and fail miserably)\n      for _, zone in ipairs(modeS.zones) do\n         zone.touched = true\n      end\n      modeS:task():reflow()\n   end\nend\n\nlocal winsize_watch = uv.new_timer()\n-- winsize_watch:start(500, 500, check_winsize)\nlocal winsize_signal = uv.new_signal()\nwinsize_signal:start(\"sigwinch\", check_winsize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _ditch = false\n\nlocal parse_input = require \"anterm:input-parser\"\n\nlocal should_dispatch_all = false\nlocal input_timer = uv.new_timer()\nlocal input_check = uv.new_check()\nlocal input_buffer = \"\"\n\nlocal function is_scroll(event)\n   return event.type == \"mouse\" and event.scrolling\nend\n\nlocal compact = assert(table.compact)\n\nlocal function consolidate_scroll_events(events)\n   -- We\'re going to nil-and-compact, so convert to ntable\n   events.n = #events\n   local i = 1\n   while i <= events.n do\n      local j = i + 1\n      if is_scroll(events[i]) then\n         events[i].num_lines = 1\n         while j <= events.n\n            and is_scroll(events[j])\n            and events[j].key == events[i].key do\n            events[i].num_lines = events[i].num_lines + 1\n            events[j] = nil\n            j = j + 1\n         end\n      end\n      i = j\n   end\n   compact(events)\nend\n\n\n\n\n\n\n\n\nlocal Set = core.set\n\nlocal stoppable = Set { \'idle\',\n                        \'check\',\n                        \'prepare\',\n                        \'timer\',\n                        \'poll\',\n                        \'signal\',\n                        \'fs_event\',\n                        \'fs_poll\' }\n\nlocal function shutDown(modeS)\n   _ditch = true\n   uv.read_stop(stdin)\n   winsize_watch:stop()\n   winsize_watch:close()\n   winsize_signal:stop()\n   winsize_signal:close()\n   input_timer:stop()\n   input_timer:close()\n   input_check:stop()\n   input_check:close()\n   uv.walk(function(handle)\n      if not (handle == stdin or handle == stdout) then\n         local h_type = uv.handle_get_type(handle)\n         if stoppable[h_type] then\n            io.stderr:write(\"Stopping a leftover \", h_type, \" \", tostring(handle), \"\\n\")\n            handle:stop()\n         end\n         if not handle:is_closing() then\n            io.stderr:write(\"Closing a leftover \", h_type, \" \", tostring(handle), \"\\n\")\n            handle:close()\n         end\n      end\n   end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function dispatch_input(seq, dispatch_all)\n   -- Clear the flag and timer indicating whether we should clear down the\n   -- input buffer this cycle. We explicitly stop the timer in case another\n   -- loop iteration occurs before the 5ms delay elapses (e.g. due to an\n   -- idler). We must use a timer with a nonzero delay because it seems that\n   -- the loop sometimes fails to retrieve input that should logically already\n   -- be present (e.g. due to a large paste) unless we wait.\n   should_dispatch_all = false\n   input_timer:stop()\n   -- Try parsing, letting the parser know whether it should definitely consume\n   -- everything it can or hold off on possible incomplete escape sequences\n   local events, pos = parse_input(seq, dispatch_all)\n   input_buffer = seq:sub(pos)\n   if #input_buffer > 0 then\n      if dispatch_all then\n         -- If it\'s been a little while and we still have stuff we can\'t parse,\n         -- figure we might have something actually invalid.\n         -- #todo perform some kind of useful error recovery here\n         error(\"Unparseable input encountered:\\n\" .. input_buffer)\n      else\n         -- Use a timer to wait until all available input has arrived to\n         -- set the flag that will cause our check handler to clear the\n         -- input buffer. If more input is available sooner than the 5ms\n         -- timeout, it will be processed immediately and the timer reset.\n         -- This is (hopefully) an upper bound on how long it will take the\n         -- next chunk of a large paste to arrive.\n         local should_dispatch_all = false\n         input_timer:start(5, 1, function()\n            if not should_dispatch_all then\n               should_dispatch_all = true\n               return\n            end\n            input_timer:stop()\n            if #input_buffer > 0 then\n               autothread(dispatch_input, input_buffer, true)\n            end\n         end)\n      end\n   end\n   consolidate_scroll_events(events)\n   for _, event in ipairs(events) do\n      modeS(event)\n      s:bore \"handled an event\"\n      -- Okay, if the action resulted in a quit, break out of the event loop\n      if modeS.has_quit then\n         shutDown(modeS)\n         break\n      end\n   end\n   s:bore \"escaped dispatch_input\"\nend\n\n\n\n\nlocal counter = 0\ninput_check:start(function()\n      counter = counter + 1\n   if should_dispatch_all and #input_buffer > 0 then\n      autothread(dispatch_input, input_buffer, true)\n   end\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal onseq_err\n\nlocal function onseq(err, seq)\n   if _ditch then return nil end\n   local success, err_trace = xpcall(function()\n      if err then error(err) end\n      autothread(dispatch_input, input_buffer .. seq, false)\n   end, debug.traceback)\n   s:bore \"escaped onseq\"\n   if not success then\n      shutDown(modeS)\n      onseq_err = err_trace\n   end\nend\n\n\n\n\n\n\n\n\nlocal sighup_handler = uv.new_signal()\nsighup_handler:start(\"sighup\", function()\n   shutDown(modeS)\nend)\n\n\n\n\n-- Get names for as many values as possible\n-- into the colorizer\n-- Treat package names as existing in the global namespace\n-- rather than having a \"package.loaded.\" prefix\nlocal names = require \"repr:repr/names\"\nnames.loadNames(package.loaded)\nnames.loadNames(_G)\nnames.loadNames(__G)\n\n-- assuming we survived that, set up our repling environment:\n\n-- raw mode\nuv.tty_set_mode(stdin, 2)\n\n-- Enable mouse tracking, save the cursor, switch screens and wipe,\n-- then put the cursor at 1,1.\n-- #todo Cursor save/restore supposedly may not work on all terminals?\n-- Test this and, if necessary, explicitly read and store the cursor position\n-- and manually restore it at the end.\nwrite(a.cursor.stash(),\n      a.alternate_screen(true),\n      a.erase.all(),\n      a.jump(1, 1),\n      a.paste_bracketing(true),\n      a.mouse.track(true),\n      a.mouse.sgr_mode(true)\n)\nuv.read_start(stdin, onseq)\n\n-- initial layout and paint screen\nmodeS:task():reflow()\n\n--[[ stop profiler if we\'re using it to measure startup time\nprofile.stop()\n--]]\n\n-- main loop\nuv.run()\n\n-- Teardown: Mouse tracking off, restore main screen and cursor\nio.stdout:write(a.mouse.sgr_mode(false),\n                a.mouse.track(false),\n                a.paste_bracketing(false),\n                a.alternate_screen(false),\n                a.cursor.pop(),\n                a.cursor.show())\n\n-- Back to normal mode\nuv.tty_reset_mode()\n\nstdin:close()\nstdout:close()\n\n-- Make sure the terminal processes all of the above,\n-- then remove any spurious mouse inputs or other stdin stuff\nio.stdout:flush()\nio.stdin:read \"*a\"\n\n-- Shut down the database conn:\nlocal helm_db = require \"helm:helm/helm-db\"\nhelm_db.close()\n\n-- If helm is shutting down due to an error, print the stacktrace\n-- now that the terminal is in a known-good state\nif (onseq_err) then\n   io.stderr:write(onseq_err)\nend\n\n-- Restore the global environment\nsetfenv(0, _G)\nend -- of _helm\n\n\n\n\n\nreturn setfenv(_helm, __G)\n\n",
name = "helm",
vc_hash = "5e67e072378a8f191b77f744e906970912b73f7f\n",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/lash.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "lash",
    repo = "git@gitlab.com:special-circumstance/lash.git\n",
},
  version = {    special = "no",
    edition = "",
    stage = "SNAPSHOT",
    major = 0,
    patch = 0,
    minor = 0,
},
  modules = {   { 
branch = "2022-02-28_RELEASE_BRANCH",
hash = "dea351a621368c880274866db9e78ba7423bb1fe82fcc88b4cf94a955c28ffe7",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Sh = {}\n\n\n\n\n-- make a safe-escaped, POSIX-compliant literal string,\n-- with the \'quote marks\'\nlocal function sh_str(str)\n    return table.concat {\"\'\", str:gsub(\"\'\", \"\'\\\\\'\'\"), \"\'\"}\nend\n-- borrowed with gratitude from:\n-- https://github.com/zserge/luash/blob/master/sh.lua\n\n-- converts key and it\'s argument to \"-k\" or \"-k=v\" or just \"\"\nlocal function arg(k, a)\n    if not a then return k end\n    if type(a) == \'string\' and #a > 0 then return k .. \'=\' .. sh_str(a) end\n    if type(a) == \'number\' then return k..\'=\'..tostring(a) end\n    if type(a) == \'boolean\' and a == true then return k end\n    error(\'invalid argument type \' .. type(a) .. \" \" .. tostring(a))\nend\n\n-- converts nested tables into a flat list of arguments and concatenated input\nlocal function flatten(t)\n    local result = {args = {}}\n\n    local function f(t)\n        local keys = {}\n        for k = 1, #t do\n            keys[k] = true\n            local v = t[k]\n            if type(v) == \'table\' then\n                f(v)\n            else\n                table.insert(result.args, v)\n            end\n        end\n        for k, v in pairs(t) do\n            if k == \'__input\' then\n                result.input = result.input or \'\'\n                result.input = result.input .. v\n            elseif not keys[k] and k:sub(1, 1) ~= \'_\' then\n                local key = \'-\'..k\n                if #k > 1 then key = \'-\' ..key end\n                table.insert(result.args, arg(key, v))\n            end\n        end\n    end\n\n    f(t)\n    return result\nend\n\n-- returns a function that executes the command with given args and returns its\n-- output, exit status etc\nlocal function command(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n        local p = io.popen(s, \'r\')\n        local output = p:read(\'*a\')\n        local _, exit, status = p:close()\n\n        local t = {\n            __input = output,\n            __exitcode = exit == \'exit\' and status or 127,\n            __signal = exit == \'signal\' and status or 0,\n        }\n        local mt = {\n            __index = function(self, k)\n                return command(k)\n            end,\n            __tostring = function(self)\n                -- return trimmed command output as a string\n                return self.__input:match(\'^%s*(.-)%s*$\')\n            end,\n            __repr = function(self)\n                return string.gmatch(self.__input, \"[^\\n]+\")\n            end\n        }\n        return setmetatable(t, mt)\n    end\nend\n\n-- export command() function\nSh.command = command\n\n\n\n\n\n\n\n\n\nlocal function preview(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n       return s\n    end\nend\n\nSh.preview = preview\n\n\n\n\n\n-- allow to call sh to run shell commands\nlocal Sh_M = {\n    __call = function(_, cmd, ...)\n        return command(cmd, ...)()\n    end,\n    __index = function(_, field)\n        return command(field)\n    end\n}\nsetmetatable(Sh, Sh_M)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.install(_Global)\n    local Global\n    local VER = string.sub( assert( _VERSION ), -4 )\n    if _Global and _Global ~= Sh then\n        Global = _Global\n    elseif VER == \" 5.1\" then\n        Global = getfenv()\n    else\n        Global = _ENV\n    end\n    local G_mt, G_index = nil, nil\n    local at_top = false\n    local our_mt = false\n    while not at_top do\n        local maybe_mt = getmetatable(Global)\n        if not maybe_mt then\n            at_top = true\n        else\n            -- we have a metatable\n            G_mt = maybe_mt\n            -- but is it the ultimate?\n            if G_mt.__index then\n                if type(G_mt.__index) == \"function\" then\n                    at_top = true\n                    G_index = G_mt.__index\n                elseif getmetatable(G_mt.__index) then\n                    at_top = false\n                    Global = G_mt.__index\n                else\n                    at_top = true\n                    G_index = G_mt.__index\n                end\n            else\n                at_top = true\n            end\n        end\n    end\n    -- if _ENV has no metatable, let\'s make one:\n    if not G_mt then\n        our_mt = true\n        G_mt = {}\n    end\n    -- *now* we can monkey-patch the global environment\n    local __index_fn\n    -- three flavors:\n    if not G_index then\n        __index_fn = function(_, cmd)\n                        return command(cmd)\n                     end\n    elseif type(G_index) == \"table\" then\n        __index_fn = function(_, key)\n                        local v = rawget(G_index, key)\n                        if v ~= nil then return v end\n                        return command(key)\n                     end\n    elseif type(G_index) == \"function\" then\n        __index_fn = function(_, key)\n                        local ok, v = pcall(G_index, _, key)\n                        if ok and (v ~= nil) then return v end\n                        return command(key)\n                     end\n    end\n    --- now set the metatable:\n    G_mt.__index = __index_fn\n    setmetatable(Global, G_mt)\n    -- stash the components for later removal\n    -- put them on the metatable to avoid polluting the\n    -- command space\n    Sh_M.__cache = { Global = Global,\n                     our_mt = our_mt,\n                     G_index = G_index,\n                     index_fn = __index_fn }\n    -- return Sh for convenience\n    return Sh\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.remove()\n    if not Sh_M.__cache then\n        -- didn\'t patch the namespace,\n        -- or already removed it\n        return nil\n    end\n    local cache = Sh_M.__cache\n    if cache.our_mt then\n        -- we made the metatable, let\'s remove the whole thing\n        setmetatable(cache.Global, nil)\n    else\n        -- if there was no G_index this will set it to nil\n        -- but only if our index function is still present.\n        local G_mt = getmetatable(cache.Global)\n        if G_mt.__index == cache.index_fn then\n            G_mt.__index = cache.G_index\n        end\n    end\n    -- remove cache\n    Sh_M.__cache = nil\nend\n\n\n\nreturn Sh\n\n",
name = "lash",
vc_hash = "e1ecc0c8802ce66ad9f70bf068a9a333758b2871\n",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/lon.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "lon",
    repo = "git@gitlab.com:special-circumstance/lon.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "5690580110a17177a04aaed56bbdf5ad37a452a3f6d2f34dabed3d93139923a7",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\nlocal s = require \"status:status\" ()\n\n\nlocal loml_str = [=[\n\n;; Overall Structure\n\n   loml    <-  expression (nl expression)* (wschar / nl)* Error?\n\n`expression` <-  ws keyval ws comment?\n             /  ws table  ws comment?\n             /  ws comment\n             /  ws &nl\n\n;; Whitespace\n\n        `ws`  <-  {\\t }*\n    `wschar`  <-  {\\t }+\n\n;; Newline\n\n        `nl`  <- \"\\n\" / \"\\r\\n\"\n\n;; Comment\n\n     comment  <- \"#\" (!nl 1)*\n\n;; Key-Value pairs\n\n      keyval  <-  key ws \"=\" ws val\n               /  key ws \"=\" ws Error\n\n         key  <-  dotted-key / simple-key\n\n`simple-key`  <-  quoted-key / unquoted-key\n\nunquoted-key  <-  ([A-Z] / [a-z] / [0-9] / \"-\" / \"_\")+\n\n  quoted-key  <-  basic-string / literal-string\n\n  dotted-key  <-  simple-key (ws \".\" ws simple-key)+\n\n         val  <-  string / boolean / array / inline-table\n                  / date-time / float / integer\n\n;; String\n\n        `string`  <-  ml-basic-string   / basic-string\n                  /   ml-literal-string / literal-string\n\n;; Note: this isn\'t technically TOML, because we\'ll use Lua string\n;; conventions. I have no interest in implementing \\u.\n\n    basic-string  <-  \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n                  /   \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* &\"\\n\" Error\n\n ml-basic-string  <- \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' 1) / &\'\"\"\"\"\' \'\"\')* \'\"\"\"\'\n                  /  \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' !-2 1))* Error\n\n  literal-string  <-  \"\'\"  (!\"\'\" !\"\\n\" 1)* \"\'\"\n                  /   \"\'\"  (!\"\'\" !\"\\n\" 1)* &\"\\n\" Error\n\nml-literal-string <- \"\'\'\'\" (!\"\'\'\'\" 1 / (&\"\'\'\'\'\" !\"\'\'\'\'\'\'\") \"\'\")* \"\'\'\'\"\n                  /  \"\'\'\'\" (!\"\'\'\'\" !-2 1)* Error\n\n;; Integer\n\n    integer  <-  hexadecimal / octal / binary / decimal\n\n    decimal  <-  sign? dec-int\n\n       sign  <-  \"+\" / \"-\"\n\n  `dec-int`  <-  [1-9] ([0-9] / \"_\" [0-9])+ / [0-9]\n\nhexadecimal  <-  \"0x\" higit (higit / \"_\" higit)*\n\n    `higit`  <- [A-F] / [a-f] / [0-9]\n\n      octal  <- \"0o\" [0-7] ([0-7] / \"_\" [0-7])*\n\n     binary  <- \"0b\" [0-1] ([0-1] / \"_\" [0-1])*\n\n;; Float\n\nfloat <- decimal \".\" decimal* ((\"e\" / \"E\") \"-\"? decimal)?\n      /  special-float\n\nspecial-float = sign? (\"inf\" / \"nan\")\n\n;; Boolean\n\nboolean = \"true\" / \"false\"\n\n;;; Not in the mood to port dates from \'ortho8600\'\n;; Date and Time (as defined in RFC 3339)\n\ndate-time <- \"placeholder@#$%@$#%\"\n\n;; Offset Date-Time\n\noffset-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date-Time\n\nlocal-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date\n\nlocal-date <- \"placeholder@#$%@$#%\"\n\n;; Local Time\n\nlocal-time <- \"placeholder@#$%@$#%\"\n\n;; Array\n\n        array  <-  \"[\" array-values? opt-comment \"]\"\n\n`opt-comment`  <-  (ws comment? nl ws)+ / ws\n\n array-values  <-  opt-comment val (opt-comment \",\" opt-comment val)* \",\"*\n\n;; Table\n\ntable  <-  std-table / array-table\n\n;; Standard Table\n\nstd-table  <-  \"[\" ws key ws \"]\"\n\n;; Inline Table\n\ninline-table <-  \"{\" ws (keyval (ws \",\" ws keyval)*)* ws \"}\"\n\n;; Array Table\n\narray-table <- \"[[\" ws key ws \"]]\"\n\n;; Error\n\nError  <-  1+\n]=]\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub, gsub, byte, format = assert(string.sub),\n                                assert(string.gsub),\n                                assert(string.byte),\n                                assert(string.format)\n\n\n\n\nlocal Twig = Node:inherit()\n\n\n\n\n\n\nfunction Twig.value(twig)\n   return twig:span()\nend\n\n\n\n\nlocal Loml = Twig :inherit \'loml\'\n\nfunction Loml.toTable(loml)\n   local tab = {}\n   local work = tab\n   for _, twig in ipairs(loml) do\n      work = twig:toTable(tab, work)\n   end\n   return tab\nend\n\n\n\nlocal Keyval = Twig: inherit \'keyval\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _noredefine(tab, field, node)\n   if tab[field] ~= nil then\n      local line, col = node:linePos()\n      local errmsg = format(\"attempt to redefine field \'%s\'\"\n                             ..\" at line %d, column %d\", field, line, col)\n      error(errmsg, 2)\n   end\nend\n\nlocal function _lvalue(tab, keynode)\n   if keynode[1].id ~= \'dotted_key\' then\n      local val = keynode:value()\n      _noredefine(tab, val, keynode)\n      return tab, val\n   else\n      local to_assign = tab\n      keynode = keynode[1]\n      for i = 1, #keynode - 1 do\n         local val = keynode[i]:value()\n         to_assign[val] = to_assign[val] or {}\n         to_assign = to_assign[val]\n      end\n      local val = keynode[#keynode]:value()\n      _noredefine(to_assign, val, keynode[#keynode])\n      return to_assign, val\n   end\nend\n\n\nfunction Keyval.toTable(keyval, tab, work)\n   if keyval[2].id == \'Error\' then\n      s:halt(\"erroneous value at line %d, col %d\", keyval[2]:linePos())\n   end\n   -- this part is actually a bit tricky, since we need to assign to the\n   -- correct field in a table with potentially unbounded subtables, e.g.\n   -- table.subtable.\"deep subtable\" etc.\n   local lval, lfield = _lvalue(work, keyval[1])\n   lval[lfield] = keyval[2]:value()\n   return work\nend\n\n\n\nlocal Val = Twig :inherit \'val\'\n\nfunction Val.value(val)\n   return val[1]:value()\nend\n\n\n\n\nlocal QuotedKey = Twig :inherit \'quoted_key\'\n\nfunction QuotedKey.value(quote)\n   return quote[1]:value()\nend\n\n\n\n\n\n\nlocal Table = Twig :inherit \'table\'\n\nfunction Table.toTable(tabnode, tab, work)\n   return tabnode[1]:toTable(tab, work)\nend\n\n\n\nlocal StdTable = Twig :inherit \'std_table\'\n\nfunction StdTable.toTable(std_tab, tab, work)\n   local lval, field = _lvalue(tab, std_tab[1])\n   lval[field] = lval[field] or {}\n   return lval[field]\nend\n\n\n\nlocal ArrayTable = Twig :inherit \'array_table\'\n\nfunction ArrayTable.toTable(array, tab, work)\n   local lval, field = _lvalue(tab, array[1])\n   -- get or create table\n   lval[field] = lval[field] or {}\n   -- create subtable\n   lval[field][#lval[field] + 1] = {}\n   return lval[field][#lval[field]]\nend\n\n\n\nlocal InlineTable = Twig :inherit \'inline_table\'\n\nfunction InlineTable.value(inline)\n   local work = {}\n   for keyval in inline :select \'keyval\' do\n      keyval:toTable(nil, work)\n   end\n   return work\nend\n\n\n\n\n\n\n\n\nlocal Array = Twig :inherit \'array\'\n\nfunction Array.value(arraynode)\n   local array = {}\n   local vals = arraynode :select \'array_values\' ()\n   if not vals then return array end\n   for _, val in ipairs(vals) do\n      array[#array + 1] = val:value()\n   end\n   return array\nend\n\n\n\n\n\n\n\nlocal LiteralString = Twig :inherit \'literal_string\'\n\nfunction LiteralString.value(litstr)\n   return sub(litstr.str, litstr.first + 1, litstr.last - 1)\nend\n\n\n\n\nlocal BasicString = Twig :inherit \'basic_string\'\n\nfunction BasicString.value(str)\n   return setfenv(load(\"return \".. str:span()), {})()\nend\n\n\n\nlocal MLLiteralString = Twig :inherit \'ml_literal_string\'\n\nfunction MLLiteralString.value(litstr)\n   -- have to skip a leading newline\n   local front = byte(litstr.str, litstr.first + 3) == 10 and 4 or 3\n   return sub(litstr.str, litstr.first + front, litstr.last - 3)\nend\n\n\n\nlocal MLBasicString = Twig :inherit \'ml_basic_string\'\n\nfunction MLBasicString.value(mlstr)\n   local span = mlstr:span()\n   local front = byte(span, 4) == 10 and 5 or 4\n   -- clip front and back\n   -- do \\ substitution\n   -- replace newlines with \\n\n   -- unescape any \\\" to \"\n   -- escape \" (which happens to undo any effect of the above!)\n   -- replace \\\\\" with \\\\\\\" (yeah. we have to. I know. but we do.)\n   -- now we have a string, load it prepended with \'return \' and\n   -- in a clean fenv for good measure!\n   return setfenv(load(\'return \"\' .. sub(span, front, -4)\n                        :gsub(\'\\\\%s+\', \"\")\n                        :gsub(\'\\n\', \"\\\\n\")\n                        :gsub(\'\\\\\"\', \'\"\')\n                        :gsub(\'\"\', \'\\\\\"\')\n                        :gsub(\'\\\\\\\\\"\', \'\\\\\\\\\\\\\"\') .. \'\"\'), {})()\n   --]]\nend\n\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nlocal function tonum(num)\n   return tonumber((gsub(num, \"_\", \"\")))\nend\n\n\n\n\n\n\nlocal Integer = Twig :inherit \'integer\'\n\nfunction Integer.value(int)\n   return int[1]:value()\nend\n\n\n\nlocal Float = Twig :inherit \'float\'\n\nfunction Float.value(float)\n   return tonum(float:span())\nend\n\n\n\nlocal Decimal = Twig :inherit \'decimal\'\n\nDecimal.value = Float.value\n\n\n\nlocal Hex = Twig :inherit \'hexadecimal\'\n\nHex.value = Float.value\n\n\n\nlocal Octal = Twig :inherit \'octal\'\n\nfunction Octal.value(octal)\n   return tonum(octal.str:sub(octal.first + 2, octal.last), 8)\nend\n\n\n\nlocal Binary = Twig :inherit \'binary\'\n\nfunction Binary.value(binary)\n   return tonum(binary.str:sub(binary.first + 2, binary.last), 2)\nend\n\n\n\n\n\n\nlocal Boolean = Twig :inherit \'boolean\'\n\nfunction Boolean.value(boolean)\n   -- we just check if the first letter is \'t\'\n   return byte(boolean.str, boolean.first) == 116 and true or false\nend\n\n\n\n\n\n\nlocal Comment = Twig :inherit \'comment\'\n\nfunction Comment.toTable(tab)\n   return\nend\n\n-- this would probably cause problems, but also shouldn\'t happen\nComment.value = Comment.toTable\n\n\n\n\n\n\n\n\n\nlocal Error = Twig :inherit \'Error\'\n\nfunction Error.toTable(err)\n   s:warn(\"Can\'t make a Lua value from an Error at line %d\", err:linePos())\n   return nil\nend\n\n\n\n\n\nlocal Loml_M = { Twig,\n                 loml = Loml,\n                 keyval = Keyval,\n                 val = Val,\n                 quoted_key = QuotedKey,\n                 table = Table,\n                 std_table = StdTable,\n                 array_table = ArrayTable,\n                 array = Array,\n                 inline_table = InlineTable,\n                 literal_string = LiteralString,\n                 ml_literal_string = MLLiteralString,\n                 ml_basic_string = MLBasicString,\n                 basic_string = BasicString,\n                 integer = Integer,\n                 float  = Float,\n                 hexadecimal = Hex,\n                 octal = Octal,\n                 decimal = Decimal,\n                 binary = Binary,\n                 boolean = Boolean,\n                 comment = Comment,\n                 Error   = Error,\n\n }\n\n\n\nreturn Peg(loml_str, Loml_M)\n\n",
vc_hash = "382e3bb416d737deacea797e7ff2391e52dd934f\n",
name = "loml",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "lun",
    repo = "",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "761fdc1e76a81000014cfe5ea268745d73274500426331d07fae0f93340a760f",
binary = "\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\n\n\n\n\n\nlocal lua_str = require \"lun:lua-peg\"\n\n\n\n\n\n\n\n\n\nlocal Twig = Node : inherit ()\n\nfunction Twig.errorAt(twig)\n   local maybe_err = twig:lastLeaf()\n   if maybe_err.id == \"Error\" then\n      local line, col = maybe_err:linePos()\n      return line, col\n   end\n   return nil, nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal precedence = { [\"or\"]  = 1,\n                     [\"and\"] = 2,\n                     compare = 3,\n                     concat  = 4,\n                     add     = 5,\n                     sub     = 5,\n                     mul     = 6,\n                     div     = 6,\n                     mod     = 6,\n                     [\"not\"] = 7,\n                     len     = 7,\n                     unm     = 7,\n                     pow     = 8, }\n\nlocal right_assoc = {\"pow\", \"concat\"}\n\nlocal unary =  {\"not\", \"unm\", \"len\"}\n\n\n\nlocal Shunter = require \"espalier:espalier/shunter\"\n\n\n\nlocal Expression, Expr_Metas = Shunter { Twig, \'expression\',\n                                         precedence = precedence,\n                                         unary = unary,\n                                         right_assoc = right_assoc }\n\n\n\n\n\n\nlocal FunctionCall = Node : inherit \'function_call\'\n\n\n\n\n\n\nlocal Caller = Node : inherit \'caller\'\n\n\n\n\n\n\nlocal Lvalue = Node :inherit \'lvalue\'\n\n\n\n\nlocal Lua = Twig : inherit \"lua\"\n\nfunction Lua.__tostring(lua)\n   return lua:span()\nend\n\nfunction Lua.errorAt(lua)\n   local maybe_err = lua:lastLeaf()\n   if maybe_err.id == \"Error\" then\n      local line, col = maybe_err:linePos()\n      return line, col\n   end\n   return nil, nil\nend\n\n\n\n\n\n\n\n\n\n\nfunction Lua.toLua(lua)\n   return lua.str\nend\n\n\n\nlocal lua_metas = { Twig,\n                    lua = Lua,\n                    function_call = FunctionCall,\n                    lvalue = Lvalue,\n                    var_list = Lvalue,\n                    caller = Caller,\n                    expression = Expression,\n                    condition  = Expression,\n                    group = Expression,\n                   }\n\n\n\nreturn Peg(lua_str, lua_metas)\n\n",
vc_hash = "1dd74c18536a0be3280153e3c5c2529db9e550b8\n",
name = "lua-parser",
branch = "third-refactor-branch",
},
  { 
hash = "1f5dda4cf832ca2e2cbcb7ce043a53eb940e98a18de1360de1011ccaca4acb04",
binary = "\n\n\n\n\nlocal lua_str = [[\n      lua  ←  shebang* _ body _ Error*\n\n  shebang  ←  \"#\" (!\"\\n\" 1)* \"\\n\"\n    body  ←  block\n    Error  ←  1+\n\n  `block`  ←   _ (statement _ semi?)* (_ last-statement _ semi?)?\n  `semi`   ←   \";\" _\n\n`statement`  ←  do\n             /  while\n             /  repeat\n             /  if\n             /  for\n             /  defn\n             /  assign\n             /  goto\n             /  label\n             /  action\n\n      do  ←  \"do\" t chunk \"end\" t\n   while  ←  \"while\" t condition \"do\" t when-true \"end\" t\n  repeat  ←  \"repeat\" t chunk \"until\" t condition\n      if  ←  \"if\" t condition \"then\" t when-true elseif* else? \"end\" t\n     for  ←  \"for\" t _ counter _ \"=\" for-numeric _ \"do\" t chunk \"end\" t\n          /  \"for\" t _ for-locals _ \"in\" t for-iter \"do\" t chunk \"end\" t\n    defn  ←  fn-head _ fn-body\n  assign  ←  local-assign / mutable-assign\n    goto  ←  \"goto\" t _ symbol\n   label  ←  \"::\" symbol \"::\"\n`action`  ←  (chain / call) _ !(index)\n\n`last-statement`  ←  return / break\n          return  ←  \"return\" t _ (exp-list)?\n           break  ←  \"break\" t\n\n           chunk  ←  block\n       condition  ←  _ expr _\n\n       elseif  ←  \"elseif\" t condition \"then\" t when-true\n         else  ←  \"else\" t when-false\n    when-true  ←  block\n   when-false  ←  block\n      counter  ←  symbol\n   for-locals  ←  symbol-list\n\n`for-numeric`  ←  expression \",\" expression (\",\" expression)?\n   `for-iter`  ←  expression (\",\" expression)? (\",\" expression)?\n\n   expression  ←  _ expr _\n\n       `expr`  ←  unop / value _ (binop  _ expr)* / group\n\n      `group`  ←  \"(\" _ expression _ \")\"\n\n          `fn-head`  ←  \"function\" t _ function-name\n                     /  local _ \"function\" t _ local-function-name\n              local  ←  \"local\" t\nlocal-function-name  ←  symbol\n      function-name  ←  symbol _ (\".\" _ symbol)* message?\n            message  ←  (\":\" _ symbol)\n\n  `local-assign`  ←  local _ lvalue _ (\"=\" _ rvalue)?\n`mutable-assign`  ←  var-list _ \"=\" _ rvalue\n          lvalue  ←  symbol-list\n          rvalue  ←  exp-list\n\n var-list  ←  var (_ \",\" _ var)*\n\n`unop`  ←  (unm / len / not) _ expr\n   unm  ←  \"-\"\n   len  ←  \"#\"\n   not  ←  \"not\"\n\n\n`binop`  ←  and / or / compare / add / sub / mul / div / mod / pow / concat\n    and  ←  \"and\" t\n     or  ←  \"or\" t\ncompare  ←  \"<=\" / \">=\" / \"~=\" / \"==\" / \"<\" / \">\"\n    add  ←  \"+\"\n    sub  ←  \"-\"\n    mul  ←  \"*\"\n    mod  ←  \"%\"\n    div  ←  \"/\"\n    pow  ←  \"^\"\n concat  ←  \"..\"\n\n`value`  ←  nil / boolean / vararg / number / string\n         /  table / function\n         /  action / var\n         /  group ; #todo this needs shunting\n\n      nil  ←  \"nil\" t\n  boolean  ←  \"true\" t / \"false\" t\n   vararg  ←  \"...\"\n\n       chain  ←  fn-lead (_ fn-segment)+\n     fn-lead  ←  call / symbol\n`fn-segment`  ←  field-call\n              /  index  &(_ seg-next)\n              /  method-call\n\n       call  ←  caller (_ arguments)+ /  expr-method\n\n     caller  ←  group / symbol\n      index  ←  \"[\" expression \"]\" / \".\" _ symbol\n field-call  ←  index (_ arguments)+\nmethod-call  ←  \":\" _ symbol (_ arguments)+\nexpr-method  ←  group _ method-call\n `seg-next`  ←  _ {:.\\\"\'{[(}\n\n      `var`  ←  var-chain / symbol / index-expr\n\n    var-chain  ←  var-lead _ (var-segment _)+\n   `var-lead`  ←  call / symbol / index-expr\n`var-segment`  ←  ( call / method-call ) _ &seg-next\n               /  index / index-expr\n\nindex-expr  ←  group _ index\n\n     table  ←  \"{\" _ field-list* _ \"}\"\n\n  function  ←  \"function\" t _ fn-body\n\nfield-list  ←  field (_ (\",\" / \";\") _ field)* (\",\" / \";\")?\n     field  ←  key _ \"=\" _ val\n            /  expression\n       key  ←  \"[\" expression \"]\" / symbol\n       val  ←  expression\n\n arguments  ←  \"(\" _ (exp-list _)? \")\"\n            /  string\n            /  table\n`exp-list`  ←  expression (\",\" expression)*\n\n    `fn-body`  ←  parameters _ body _ \"end\" t\n   parameters  ←  \"(\" _ (symbol-list (_ \",\" _ vararg)*)* _ \")\"\n               /  \"(\" _ vararg _ \")\"\n`symbol-list`  ←  (symbol _ (\",\" _ symbol _)*)\n\n\n         string  ←  single-string / double-string / long-string\n`single-string`  ←  \"\'\" (\"\\\\\" \"\'\" / \"\\\\\" 1 / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`double-string`  ←  \'\"\' (\'\\\\\' \'\"\' / \"\\\\\" 1 / (!\'\"\' !\"\\n\" 1))* \'\"\'\n  `long-string`  ←  ls_open (!ls_close 1)* ls_close\n\n `ls_open`  ←  \"[\" \"=\"*@eq \"[\"\n`ls_close`  ←  \"]\" \"=\"*@(eq) \"]\"\n\n`glyph` ← {!@#$%^&*()-+={[]\\\\|:;\\\"\'<,>.?/~`} / \"}\"\n\n`utf8`  ←  [\\x00-\\x7f]\n        /  [\\xc2-\\xdf] [\\x80-\\xbf]\n        /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n        /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n\nsymbol  ←  ; repr-symbol / ; not used, might be useful later\n        !keyword (\n              ;; first character not this:\n              (!(glyph / { \\t\\n\\r} / [0-9])\n              ;; but anything(?) else is ok:\n              utf8\n              ;; after which digits are also legal\n              (!(glyph / { \\t\\n\\r}) utf8)*\n              / [A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )* )\n\n; repr-symbol  ←  \"$\" ([1-9] [0-9]*)* (\".\" ([a-z]/[A-Z]))*\n\n     number  ←  imaginary / real / long / hex / integer\n`imaginary`  ←  real {Ii}\n     `real`  ←  integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n     `long`  ←  (integer / hex) {Uu}? {Ll}%2\n  `integer`  ←  [0-9]+\n      `hex`  ←  \"0\" {Xx} higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n    `higit`  ←  [0-9] / [a-f] / [A-F]\n\n           `_`  ←  comment+ / whitespace\n       comment  ←  whitespace long-comment whitespace\n                /  whitespace \"--\" (!\"\\n\" 1)* whitespace\n`long-comment`  ←  \"--\" long-string\n  `whitespace`  ←  { \\t\\n\\r}*\n\nkeyword  ←  ( \"and\" / \"break\" / \"do\" / \"elseif\" / \"else\"\n            / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n            / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n            / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n            t ; t is the most PEG thing about PEGs\n    `t`  ←  !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\nreturn lua_str\n\n",
vc_hash = "1dd74c18536a0be3280153e3c5c2529db9e550b8\n",
name = "lua-peg",
branch = "third-refactor-branch",
},
  { 
hash = "d667b148e2dbf220cb7d10096256493499a5892569a0017e92e7ce6c9ad5c3cd",
binary = "\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal lua_str = [[\nlun  <-  shebang* _ chunk _ Error* ; more to come\nshebang  <-  \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk  <-  _ (statement _ \";\"?)* (_ last-statement _ \";\"?)?\n\nError  <-  1+\n\nstatement  <-  do-state\n            /  while-state\n            /  repeat-state\n            /  if-state\n            /  for-state\n            /  fn-state\n            /  my-function-state\n            /  assign-state\n            /  varlist-explist-state\n            /  goto-state\n            /  label-state\n            /  fncl-state\n            /  yield-state\n\ndo-state  <-  \"do\" t chunk \"end\" t\nwhile-state  <-  \"while\" t expr \"do\" t chunk \"end\" t\nrepeat-state <-  \"repeat\" t chunk \"until\" t expr\nif-state  <-  \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\nfor-state  <-  \"for\" t _ symbol _ \"=\" expr _ \",\" _ expr _ (\",\" _ expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbol-list _ \"in\" t expr \"do\" t chunk \"end\" t\nmy-fn-state  <-  \"fn\" t _ func-name _ funcbody\n          / \"my\" t _ \"fn\" t _ symbol _ funcbody\nassign-state  <-  \"my\" t _ symbol-list _ (\"=\" _ exp-list)?\nvarlist-explist-state   <-  varlist _ \"=\" _ explist\ngoto-state  <-  \"goto\" t _ symbol\nlabel-state  <-  \"::\" symbol \"::\"\nfncl-state  <-  fn-call\nyield-state  <-  \"~~>\" exp-list?\n\nlast-statement  <-  \"->\" t _ (exp-list)?\n              / \"break\" t\n\nfn-name  <-  symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvar-list   <-  var (_ \",\" _ var)*\n\n`expr`   <-  _ unop _ expr _\n      / _ value _ (binop _ expr)* _\n      ; value ? true :: false\n\nunop   <-  \"-\" / \"#\" / \"not\" ; \"~\" ? \"?\" ?! \"!\" !!\nbinop  <-  \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n      / \"+=\" / \"-=\" / \"/=\" / \"*=\" / \"^=\" / \"%=\" / \"..=\"\n\n`value`  <-  Nil / bool / vararg / number / string\n          / table-constructor / Function\n          / fn-call / var\n       / \"(\" _ expr _ \")\"\n\n    Nil  <-  \"nil\" t\n   bool  <-  \"true\" t / \"false\" t\n vararg  <-  \"...\"\n\nfn-call  <-  prefix (_ suffix &(_ suffix))* _ call\ntable-constructor  <-  \"{\" _ field-list* _ \"}\"\nFunction  <-  \"fn\" t _ fn-body\n\nvar  <-  prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`field-list`  <-  field (_ (\",\" / \";\") _ field)* ; @field\nfield  <-  key _ \"=\" _ val\n      / expr\nkey  <-  \"[\" expr \"]\" / symbol\nval  <-  expr\n\n`prefix`   <-  \"(\" expr \")\" / symbol\nindex    <-  \"[\" expr \"]\" / \".\" _ symbol\n`suffix`   <-  call / index\n`call`     <-  args / method\nmethod     <-  \":\" _ symbol _ args\n\nargs  <-  \"(\" _ (exp-list _)? \")\"\n     / string\n     / table-constructor\n`explist`  <-  expr (\",\" expr)*\n\n`fn-body`  <-  parameters _ chunk _ \"end\" t\nparameters  <-  \"(\" _ (symbol-list (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbol-list`  <-  (symbol (\",\" _ symbol)*)\n\n\nstring  <-  single-string / double-string / long-string\n`single-string`  <-  \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`double-string`  <-  \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n`long-string`    <-  ls-open (!ls-close 1)* ls-close\n\n`ls-open`  <-  \"[\" \"=\"*@eq \"[\"\n`ls-close`  <-  \"]\" \"=\"*@(eq) \"]\"\n\nsymbol  <-  repr-symbol\n       / !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nrepr-symbol  <-  \"$\" ([1-9] [0-9]*)* (\".\" ([a-z]/[A-Z]))*\n\nnumber  <-  real / hex / integer\n`integer`  <-  [0-9]+\n`real`  <-  integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex`  <-  \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit`  <-  [0-9] / [a-f] / [A-F]\n\n`_`  <-  comment+ / whitespace\ncomment  <-  whitespace long-comment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`long-comment`  <-  \"--\" long-string\n`whitespace`  <-  { \\t\\n\\r}*\n\nkeyword  <-  (\"->\" / \"~~>\"/ \"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"fn\" / \"goto\" / \"if\"\n        / \"in\" / \"my\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n`t`  <-  !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Lua = Node : inherit \"lua\"\n\nfunction Lua.__tostring(lua)\n   return lua:span()\nend\n\nlocal lua_metas = { lua = Lua }\n\n\n\nreturn Peg(lua_str) : toGrammar(lua_metas)\n\n",
vc_hash = "1dd74c18536a0be3280153e3c5c2529db9e550b8\n",
name = "lun-parser",
branch = "third-refactor-branch",
},
  { 
hash = "2d4580b753992b56854a7c3a8dbe9c18c5916d5303a450fb39720f436e7e7b60",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n\n",
vc_hash = "1dd74c18536a0be3280153e3c5c2529db9e550b8\n",
name = "lun",
branch = "third-refactor-branch",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "mailman",
    repo = "git@gitlab.com:special-circumstance/mailman.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "0c502d363dd399325a1e10b292ba3ed21e6f41bb4c6fa102671637b330d7a4eb",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Deque = require \"deque:deque\"\n\n\n\n\n\n\n\n\nlocal Mailbox = {}\nMailbox.__index = Mailbox\n\n\n\n\n\n\n\n\nfunction Mailbox.send(mailbox, msg)\n   mailbox.__out:push(msg)\nend\n\n\n\n\n\n\n\n\nfunction Mailbox.sendAll(mailbox, ...)\n   for i = 1, select(\'#\', ...) do\n      mailbox.__out:push(select(i, ...))\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Mailbox.read(mailbox)\n   return mailbox.__in:popAll()\nend\n\n\n\n\n\n\n\n\n\nfunction Mailbox.peek(mailbox)\n   return mailbox.__in:peekAll()\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Mailbox.readOne(mailbox)\n   return mailbox.__in:pop()\nend\n\n\n\n\n\n\n\n\n\nfunction Mailbox.peekNext(mailbox)\n   return mailbox.__in:peek()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new()\n   local _main, _back = Deque(), Deque()\n   local inbox, outbox = setmetatable({}, Mailbox), setmetatable({}, Mailbox)\n   inbox.__out, inbox.__in = _main, _back\n   outbox.__out, outbox.__in = _back, _main\n   inbox.isInbox, outbox.isOutbox = true, true\n   return inbox, outbox\nend\n\nMailbox.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "85884b58748230bf30afeb7b46075d0120f22e7d\n",
name = "mailman",
branch = "2022-02-28_RELEASE_BRANCH",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "manifest",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "67a1c340c4417e8bc73db6b0712bf0d5544aac81637e75522b375eb39a2f369e",
binary = "\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\n\n\n\n\n\nlocal define = require \"manifest:define\"\nlocal Manifest = require \"manifest:manifest\"\nlocal Read = require \"manifest:read\"\n-- this probably comes from the Maniest:\nlocal View = require \"manifest:view\"\n\n\n\n\n\nlocal basis = assert(cluster.contract.basis)\n\nlocal test_tab_define = { \'stuff\',\n   widget = {\n      inventory = 0,\n      sku = basis.isnumber,\n      name = \"\",\n   }\n}\n\n\n\nlocal testManifest = Manifest(test_tab_define)\n\n\n\nlocal readManifest = testManifest:read \'./etc/stuff.orb\'\n\n\n\nreturn readManifest\n\n",
vc_hash = "f5234ffa79b739fe62ad5528473ea6a4260bf18c\n",
name = "spec/test_table",
branch = "manifest-elaborations",
},
  { 
hash = "3e27876dee64d830c7b4629963cd8c47cbb272ed922bb95de13658fbb3f218e5",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function define(shape)\n   local proto, mold = {}, {}\n   -- a namespace means we need to wrap\n   local proto_out, mold_out = proto, mold\n   local main = shape[1]\n   if main then\n      shape[1] = nil\n      proto_out = { [main] = proto }\n      mold_out  = { [main] = mold }\n   end\n   for key, value in pairs(shape) do\n      local t_v = type(value)\n      if t_v == \'table\' then\n         proto[key], mold[key] = define(value)\n      elseif t_v == \'function\' then\n         mold[key] = value\n      else\n         proto[key] = value\n      end\n   end\n\n   return proto_out, mold_out\nend\n\n\n\n\nreturn define\n\n",
vc_hash = "f5234ffa79b739fe62ad5528473ea6a4260bf18c\n",
name = "define",
branch = "manifest-elaborations",
},
  { 
hash = "f326e0b44c6b95d0624ca859fe1d721dc42bcdeb2e248f10f9bfaf385ed9ca58",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.boring = false\n\nlocal define = require \"manifest:define\"\n\nlocal Skein = require \"orb:skein/skein\"\n\nlocal Toml = require \"lon:loml\"\n\n\n\n\n\n\nlocal new, Manifest, Manifest_M = cluster.order()\n\n\n\n\n\n\n\n\nlocal __call;\n\ncluster.construct(new, function(_new, manifest, def, block)\n   manifest.proto, manifest.mold = define(def)\n   manifest.data = {}\n   if block then\n      __call(manifest, block)\n   end\n\n   return manifest\nend)\n\n\n\n\n\n\n\n\nlocal clone = assert(core.table.cloneinstance)\n\nlocal function apply(base, diff)\n   for key, value in pairs(diff) do\n      if type(value) == \'table\' then\n         base[key] = apply(base[key] or {}, diff[key])\n      else\n         base[key] = value\n      end\n   end\n   return base\nend\n\nfunction Manifest.getAll(manifest)\n   local view = clone(manifest.proto)\n   return apply(view, manifest.data)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Manifest.child(manifest)\n   return clone(manifest)\nend\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\nlocal File = require \"fs:fs2/file\"\nlocal Skein = require \"orb:skein/skein\"\n\n\n\nfunction Manifest.read(manifest, path)\n   local mani_file = File(path)\n   if mani_file:exists() then\n      manifest.file_exists = true\n      s:verb(\"Found manifest.orb at %s\", tostring(mani_file))\n      local skein = Skein(mani_file):tailor()\n      if skein then\n         manifest(skein)\n      else\n         s:warn(\"Couldn\'t read %s\", path)\n      end\n   else\n      manifest.file_exists = false\n      manifest.missing_file = path\n      s:verb(\"Didn\'t find a manifest.orb at %s\", tostring(mani_file))\n   end\n\n   return manifest\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _addTable(data, tab)\n   for k,v in pairs(tab) do\n      s:verb(\"adding %s : %s\", k, v)\n      if type(v) == \'table\' and data[k] ~= nil then\n         _addTable(data[k], v)\n      else\n         data[k] = v\n      end\n   end\nend\n\n\n\n\n\nlocal function _addNode(manifest, block)\n   -- quick sanity check\n   assert(block and block.isNode, \"manifest() must receive a Node\")\n   -- codeblocks are all we know (for now)\n   if not (block.id == \'codeblock\')then\n      s:verb(\"found a %s node tagged with #manifest, no action\", block.id)\n      return\n   end\n   -- toml is all we speak (for now)\n   local code_type = block :select \'code_type\' () :span()\n   if code_type ~= \'toml\' then\n      s:chat(\"don\'t know what to do with a %s codeblock tagged with #manifest\",\n             code_type)\n      return\n   end\n\n   local codebody = block :select \'code_body\' () :span()\n   local toml = Toml(codebody)\n   if toml then\n      s:verb(\"adding contents of manifest codebody\")\n      local contents = toml:toTable()\n      _addTable(manifest.data, contents)\n   else\n       s:warn(\"no contents generated from #manifest block, line %d\",\n              block:linePos())\n   end\nend\n\n\n\n\n\n\nlocal function _addSkein(manifest, skein)\n   -- check if the Skein has been loaded and spun (probably not)\n   if (not skein.source.text) or (not skein.source.doc) then\n      skein:load():spin():tag()\n   end\n   local nodes = skein.tags.manifest\n   if nodes then\n      for _, block in ipairs(nodes) do\n         if block.id == \'codeblock\' then\n            s:verb \"adding codeblock from Skein\"\n            _addNode(manifest, block)\n         else\n            s:verb(\"don\'t know what to do with a %s tagged \"\n                   .. \"with #manifest\", block.id)\n         end\n      end\n   else\n      s:verb(\"no manifest blocks found in %s\" .. tostring(skein.source.file))\n   end\nend\n\n\n\n\n\n\n\nfunction __call(manifest, msg)\n   s:bore \"entering manifest()\"\n   if not type(msg) == \'table\' then\n      s:warn(\"oopsie in manifest of type %s\", type(msg))\n      return\n   end\n   --assert(type(msg)  == \'table\', \"argument to manifest must be a table\")\n   -- otherwise this should be a codeblock or a Skein\n   if msg.idEst and msg.idEst == Skein then\n      s:bore(\"manifest was given a skein\")\n      _addSkein(manifest, msg)\n   elseif msg.isNode then\n      s:bore(\"manifest was given a node\")\n      _addNode(manifest, msg)\n   else\n      s:warn(\"manifest given something weird, type %s\", type(msg))\n   end\n   s:bore \"leaving manifest()\"\nend\n\nManifest_M.__call = __call\n\n\n\nreturn new\n\n",
vc_hash = "f5234ffa79b739fe62ad5528473ea6a4260bf18c\n",
name = "manifest",
branch = "manifest-elaborations",
},
  { 
hash = "74391ef6763d79b8fc87587ee074fcc263e1e22dc05d60080c2342c9383eec50",
binary = "\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\n\n\n\nlocal File = require \"fs:fs2/file\"\nlocal Manifest = require \"orb:manifest/manifest\"\nlocal Skein = require \"orb:skein/skein\"\n\n\n\nlocal function read(path)\n   local manifest = Manifest()\n   local mani_file = File(path)\n   if mani_file:exists() then\n      s:verb(\"Found manifest.orb at %s\", tostring(mani_file))\n      manifest.file_exists = true\n      local skein = Skein(mani_file):tailor()\n      manifest(skein)\n   else\n      s:verb(\"Didn\'t find a manifest.orb at %s\", tostring(mani_file))\n   end\n   return manifest\nend\n\n\n\nreturn read\n\n",
vc_hash = "f5234ffa79b739fe62ad5528473ea6a4260bf18c\n",
name = "read",
branch = "manifest-elaborations",
},
  { 
hash = "c9d5f383b210855ff8f4436cac2c42e87ad27e8f7a31aeed659fccb98e90a10e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal table = core.table\n\n\n\nlocal new, View, View_M = cluster.order()\n\n\n\n\n\n\nlocal function build(_new, view, manifest, is_data)\n   local data = is_data and assert(manifest) or manifest:getAll()\n   for key, value in pairs(data) do\n      if table(value) then\n         view[key] = new(value, true)\n      else\n         view[key] = value\n      end\n   end\n\n   return view\nend\n\n",
vc_hash = "f5234ffa79b739fe62ad5528473ea6a4260bf18c\n",
name = "view",
branch = "manifest-elaborations",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "ml",
    repo = "git@gitlab.com:special-circumstance/ml.git",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "f4042b59ea8c210f6712a1bd4009471889d7f0e2d695e9e96f6c1da05bdc1a11",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"core:cluster\"\nlocal meta, constructor = assert(cluster.Meta), assert(cluster.constructor)\n\n\n\n\n\n\nlocal Entity = meta {}\nEntity.isElement = false -- not where it counts\n\n\n\n\n\n\n\n\n\nfunction _call(ent, ...)\n   local top = #ent\n   for i = 1, select(\'#\', ...) do\n      ent[top + i] = select(i, ...)\n   end\n\n   return ent\nend\n\n",
vc_hash = "eb2a9028bf093610d44cacce7271df8944c5b6f3",
name = "ml/entity",
branch = "builder",
},
  { 
hash = "bedd305eebfc40a95784b67afe36f615b8a71ac35d60c70812b909e56f728d76",
binary = "\n\n\n\n\n\n\n\n\n\nreturn function (doctype)\n   local new_G = setmetatable({}, { __index = doctype})\n   return function (fn)\n      return setfenv(fn, new_G)()\n   end\nend\n\n",
vc_hash = "eb2a9028bf093610d44cacce7271df8944c5b6f3",
name = "ml/builder",
branch = "builder",
},
  { 
hash = "826f51fd229c00636d6fa7ededccadc236fa44197e538b3deb3a91d7ee3893e4",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"core:core/cluster\"\nlocal meta, constructor, methodcaller = assert(cluster.Meta),\n                                        assert(cluster.constructor),\n                                        assert(cluster.methodchain)\nlocal Element = require \"ml:ml/element\"\n\n\n\n\nlocal Doctype = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal function __index(doc, key)\n   doc[key] = Element(key)\n   return doc[key]\nend\n\nlocal Doctype_M = { __index = __index }\n\n\n\nlocal function new()\n   return setmetatable({}, Doctype_M)\nend\n\n\n\nreturn new\n\n",
vc_hash = "eb2a9028bf093610d44cacce7271df8944c5b6f3",
name = "ml/doctype",
branch = "builder",
},
  { 
hash = "157b2b35408a1785ad6e7e5c11e3bbf9bda02ef82491393786b3c0f581158765",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = require \"core:cluster\"\nlocal meta, constructor = assert(cluster.Meta), assert(cluster.constructor)\n\nlocal Entity = require \"ml:ml/entity\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Element = meta {}\nElement.isElement = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal gsub, format = assert(string.gsub), assert(string.format)\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal map = { [\'&\'] = \'&amp;\',\n              [\'<\'] = \'&gt;\',\n              [\'>\'] = \'&lt;\',\n              [\'\"\'] = \'&quot;\',\n              [\"\'\"] = \'&apos;\' }\n\nlocal function ml_escape(str)\n   return (gsub(str, \'[&<>\"\\\']\', map))\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, match = L.P, L.R, L.match\n\nlocal name_patt = (R\"AZ\" + R\"az\" + P\"_\" + P\":\")\n               * (R\"az\" + R\"AZ\" + R\"09\" + P\"_\" + P\"-\" + P\".\" + P\":\")^0\n\nlocal function valid_name(str)\n   return (match(name_patt, str) == (#str + 1))\n          and str or nil\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal _master_attr = setmetatable({}, { __mode = \'kv\' })\n\n\n\n\n\n\n\n\n\n\n\nlocal _attr_M = setmetatable({}, { __mode = \'kv\' })\n\nlocal function _metaFor(attr)\n   if _attr_M[attr] then\n      return _attr_M[attr]\n   end\n   local attr_M = { __index = attr }\n   _attr_M[attr] = attr_M\n\n   return attr_M\nend\n\n\n\n\n\n\n\n\nlocal value_catch = {}\nlocal remove = assert(table.remove)\n\nlocal function value__call(value_catch, value)\n   value_catch[1]._attr[value_catch[2]] = value\n   value_catch[2] = nil\n   return remove(value_catch)\nend\n\nsetmetatable(value_catch, { __call = value__call })\n\nfunction Element.attr(elem, key)\n   if (_master_attr[elem.tag] == elem._attr)\n      and (not elem.isElement) then\n         -- we add an entity metatable here, creating if necessary\n         elem._attr = setmetatable({}, _metaFor(elem._attr))\n   end\n   value_catch[1], value_catch[2] = elem, assert(valid_name(key),\n                                                 \"invalid tag! \" ..\n                                                 key)\n   return value_catch\nend\n\n\n\n\nfunction new(_, tag, attr, void, inline)\n   attr = attr or {}\n   assert(type(tag) == \'string\', \"#1 of Element() must be a string\")\n   assert(type(attr) == \'table\', \"#2 of Element() must be a table\")\n\n   local elem = setmetatable( { _attr = {} }, Element)\n   elem.tag = assert(valid_name(tag), \'tag name is syntactically invalid: \'\n                                      .. tag)\n   -- cache the attributes by tag\n   _master_attr[tag] = elem._attr\n   for k, v in pairs(attr) do\n      assert(valid_name(k), format(\"invalid key %s\", k))\n      elem._attr[k] = v\n   end\n\n   elem.start = \"<\" .. tag\n   elem.void = not (not void) -- cast to boolean\n   elem.indent = not inline\n   if elem.void then\n      elem.indent = true\n   else\n      elem.close = \"</\" .. tag .. (elem.indent and \">\\n\" or \"> \")\n   end\n   return elem\nend\n\n\n\n\n\n\n\n\nfunction Element.hasattr(elem, key)\n   return elem._attr[key] or nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Element.render(elem, page, d)\n   if type(elem) == \'string\' then\n      insert(page, ml_escape(elem))\n      return\n   end\n   local nl = elem.indent and #elem > 0 and \'\\n\' or \'\'\n\n   d = d or 0\n   page = page or {}\n   local dent;\n   -- pad\n   if elem.indent then\n      dent = (\'\\t\'):rep(d)\n      insert(page, dent)\n   end\n   insert(page, elem.start)\n\n   for k, v in pairs(elem._attr) do\n      -- keys are validated on the way in and don\'t need escaping\n      insert(page, \' \' .. k .. \'=\"\' .. ml_escape(v) .. \'\"\')\n   end\n\n   if elem.void then\n      insert(page, \'/>\\n\')\n   else\n      insert(page, \'>\')\n      insert(page, nl)\n   end\n\n   for _, _elem in ipairs(elem) do\n      -- unusual \'method call\' here because _elem can be a string\n      elem.render(_elem, page, d + 1)--\n   end\n\n   if elem.close then\n      -- indent again and close tag\n      insert(page, nl)\n      insert(page, dent)\n      insert(page, elem.close)\n   end\n\n\n   if d == 0 then\n      return concat(page)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ent_call(ent, ...)\n   local top = #ent\n   for i = 1, select(\'#\', ...) do\n      ent[top + i] = select(i, ...)\n   end\n\n   return ent\nend\n\n\n\n\nfunction Element.__call(elem, ...)\n   local ent = setmetatable({ isElement = false }, { __index = elem,\n                                                     __call   = ent_call })\n   return ent_call(ent, ...)\nend\n\n\n\n\nreturn constructor({}, new)\n\n",
vc_hash = "eb2a9028bf093610d44cacce7271df8944c5b6f3",
name = "ml/element",
branch = "builder",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "modlang",
    repo = "git@gitlab.com:special-circumstance/ml.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "12cf9976097c6337c7e1c5153eecf568e8fea11983d699fb250e7dc728a8fcee",
binary = "\n\n\n\nlocal DocBuild = require \"modlang:docbuild\"\nlocal SVGDocT = require \"modlang:doctype/svg\"\n\nreturn DocBuild(SVGDocT)\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "svg/build",
branch = "rise-of-modlang",
},
  { 
hash = "87f6f722ee8e21e8409a1acf6e34f13283811bf56db3089d02d493f8b6e52812",
binary = "\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\n\n\n\n\n\n\n\n\nlocal Doctype = require \"modlang:doctype\"\n\n\n\n\n\n\n\n\nlocal E = require \"modlang:element\"\nlocal function el(name)\n   return E(name, {}, true)\nend\n\n\n\nlocal SVG_config = { \'SVG\',\n   header = [[\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n]],\n   comment = \"generated using the bridge modlang system\",\n   tag = \'svg\',\n   attr = { xmlns=\"http://www.w3.org/2000/svg\", version=\"1.1\" },\n   elem = {\n      line     = el \'line\',\n      polyline = el \'polyline\',\n      rect     = el \'rect\',\n      ellipse  = el \'ellipse\',\n      polygon  = el \'polygon\',\n      path     = el \'path\', },\n}\n\n\n\n\n\n\n\n\n\n\n\nlocal function stripe(tab)\n   return function(attr)\n      if #attr == 0 then\n         -- no point\n         return attr\n      end\n\n      for i, key in ipairs(tab) do\n         attr[key] = attr[i]\n         attr[i] = nil\n      end\n\n      return attr\n   end\nend\n\n\n\nlocal tag_mold = {}\n\n\n\n\ntag_mold.line = stripe {\'x1\', \'y1\', \'x2\', \'y2\'}\n\n\n\n\n\n\n\nlocal SVG = Doctype(SVG_config)\n\n\n\n\n\n\n\n\n\n\n\nfor tag, mold in pairs(tag_mold) do\n   SVG.elements[tag].moldAttr = mold\nend\n\n\n\n\nreturn SVG\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "svg/doctype",
branch = "rise-of-modlang",
},
  { 
hash = "96e9df2f61c7644e783b2dab084758587252a25e56c35a59935496aada58e4e6",
binary = "\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal match, P, R, S = L.match, L.P, L.R, L.S\nlocal Peg = require \"espalier:espalier/peg\"\n\n\n\n\n\n\n\n\n\nlocal digit_p = R\"09\"\nlocal int_p   = (P\"+\" + P\"-\")^-1 * digit_p^1\nlocal num_p   = int_p * (P\".\" * digit_p^1)^-1 * (S\"Ee\" * int_p)^-1\n\n\n\n\n\n\n\n\n\n\n\n\nlocal digit_str = [[\n   digit ←  [0-9]\n]]\n\nlocal integer_str = [[\n   integer ←  (\"+\" / \"-\")? digit+\n]]\n\nlocal number_str = [[\n   number ←  integer (\".\" digit+)* ({Ee} integer)?\n]]\n\n\n\nlocal format = assert(string.format)\n\n\n\n\nlocal function number(v)\n   local n = tonumber(v)\n   if n then\n      return tostring(n)\n   else\n      return nil, \"can\'t make a number from value\"\n   end\nend\n\n\n\nlocal function integer(v)\n   local n, err = number(v)\n   if not n then\n      return nil, err\n   end\n\n   if match(int_p * P(-1), n) then\n      return n\n   else\n      return nil, \"can\'t make an integer from numeric value\"\n   end\nend\n\n\n\n\n\n\n\nlocal svg_len_p = num_p * (P\"em\" + \"ex\" + \"px\" + \"in\" + \"cm\" + \"mm\" + \"pt\"\n                          + \"pc\" + \"%\")^1\n\nlocal function svg_length(v)\n   local n = number(v)\n   if not n then\n      if match(svg_len_p * P(-1), v) then\n         return v\n      else\n         return nil, \"can\'t make a length from value\"\n      end\n   else\n      return n\n   end\nend\n\n\n\n\n\n\nlocal name_p = (-(S\",()\\x20\\x09\\x0d\\x0a\") * P(1))^1\n\nlocal function name(v)\n   if match(name_p * P(-1), v) then\n      return v\n   else\n      return nil, \"can\'t make a name from value\"\n   end\nend\n\n\n\n\nreturn { number     =  number,\n         integer    =  integer,\n         name       =  name,\n         svg_length =  svg_length, }\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "mold/attr",
branch = "rise-of-modlang",
},
  { 
hash = "4f1a8db85da13ef0025f160a5456cfe5eefd3f1169ce8bebc3205e6716d1d6f1",
binary = "\n\nlocal svg_peg = [[\npath <- segment+\nsegment <- moveto\n         / closepath\n         / lineto\n         / h-lineto\n         / v-lineto\n         / curveto\n         / s-curveto\n         / q-curveto\n         / t-curveto\n         / elliptic-arc\n]]\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "svg/path",
branch = "rise-of-modlang",
},
  { 
hash = "d3e92ccc1ec1cd55b68e5d7b96079dcbfb91574f2424c994693aa7ae85c55946",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal mlEscape, isCDATA, escDATA;\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal string, table = core.string, core.table\nlocal gsub, format = assert(string.gsub), assert(string.format)\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal map = { [\'&\'] = \'&amp;\',\n              [\'<\'] = \'&gt;\',\n              [\'>\'] = \'&lt;\',\n              [\'\"\'] = \'&quot;\',\n              [\"\'\"] = \'&apos;\' }\n\nfunction mlEscape(str)\n   str = tostring(str)\n   return (gsub(str, \'[&<>\"\\\']\', map))\nend\n\n\n\nlocal litpat = assert(string.litpat)\nlocal ESC_CDATA = \"]]]]><![CDATA[>\"\nlocal END_CDATA =  \"]]>\"\nlocal BEGIN_CDATA =  \"<![CDATA[\"\nlocal find = assert(string.find)\n\nfunction isCDATA(str)\n   local pre = find(str, BEGIN_CDATA, 1, true)\n   if not pre then return false end\n   local post, final = find(str, END_CDATA, 1, true)\n   if post and final == #str then\n      return true\n   else\n      return false, \"prefixed\"\n   end\nend\n\nlocal endpatt = litpat(END_CDATA)\n\nfunction escCDATA(str)\n   return (gsub(str, endpatt, ESC_CDATA))\nend\n\n\n\nreturn {\n  mlEscape = mlEscape,\n  isCDATA = isCDATA,\n  escCDATA = escCDATA,\n}\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "base",
branch = "rise-of-modlang",
},
  { 
hash = "58798dc4f248343096c8b5db5004d63a007ad3170963e9078f6eb8a2514629e6",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Element;\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function entityBuilder(elements, entity)\n   Element = Element or require \"modlang:element\"\n\n   local entityBuild = {}\n\n   local accumulate_entity;\n\n   -- index for the doc builder, takes care of :tag\n   local function _index(build, key)\n      if type(key) == \'string\' then\n         local elem = elements[key]\n         if not elem then\n            elem = Element(key)\n            elements[key] = elem\n         end\n         return accumulate_entity(elem)\n      else\n         return rawget(build, key)\n      end\n   end\n\n   -- caller for the doc builder calls the *latest* entity\n   local function _call(build, ...)\n      local ent = entity[#entity] or entity\n      return ent(...)\n   end\n\n   -- the accumulator function\n   -- confused? look at the order: ↴\n   local function caller(shovel, _entityBuild, attr)\n      local elem = shovel[1]\n      local ent = elem(attr)\n      insert(entity, ent)\n\n      return _entityBuild -- we could return either reference ¯\\_(ツ)_/¯\n   end\n\n   -- entityBuild :index, the intended usage, passes entityBuild as the\n   -- first argument, to the callable returned, this critter:\n   function accumulate_entity(elem)\n      local shovel = setmetatable({elem}, { __call = caller })\n      shovel.isShovel = true\n      return shovel\n   end\n\n   -- so shovel is called, putting itself before entityBuild, where it\n   -- drops off the element and skips town.\n   return setmetatable(entityBuild, { __index = _index })--, __call = _call })\nend\n\n\n\nlocal function new(elements)\n   elements = elements or {}\n   return function(entity)\n      return entityBuilder(elements, entity)\n   end\nend\n\n\n\nreturn new\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "builder",
branch = "rise-of-modlang",
},
  { 
hash = "acba7307a3898216e9781495ca0b5b375a1354b6b59f88e37483fac6272499ee",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal table, string = core.table, core.string\n\n\n\nlocal new, DocBuild, DocBuild_M = cluster.order()\n\nlocal clone = table.clone1\n\ncluster.create(new, function(_new,  doctype)\n   local docBuild = clone(doctype)\n   return docBuild\nend)\n\n\n\n\n\n\n\n\nfunction DocBuild.build(docBuild, attr) -- probably cfg but\n   local baseElem = assert(docBuild.elements[docBuild.tag],\n                           \"missing root element\")\n   local baseEnt = baseElem(attr)\n   docBuild.base = baseEnt\n   return baseEnt:build()\nend\n\n\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nfunction DocBuild.render(docBuild)\n   local phrase = {}\n   local css = docBuild.css\n   if docBuild.header then\n      insert(phrase, docBuild.header)\n   end\n   if css and string(css) then\n      insert(phrase, css)\n   elseif table(css) then\n      -- render right?\n      insert(phrase (css:render()))\n   end\n   local body = docBuild.base:render()\n   insert(phrase, body)\n   return concat(phrase), phrase\nend\n\n\n\nlocal lines = core.string.lines\n                       -- .\\ -> lines($[1]) -- end elision on return, why not\nlocal view_M = { __repr = function(t) return lines(t[1]) end }\n\nfunction DocBuild.view(docBuild)\n   local render = docBuild:render()\n   return setmetatable({render}, view_M)\nend\n\n\n\n\n\n\n\n\n\nlocal function DocBuilderBuilder(doctype)\n   return function()\n      return new(doctype)\n   end\nend\n\nreturn DocBuilderBuilder\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "docbuild",
branch = "rise-of-modlang",
},
  { 
hash = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {is = isCDATA, esc = escCDATA}\n\n",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {is = isCDATA, esc = escCDATA}\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "cdata",
branch = "rise-of-modlang",
},
  { 
hash = "ea3f3ce422c6ba0cfa0ca8e474c721f00261a97944697db31801a7642ec5092f",
binary = "\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Element = require \"modlang:element\"\n\n\n\n\n\n\n\n\n\n\n\nlocal function _DocElement(build, tag, attrs, void, inline)\n   local elem = Element(tag, attrs, void, inline)\n   elem.build = build\n   return elem\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(core.fn.curry)\nlocal string, table = assert(core.string), assert(core.table)\nlocal builder = require \"modlang:builder\"\n\nlocal new, Doctype, Doctype_M = cluster.order()\n\ncluster.construct(new, function(_new, doctype, cfg)\n   if string(cfg) then\n      doctype.name = cfg\n      cfg = {}\n   elseif table(cfg) then\n      doctype.name = cfg[1]\n      for k,v in pairs(cfg) do\n         doctype[k] = v\n      end\n   else\n      error(\"Illegal argument of type \" .. type(cfg))\n   end\n   doctype.tag = cfg.tag or doctype.name\n   local elements = {}\n   doctype.elements = elements\n   local build = builder(elements)\n   doctype.DocElement = curry(_DocElement, build)\n   local tag = cfg.tag\n   if tag then\n      doctype.elements[tag] = doctype.DocElement(tag, doctype.attr or {})\n   end\n   for key, value in pairs(cfg.elem or {}) do\n       if type(key) == \'string\' then\n         local elem = value\n         elem.build = build\n         elements[key] = elem\n      end\n   end\n   return doctype\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Doctype.define(doctype)\n   local DocElement = assert(doctype.DocElement)\n   local elements = assert(doctype.elements)\n   local _index, caller, accumulate_key;\n   local docTypeBuild = {}\n\n   -- index for the doc builder, takes care of :tag\n   function _index(build, key)\n      if type(key) == \'string\' then\n         local elem = elements[key]\n         if elem then\n            error(doctype.name .. \" already has an element tagged \" .. key)\n         end\n         return accumulate_key(key)\n      else\n         return nil\n      end\n   end\n\n   -- the accumulator function\n   function caller(shovel, _docbuild, attr, void, inline)\n      local key = shovel[1]\n      local elem = DocElement(key, attr, void, inline)\n      elements[key] = elem\n\n      return docTypeBuild\n   end\n\n   function accumulate_key(key)\n      local shovel = setmetatable({key}, {__call = caller})\n      shovel.isShovel = true\n      return shovel\n   end\n\n   return setmetatable(docTypeBuild, {__index = _index})\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "doctype",
branch = "rise-of-modlang",
},
  { 
hash = "d863fb4b5f5eb662407bee6ca784794b4d7eb97d9a12b93e2b546d332a8d802d",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal table, string = core.table, core.string\n\nlocal Entity = require \"modlang:entity\"\n\n\n\n\n\n\n\n\n\nlocal new, Element, Elem_M = cluster.order()\n\n\n\n\n\nElement.isElement = true\nElement.moldAttr = cluster.ur.pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal valid_name;\n\nlocal keys = assert(core.table.keys)\nlocal format = assert(string.format)\n\nlocal validAttr;\n\ncluster.construct(new, function(_new, elem, tag, attr, void, inline)\n   -- tag is either a table or config\n   local cfg;\n   if type(tag) == \'table\' then\n      assert(not (attr or void or inline),\n             \"table-constructed elements take one argument\")\n      cfg = tag\n      tag = cfg[1]\n      attr = cfg.attr\n      void = cfg.void\n   else\n      cfg = {}\n      assert(type(tag) == \'string\', \"#1 of Element() must be a string\")\n   end\n   elem.moldAttr = cfg.moldAttr or _new.moldAttr\n   elem._attr = validAttr(elem, attr or {})\n   elem.tag = assert(valid_name(tag), \'tag name is syntactically invalid: \'\n                                      .. tag)\n   -- rendering\n   elem.start = \"<\" .. tag\n   elem.void = not (not void) -- cast to boolean\n   elem.indent = not inline\n   if elem.void then\n      elem.indent = true\n   else\n      elem.close = \"</\" .. tag .. (elem.indent and \">\\n\" or \"> \")\n   end\n\n   return elem\nend)\n\n\n\n\nfunction validAttr(elem, attr)\n   for key, value in pairs(attr) do\n      assert(valid_name(key), format(\"invalid key %s\", key))\n   end\n   return elem.moldAttr(attr)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, match = L.P, L.R, L.match\n\nlocal name_patt = (R\"AZ\" + R\"az\" + P\"_\" + P\":\")\n               * (R\"az\" + R\"AZ\" + R\"09\" + P\"_\" + P\"-\" + P\".\" + P\":\")^0\n\nfunction valid_name(str)\n   return (match(name_patt, str) == (#str + 1))\n          and str or nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Element.hasattr(elem, key)\n   return elem._attr[key] or nil\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone = table.cloneinstance\n\nfunction Elem_M.__add(elem, attr)\n   local why; attr, why = validAttr(elem, attr)\n   if not attr then\n      error(why)\n   end\n\n   local _elem = clone(elem)\n   local _attr = _elem._attr\n   for key, value in pairs(attr) do\n      if table(value) then\n         if not _attr[key] then\n            _attr[key] = clone(value)\n         else\n            local tab = _attr[key]\n            if not table(tab) then\n               tab = {tab}\n            end\n            local top = #tab\n            for i = 1, #value do\n               tab[top+i] = value[i]\n            end\n         end\n      else\n         _attr[key] = value\n      end\n   end\n\n   return _elem\nend\n\n\n\n\n\n\n\n\n\n\n\n\nElement.render = require \"modlang:render\"\n\n\n\n\n\n\n\n\nfunction Elem_M.__call(elem, attr)\n   local entity = Entity(elem, attr)\n\n   return entity\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "element",
branch = "rise-of-modlang",
},
  { 
hash = "2e964141968ce48a2a73654368ef306e8c745f5b9493a6ff349b24260644def5",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = use(\"qor:core\", \"cluster:cluster\")\nlocal Set = core.set\nlocal table, string = core.table, core.string\nlocal XML = require \"util:xml\"\nlocal walk = require \"gadget:walk\"\nlocal Deque = use \"deque:deque\"\n\n\n\nlocal XSD = core.string.slurp(\"../util/etc/xml/svgxsd.xml\")\n\n\n\nlocal push, pop = table.insert, table.remove\nlocal getset = table.getset\n\nlocal filter, depth = assert(walk.filter), assert(walk.depth)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function oneStat(st, elem)\n   local name, attr = elem.name, elem.attr\n   local ct = st.count or 0\n   st.count = ct + 1\n   local at_set, parent = st.attr   or Set {},\n                          st.parent or Set {}\n   st.attr, st.parent = at_set, parent\n   if elem.parent then\n      parent[elem.parent] = true\n   end\n   for key_name in pairs(attr or {}) do\n      at_set[key_name] = true\n   end\nend\n\nlocal function statElement(stat, elem)\n   local popct = assert(stat.popCount)\n   local st, new = getset(popct, elem.name)\n   if new then\n      st.attr, st.parent, st.child = Set(), Set(), Set()\n      st.count = 0\n   end\n   oneStat(st, elem)\n   local child = st.child\n\n   for _, node in ipairs(elem) do\n      child[node.name] = true\n      statElement(stat, node)\n   end\nend\n\n\n\nlocal function statSchema(stat, scheme)\n   assert(scheme.name == \'schema\')\n   local topElements = Set {}\n   local nameless = 0\n   for _, elem in ipairs(scheme) do\n      if elem.name then\n         topElements[elem.name] = true\n      else\n         nameless = nameless + 1\n      end\n   end\n   stat.topElements = topElements\n   stat.namelessTopElements = nameless > 0 and nameless or nil\nend\n\n\n\n\nlocal function xmlStat(xml)\n   xml = xml or XSD\n   local dom = XML:tree(xml, { no_comment = true,\n                                drop = { annotation = true,\n                                         documentation = true, } })\n   local stat = {popCount = {}}\n   local scheme = assert(dom[2])\n   statSchema(stat, scheme)\n   statElement(stat, dom)\n   return stat\nend\n\n\n\n\n\n\n\n\n\n\nlocal relevantSimple = Set {\'enumeration\', \'restriction\', \'union\', \'list\'}\n\nlocal dontCare = Set {\'annotation\', \'documentation\', \"#comment\"}\n\n\n\nlocal function popCount(name_map)\n   local pops = {}\n\n   for tag, tree in pairs(name_map) do\n      local pop = {}\n      pops[tag] = pop\n      for node in depth(tree) do\n         local name = node.name\n         if node.name then\n            local popct = pop[name] or 0\n            pop[name] = popct + 1\n         end\n      end\n   end\n\n   return pops\nend\n\n\n\nlocal op = {}\n\nlocal function Nil()\n   return nil\nend\n\nfor elem in pairs(dontCare) do\n   op[elem] = Nil\nend\n\nlocal digestSimple;\n\n\n\nlocal find, sub = assert(string.find), assert(string.sub)\nlocal split = assert(string.split)\n\nlocal function svgName(str)\n   local first, last = find(str, \'svg:\')\n   if first then\n      return true, sub(str, last + 1)\n   else\n      local ns, name = split(str, \":\")\n      if name ~= \"\" then\n         return false, name, ns\n      else\n         return false, str\n      end\n   end\nend\n\n\nlocal function hasKid(parent, name)\n   for _, kid in ipairs(parent) do\n      if kid.name == name then\n         return true\n      end\n   end\n   return false\nend\n\nfunction op.pattern(strict)\n   for _, kid in ipairs(strict) do\n      if kid.name == \'pattern\' then\n         return assert(kid.attr.value)\n      end\n   end\nend\n\nlocal restrictedKid = Set {\'enumeration\', \'#comment\',\n                           \'simpleType\', \'union\', \'pattern\'}\n\nfunction op.restriction(strict)\n   local st = { base = strict.attr.base }\n\n   if hasKid(strict, \'enumeration\') then\n      st.enum = op.enumeration(strict)\n   end\n   if hasKid(strict, \'simpleType\') then\n      st.simple = digestSimple(strict[1])\n   end\n   if hasKid(strict, \'union\') then\n      st.union = op.union(strict)\n   end\n   if hasKid(strict, \'pattern\') then\n      st.pattern = op.pattern(strict)\n   end\n\n   st.not_handled = {}\n   for _, kid in ipairs(strict) do\n      if not restrictedKid[kid.name] then\n         push(st.not_handled, kid.name or kid)\n      end\n   end\n   if #st.not_handled == 0 then\n      st.not_handled = nil\n   end\n\n   return st\nend\n\nfunction op.enumeration(strict)\n   local enum = Set {}\n   for _, variant in ipairs(strict) do\n      if variant.name == \'enumeration\' then\n         local value = variant.attr.value\n         if value then\n            enum[value] = true\n         end\n      end\n   end\n   return enum\nend\n\nfunction op.union(union_of)\n   local union = {}\n   for _, simple in ipairs(union_of) do\n      push(union, (digestSimple(simple)))\n   end\n   return { union = union }\nend\n\nfunction op.list(list)\n   return { list_of_type = assert(list.attr.itemType) }\nend\n\n\nfunction digestSimple(simple)\n   local stats, rejects = { simple = true }, {}\n   --stats.pops = popCount({simple = simple}) . simple\n   for i, elem in ipairs(simple) do\n      if relevantSimple[elem.name] then\n         push(stats, op[elem.name](elem))\n      elseif dontCare[elem.name] then\n         -- continue\n      else\n         insert(rejects, elem)\n      end\n   end\n   if #rejects == 0 then\n      rejects = nil\n   end\n   if #stats == 1 then\n      stats = stats[1]\n      stats.simple = true\n   end\n   return stats, rejects\nend\n\n\n\nlocal nkeys = assert(table.nkeys)\n\n\n\nlocal function elementChild(parent, elem)\n   local name = elem.attr.name or elem.attr.ref\n   if nkeys(elem.attr) > 1 then\n      parent[name] = elem.attr\n   else\n      parent[name] = { ref = elem.attr.ref and true or nil,\n                       name = elem.attr.name and true or nil }\n   end\n   return parent\nend\n\n\n\nlocal onSequence, onChoice, onGroup, onAttribute\n\n\n\nfunction onSequence(sequence)\n   local seq = { maxOccurs = sequence.attr.maxOccurs,\n                 minOccurs = sequence.attr.minOccurs }\n   for _, elem in ipairs(sequence) do\n      if elem.name == \'choice\' then\n         push(seq, { choice = onChoice(elem) })\n      elseif elem.name == \'element\' then\n         push(seq, { element = elementChild({}, elem) })\n      elseif elem.name == \'group\' then\n         if elem.attr.ref ~=\"svg:descTitleMetadata\" then\n            error(\"interesting group discovered\")\n         end\n      else\n         error(\"spurious sequence child \" .. elem.name)\n      end\n   end\n\n   return seq\nend\n\n\n\nfunction onChoice(choice)\n   local choose = { maxOccurs = choice.attr.maxOccurs,\n                    minOccurs = choice.attr.minOccurs }\n   choose.elem = {}\n   for _, elem in ipairs(choice) do\n      assert(#elem == 0)\n      if elem.name == \'element\' then\n         elementChild(choose.elem, elem)\n      else\n         error(\"choice child \" .. elem.name)\n      end\n   end\n\n   return choose\nend\n\n\n\nfunction onAttribute(attrib, exclude)\n   local trib = {}\n\n   for key, value in pairs(attrib.attr) do\n      if key == \'type\' then\n         local is_svg, short_val, ns = svgName(value)\n         if is_svg then\n            trib[key] = short_val\n         elseif ns then\n            trib[key] = { [ns] = short_val }\n         else\n            trib[key] = value\n         end\n      elseif key ~= exclude then\n         trib[key] = value\n      end\n   end\n\n   if exclude ~= \'name\' then\n      trib[exclude] = true\n   end\n\n   for _, elem in ipairs(attrib) do\n      if elem.name == \'simpleType\' then\n         assert(not trib.type, \"a double type? bad schema\")\n         trib.type = digestSimple(elem)\n      end\n   end\n\n   return trib\nend\n\n\n\nfunction digestAttributeGroup(attribGroup)\n   local attribG = {}\n   for _, attrib in ipairs(attribGroup) do\n      if attrib.name == \'attribute\' then\n         if attrib.attr.name then\n            attribG[attrib.attr.name] = onAttribute(attrib, \'name\')\n         elseif attrib.attr.ref then\n            attribG[attrib.attr.ref] = onAttribute(attrib, \'ref\')\n         else\n            error (\"weird attribute nkeys \" .. nkeys(attrib.attr))\n         end\n      elseif attrib.name == \'attributeGroup\' then\n         assert(nkeys(attrib.attr) == 1)\n         attribG[attrib.attr.ref] = true\n      else\n         error(\"weird attributeGroup element \" .. attrib.name)\n      end\n   end\n   return attribG\nend\n\n\n\nlocal function digestComplex(complex)\n   local stat = {}\n   local attribute, attrGroup, sequence, choice = {}, {}, {}, {}\n   for key, value in pairs(complex.attr) do\n      if key ~= \'name\' then\n         stat.attr = stat.attr or {}\n         stat.attr[key] = value\n      end\n   end\n   for i, elem in ipairs(complex) do\n      local name = elem.attr and elem.attr.name\n      if elem.name == \'attribute\' then\n         if name then\n            attribute[name] = onAttribute(elem, \'name\')\n         elseif elem.attr.ref then\n            attribute[elem.attr.ref] = onAttribute(elem, \'ref\')\n         else\n            push(stat, onAttribute(elem))\n         end\n      elseif elem.name == \'attributeGroup\' then\n         local is_svg, ref = svgName(elem.attr.ref)\n         if is_svg then\n            push(attrGroup, ref)\n         else\n            push(attrGroup, elem.attr.ref)\n         end\n         assert(#elem == 0)\n         for key in pairs(elem.attr) do\n            if key ~= \'ref\' then\n               error(\"handle an attributeGroup attribute \" .. key)\n            end\n         end\n      elseif elem.name == \'choice\' then\n         assert(not stat.choice)\n         stat.choice = onChoice(elem)\n      elseif elem.name == \'sequence\' then\n         assert(not stat.sequence)\n         stat.sequence = onSequence(elem)\n      else\n         local ct = stat[elem.name] or 0\n         stat[elem.name] = ct + 1\n      end\n   end\n\n   if nkeys(attribute) > 0 then\n      stat.attribute = attribute\n   end\n\n   if nkeys(attrGroup) > 0 then\n      stat.attrGroup = Set(attrGroup)\n   end\n\n   if #sequence > 0 then\n      stat.sequence = sequence\n   end\n\n   return stat\nend\n\n\n\n\nlocal function Flense(xml)\n   xml = xml or XSD\n   local tree = XML:tree(xml, { no_comment = true,\n                                drop = { annotation = true,\n                                         documentation = true, } })\n   -- look for the schema\n   local schema, at;\n   for i, elem in ipairs(tree) do\n      if elem.name == \'schema\' then\n         schema = elem\n         at = i\n         break\n      end\n   end\n   if not schema then\n      error \"document has no schema element\"\n   end\n   -- find target namespace and prefix\n   local namespaces = {}\n   local target, namespace;\n   for key, value in pairs(schema.attr) do\n      if key == \'targetNamespace\' then\n         target = value\n      else\n         local prefix = sub(key, 1, 5)\n         if prefix == \'xmlns\' then\n            namespaces[key] = value\n         end\n      end\n   end\n   for ns, link in pairs(namespaces) do\n      if link == target then\n         --assert(sub(ns, 1, 6) == \'xmnls:\', \"oops  \" .. ns)\n         namespace = sub(ns, 7)\n         break\n      end\n   end\n\n\n   local simple, complex, element, attrGroup =  {}, {}, {}, {}\n\n   for _, elem in ipairs(schema) do\n      elem.o = nil -- don\'t need this one\n      local name = elem.attr and elem.attr.name\n      if elem.name == \'simpleType\' then\n         simple[name] = digestSimple(elem)\n      elseif elem.name == \'complexType\' then\n         complex[name] = digestComplex(elem)\n      elseif elem.name == \'attributeGroup\' then\n         attrGroup[name] = digestAttributeGroup(elem)\n      elseif elem.name == \'element\' then\n         local is_svg, tName, ns = svgName(elem.attr.type)\n         if is_svg then\n            element[name] = tName\n         else\n            element[name] = ns and { [ns] = tName } or tNAme\n         end\n         assert(nkeys(elem.attr) == 2, \"more or less keys\")\n      end\n   end\n\n   --- combine all simple and complex into just \'types\'\n   local allTypes = table.clone(simple)\n   for k, v in pairs(complex) do\n      assert(not allTypes[k], \"duplicate key in complex of \" .. k)\n      allTypes[k] = v\n   end\n\n   -- assign types to elements\n   for name, type in pairs(element) do\n      assert(allTypes[type], type)\n      element[name] = allTypes[type]\n   end\n\n\n   local busted = {}\n\n   ---[[ resolve attribute groups\n   for groupName, group in pairs(attrGroup) do\n      for name, elem in pairs(group) do\n         if elem == true then\n            assert(name:sub(1,4) == \'svg:\', \"failed \" .. name)\n            local ref = sub(name, 5)\n            group[ref] = assert(attrGroup[ref])\n            group[name] = nil\n         end\n      end\n   end\n\n   local function refElements(elem)\n      for name, el in pairs(elem) do\n         if type(el) == \'table\' and el.ref then\n            local is_svg, ref = svgName(name)\n            if is_svg then\n               elem[ref] = element[ref]\n               elem[name] = nil\n            end\n         end\n      end\n      return elem\n   end\n\n   ---[[ make complex types complex\n   for name, cType in pairs(allTypes) do\n      local _attrG = cType.attrGroup\n      local attribute = cType.attribute or {}\n      for ref in pairs(_attrG or {}) do\n         local group = assert(attrGroup[ref], \"missing\" .. ref)\n         for name, attr in pairs(group) do\n            if attr == true then\n               assert(name:sub(1,4) == \'svg:\', \"failed \" .. name)\n               local ref = sub(name, 5)\n               group[ref] = assert(attrGroup[ref])\n               group[name] = nil\n            end\n            --attribute[name] = attr\n         end\n         cType.attrGroup = nil\n         cType.attribute = attribute\n      end\n      for name, attr in pairs(attribute) do\n         if attr == true then\n            assert(name:sub(1,4) == \'svg:\', \"failed \" .. name)\n            local ref = sub(name, 5)\n            attribute[name] = nil\n            attribute[ref] = assert(attrGroup[ref])\n         elseif attr.type and type(attr.type) == \'string\' then\n            attr.type = allTypes[attr.type] or attr.type\n         end\n      end\n      local choice = cType.choice\n      if choice then\n         choice.elem = refElements(choice.elem)\n      end\n      local seq = cType.sequence\n      if seq then\n         for i, el in ipairs(seq) do\n            if el.element then\n               el.element = refElements(el.element)\n            elseif el.choice then\n               el.choice = refElements(el.choice.elem)\n            end\n         end\n      end\n   end --]]\n   ---[[ the dupe ripper. shouldn\'t need it.. but.\n   local dupe = {}\n   local function ripper(tab)\n      if dupe[tab] then return end\n      dupe[tab] = true\n      for k, v in pairs(tab) do\n         if type(k) == \'string\' and sub(k, 1, 4) == \'svg:\' then\n            --busted[k] = true\n            local str = sub(k, 5)\n            tab[k] = nil\n            tab[str] = attrGroup[str] or element[str] or error \"rogue key\"\n         end\n         if type(v) == \'table\' then\n            ripper(v)\n         end\n      end\n   end\n   --]]\n   ripper(complex)\n\n   return { simple    = simple,\n            namespace = namespace,\n            namespaces = namespaces,\n            allTypes  = allTypes,\n            attrGroup = attrGroup,\n            busted    = busted,\n            tree      = tree,\n            complex   = complex,\n            element   = element }\nend\n\n\n\nreturn { stat   =  xmlStat,\n         flense =  Flense }\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "flense",
branch = "rise-of-modlang",
},
  { 
hash = "de2c770ac11b9b6b644856f0078a985fdc8b7057418fa6b66584936abcc687ba",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal gsub, format = assert(string.gsub), assert(string.format)\nlocal insert, concat = assert(table.insert), assert(table.concat)\nlocal base = require \"modlang:base\"\nlocal mlEscape = assert(base.mlEscape)\n\n\n\n\n\n\nlocal ts = require \"repr:repr\" .ts\nlocal table = core.table\nlocal keys = assert(table.keys)\n\nlocal function formatAttr(key, value)\n   -- keys are validated on the way in and don\'t need escaping\n   return \' \' .. key .. \'=\"\' .. mlEscape(value) .. \'\"\'\nend\n\nlocal function render(elem, page, d)\n   local nl = #elem > 0 and \'\\n\' or \"\"\n\n   -- we need the Real Element for most of this, which we get this way\n   local E = elem.elem or elem -- entity points to papa\n\n   d = d or 0\n   page = page or {}\n   local dent;\n   -- pad\n   if E.indent then\n      dent = (\'\\t\'):rep(d)\n      insert(page, dent)\n   end\n   -- start\n   insert(page, E.start)\n\n   -- attrs: Entities have a key Set, Elements iterate the same way\n   -- this should be something like =for k, v in elem:attributes()= really\n   local attr_key = elem.attr_key or elem._attr\n   for key in pairs(attr_key) do\n      local value = elem._attr[key]\n      if table(value) then\n         for _, val in ipairs(value) do\n            insert(page, formatAttr(key, val))\n         end\n      else\n         insert(page, formatAttr(key, value))\n      end\n   end\n\n   if E.void then\n      insert(page, \'/>\\n\')\n      -- self-closing tags with children are malformed, let\'s complain\n      if #elem > 0 then\n         -- better for this to be impermissable but\n         local punchline = #elem > 1 and \" children\" or \" child\"\n         error(\"void tag \" .. E.tag .. \" with \" .. #elem .. punchline)\n      else\n         return page\n      end\n   else\n      insert(page, \'>\')\n      insert(page, nl)\n   end\n\n   -- Elements may not(?) have sub-entities\n   if E ~= elem then\n      for _, child in ipairs(elem) do\n         if child.isText then\n            insert(page, child:render())\n         else\n            render(child, page, d + 1)\n         end\n      end\n   end\n\n   if E.close then\n      -- indent again and close tag\n      insert(page, dent)\n      insert(page, E.close)\n   end\n   --]]\n\n\n   return page\nend\n\n\n\nreturn function(elem, page, d) return concat(render(elem, page, d)) end\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "render",
branch = "rise-of-modlang",
},
  { 
hash = "6b0711c06803babc5fa80c04d2b72ca3dd5bccb226b8045fdf35296fb4634628",
binary = "\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal string, table = core.string, core.table\nlocal Set = assert(core.set)\nlocal Text = require \"modlang:text\"\n\n\n\n\n\n\n\n\nlocal new, Entity, Entity_M = cluster.order()\nEntity.isEntity = true\n\n\n\n\n\n\n\n\n\n\n\nlocal _attr_M = setmetatable({}, { __mode = \'kv\' })\n\nlocal function _metaFor(attr)\n   if _attr_M[attr] then\n      return _attr_M[attr]\n   end\n   local attr_M = { __index = attr }\n   _attr_M[attr] = attr_M\n\n   return attr_M\nend\n\n\n\ncluster.construct(new, function(_new, entity, elem, attr)\n   attr = attr or {}\n   entity.elem = elem\n   -- mold new attributes\n   attr = elem.moldAttr(attr)\n   entity._attr = setmetatable(attr, _metaFor(elem._attr))\n   local attr_key = Set {}\n   entity.attr_key = attr_key\n   for key in pairs(elem._attr) do\n      attr_key[key] = true\n   end\n   for key in pairs(attr) do\n      attr_key[key] = true\n   end\n   return entity\nend)\n\n\n\n\n\n\n\n\nfunction Entity_M.call(entity, ...)\n   local elem = ...\n   if elem == nil then return nil end\n   -- here we validate: entity, element, text, cdata, comment\n   -- and more advanced stuff as we go, component? something like that\n   insert(entity, elem)\n   return entity(select(2, ...))\nend\n\n\n\n\n\n\nEntity.render = require \"modlang:render\"\n\n\n\n\n\n\n\n\n\nfunction Entity_M.__add(entity, attr)\n   assert(entity.isEntity, \"Entity must be left hand side of addition\")\n   attr = entity.elem.moldAttr(attr)\n   for k, v in pairs(attr) do\n      entity.attr_key[k] = true\n      entity._attr[k] = v\n   end\n\n   return entity\nend\n\n\n\n\n\n\n\nfunction Entity_M.__concat(entity, str)\n   assert(string(str))\n   insert(entity, Text(str))\n\n   return entity\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _build = require \"modlang:builder\"\n\nfunction Entity.build(entity)\n   local elem = entity.elem\n   local build;\n   if elem then\n      build = elem.build\n   end\n   if not build then\n      build = _build()\n   end\n   return build(entity)\nend\n\n\n\nreturn new\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "entity",
branch = "rise-of-modlang",
},
  { 
hash = "11b3406c5652d1806e1736b147a2f9bd6aa57a52ce6bad4ae89b7f4568baad8b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal base = require \"modlang:base\"\n\n\n\nlocal new, Text = cluster.order()\n\n\n\nlocal mlEscape = assert(base.mlEscape)\n\ncluster.construct(new, function(_new, text, str)\n   text.txt = str\n   text.isText = true\n   text.esc_txt = mlEscape(str)\n   return text\nend)\n\n\n\n\n\n\n\n\nfunction Text.render(text)\n   return text.esc_txt\nend\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
vc_hash = "52d61350975aad42ad92c6b5061e9162971b19f4\n",
name = "text",
branch = "rise-of-modlang",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.com/special-circumstance/orb.git\n\nhttps://gitlab.com/atman/orb.git\n\nhttps://gitlab.special-circumstanc.es/bridge-tools/orb.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "orb",
    repo = "https://github.com/mnemnion/orb.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "19a1473e4c09e06c7fbe361d3f310e57bd20507c86933cafd6dd7fd3de3c1d17",
binary = "\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\nlocal sql = assert(sql, \"must have sql in bridge _G\")\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal uv  = require \"luv\"\nlocal sha = require \"compile/sha2\" . sha3_512\nlocal database = require \"orb:compile/database\"\n\n\n\nlocal commit = {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\nlocal function commitModule(stmt, bytecode, project_id, bundle_id,\n                            version_id, git_info, now)\n   -- get code_id from the hash\n   local code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmt.new_code:bindkv(bytecode):step()\n      stmt.code_id:reset()\n      code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmt.add_module:bindkv(mod):step()\n   for _, st in pairs(stmt) do\n      st:reset()\n   end\nend\n\ncommit.commitModule = commitModule\n\n\n\n\n\n\nlocal sh = require \"lash:lash\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction commit.commitCodex(codex)\n   local conn = database.open()\n   local now = tostring(date())\n   -- begin transaction\n   conn:exec \"BEGIN TRANSACTION;\"\n   -- select project_id\n   local project_id = database.project(conn, codex:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, codex:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmt = { code_id = conn:prepare(get_code_id_by_hash),\n                  new_code = conn:prepare(new_code),\n                  add_module = conn:prepare(add_module) }\n   for _, bytecode in pairs(codex.bytecodes) do\n      commitModule(stmt,\n                   bytecode,\n                   project_id,\n                   bundle_id,\n                   version_id,\n                   codex.git_info,\n                   now)\n   end\n   -- commit transaction\n   conn:exec \"COMMIT;\"\n   -- use a pcall because we get a (harmless) error if the table is locked\n   -- by another process:\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   -- set up an idler to close the conn, so that e.g. busy\n   -- exceptions don\'t blow up the hook\n   local close_idler = uv.new_idle()\n   close_idler:start(function()\n      local success = pcall(conn.close, conn)\n      if not success then\n        return nil\n      else\n        close_idler:stop()\n        uv.stop()\n      end\n   end)\n   if not uv.loop_alive() then\n      uv.run \"default\"\n   end\nend\n\n\n\n\nreturn commit\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "compile/commit",
branch = "orb-scry",
},
  { 
hash = "ce2d1cdcff5467a78f01c44a34da0c7ee84db9ab23fd798cb60d1ed314b6434b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compiler, compilers = {}, {}\ncompiler.compilers = compilers\n\n\n\n\n\n\nlocal sha = require \"util:sha\" . shorthash\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _moduleName(path, project)\n   local mod = {}\n   local inMod = false\n   for i, v in ipairs(path) do\n      if v == project then\n         inMod = true\n      end\n      if inMod then\n         if i ~= #path then\n            table.insert(mod, v)\n          else\n             table.insert(mod, path:barename())\n         end\n      end\n   end\n   -- drop the bits of the path we won\'t need\n   --- awful kludge fix\n   local weird_path = table.concat(mod)\n   local good_path = string.gsub(weird_path, \"%.%_\", \"\")\n   local _, cutpoint = string.find(good_path, \"/src/\")\n   local good_path = string.sub(good_path, cutpoint + 1)\n   return good_path\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction compilers.lua(skein)\n   local project = skein.lume.project\n   skein.compiled = skein.compiled or {}\n   local compiled = skein.compiled\n   local path = skein.knitted.lua.path\n   local src = skein.knitted.lua\n   local mod_name = _moduleName(path, project)\n   local bytecode, err = load (tostring(src), \"@\" .. mod_name)\n   if bytecode then\n      -- add to srcs\n      local byte_str = tostring(src) -- #todo: parse and strip\n      local byte_table = {binary = byte_str}\n      byte_table.hash = sha(byte_str)\n      byte_table.name = mod_name\n      byte_table.err = false\n      compiled.lua = byte_table\n      s:verb(\"compiled: \" .. project .. \":\" .. byte_table.name)\n   else\n      s:chat \"error:\"\n      s:chat(err)\n      -- exit (later) with error code\n      bridge.retcode = bridge.retcode + 1\n      compiled.lua = { err = err }\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction compiler.compile(compiler, skein)\n   for extension, scroll in pairs(skein.knitted) do\n      if compiler.compilers[extension] then\n         compiler.compilers[extension](skein)\n      end\n   end\nend\n\n\n\nreturn compiler\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "compile/compiler",
branch = "orb-scry",
},
  { 
hash = "e5cfe863e3d8022d75f146db58fdd011b0dd248a14b22e041147990fdca7aaf5",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal unwrapKey, toRow = assert(sql.unwrapKey), assert(sql.toRow)\n\n\n\n\n\n\nlocal database = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project = [[\nSELECT * FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal latest_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = ?\nORDER BY major DESC, minor DESC, patch DESC\nLIMIT 1\n;\n]]\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = :project\nAND version.major = :major\nAND version.minor = :minor\nAND version.patch = :patch\nAND version.edition = :edition\nAND version.stage = :stage\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, stage, project, major, minor, patch)\nVALUES (:edition, :stage, :project, :major, :minor, :patch)\n;\n]]\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal function _updateProjectInfo(conn, db_project, codex_project)\n   -- determine if we need to do an update\n   local update = false\n   for k, v in pairs(codex_project) do\n      if db_project[k] ~= v then\n         update = true\n      end\n   end\n   if update then\n      local stmt = conn:prepare(update_project)\n      stmt:bindkv(codex_project):step()\n   end\nend\n\n\n\nfunction database.project(conn, codex_info)\n   local db_info = conn:prepare(get_project):bind(codex_info.name):resultset()\n   db_info = toRow(db_info) or {}\n   local project_id = db_info.project_id\n   if project_id then\n      s:verb(\"project_id is \" .. project_id)\n      -- update information if there are any changes\n      _updateProjectInfo(conn, db_info, codex_info)\n   else\n      conn:prepare(new_project):bindkv(codex_info):step()\n      project_id = conn:prepare(get_project):bind(codex_info.name):step()\n      if not project_id then\n         error (\"failed to create project \" .. codex_info.project)\n      else\n         project_id = project_id[1]\n      end\n   end\n   return project_id\nend\n\n\n\n\n\n\nfunction database.version(conn, version_info, project_id)\n   local version_id\n   if not version_info.is_versioned then\n      version_id = conn:prepare(latest_version):bind(project_id):step()\n      if not version_id then\n         conn : prepare(new_version_snapshot) : bindkv\n              { edition = \"\",\n                project = project_id }\n              : step()\n         version_id = conn:prepare(latest_version):bind(project_id):step()\n         if not version_id then\n            error \"didn\'t make a SNAPSHOT\"\n         else\n            version_id = version_id[1]\n         end\n      else\n         version_id = version_id[1]\n      end\n   else\n      version_info.project = project_id\n      conn:prepare(new_version):bindkv(version_info):step()\n      version_id = conn:prepare(get_version):bindkv(version_info):step()\n      if not version_id then\n         error \"failed to create version\"\n      end\n      version_id = version_id[1]\n   end\n   s:verb(\"version_id is \" .. version_id)\n   return version_id\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\n\nfunction database.commitSkein(skein, stmts, ids, git_info, now)\n   local bytecode = skein.compiled and skein.compiled.lua\n   if not bytecode or bytecode.err then\n      local err = bytecode and bytecode.err\n      if err then\n        s:complain(\"attempt to commit erroneous bytecode data: %s, %s\",\n               tostring(skein.source.file), err)\n        return nil, err\n      end\n      -- missing bytecode means the Doc didn\'t create a knitted.lua, which\n      -- is normal\n      return nil\n   end\n   local project_id, version_id, bundle_id = ids.project_id,\n                                             ids.version_id,\n                                             ids.bundle_id\n   -- get code_id from the hash\n   local code_id = stmts.code_id :bindkv(bytecode) :value()\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmts.new_code :bindkv(bytecode) :value()\n      code_id = stmts.code_id :bindkv(bytecode) :value()\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmts.add_module:bindkv(mod) :value()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction database.writeArtifacts(stmts, stuff, git_info, now, ids)\n   local bytecode = stuff.bytecode\n   if not bytecode or bytecode.err then\n      local err = bytecode and bytecode.err\n      if err then\n        s:complain(\"attempt to commit erroneous bytecode data: %s, %s\",\n               tostring(stuff.name), err)\n        return nil, err\n      end\n      -- missing bytecode means the Doc didn\'t create a knitted.lua, which\n      -- is normal\n      return nil\n   end\n   -- we probably should unwrap these into parameters\n   local project_id, version_id, bundle_id = ids.project_id,\n                                             ids.version_id,\n                                             ids.bundle_id\n   -- get code_id from the hash\n   local code_id = stmts.code_id :bindkv(bytecode) :value()\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmts.new_code :bindkv(bytecode) :value()\n      code_id = stmts.code_id :bindkv(bytecode) :value()\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmts.add_module:bindkv(mod) :value()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction database.commitBundle(lume)\n   local conn = lume.conn or s:halt(\"no database conn on the Lume\")\n   local now = lume:now()\n   -- select project_id\n   local project_id = database.project(conn, lume:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, lume:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmts = { code_id = conn:prepare(get_code_id_by_hash),\n                   new_code = conn:prepare(new_code),\n                   add_module = conn:prepare(add_module) }\n   -- wrap ids\n   local ids = { project_id = project_id,\n                 version_id = version_id,\n                 bundle_id  = bundle_id }\n   return stmts, ids, now\nend\n\n\n\n\nreturn database\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "compile/database",
branch = "orb-scry",
},
  { 
hash = "79e5c65deda8e1f0f2acf102efb4838e4ec115c96b04ec0e6c58351328f635fa",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint (\n   codepoint_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   codevalue NOT NULL,\n   utf INTEGER default 1,\n   category STRING NOT NULL DEFAULT \'utf\',\n   version STRING NOT NULL DEFAULT \'official\',\n   destription STRING NOT NULL,\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint_in (\n   codepoint_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   document UNIQUE, NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   codepoint INTEGER NOT NULL,\n   doc INTEGER NOT NULL,\n   document INTEGER NOT NULL,\n   FOREIGN KEY codepoint\n      REFERENCES codepoint (codepoint_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word (\n   word_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word STRING UNIQUE NOT NULL ON CONFLICT DO NOTHING,\n   -- JSON array of codepoint_ids\n   spelling BLOB NOT NULL ON CONFLICT DO NOTHING,\n   thesaurus INTEGER,\n   FOREIGN KEY thesaurus\n      REFERENCES thesaurus (thesaurus_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word_in (\n   word_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word_repr STRING NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   word INTEGER,\n   doc INTEGER,\n   document INTEGER,\n   FOREIGN KEY word\n      REFERENCES word (word_id),\n   FOREIGN KEY doc\n      REFERENCE doc (doc_id)\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "concordance/concordance",
branch = "orb-scry",
},
  { 
hash = "64c2f718f7d1581d0e42030c3bd58666b892d5a6fe69bec990a75a3976f08043",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c_noknit = require \"orb:knit/predicator\" \"#asLua\"\n\n\n\n\n\n\nlocal C_knit = require \"orb:knit/knitter\" \"c\"\n\n\n\n\n\n\n\n\n\nfunction C_knit.examine(c_knit, skein, codeblock)\n   if c_noknit(codeblock, skein) then\n      return false\n   else\n      return true\n   end\nend\n\n\n\n\nreturn C_knit\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/c",
branch = "orb-scry",
},
  { 
hash = "f614f06d2878d172469c3a5cb6445cc6aa5e190e1bad1e439b940a50fda81c65",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.boring = false\n\n\n\n\n\nlocal knitters = require \"orb:knit/knitters\"\n\n-- we need this as long as we have to support both forms, and perhaps not\n-- after\nlocal Knitter = require \"orb:knit/knitter\"\n\nlocal core = require \"core:core\"\n\n\n\nlocal Knit = {}\nKnit.__index = Knit\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Knit.knit(knitter, skein)\n   local doc = skein.source.doc\n   local knitted\n   if skein.knitted then\n      knitted = skein.knitted\n   else\n      knitted = {}\n      skein.knitted = knitted\n   end\n   local knitters = knitters\n\n   for codeblock in doc :select \'codeblock\' do\n      local code_type = codeblock :select \'code_type\'() :span()\n      local tagset = skein:tagsFor(codeblock)\n      if tagset(\"noKnit\") then\n         goto continue\n      end\n      -- special case asLua blocks, for now\n      if tagset(\"asLua\") then\n         local scroll = skein:knitScroll(knitters.lua)\n         knitters.lua:knit(skein, codeblock, scroll)\n      end\n      -- this takes over\n      for _type, knitter in pairs(knitters) do\n         if _type == code_type then\n            s:bore(\"block of type %s\", _type)\n            if knitter:examine(skein, codeblock) then\n               local scroll = skein:knitScroll(knitter)\n               knitter:knit(skein, codeblock, scroll)\n            end\n         end\n      end\n      ::continue::\n   end\n   -- clean up unused scrolls\n   for code_type, scroll in pairs(knitted) do\n      if #scroll == 0 then\n         knitted[code_type] = nil\n      end\n   end\nend\n\n\n\nlocal function new()\n   local knitter = setmetatable({}, Knit)\n\n   return knitter\nend\n\nKnit.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/knit",
branch = "orb-scry",
},
  { 
hash = "38521c9fe203af463f595c61ad96cad589ab35250ae15f9b5d58f378c6cc3142",
binary = "\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\nlocal new, Knitter, Knit_M = cluster.genus()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnitter.code_type = nil\n\n\n\n\n\n\n\n\n\n\n\n\nKnitter.tags = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncluster.construct(new, function(_new, knitter, code_type)\n   assert(type(code_type) == \'string\', \"#1 must be a string\")\n   knitter.code_type = code_type\n   return knitter\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnitter.examine = assert(cluster.ur.no)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Knitter.knit(knitter, skein, codeblock, scroll)\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 1 do\n      scroll:add \"\\n\"\n   end\n   scroll:add(codebody)\n   -- add an extra line and skip 2, to get a newline at EOF\n   scroll:add \"\\n\"\n   scroll.line_count = line_end + 2\nend\n\n\n\nreturn new\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/knitter",
branch = "orb-scry",
},
  { 
hash = "ccbbdf71564ec024da85ea1e3f314431c50aba04eabc6ae8453ad2d18df60b85",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {  lua = require \"orb:knit/lua\",\n            c = require \"orb:knit/c\",\n         scad = require \"orb:knit/scad\",\n         plantuml = require \"orb:knit/plantuml\" }\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/knitters",
branch = "orb-scry",
},
  { 
hash = "2c476b15a305cafdabb580f46ee958672e5cb1a79d17f0466b862e91abcce133",
binary = "\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal Set = assert(core.set)\n\nlocal s = require \"status:status\" ()\n\n\n\nlocal Lua_knit = require \"orb:knit/knitter\" \"lua\"\n\n\n\n\n\n\nLua_knit.tags = Set {\'asLua\'}\n\n\n\n\n\n\nfunction Lua_knit.examine()\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, gsub = assert(string.format),\n                           assert(string.find),\n                           assert(string.gsub)\nlocal L = require \"lpeg\"\n\nlocal end_str_P = L.P \"]\" * L.P \"=\"^0 * L.P \"]\"\n\nlocal function _disp(first, last)\n   return last - first - 2\nend\n\n-- capture an array containing the number of equals signs in each matching\n-- long-string close, e.g. \"aa]]bbb]=]ccc]==]\" returns {0, 1, 2}\n\nlocal find_str = L.Ct(((-end_str_P * 1)^0\n                      * (L.Cp() * end_str_P * L.Cp()) / _disp)^1)\n\nfunction _pred_knit(codeblock, scroll, skein)\n   local name = codeblock:select \"name\"()\n   local codetype = codeblock:select(\"code_type\")():span()\n   local header, str_start = \"\", \" = [\"\n   if name then\n      -- stringify and drop \"@\"\n      name = name:select \"handle\"() :span() :sub(2)\n      -- normalize - to _\n      name = gsub(name, \"%-\", \"_\")\n      -- two forms: =local name= or (=name.field=, name[field])\n      if not (find(name, \"%.\") or find(name, \"%[\")) then\n         header = \"local \"\n      end\n   elseif codetype ~= \"c\" then\n      local linum = codeblock :select \"code_start\"() :linePos()\n      s:warn(\"an #asLua block must have a name, line: %d\", linum)\n      return\n   end\n   -- special-case #asLua C blocks as ffi.cdef\n   -- this allows for a named C code block; the name isn\'t used here but\n   -- can be used to reference the block elsewhere.\n   if codetype == \"c\" then\n      header = \"ffi.cdef \"\n      name = \"\"\n      str_start = \" [\"\n   end\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 2 do\n      scroll:add \"\\n\"\n   end\n   -- search for ==\"]\" \"=\"* \"]\"== in code_body span and add more = if\n   -- needful\n   local eqs = \"\"\n   local caps = L.match(find_str, codebody:span())\n   if caps then\n      table.sort(caps)\n      eqs = (\"=\"):rep(caps[#caps] + 1)\n   end\n   header = header .. name .. str_start .. eqs .. \"[\\n\"\n   scroll:add(header)\n   scroll:add(codebody)\n   scroll:add(\"]\" .. eqs .. \"]\\n\")\n   scroll.line_count = line_end + 2\nend\n\n\n\n\n\nfunction Lua_knit.knit(lua_knit, skein, codeblock, scroll)\n   local tags = skein.tags[codeblock]\n   -- old sets!\n   if tags and tags(\"asLua\") then\n      _pred_knit(codeblock, scroll, skein)\n   else\n      local codebody = codeblock :select \"code_body\" ()\n      local line_start, _ , line_end, _ = codebody:linePos()\n      for i = scroll.line_count, line_start - 1 do\n         scroll:add \"\\n\"\n      end\n      scroll:add(codebody)\n      -- add an extra line and skip 2, to get a newline at EOF\n      scroll:add \"\\n\"\n      scroll.line_count = line_end + 2\n   end\nend\n\n\n\n\nreturn Lua_knit\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/lua",
branch = "orb-scry",
},
  { 
hash = "cfb1161d019dd75713806df69088e542b0727088f5383d0c88d225bda9235341",
binary = "\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.chatty = true\nlocal Case = require \"scroll:case\"\n\n\n\nlocal PlantUML = require \"orb:knit/knitter\" \"plantuml\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction PlantUML.customScroll(plant, skein)\n   return Case()\nend\n\n\n\n\n\n\n\n\n\nfunction PlantUML.examine(plant, skein, codeblock)\n   return true\nend\n\n\n\nlocal spawn;\n\nfunction PlantUML.knit(plant, skein, codeblock, scroll)\n   spawn = spawn or require \"proc:spawn\"\n   local proc = spawn(\"plantuml\", {\"-tsvg\", \"-pipe\"})\n   if proc.didnotrun then\n      s:warn \"plantuml didn\'t run, is it installed?\"\n      return\n   end\n   s:verb \"writing plantuml\"\n   proc:write(codeblock :select \"code_body\"() :span())\n   local reddit = assert(proc:read(), debug.traceback())\n   s:chat(reddit)\n   scroll:add(reddit)\n   proc:exit() -- we can do better than this\nend\n\n\n\nreturn PlantUML\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/plantuml",
branch = "orb-scry",
},
  { 
hash = "4e791c5318b3f460bd5fc89d3fb8caca60c194212b003dde56391745256e197b",
binary = "\n\n\n\n\n\n\n\n\n\nreturn function(hashtag)\n   return function(codeblock, skein)\n      local tags = skein.tags[codeblock]\n      if tags and tags(hashtag) then\n         return true\n      else\n         return false\n      end\n   end\nend\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/predicator",
branch = "orb-scry",
},
  { 
hash = "3e2907fc12f455477d95e3d61a0877043f3617cbec9216bab7de298fdd25d0bc",
binary = "\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal Scad_knit = require \"orb:knit/knitter\" \"scad\"\n\n\n\nreturn Scad_knit\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "knit/scad",
branch = "orb-scry",
},
  { 
hash = "43b2566ae29561a97163d477b664c879f0cc74f12c4e8de98a233a1bbde51b59",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal sql = assert(sql)\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal git_info = require \"orb:util/gitinfo\"\nlocal Skein    = require \"orb:skein/skein\"\n-- local Deck     = require \"orb:lume/deck\"\nlocal Watcher  = require \"orb:lume/watcher\"\nlocal Manifest = require \"orb:manifest/manifest\"\nlocal database = require \"orb:compile/database\"\n\nlocal Dir   = require \"fs:fs/directory\"\nlocal File  = require \"fs:fs/file\"\nlocal Path  = require \"fs:fs/path\"\nlocal Deque = require \"deque:deque\"\nlocal Set   = require \"set:set\"\n\n\n\n\n\n\nlocal Lume = {}\nLume.__index = Lume\n\n\n\n\n\n\nlocal _Lumes = setmetatable({}, { __mode = \"kv\" })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Net = {}\n\n\n\nfunction Net.__index(net, ref)\n   -- resolve reference\n   -- make Skein\n   -- net carries a reference to parent lume:\n   s:verb(\"initial load of \" .. tostring(ref))\n   local skein = Skein(ref, net.lume)\n   -- cache result\n   rawset(net, ref, skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.run(lume)\n   -- determine if we need to start the loop\n   local loop_mode = uv.loop_mode()\n   local launcher = uv.new_idle()\n   local launch_running = true\n   launcher:start(function()\n      lume:bundle()\n      launcher:stop()\n      launch_running = false\n   end)\n\n   if not loop_mode then\n      s:chat \"running loop\"\n      uv.run \'default\'\n   end\n\n   local loop_alive = uv.loop_alive()\n   -- if there are remaining (hence broken) coroutines, run the skein again,\n   -- to try and catch the error:\n   local retrier = uv.new_idle()\n   retrier :start(function()\n      if launch_running or lume.persisting then\n         return\n      end\n\n      for _, skein in pairs(lume.inflight) do\n         s:verb(\"retry on %s\", tostring(skein.source.file))\n         local ok, err = xpcall(skein.transform, debug.traceback, skein)\n         if not ok then\n            s:warn(err)\n         end\n      end\n      retrier:stop()\n      s:verb(\"end run\")\n   end)\n   if not loop_alive then\n      uv.run \'default\'\n   end\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\nlocal function changer(lume)\n   return function (watcher, fname)\n      local full_name = tostring(lume.orb) .. \"/\" .. fname\n      s:chat (\"altered or new file %s\", full_name)\n      -- refresh git info\n      lume:gitInfo()\n      local skein = lume.net[File(full_name)]\n      skein:transform()\n      lume.has_file_change = true\n      s:chat(\"processed %s\", full_name)\n   end\nend\n\nfunction Lume.serve(lume)\n   s:chat(\"listening for file changes in orb/\")\n   s:chat(\"^C to exit\")\n   local loop_alive = uv.loop_alive()\n   lume.server = Watcher { onchange = changer(lume),\n                            onrename = changer(lume) }\n   lume.server(tostring(lume.orb))\n   if not loop_alive then\n      uv.run \'default\'\n   end\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, resume, running, yield = assert(coroutine.create),\n                                       assert(coroutine.resume),\n                                       assert(coroutine.running),\n                                       assert(coroutine.yield)\n\nlocal function _loader(skein, lume, path)\n   s:verb(\"begin read of %s\", path)\n   local co = running()\n   lume.inflight[co] = skein\n   -- one stage per line for nice stack traces\n   skein :load() -- yields\n         -- :filter()  -- #NYI\n         :spin()\n         :tag()\n         :tagAct()\n         :knit()\n         :weave()\n         :compile()\n         :tailor() -- this is in fact the only necessary method.\n   s:verb(\"processed: %s\", path)\n   lume.count = lume.count - 1\n   lume.inflight[co] = nil\n   lume.tailored:push(skein)\n   return yield()\nend\n\nfunction Lume.bundle(lume)\n   lume.count = 0\n   -- #todo this is, ideally, temporary; we need it while things can still\n   -- break.\n   lume.inflight = {}\n   -- bail early if there\'s nothing on the shuttle\n   if lume.shuttle:isEmpty() then return lume end\n   repeat\n      local skein = lume.net[lume.shuttle:pop()]\n      local path = tostring(skein.source.file)\n      s:verb(\"loaded skein: %s\", path)\n      lume.count = lume.count + 1\n      resume(create(_loader), skein, lume, path)\n   until lume.shuttle:isEmpty()\n   s:verb(\"cleared shuttle\")\n   lume:persist()\n\n   return lume\nend\n\n\n\n\n\n\n\nfunction Lume.stillBundling(lume)\n   return (lume.count > 0) or (not lume.git_info.complete)\nend\n\n\n\nlocal commitBundle, commitSkein = assert(database.commitBundle),\n                                  assert(database.commitSkein)\nlocal writeArtifacts = assert(database.writeArtifacts)\nlocal status = coroutine.status\n\nlocal warn_at = 4096\n\nfunction Lume.persist(lume)\n   local persistor = uv.new_idle()\n   lume.persisting = true\n   local check, report = 0, 1\n\n   local git_info = lume.git_info\n\n   persistor :start(function()\n      -- watch for next phase\n      check = check + 1\n      if check == report then\n         if lume.count > 0 then\n            s:verb(\"lume.count: %d\", lume.count)\n         end\n         report = report * 2\n      end\n      if check > warn_at then\n         s:warn(\"many cycles, lume.count: %d\",\n                lume.count)\n         check = 0\n         warn_at = warn_at * 2\n         for co, skein in pairs(lume.inflight) do\n            if status(co) == \'dead\' then\n               s:chat(\"broken coroutine in processing %s: %s\",\n                       tostring(skein.source.file), debug.traceback(co))\n               lume.inflight[co] = nil\n               lume.count = lume.count - 1\n            end\n         end\n      end\n      if lume:stillBundling() then return end\n      s:chat(\"done bundling, setting up transaction\")\n      -- stop the idle, we block to completion\n      persistor:stop()\n      lume.persisting = false\n      -- set up transaction\n      -- this blocks now, and it should it\'s a transaction.\n      local conn = lume.conn\n      local stmts, ids, now = commitBundle(lume)\n      -- cache db info for later commits\n      lume.db = { stmts    = stmts,\n                  ids      = ids,\n                  git_info = git_info,\n                  now      = now }\n      -- make closures for transaction so we can reuse them\n      lume.db.begin = function() conn:exec [[BEGIN TRANSACTION;]] end\n      lume.db.commit = function() conn:exec [[COMMIT;]] end\n      s:chat(\"writing artifacts to database\")\n      lume.db.begin()\n      for skein in lume.tailored:peekAll() do\n         local stuff = assert(skein:forModuleDatabase())\n         writeArtifacts(stmts, stuff, git_info, now, ids)\n      end\n      -- commit transaction\n      lume.db.commit()\n      -- checkpoint\n      -- use a pcall because we get a (harmless) error if the table is locked\n      -- by another process:\n      pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n      -- clean up db cache\n      lume.db.ids.bundle_id = nil\n      lume.db.now = nil\n      s:verb \"transaction complete\"\n      for skein in lume.tailored:popAll() do\n         skein:persist()\n      end\n   end)\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sh = require \"lash:lash\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction Lume.now(lume)\n   return tostring(date())\nend\n\n\n\n\n\n\n\n\n\n\nfunction Lume.gitInfo(lume)\n   lume.git_info = git_info(tostring(lume.root))\n   return lume.git_info\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.projectInfo(lume)\n   local proj = {}\n   proj.name = _Bridge.args.project or lume.project\n   if lume.git_info.is_repo then\n      proj.repo_type = \"git\"\n      proj.repo = lume.git_info.url\n      -- #Todo read these from manifest if provided\n      proj.home = lume.home or \"\"\n      proj.website = lume.website or \"\"\n      local alts = {}\n      for _, repo in ipairs(lume.git_info.remotes) do\n         alts[#alts + 1] = repo[2] ~= proj.repo and repo[2] or nil\n      end\n      proj.repo_alternates = table.concat(alts, \"\\n\")\n   end\n   return proj\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.versionInfo(lume)\n   if not _Bridge.args.version then\n      return { is_versioned = false }\n   end\n   local version = { is_versioned = true }\n   for k,v in pairs(_Bridge.args.version) do\n      version[k] = v\n   end\n   version.edition = _Bridge.args.edition or \"\"\n   version.stage   = _Bridge.args.stage or \"SNAPSHOT\"\n   return version\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function should_process(file)\n   return file:extension() == \'.orb\'\nend\n\nlocal function case(lume, dir, dupes)\n   dupes = dupes or {}\n   s:verb(\"dir: %s\", tostring(dir))\n   dir = type(dir) == \'string\' and assert(Dir(dir))\n                      or dir.idEst == Dir and dir\n                      or error \"#2 must be a directory or path string\"\n   assert(dir:exists(), \"passed directory doesn\'t exist\")\n   local ino = dir:attributes().ino\n   if dupes[ino] then return end\n   dupes[ino] = true\n   s:verb(\"casing %s\", tostring(dir))\n   local subdirs = dir:getsubdirs()\n   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)\n   for i, sub in ipairs(subdirs) do\n      case(lume, sub)\n   end\n   local files = dir:getfiles()\n   s:verb(\"  \" .. \"# files: \" .. #files)\n   for i, file in ipairs(files) do\n      if should_process(file) then\n         lume.shuttle:push(file)\n      end\n   end\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _findSubdirs(lume, dir)\n   local isCo = false\n   local orbDir, srcDir, libDir = nil, nil, nil\n   local docDir, docMdDir, docDotDir, docSvgDir = nil, nil, nil, nil\n   lume.root = dir\n   local subdirs = dir:getsubdirs()\n\n   for i, sub in ipairs(subdirs) do\n      local name = sub:basename()\n      if name == \"orb\" then\n         s:verb(\"orb: \" .. tostring(sub))\n         orbDir = sub\n         lume.orb = sub\n      elseif name == \"src\" then\n         s:verb(\"src: \" .. tostring(sub))\n         srcDir = Dir(sub)\n         lume.src = sub\n      elseif name == \"doc\" then\n         s:verb(\"doc: \" .. tostring(sub))\n         docDir = sub\n         lume.doc = sub\n         local subsubdirs = docDir:getsubdirs()\n         for j, subsub in ipairs(subsubdirs) do\n            local subname = subsub:basename()\n            if subname == \"md\" then\n               s:verb(\"doc/md: \" .. tostring(subsub))\n               docMdDir = subsub\n               lume.docMd = subsub\n            end\n         end\n      end\n   end\n\n   return (orbDir and srcDir and docDir)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _makeManifest(lume)\n   local manifest = Manifest()\n\n   -- try for global manifest\n   if Dir(_Bridge.orb_home):exists() then\n      s:verb \"Found Orb home directory\"\n      local global_mani = File(_Bridge.orb_home .. \"/manifest.orb\")\n      if global_mani:exists() then\n         s:verb \"Found global manifest file\"\n         manifest(Skein(global_mani, lume))\n         manifest = manifest:child()\n      else\n         s:verb \"Didn\'t find global manifest\"\n      end\n   else\n      s:verb \"Didn\'t find Orb home directory\"\n   end\n\n   local mani_file = File(Path(uv.cwd() .. \'/manifest.orb\'))\n   if mani_file:exists() then\n      s:verb(\"Found manifest.orb at %s\", tostring(mani_file))\n      manifest(Skein(mani_file, lume))\n   else\n      s:verb(\"Didn\'t find a manifest.orb at %s\", tostring(mani_file))\n   end\n   return manifest\nend\n\n\n\n\nlocal function new(dir, db_conn, no_write)\n   if type(dir) == \'string\' then\n      dir = Dir(dir)\n   end\n   if _Lumes[dir] then\n      return _Lumes[dir]\n   end\n   local lume = setmetatable({}, Lume)\n   lume.conn = db_conn and _Bridge.new_modules_db(db_conn)\n                       or _Bridge.modules_conn\n                       or error \"no database\"\n   lume.no_write = no_write\n   lume.shuttle = Deque()\n   lume.tailored = Deque()\n   lume.pedantic = _Bridge.args.pedantic and true or false\n   lume.well_formed = _findSubdirs(lume, dir)\n   if lume.well_formed then\n      case(lume, lume.orb)\n\n\n\n\n\n\n\n\n\n   else\n      -- this will probably break currently, but the end goal of\n      -- this architecture is to try and do something more sensible\n      -- than that.\n      s:warn(\"%s is not a well formed codex\", uv.cwd())\n   end\n   lume.manifest = _makeManifest(lume)\n   lume.project = dir.path[#dir.path]\n   lume.git_info = git_info(tostring(dir))\n   uv.run \'once\'\n   lume.net = setmetatable({}, Net)\n   lume.net.lume = lume\n   _Lumes[dir] = lume\n   return lume\nend\n\nLume.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "lume/lume",
branch = "orb-scry",
},
  { 
hash = "6c384ede3da932029ed2e8089fb651ce70af62515df426c2f303c3c1236d353c",
binary = "\n\n\n\n\n\n\nlocal s   = require \"status:status\" ()\ns.verbose = false\ns.chatty  = true\n\nlocal Dir = require \"fs:fs/directory\"\n\n\n\nlocal new;\n\nlocal Deck = {}\nDeck.__index = Deck\nlocal __Decks = setmetatable({}, { __mode = \"kv\" })\n\n\n\n\n\n\n\nlocal function case(deck)\n   return\nend\n\n\n\n\n\n\nlocal function new(dir, lume)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   s:verb(\"directory: %s\", tostring(dir))\n   if __Decks[dir] then\n      return __Decks[dir]\n   end\n   local deck = setmetatable({}, Deck)\n   deck.dir = dir\n   deck.lume = lume\n   deck.files  = {}\n   case(deck)\n   return deck\nend\n\n\n\n\nDeck.idEst = new\nreturn new\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "lume/deck",
branch = "orb-scry",
},
  { 
hash = "6c0b2bb6dd3f6caa6974a406faeba7b84da0d11d4a9f352d7c993c94c9ea82ed",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n    watcher.dir = dir\n    -- default to a recursive watch\n    if recur == nil then\n        recur = true\n    end\n    local fse = uv.new_fs_event()\n    watcher.fse = fse\n    uv.fs_event_start(fse, dir, {recursive = recur},\n       function (err,fname,status)\n          if (err) then\n             print(\"Error \"..err)\n          else\n             local ev = nil\n             for k,v in pairs(status) do\n                ev = k\n             end\n             if ev == \"change\" then\n                watcher:onchange(fname)\n             elseif ev == \"rename\" then\n                watcher:onrename(fname)\n             else\n                print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n             end\n          end\n       end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "lume/watcher",
branch = "orb-scry",
},
  { 
hash = "75051491c98cccc53b0c8ee69a6df0ca7aaeb565b1c2164ec8ee4c1dd1e691fa",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\nlocal s = require \"status:status\" ()\nlocal ts = require \"repr:repr\" . ts_color\ns.verbose = false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ref_str = [[\n        ref  ←  pat ( domain net project col doc-path\n                    / project col doc-path\n                    / doc-path ) (hax fragment)*\n\n     domain  ←  (!\"/\" 1)+\n    project  ←  (!\":\" 1)*\n   doc-path  ←  (!\"#\" 1)*\n   fragment  ←  (!\"]\" 1)+\n        net  ←  \"/\"\n        pat  ←  \"@\"\n        col  ←  \":\"\n        hax  ←  \"#\"\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anchor_str = [[\n   anchor  ←  ref / url / bad-form\n      url  ←  \"http://example.com\" ; placeholder\n bad-form  ←  (! \"]\" 1)+\n]]\n\n\nanchor_str = anchor_str .. \"\\n\\n\" .. ref_str\n\n\n\n\n\nlocal Ref = Twig :inherit \"ref\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ext_refs = { md = \"markdown_dir\",\n                   html = \"weave_dir\" }\nlocal ext_defaults = { markdown_dir = \"doc/md/\",\n                       weave_dir    = \"/doc/html/\" }\n\n\nlocal print_manifest = true\nlocal format = assert(string.format)\nfunction Ref.resolveLink(ref, skein, extension)\n   if print_manifest then\n      print_manifest = false\n      s:bore(ts(skein.manifest))\n   end\n   extension = extension or \"\"\n   -- manifest or suitable dummy\n   local man_ref;\n   local manifest = skein.manifest\n   if manifest then\n      man_ref = manifest.data.ref or { domains = {} }\n   else\n      man_ref = {domains = {}}\n   end\n   local project  = skein.lume and skein.lume.project or \"\"\n   s:bore(\"ref: %s\", ts(ref:span()))\n   local url = \"\"\n   -- build up the url by pieces\n   local domain = ref :select \"domain\" ()\n   local project = ref :select \"project\" ()\n   local doc_path = ref :select \"doc_path\" ()\n   local fragment = ref :select \"fragment\" ()\n   s:bore(\"domain: %s, project: %s, doc_path: %s, fragment: %s\",\n          domain and domain:span() or \"\'\'\",\n          project and project:span() or \"\'\'\",\n          doc_path and doc_path:span() or \"\'\'\",\n          fragment and fragment:span() or \"\'\'\")\n   if not domain then\n      if man_ref.default_domain then\n         url = url .. (man_ref.domains[man_ref.default_domain]\n                       or format (\"NO_DEFAULT_DOMAIN_URL for %s\",\n                                  man_ref.default_domain))\n      else\n         url = url .. \"NO default.domain IN MANIFEST\"\n      end\n   else\n      url = url .. (man_ref.domains[domain:span()]\n                    or format(\"no manifest domain for %s\", domain:span()))\n   end\n   if project then\n      project = project:span()\n      if project == \"\" then\n         -- default project\n         project = man_ref.project_path or skein.lume.project\n      end\n   else\n      -- default project\n      project = man_ref.project_path or skein.lume.project\n   end\n   url = url  .. project .. \"/\"\n   if not doc_path then\n      return url\n   end\n   url = url .. (man_ref.post_project or \"MISSING_POST_PROJECT\")\n   -- extension directory\n   local ext_field, ext_dir = ext_refs[extension], nil\n   if ext_field then\n      ext_dir = man_ref[ext_field] or ext_defaults[ext_field]\n   end\n   if ext_dir then\n      url = url .. ext_dir\n   end\n   url = url .. doc_path:span() .. \".\" .. extension\n   if fragment then\n      url = url .. \"#\" .. fragment:span()\n   end\n\n   s:bore(\"url: %s\", url)\n   return url\nend\n\n\n\n-- We\'ll need some custom metatables soon, but: not this instant.\nlocal Anchor_M = { Twig,\n                   ref = Ref }\n\nlocal anchor_grammar = Peg(anchor_str, Anchor_M)\n\nreturn subGrammar(anchor_grammar.parse, \"anchor-nomatch\")\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/anchor",
branch = "orb-scry",
},
  { 
hash = "94a6e35256ed2b5f0581b5091c9371e84d36c20c548c6266c79fa45905d640b7",
binary = "\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal DocMetas = {}\n\n\n\n\n\n\n\nlocal Doc_M = Twig:inherit \"doc\"\nDocMetas.doc = Doc_M\n\n\n\nfunction Doc_M.toMarkdown(doc, scroll, skein)\n   for _, block in ipairs(doc) do\n      block:toMarkdown(scroll, skein)\n   end\nend\n\n\n\n\n\n\n\n\nlocal Skein;\nfunction Doc_M.toSkein(doc)\n   Skein = Skein or require \"orb:orb/skein\"\nend\n\n\n\nlocal Section_M = Twig:inherit \"section\"\nDocMetas.section = Section_M\n\n\n\nfunction Section_M.toMarkdown(section, scroll, skein)\n   for _, block in ipairs(section) do\n      block:toMarkdown(scroll, skein)\n   end\nend\n\n\n\nreturn DocMetas\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/docmetas",
branch = "orb-scry",
},
  { 
hash = "c1c15e75dbe72c60ceaceaeabcde1fc52c98415beffb2e634b49ca72cef1909d",
binary = "\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal Header_M = {}\n\n\n\nlocal Header = Twig:inherit \"header\"\nHeader_M.header = Header\n\n\n\n\n\nfunction Header.toMarkdown(header, scroll, skein)\n   local phrase = (\"#\"):rep(header:select(\"level\")():len())\n   scroll:add(phrase)\n   for i = 2, #header do\n      header[i]:toMarkdown(scroll, skein)\n   end\nend\n\n\n\nreturn Header_M\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/headermetas",
branch = "orb-scry",
},
  { 
hash = "d6e05b04489ee162ad1d29a87c4c38a5cd66f7edb40c604bd191b35af0f15913",
binary = "\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal function bookmaker(icon)\n   return function(bookended, scroll, skein)\n      scroll:add(icon)\n      for i = 2, #bookended - 1 do\n         bookended[i]:toMarkdown(scroll, skein)\n      end\n      scroll:add(icon)\n   end\nend\n\n\n\nlocal bold_M = Twig:inherit \"bold\"\nbold_M.toMarkdown = bookmaker \"**\"\n\n\n\nlocal italic_M = Twig:inherit \"italic\"\nitalic_M.toMarkdown = bookmaker \"*\"\n\n\n\n\n\n\n\nlocal literal_M = Twig:inherit \"literal\"\n\nlocal find, rep = assert(string.find), assert(string.rep)\n\nfunction literal_M.toMarkdown(literal, scroll, skein)\n   local span = literal :select \"body\"() :span()\n   local ends = \"`\"\n   local head, tail = find(span, \"%`+\")\n   if head then\n      ends = rep(\"`\", tail + 2 - head)\n   end\n   scroll:add(ends .. span .. ends)\nend\n\n\n\nlocal strike_M = Twig:inherit \"strike\"\nstrike_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal underline_M = Twig:inherit \"underline\"\nunderline_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal verbatim_M = Twig:inherit \"verbatim\"\nverbatim_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal Prose_M = { bold = bold_M,\n                  italic = italic_M,\n                  literal = literal_M,\n                  strike = strike_M,\n                  underline = underline_M,\n                  verbatim = verbatim_M, }\n\n\n\n\nreturn Prose_M\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/prosemetas",
branch = "orb-scry",
},
  { 
hash = "2d4f9e882b34defc8e37e7a173b83adf0ea0852bc8bff727bb041f1eb7664962",
binary = "\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal a = require \"anterm:anterm\"\nlocal Set = require \"qor:core\" . set\nlocal Codepoints = require \"singletons:singletons/codepoints\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\n\n\n\n\n\n\nlocal Twig = {}\n\nfor k,v in next, Node do\n   Twig[k] = v\nend\n\nTwig.__index = Twig\nTwig.id = \"twig\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal md_special = Set {\"\\\\\", \"`\", \"*\", \"_\", \"{\", \"}\", \"[\", \"]\", \"(\", \")\",\n                        \"#\", \"+\", \"-\", \".\", \"!\"}\n\nfunction Twig.toMarkdown(twig, scroll, skein)\n   if #twig == 0 then\n      local points = Codepoints(twig:span())\n      for i , point in ipairs(points) do\n         if md_special[point] then\n            points[i] = \"\\\\\" .. point\n         end\n      end\n      scroll:add(tostring(points))\n   else\n      for _, sub_twig in ipairs(twig) do\n         sub_twig:toMarkdown(scroll, skein)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _escapeHtml(span)\n   -- stub\n   return span\nend\n\nfunction Twig.toHtml(twig, skein)\n   local phrase = \'<span class=\"\' .. twig.id .. Phrase \'\">\'\n   if #twig == 0 then\n      phrase = phrase .. _escapeHtml(twig:span())\n   else\n      for _, sub_twig in ipairs(twig) do\n         phrase = phrase .. sub_twig:toHtml(skein)\n      end\n   end\n   return phrase .. \"</span>\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction Twig.nullstring()\n   return \"\"\nend\n\n\n\nreturn Twig\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/twig",
branch = "orb-scry",
},
  { 
hash = "62740b54addf9bb357f7b8cb0e31d711c99e6abee2f3a46ca6511e0bba3afa8b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal WS = Twig:inherit \"WS\"\n\n\n\nWS.strLine = Twig.nullstring\n\n\n\nreturn WS\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/metas/ws",
branch = "orb-scry",
},
  { 
hash = "1887bae63f20941c19f85481d0e223ced3ca9f712bc92c2138c532153990c676",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\nlocal code_str = [[\n    codeblock  ←  code-start code-body  code-end\n   code-start  ←  start-mark code-type? (WS name)* rest* NL\n   start-mark  ←  \"#\" \"!\"+\n           NL  ←  \"\\n\"\n           WS  ←  \" \"+\n    code-body  ←  (!code-end 1)+\n     code-end  ←  end-mark code-type? execute* rest* line-end\n               /  -1\n     end-mark  ←  \"#\" \"/\"+\n    code-type  ←  symbol\n     line-end  ←  (\"\\n\\n\" \"\\n\"* / \"\\n\")* (-1)\n         name  ←  handle\n      execute  ←  \"(\" \" \"* \")\"\n       `rest`  ←  (handle / hashtag / raw)+\n          raw  ←  (!handle !hashtag !\"\\n\" 1)+\n]]\n\n\ncode_str = code_str\n           .. fragments.symbol\n           .. fragments.handle\n           .. fragments.hashtag\n\n\n\nlocal Code_M = Twig :inherit \"codeblock\"\n\n\n\nfunction Code_M.toMarkdown(codeblock, scroll, skein)\n   local phrase = \"```\"\n   -- #Todo code_type is optional, change this\n   phrase = phrase .. codeblock :select \"code_type\"() :span() .. \"\\n\"\n   phrase = phrase .. codeblock :select \"code_body\"() :span()\n   local code_end = codeblock :select \"code_end\"()\n   local line_end\n   if not code_end[1] then\n      line_end = \"\\n\"\n      -- might be a missing newline\n      if not tostring(phrase):sub(-1) == \"\\n\" then\n         phrase = phrase .. \"\\n\"\n      end\n   else\n      line_end = code_end :select \"line_end\"() :span()\n   end\n   phrase = phrase .. \"```\" .. line_end\n   scroll:add(phrase)\nend\n\n\n\nlocal code_peg = Peg(code_str, { Twig, codeblock = Code_M })\n\n\n\n\n\nreturn subGrammar(code_peg.parse, nil, \"code-nomatch\")\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/codeblock",
branch = "orb-scry",
},
  { 
hash = "e361b996698491e4241d4818d8132b6c459cf00195408f2b5ebfe1c22de8b814",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg   = require \"espalier:peg\"\nlocal table = require \"core:core/table\"\n\n\n\n\n\n\nlocal Twig      = require \"orb:orb/metas/twig\"\nlocal Header    = require \"orb:orb/header\"\nlocal Codeblock = require \"orb:orb/codeblock\"\nlocal Table     = require \"orb:orb/table\"\nlocal Prose     = require \"orb:orb/prose\"\nlocal List      = require \"orb:orb/list\"\nlocal Listline  = require \"orb:orb/list-line\"\nlocal fragments = require \"orb:orb/fragments\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Doc_str = [[\n            doc  ←  (first-section / section) section*\n`first-section`  ←  (block-sep / line-end)? blocks / (block-sep / line-end)\n\n        section  ←  header line-end blocks*\n                 ;  newline-escaped header?\n                 ;  \" \"* \"*\"+ \" \" (\"\\\\\\n   \" / !\"\\n\" 1)*\n                 ;  need to cover that case in the subgrammar\n         header  ←  \" \"* \"*\"+ \" \" (!\"\\n\" 1)*\n                 /   \" \"* \"*\"+ &\"\\n\"\n\n       `blocks`  ←  block (block-sep* block)* block-sep*\n        `block`  ←  structure\n                 /  paragraph\n    `structure`  ←  codeblock\n                 /  blockquote\n                 /  table\n                 /  list\n                 /  handle-line\n                 /  hashtag-line\n                 /  note\n                 /  link-line\n                 /  drawer\n      block-sep  ←  \"\\n\\n\" \"\\n\"*\n\n      codeblock  ←  code-start (!code-end 1)* code-end\n   `code-start`  ←  \"#\" (\"!\"+)@codelevel code-type@code_c (!\"\\n\" 1)* \"\\n\"\n     `code-end`  ←  \"\\n\" \"#\" (\"/\"+)@(#codelevel) code-type@(code_c)\n                     (!\"\\n\" 1)* line-end\n                 /  -1\n    `code-type`  ←  symbol?\n\n     blockquote  ←  block-line+ line-end\n   `block-line`  ←  \" \"* \"> \" (!\"\\n\" 1)* (!\"\\n\\n\" \"\\n\")?\n\n          table  ←  table-head table-line*\n   `table-head`  ←  (\" \"* handle_h* \" \"*)@table_c\n                    \"|\" (!\"\\n\" 1)* line-end\n   `table-line`  ←  (\" \"*)@(#table_c) \"|\" (!line-end 1)* line-end\n\n           list  ←  (list-line / numlist-line)+\n      list-line  ←  (\"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>list_c) !\"- \"\n                    (!line-end 1)* line-end)*\n                 /  (\" \"+ \"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>=list_c) !\"- \" (!line-end 1)* line-end)*\n   numlist-line  ←  list-num@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n                 /  (\" \"+ list-num)@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>=numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n     `list-num`  ←  [0-9]+ \". \"\n\n    handle-line  ←  handle (!line-end 1)* line-end\n\n   hashtag-line  ←  hashtag (!line-end 1)* line-end\n\n           note  ←  note-slug note-body line-end\n      note-slug  ←  \"{\" (!\" \" !\"\\n\" !\"}\" 1)+ \"}: \"\n      note-body  ←  note-lines\n   `note-lines`  ←  (note-line note-line-end)* note-line\n    `note-line`  ←  (!\"\\n\" 1)+\n`note-line-end`  ←  \"\\n\"+ \"   \" &note-line\n\n      link-line  ←  link-open obelus link-close link line-end\n      link-open  ←  \"[\"\n         obelus  ←  !(\"[\" / \"{\" / \"#\") 1 (!\"]\" 1)*\n     link-close  ←  \"]: \"\n           link  ←  (!line-end 1)*\n\n         drawer  ←  drawer-top line-end\n                    ((structure \"\\n\"* / (!drawer-bottom prose-line)+)+\n                    / &drawer-bottom)\n                    drawer-bottom\n                    ;; :[contents]:, ::[contents]::\n   `drawer-top`  ←  \" \"* (\":\")+@drawer_l \"[\"\n                    (!\"\\n\" !\"]:\" 1)*\n                    \"]\" (\":\")+@(drawer_l) &\"\\n\"\n`drawer-bottom`  ←  \" \"* (\":\")+@(drawer_l) \"[\"\n                    (!\"\\n\" !\"]:\" 1)*@(drawer_c)\n                    \"]\" (\":\")+@(drawer_l) line-end\n\n      paragraph  ←  (!header !structure par-line (!\"\\n\\n\" \"\\n\")?)+\n     `par-line`  ←  (!\"\\n\" 1)+\n     prose-line  ←  (!\"\\n\" 1)* \"\\n\"\n       line-end  ←  (block-sep / \"\\n\" / -1)\n]]\n\n\n\n\n\nDoc_str = Doc_str .. fragments.symbol .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\n\n\n\n\nlocal compact = assert(table.compact)\n\nlocal function _parent(levels, section)\n   local top = #levels\n   if top == 0 then\n      return section\n   end\n   local level = section :select \"level\"() :len()\n   for i = top, 1, -1 do\n      local p_level = levels[i] :select \"level\"() :len()\n      if p_level < level then\n         return levels[i]\n      end\n   end\n   return section\nend\n\nlocal function post(doc)\n   local levels = {}\n   local top = #doc\n   for i = 1, top do\n      local section = doc[i]\n      if section:select \"section\" () then\n         local parent = _parent(levels, section)\n         if parent ~= section then\n            -- add to section\n            section.parent = parent\n            parent[#parent + 1] = section\n            -- remove from doc\n            doc[i] = nil\n            -- adjust .last fields\n            parent.last = section.last\n            local under\n            repeat\n               under = parent\n               parent = _parent(levels, under)\n               parent.last = section.last\n            until parent == under\n         end\n         levels[#levels + 1] = section\n      end\n   end\n   compact(doc, top)\n   return doc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Linkline = Twig:inherit \"link_line\"\n\nLinkline.toMarkdown = Twig.nullstring\n\n\n\n\nlocal DocMetas = { Twig,\n                   header       = Header,\n                   codeblock    = Codeblock,\n                   table        = Table,\n                   paragraph    = Prose,\n                   blockquote   = Prose,\n                   list         = List,\n                   list_line    = Listline,\n                   numlist_line = Listline,\n                   note_body    = Prose,\n                   link_line    = Linkline, }\n\n\n\nlocal addall = assert(table.addall)\n\naddall(DocMetas, require \"orb:orb/metas/docmetas\")\n\n\n\nreturn Peg(Doc_str, DocMetas, nil, post)\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/doc",
branch = "orb-scry",
},
  { 
hash = "3665b90213df73e5a55c97b523a6493f399fa32179861e76392b28726f678fbd",
binary = "\n\n\n\n\n\n\n\n\n\nlocal fragments = {}\n\n\n\n\n\n\n\n\n\n\nlocal gap_str = [[\n    `gap`  <-  { \\n([)]} / \"{\" / \"}\" / -1\n]]\nfragments.gap = gap_str\n\n\n\n\n\n\nlocal hashtag_h_str = [[\n   `hashtag_h`  ←  \"#\" ends_h+ (middle_h+ ends_h+)*\n        `ends_h`  ←  [A-Z] / [a-z] / [0-9] / \"-\" / \"_\"\n       `middle_h` ←  \".\" / \"/\" / \":\"\n]]\n\n\nlocal hashtag_str = [[\n\n   hashtag  ←  hashtag_h\n]] .. hashtag_h_str\n\n\nfragments.hashtag = hashtag_str\nfragments.hashtag_h = hashtag_h_str\n\n\n\n\n\n\nlocal handle_h_str = [[\n\n  `handle_h`  ← \"@\" (!gap 1 / \"[\" (!gap ! \"]\" 1)+ \"]\")+\n]] .. gap_str\n\nlocal handle_str = [[\n\n   handle  ←  handle_h\n]] .. handle_h_str\n\nfragments.handle = handle_str\nfragments.handle_h = handle_h_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal symbol_str = [[\n\n   `symbol`  <-  (([a-z]/[A-Z]) ([a-z]/[A-Z]/[0-9]/\"-\"/\"_\")*)\n]]\nfragments.symbol = symbol_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal term_str = [[\n\n   `t` = { \\n.,:;?!)(][\\\"} / -1\n]]\nfragments.t = term_str\n\n\n\n\n\n\n\n\n\n\n\nlocal utf8_str = [[\n   `utf8`  ←  [\\x00-\\x7f]\n           /  [\\xc2-\\xdf] [\\x80-\\xbf]\n           /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n           /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\nfragments.utf8 = utf8_str\n\n\n\nreturn fragments\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/fragments",
branch = "orb-scry",
},
  { 
hash = "1a5d4cec60cc230871ed399354fbd2b750d58327583d016ef0396656979e9319",
binary = "\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Header_M = require \"orb:orb/metas/headermetas\"\nlocal fragments = require \"orb:orb/fragments\"\n\n\nlocal header_str = [[\n        header  ←  WS? level head-line* -1\n         WS     ←  \" \"+\n         level  ←  \"*\"+\n   `head-line`  ←  handle / hashtag / raw\n         raw    ←  (!handle !hashtag 1)+\n]]\n\n\nheader_str = header_str .. fragments.handle .. fragments.hashtag\n\nlocal addall = assert(require \"core:core/table\" . addall)\nlocal head_M = {Twig}\naddall(head_M, Header_M)\nlocal header_grammar = Peg(header_str, head_M)\n\n\n\n\nreturn subGrammar(header_grammar.parse, \"header-nomatch\")\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/header",
branch = "orb-scry",
},
  { 
hash = "d4322d3154d6b19c82697181d83a54b7a00b5d36c892147c9d12317132aefe63",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal fragments = require \"orb:orb/fragments\"\nlocal WS  = require \"orb:orb/metas/ws\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\nlocal Anchor = require \"orb:orb/metas/anchor\"\n\nlocal s = require \"status:status\" ()\ns.grumpy = true\n\n\nlocal link_str = [[\n   link         ←  link-head link-text link-close WS*\n                   (link-open anchor link-close)\n                   (WS* hashtag WS*)* link-close\n                /  link-head anchor link-close\n                   (WS* hashtag WS*)* link-close\n                /  link-head link-text link-close obelus link-close\n\n   link-head    ←  \"[[\"\n   link-close   ←  \"]\"\n   link-open    ←  \"[\"\n   link-text    ←  (!\"]\" 1)*\n\n   anchor       ←  (!\"]\" 1)+\n   obelus       ←  (!\"]\" 1)+\n   WS           ←  { \\n}+\n]]\n\n\nlink_str = link_str .. fragments.hashtag\n\nlocal link_M = Twig :inherit \"link\"\n\n\n\nlocal function obelusPred(ob_mark)\n   return function(twig)\n      if twig.id ~= \'link_line\' then return false end\n\n      local obelus = twig:select \"obelus\" ()\n      if obelus and obelus:span() == ob_mark then\n         return true\n      end\n      return false\n   end\nend\n\nfunction link_M.toMarkdown(link, scroll, skein)\n   local link_text = link:select(\"link_text\")()\n   link_text = link_text and link_text:span()\n   local link_anchor = link:select(\"anchor\")()\n   if link_anchor then\n\n      local ref = link_anchor:select \"ref\" ()\n      if ref then\n         link_anchor = ref:resolveLink(skein, \"md\")\n      else\n         link_anchor = link_anchor:span()\n      end\n   else\n      -- look for an obelus\n      local obelus = link:select(\"obelus\")()\n      if obelus then\n         -- find the link_line\n         local ob_pred = obelusPred(obelus:span())\n         local link_line = link\n                             :root()\n                             :selectFrom(ob_pred, link.last + 1) ()\n         if link_line then\n            link_anchor = link_line :select \"link\" () :span()\n         else\n            local line_pos = obelus:linePos()\n            local link_err = \"link line not found for obelus: \"\n                             .. obelus:span() .. \" on line \" .. line_pos\n            s:warn(link_err)\n            scroll:addError(link_err)\n            link_anchor = link_err\n         end\n      else\n         link_anchor = \"\"\n      end\n   end\n   if not link_text then\n      link_text = link_anchor\n   end\n   local phrase = \"[\" .. link_text .. \"]\" .. \"(\" ..  link_anchor .. \")\"\n   scroll:add(phrase)\nend\n\n\n\nlocal Link_Metas = { Twig,\n                     link = link_M,\n                     anchor = Anchor,\n                     WS   = WS, }\nlocal link_grammar = Peg(link_str, Link_Metas)\n\n\n\nreturn subGrammar(link_grammar.parse, \"link-nomatch\")\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/link",
branch = "orb-scry",
},
  { 
hash = "238ca9d37cce6b7dc9187cdb3b88dc41d557879580294c033a3f5f2203c8b503",
binary = "\n\n\n\n\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Peg = require \"espalier:espalier/peg\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal prose = require \"orb:orb/prose\"\nlocal fragments = require \"orb:orb/fragments\"\nlocal anterm = require \"anterm:anterm\"\n\n\nlocal listline_str = [[\n     list-line  ←  depth number* sep WS\n                   (cookie / radio)*\n                   (key colon text / text) cookie* list-end\n         depth  ←  \" \"*\n        number  ←  [0-9]+\n           sep  ←  \"-\" / \".\"\n        cookie  ←  \"[\" (!\"]\" 1)+ \"]\"\n         radio  ←  \"(\" 1 \")\" ; this should be one utf-8 character\n           key  ←  \" \"* (handle / hashtag / (!\":\" !gap 1)+) \" \"*\n         colon  ←  \":\" &(ws (!ws 1))\n          text  ←  (!(cookie list-end / list-end) 1)+\n            WS  ←  ws\n          `ws`  ←  { \\n}+\n      list-end  ←  \"\\n\"* -1\n]]\n\n\nlistline_str = listline_str .. fragments.gap\n               .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\nlocal Sep = Twig:inherit \'sep\'\n\nfunction Sep.toMarkdown(sep, scroll, skein)\n   scroll:add(sep:span())\nend\n\n\n\n\n\n\nlocal Cookie = Twig:inherit \'cookie\'\nCookie.toMarkdown = Sep.toMarkdown\n\n\n\n\n\n\nlocal listline_Meta = { Twig,\n                        text = prose,\n                        sep = Sep,\n                        cookie = Cookie }\nlocal listline_grammar = Peg(listline_str, listline_Meta).parse\n\n\n\n\n\n\n\n\nlocal Listline = Twig:inherit \"list_line\"\n\n\nlocal super_strExtra = Twig . strExtra\n\nfunction Listline.strExtra(list_line)\n   local phrase = super_strExtra(list_line)\n   return phrase .. anterm.magenta(tostring(list_line.indent))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nlocal function makeAdjustment(level_space)\n   return function(str)\n      return gsub(str, \'\\n[ ]+\', level_space)\n   end\nend\n\nfunction Listline.toMarkdown(list_line, scroll, skein)\n   local phrase = \"\"\n   local level_space = \"\\n\" .. (\" \"):rep(list_line.indent + 2)\n   local defer = makeAdjustment(level_space)\n   local close_mark = scroll:deferStart(defer)\n   for _, node in ipairs(list_line) do\n      node:toMarkdown(scroll, skein)\n   end\n   scroll:deferFinish(close_mark)\nend\n\n\n\n\nlocal function listline_fn(t)\n   local match = listline_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t.last then\n         -- label the match according to the rule\n         match.id = t.id or \"list_line\"\n         match.indent = match:select\"sep\"().last - match.first + 2\n         return setmetatable(match, Listline)\n       else\n         match.id = t.id .. \"_INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   -- we need to fix the list line grammar to recognize more lists, but for\n   -- now, we know it makes mistakes. So we\'re just going to post-process\n   -- it in a sort of ugly way\n   setmetatable(t, Listline)\n   t.id = \'list_line_nomatch\'\n   local _, sep_end = t:span():find(\'%s+- \')\n   t.indent = sep_end\n   return setmetatable(t, Twig)\nend\n\n\n\n\n\nreturn listline_fn\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/list-line",
branch = "orb-scry",
},
  { 
hash = "ec207be79bef458620308a90a3f8c5d36cc85de21bda6edaffdf4ab569648d0a",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal table = require \"core:core/table\"\nlocal anterm = require \"anterm:anterm\"\nlocal c = require \"singletons/color\" . color -- #todo remove\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\nlocal List = Twig :inherit \'list\'\n\nlocal super_strExtra = Twig . strExtra\n\nfunction List.strExtra(list)\n   local phrase = super_strExtra(list)\n   return phrase .. anterm.magenta(tostring(list.indent))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal DEPTH = 512\nlocal function _parent(list, dent, list_line)\n   local parent = list\n   local count = 1\n   repeat\n      parent = parent.parent\n      count = count + 1\n   until parent.indent <= dent or count == DEPTH\n   if count >= DEPTH then\n      s:warn(anterm.red(\"infinite loop or absurdly deep list folding!\"))\n      s:warn(debug.traceback())\n   end\n   return parent\nend\n\n\n\nlocal function _makesublist(parent, line)\n   if not line then\n      s:verb(\"no line! \\n %s\", debug.traceback())\n   end\n   local sublist = { first = line.first,\n                     last = line.last,\n                     parent = parent,\n                     str = line.str }\n   local lead = { first = line.first,\n                  last = line.last,\n                  parent = sublist,\n                  str = line.str,\n                  id = \'lead\' }\n   setmetatable(lead, Twig)\n   sublist[1] = lead\n   lead[1] =  line\n   line.parent = lead\n   return setmetatable(sublist, List)\nend\n\n\n\nlocal insert, compact = assert(table.insert), assert(table.compact)\n\nlocal function _insert(list, list_line)\n   insert(list, list_line)\n   list_line.parent = list\n   list.last = list_line.last\n   -- the base list won\'t have a parent yet\n   if not list.parent then return end\n   local parent = list.parent\n   while parent.parent and parent.id == \'list\' do\n      parent.last = list_line.last\n      local newparent = parent.parent\n      parent = newparent\n   end\n   --]]\nend\n\nlocal function post(list)\n   local linum = list:linePos()\n   local top = #list\n   local base = list[1].indent\n   -- add an indent to the list itself\n   list.indent = base\n   -- tracking variables:\n   local dent = base\n   local work_list = list\n   for i = 1, top do\n      -- is it an indent line?\n      if not list[i].indent then\n         local id, line, col = list[i].id, list[i]:linePos()\n         s:verb(\"no indent on %s at line %d, col %d\", id, line, col)\n      end\n      if list[i].indent > dent then\n         -- handle base list a bit differently\n         if work_list == list then\n            -- make a list from the previous line\n            local sublist = _makesublist(work_list, list[i - 1])\n            dent = list[i].indent\n            sublist.indent = dent\n            -- insert working line\n            _insert(sublist, list[i])\n            -- replace prior line with list\n            list[i - 1] = sublist\n            -- nil out working line\n            list[i] = nil\n            -- replace the work list\n            work_list = sublist\n         else\n            local sublist = _makesublist(work_list, work_list[#work_list])\n            -- this moves the tip of the work list to the lead of the sub list\n            -- so we need to remove it from the work list\n            work_list[#work_list] = nil\n            dent = list[i].indent\n            sublist.indent = dent\n            _insert(work_list, sublist)\n            _insert(sublist, list[i])\n            list[i] = nil\n            work_list = sublist\n         end\n      elseif dent > base and dent == list[i].indent then\n         -- put it in the worklist\n         _insert(work_list, list[i])\n         list[i] = nil\n      elseif list[i].indent < dent then\n         -- get a new work_list\n         work_list = _parent(work_list, list[i].indent, list[i])\n         if work_list ~= list then\n            _insert(work_list, list[i])\n            dent = list[i].indent\n            list[i] = nil\n         else -- otherwise, we leave the line in-place\n            dent = list[i].indent\n         end\n      else -- otherwise we have a list_line we can leave in place\n         local linstart = list[i]:linePos()\n      end\n   end\n   compact(list, top)\n   return list\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function List_fn(list, offset)\n   setmetatable(list, List)\n   return post(list)\nend\n\n\n\nreturn List_fn\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/list",
branch = "orb-scry",
},
  { 
hash = "d6b6e631121976be7821025c18b16b77fcd0b8e4e889b5e8c908daacee06c30e",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:peg\"\nlocal Set = require \"qor:core\" . set -- could be using \'qor\' below\nlocal core = require \"core:core\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal fragments = require \"orb:orb/fragments\"\n\nlocal ProseMetas = require \"orb:orb/metas/prosemetas\"\n\n\n\n\n\n\n\n\n\n\nlocal prose_str = [[\n            prose  ←  ( escape\n                       / link\n                       / note-link\n                       / italic\n                       / bold\n                       / strike\n                       / literal\n                       / verbatim\n                       / underline\n                       / raw )+\n\n           escape  ←  \"\\\\\" {*/~_=`][}\n             link  ←  \"[[\" (!\"]\" 1)+ \"]\" WS*     ; link phrase\n                       (\"[\" (!\"]\" 1)+ \"]\")*      ; link body\n                       (WS* hashtag WS*)* \"]\"    ; optional hashtag\n                      ; obelus link\n                   /  \"[[\" (!\"]\" 1)+ \"]\" !(\"#\" / \"{\" / \"[\" / \"]\") 1\n                      (!(WS / \"]\") 1)* \"]\"\n\n        note-link  ←  note-open note-prose note-slug note-close\n                   /  note-slug\n       note-prose  ←  (!note-slug 1)+\n        note-slug  ←  \"[{\" (!WS !\"}\" 1)+ \"}]\"\n        note-open  ←  \"[\"\n       note-close  ←  \"]\"\n\n\n             bold  ←   bold-start bold-body bold-end\n     `bold-start`  ←  \"*\"+@bold-c !WS\n       `bold-end`  ←  \"*\"+@(bold-c)\n      `bold-body`  ←  ( WS+ (!non-bold !bold-end fill)+\n                       / WS* non-bold\n                       / (!non-bold !bold-end fill)+ )+\n       `non-bold`  ←  italic / strike / underline / literal / verbatim\n\n           italic  ←  italic-start italic-body italic-end\n   `italic-start`  ←  \"/\"+@italic-c !WS\n     `italic-end`  ←  \"/\"+@(italic-c)\n    `italic-body`  ←  ( WS+ (!non-italic !italic-end fill)+\n                       / WS* non-italic\n                       / (!non-italic !italic-end fill)+ )+\n     `non-italic`  ←  bold / strike / underline / literal / verbatim\n\n           strike  ←  strike-start strike-body strike-end\n   `strike-start`  ←  \"~\"+@strike-c !WS\n     `strike-end`  ←  \"~\"+@(strike-c)\n    `strike-body`  ←  ( WS+ (!non-strike !strike-end fill)+\n                             / WS* non-strike\n                             / (!non-strike !strike-end fill)+ )+\n     `non-strike`  ←  bold / italic / underline / literal / verbatim\n\n        underline  ←  underline-start underline-body underline-end\n`underline-start`  ←  \"_\"+@underline-c !WS\n  `underline-end`  ←  \"_\"+@(underline-c)\n `underline-body`  ←  ( WS+ (!non-underline !underline-end fill)+\n                          / WS* non-underline\n                          / (!non-underline !underline-end fill)+ )+\n  `non-underline`  ←  bold / italic / strike / literal / verbatim\n\n          literal  ←  literal-start literal-body literal-end\n  `literal-start`  ←  \"=\"+@literal-c\n    `literal-end`  ←  \"=\"+@(literal-c)\n   `literal-body`  ←  (!literal-end 1)+\n\n         verbatim  ←  verbatim-start verbatim-body verbatim-end\n `verbatim-start`  ←  (\"`\" \"`\"+)@verbatim-c\n   `verbatim-end`  ←  (\"`\" \"`\"+)@(verbatim-c)\n  `verbatim-body`  ←  (!verbatim-end 1)+\n\n           `fill`  ←  link / note-link / hashtag / handle / !WS 1\n               WS  ←  (\" \" / \"\\n\")\n            `raw`  ←  ( !bold\n                        !italic\n                        !strike\n                        !literal\n                        !verbatim\n                        !underline\n                        !escape\n                        !note-link\n                        !link (hashtag / handle / word / punct / WS) )+\n             word  ←  (!t 1)+\n            punct  ←  ({\\n.,:;?!)(]\\\"} / (!\"[[\" \"[\"))+\n]]\n\n\nprose_str = prose_str .. fragments.t .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bounds = { bold      = \"*\",\n                 italic    = \"/\",\n                 literal   = \"=\",\n                 verbatim  = \"`\",\n                 underline = \"_\",\n                 strike    = \"~\" }\nlocal bookends = Set(core.keys(bounds))\n\n\n\nlocal byte = assert(string.byte)\nlocal insert = assert(table.insert)\n\nlocal function _makeBooks(bound, bookended)\n   local first, last, str = bookended.first, bookended.last, bookended.str\n   local count = 0\n   while true do\n      if byte(str, first + count + 1) ~= bound then\n         break\n      end\n      -- may as well prevent infinite work on malformed input...\n      if first + count + 1 > last then break end\n      count = count + 1\n   end\n   local head = setmetatable({ first  = first,\n                               last   = first + count,\n                               str    = str,\n                               parent = bookended,\n                               id     = \"bound\" }, Twig)\n   local tail = setmetatable({ first  = last - count,\n                               last   = last,\n                               str    = str,\n                               parent = bookended,\n                               id    = \"bound\" }, Twig)\n   return head, tail, count\nend\n\n\nlocal function _fillGen(bookended)\n   local bound = byte(bounds[bookended.id])\n   local str, first, last = bookended.str, bookended.first, bookended.last\n   if #bookended == 0 then\n      local head, tail, count = _makeBooks(bound, bookended)\n      local body = setmetatable({ first = first + count + 1,\n                                  last  = last - count - 1,\n                                  str   = str,\n                                  parent = bookended,\n                                  id    = \"body\" }, Twig)\n      insert(bookended, head)\n      insert(bookended, body)\n      insert(bookended, tail)\n   else\n      local head, tail, count = _makeBooks(bound, bookended)\n      -- temporary array to hold the new collection\n      local new_order = {head}\n      local next_first = head.last + 1\n      -- test and capture first text\n      if next_first ~= bookended[1].first then\n      insert(new_order, setmetatable({ first  = next_first,\n                                       last   = bookended[1].first - 1,\n                                       str    = str,\n                                       parent = bookended,\n                                       id     = \"word\" }, Twig))\n      end\n      -- test and capture interspersed text\n      for i = 2, #bookended do\n         insert(new_order, bookended[i - 1])\n         if not (bookended[i - 1].last + 1 == bookended[i].first) then\n            local inter = setmetatable({ first  = bookended[i - 1].last + 1,\n                                         last   = bookended[i].first - 1,\n                                         str    = str,\n                                         parent = bookended,\n                                         id     = \"word\" }, Twig)\n            insert(new_order, inter)\n         end\n      end\n      insert(new_order, bookended[#bookended])\n      -- test and capture end text\n      if bookended[#bookended].last ~= bookended.last then\n         local hip = setmetatable({ first  = bookended[#bookended].last + 1,\n                                    last   = bookended.last - count - 1,\n                                    str    = str,\n                                    parent = bookended,\n                                    id     = \"word\" }, Twig)\n         insert(new_order, hip)\n      end\n      for i, node in ipairs(new_order) do\n         bookended[i] = node\n      end\n      insert(bookended, tail)\n   end\nend\n\n\n\nlocal prose_fn;\n\nlocal function _prosePost(prose)\n   -- walk manually to replace note-bodies\n   for i, node in ipairs(prose) do\n     if bookends[node.id] then\n        _fillGen(node)\n     elseif node.id == \'note_prose\' then\n        prose[i] = prose_fn(node)\n     end\n     _prosePost(node)\n   end\n   return prose\nend\n\nlocal function _prosePost(prose)\n   for node in prose:walk() do\n     if bookends[node.id] then\n        _fillGen(node)\n     end\n   end\n   return prose\nend\n\n\n\n\n\nlocal proseMetas = { Twig,\n                     WS   =  require \"orb:orb/metas/ws\",\n                     link =  require \"orb:orb/link\" }\n\ncore.addall(proseMetas, require \"orb:orb/metas/prosemetas\")\n\nprose_grammar = Peg(prose_str, proseMetas, nil, _prosePost).parse\n\n\n\n\n\n\n\n\n\nprose_fn = function(t)\n   local match = prose_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t. last then\n         -- label the match according to the rule\n         match.id = t.id or \"prose\"\n         return match\n       else\n         match.id = t.id .. \"-INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   t.id = \"prose-nomatch\"\n   return setmetatable(t, Twig)\nend\n\n\n\nreturn prose_fn\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/prose",
branch = "orb-scry",
},
  { 
hash = "90bfab22cc9fbd96690af044863bcfeff5c765ba66fbb486ba1fc213ef7566c2",
binary = "\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig      = require \"orb:orb/metas/twig\"\n\n\nlocal table_str = [[\n      table  ←  WS* handle* WS* row+\n        row  ←  WS* pipe cell (!table-end pipe cell)* table-end\n       cell  ←  (!table-end !pipe 1)+\n       pipe  ←  \"|\"\n`table-end`  ←  (pipe / hline / double-row)* line-end\n      hline  ←  \"~\"\n double-row  ←  \"\\\\\"\n         WS  ←  \" \"+\n   line-end  ←  (block-sep / \"\\n\" / -1)\n  block-sep  ←  \"\\n\\n\" \"\\n\"*\n]]\n\n\ntable_str = table_str .. fragments.handle .. fragments.symbol\n\n\n\nlocal table_grammar = Peg(table_str, {Twig})\n\n\n\nreturn subGrammar(table_grammar, nil, \"table-nomatch\")\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb/table",
branch = "orb-scry",
},
  { 
hash = "b1f9c4cb8d28c8bafd9f829f7309518fc76dc810b8ac74837d4f092f1f58e5c1",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal a = require \"anterm:anterm\"\ns.chatty = true\ns.angry = false\n\n\n\nlocal Doc      = require \"orb:orb/doc\"\nlocal knitter  = require \"orb:knit/knit\" ()\nlocal compiler = require \"orb:compile/compiler\"\nlocal database = require \"orb:compile/database\"\nlocal Manifest; -- optional load which would otherwise be circular\n\nlocal File   = require \"fs:fs/file\"\nlocal Path   = require \"fs:fs/path\"\nlocal Scroll = require \"scroll:scroll\"\nlocal Notary = require \"status:annotate\"\n\n\n\nlocal Skein = {}\nSkein.__index = Skein\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.load(skein)\n   local file = assert(skein.source.file, \"no file on skein\")\n   -- fix the rest of green/autothread/etc and let this yield ffs\n   if file.fs2file then\n      -- suuuuper cheating\n   end\n   local ok, text = pcall(file.read, file)\n   if ok then\n      skein.source.text = text\n   else\n      skein.source.cant_load = true\n      skein.source.load_err = text\n      s:complain(\"fail on load %s: %s\", tostring(file), text)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.filter(skein)\n   if not skein.source.text then\n      skein:load()\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.spin(skein)\n   if not skein.source.text then\n      skein:load()\n   end\n   local ok, doc = pcall(Doc, skein.source.text)\n   if not ok then\n       s:complain(\"couldn\'t make doc: %s, %s\", doc, tostring(skein.source.file))\n   end\n   skein.source.doc = doc\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\nSkein.tag = require \"orb:tag/tagger\"\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.tagAct(skein)\n   if not skein.tags then\n      skein:tag()\n   end\n   -- this will most likely turn into a table because tag actions are a /very/\n   -- complex stage.\n   skein.tag_acted = true\n   local mani_blocks = skein.tags.manifest\n   if mani_blocks then\n      Manifest = require \"orb:manifest/manifest\"\n      s:chat(\"found manifest blocks in %s\", tostring(skein.source.file))\n      skein.manifest = skein.manifest and skein.manifest:child() or Manifest()\n      for _, block in ipairs(mani_blocks) do\n         s:verb(\"attempted add of node type %s\", block.id)\n         skein.manifest(block)\n      end\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\nfunction Skein.format(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\nlocal orbScry;\n\n\n\nlocal with_scry = require \"bridge\" . args . scry\n\nfunction Skein.knit(skein)\n   if not skein.tag_acted then\n      skein:tagAct()\n   end\n   local ok, err = xpcall(knitter.knit, debug.traceback, knitter, skein)\n   if not ok then\n      s:warn(\"failure to knit %s: %s\", tostring(skein.source.file), err)\n   end\n   -- this used to be a de-facto error but no longer is\n   if not skein.knitted.lua then\n      s:verb(\"no Lua document produced from %s\", tostring(skein.source.file))\n   elseif with_scry then\n      orbScry = orbScry or require \"scry:orb-scry\"\n      orbScry(skein)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.weave(skein)\n   if not skein.knitted then\n      skein:knit()\n   end\n   if not skein.woven then\n      skein.woven = {}\n   end\n   local woven = skein.woven\n   woven.md = {}\n   local ok, err = pcall(function()\n      local scroll = Scroll()\n      skein.source.doc:toMarkdown(scroll, skein)\n      local ok = scroll:deferResolve()\n      if not ok then\n         scroll.not_resolved = true\n      end\n      woven.md.text = tostring(scroll)\n      woven.md.scroll = scroll\n      -- report errors, if any\n      for _, err in ipairs(scroll.errors) do\n         s:warn(tostring(skein.source.file) .. \": \" .. err)\n      end\n      -- again, this bakes in the assumption of \'codex normal form\', which we\n      -- need to relax, eventually.\n      woven.md.path = skein.source.file.path\n                          :subFor(skein.source_base,\n                                  skein.weave_base .. \"/md\",\n                                  \"md\")\n   end)\n   if not ok then\n      s:complain(\"couldn\'t weave %s: %s\", tostring(skein.source.file), err)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.compile(skein)\n   if not skein.knitted then skein:knit() end\n\n   compiler:compile(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.tailor(skein)\n   if not skein.compiled then skein:compile() end\n\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal commitSkein = assert(database.commitSkein)\n\nfunction Skein.commit(skein, stmts, ids, git_info, now)\n   if not skein.compiled then skein:compile() end\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n   assert(now)\n   commitSkein(skein, stmts, ids, git_info, now)\n   return skein\nend\n\n\n\n\n\n\n\n\nfunction Skein.forModuleDatabase(skein)\n   local artifacts = skein.compiled and skein.compiled.lua\n   return { bytecode = artifacts,\n            name = tostring(skein.source.file) }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transact(skein, stmts, ids, git_info, now)\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n   skein.lume.db.begin()\n   commitSkein(skein, stmts, ids, git_info, now)\n   skein.lume.db.commit()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function writeOnChange(scroll, path, dont_write)\n   -- if we don\'t have a path, there\'s nothing to be done\n   -- #todo we should probably take some note of this situation\n   if not path then return end\n   local current = File(path):read()\n   local newest = tostring(scroll)\n   if newest ~= current then\n      s:chat(a.green(\"    - \" .. tostring(path)))\n      if not dont_write then\n         File(path):write(newest)\n      end\n      return true\n   else\n   -- Otherwise do nothing\n      return nil\n   end\nend\n\n\n\nfunction Skein.persist(skein)\n   for code_type, scroll in pairs(skein.knitted) do\n      if scroll.idEst == Scroll then\n         writeOnChange(scroll, scroll.path, skein.no_write)\n      else -- a case, soon\n\n      end\n   end\n   local md = skein.woven.md\n   if md then\n      writeOnChange(md.text, md.path, skein.no_write)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transform(skein)\n   local db = skein.lume.db\n   skein\n     : load()\n     : filter()\n     : spin()\n     : tag()\n     : tagAct()\n     : knit()\n     : weave()\n     : compile()\n     : transact(db.stmts, db.ids, db.git_info, skein.lume:now())\n     : persist()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal empty_set = require \"set:set\" ()\n\nfunction Skein.tagsFor(skein, node)\n   local tags = assert(skein.tags, \"Skein has not been tagged\")\n   return tags[node] or empty_set\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.knitScroll(skein, knitter)\n   local code_type, knitted = knitter.code_type, skein.knitted\n   -- Right now we always return the same value\n   if knitted[code_type] then\n      return knitted[code_type]\n   end\n   -- Adding custom \"scrolls\"\n   if knitter.customScroll then\n      local scroll = knitter:customScroll()\n      knitted[knitter.code_type] = scroll\n      return scroll\n   end\n   -- We do additional setup which customScroll is expected to handle\n   local scroll = Scroll()\n   knitted[code_type] = scroll\n   scroll.line_count = 1\n   -- #todo this bakes in assumptions we wish to relax\n   scroll.path = skein:knitPathFor(code_type)\n   return scroll\nend\n\n\n\n\n\n\n\n\nfunction Skein.knitPathFor(skein, code_type)\n   return skein.source.file.path\n                    :subFor(skein.source_base,\n                            skein.knit_base,\n                            code_type)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(path, lume)\n   local skein = setmetatable({}, Skein)\n   skein.note = Notary()\n   skein.source = {}\n   if not path then\n      error \"Skein must be constructed with a path\"\n   end\n\n   local file;\n   local path_t = type(path)\n   if path_t == \'table\' and path.fs2file then\n      -- we cheat\n      file = path\n      skein.an_fs2File = true\n   -- handles: string, Path, or File objects\n   elseif path_t == \'string\' or path.idEst ~= File then\n      file = File(Path(path):absPath())\n   else\n      file = path\n   end\n   if lume then\n      skein.lume = lume\n      -- lift info off the lume here\n      skein.project     = lume.project\n      skein.source_base = lume.orb\n      skein.knit_base   = lume.src\n      skein.weave_base  = lume.doc\n      skein.manifest    = lume.manifest\n      if lume.no_write then\n         skein.no_write = true\n      end\n   end\n\n   skein.source.relpath = Path(tostring(path)):relPath(skein.source_base)\n   skein.source.file = file\n   return skein\nend\n\nSkein.idEst = new\n\n\n\n\nreturn new\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "skein/skein",
branch = "orb-scry",
},
  { 
hash = "0ae907de91df024198e3f4b5686d9af99660b79a9b220ffab88ba03594e1f005",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\n\n\n\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\n\n\nlocal taggable = Set {\n   \'header\',\n   \'list_line\',\n   \'section\',\n   \'numlist_line\',\n   \'codeblock\',\n   \'blockquote\',\n   \'paragraph\',\n   \'handle_line\',\n   \'hashtag_line\',\n   \'table\',\n   \'drawer\',\n}\n\n\n\n\n\n\n\n\nlocal sub, lower = assert(string.sub), assert(string.lower)\nlocal insert = assert(table.insert)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _taggableParent(node, doc, note)\n-- note(\"finding parent of %s\", node.id)\n   local parent = node.parent\n   while parent ~= doc do\n      -- note(\"checking parent %s\", parent.id)\n      if taggable :∈ (parent.id) then\n         break\n      end\n      parent = parent.parent\n   end\n   return parent\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _capitalTag(tag)\n   local first = sub(tag, 1, 1)\n   if lower(first) == first then\n      return false, tag\n   else\n      return true, lower(first) .. sub(tag, 2)\n   end\nend\n\n\n\n\n\n\n\nlocal function _tagUp(tags, node, tag, note)\n   note(\"tagging a %s on line %d with %s\", node.id, (node:linePos()), tag)\n   tags[tag] = tags[tag] or {}\n   insert(tags[tag], node)\n   tags[node] = tags[node] or Set {}\n   tags[node][tag] = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _endPred(node)\n   if node.id == \"line_end\" or node.id == \"block_sep\" then\n      return true\n   else\n      return false\n   end\nend\n\nlocal function _clingsDown(cling_line, note)\n   local back, front = cling_line :selectBack(_endPred)(),\n                       cling_line :selectFrom(_endPred, cling_line.first)()\n   local backlen = back and back:len() or 0\n   local frontlen = front and front:len() or 0\n\n   note(\"back length %d front length %d\", backlen, frontlen)\n   --[[\n   if back then\n      note(\"back token %s\", back:strLine())\n   end\n   if front then\n      note(\"front token %s\", front:strLine())\n   end\n   --]]\n\n   return backlen >= frontlen\nend\n\n\n\n\n\n\n\n\n\n-- a set of whitespace-esque possible block values, which we don\'t want\n-- to tag during the cling rule\nlocal skippable = Set {\'block_sep\', \'line_end\'}\n-- I don\'t know that line_end will ever come up but we may as well exclude it\n\nlocal _capTagResolve = {\n   list_line = function(tags, list_line, tag, note)\n      if list_line.parent.id ~= \'lead\' then\n         -- no children on a list line, just apply the tag\n         _tagUp(tags, list_line, tag, note)\n         return\n      end\n      local list = list_line.parent.parent\n      local function _tagChildren(l)\n         note(\"tagging children of list on line %d\", list_line:linePos())\n         for _, child in ipairs(l) do\n            if child.id == \'lead\' then\n               -- tag the list_line\n               _tagUp(tags, child[1], tag, note)\n            elseif child.id == \'list_line\' or child.id == \'numlist_line\' then\n               _tagUp(tags, child, tag, note)\n            elseif child.id == \'list\' then\n               _tagChildren(child)\n            else\n               note(\"encountered a strange child: %s\", child.id)\n            end\n         end\n      end\n      _tagChildren(list)\n   end,\n   header = function(tags, header, tag, note)\n      local section = header.parent\n      note(\"tagging %s and subsections with %s on line %d\",\n           section.id, tag, section:linePos())\n      _tagUp(tags, section, tag, note)\n      local function _tagChildren(sec)\n         for _, child in ipairs(sec) do\n            if child.id == \'section\' then\n               note(\"tagging subsection on line %d\", child:linePos())\n               _tagUp(tags, child, tag, note)\n               _tagChildren(child)\n            end\n         end\n      end\n      _tagChildren(section)\n   end,\n   hashtag_line = function(tags, hashtag_line, tag, note)\n      local clingsDown = _clingsDown(hashtag_line, note)\n      local section = hashtag_line.parent\n      assert(section.id == \'section\' or section.id == \'doc\',\n             \"found tagline parent with id \" .. section.id)\n      local cD = clingsDown and \"clings down\" or \"clings up\"\n      note(\"tagline parent is %s, %s\", section.id, cD)\n      local index;\n      for i = 1, #section do\n         if section[i] == hashtag_line then\n            index = i\n         end\n      end\n      -- rummage around for valid blocks to tag before and after the index\n      local prior, after;\n      local cursor = index - 1\n      while not prior do\n         if section[cursor] and (not skippable(section[cursor].id)) then\n            prior = section[cursor]\n         elseif cursor == 0 then\n            -- leave prior nil\n            break\n         else\n            cursor = cursor - 1\n         end\n      end\n      cursor = index + 1\n      while not after do\n         if section[cursor] and (not skippable(section[cursor].id)) then\n            after = section[cursor]\n         elseif cursor == #section + 1 then\n            break\n         else\n            cursor = cursor + 1\n         end\n      end\n      if not after then\n         note(\"no after\")\n      end\n      if not prior then\n         note(\"no prior\")\n      end\n\n      if clingsDown then\n         -- can\'t tag down if we\'re at the end of the Doc\n         if not after then\n            note(\"forcing cling up at end of Doc\")\n            if not prior then\n               -- this can happen if a Doc is just a hashtag line\n               note(\"didn\'t find a valid taggable before or after, weird\")\n            else\n               _tagUp(tags, prior, tag, note)\n            end\n         else\n            _tagUp(tags, after, tag, note)\n         end\n      else\n         -- can\'t tag up if we\'re in the first block of a Doc\n         if prior then\n            _tagUp(tags, prior, tag, note)\n         elseif not after then\n            note(\"didn\'t find a valid taggable before or after, weird\")\n         else\n            _tagUp(tags, after, tag, note)\n         end\n      end\n   end,\n   -- some are as simple as just tagging the parent\n   codeblock  = _tagUp,\n   blockquote = _tagUp,\n   paragraph  = _tagUp,\n   table      = _tagUp,\n   drawer     = _tagUp,\n   handle_line = _tagUp,\n}\n\n-- numlist_lines use the list_line logic\n_capTagResolve.numlist_line = _capTagResolve.list_line\n\n-- miniscule tags are mostly just _tagUp\nlocal _minTagResolve = {}\n\nfor field in pairs(taggable) do\n   _minTagResolve[field] = _tagUp\nend\n\n_minTagResolve.hashtag_line = _capTagResolve.hashtag_line\n\n\n\nlocal function hashtagAction(hashtag, skein)\n   local line = hashtag:linePos()\n   -- this is where all the gnarly stuff happens\n   -- for now, add the hashtag itself to the tag collection\n   local tagspan = sub(hashtag.str, hashtag.first + 1, hashtag.last)\n   local tag_parent = _taggableParent(hashtag, skein.source.doc, skein.note)\n   local iscap, tag = _capitalTag(tagspan)\n   if iscap then\n      skein.note(\"line %d: capital tag %s on %s, made into %s\",\n            line, tagspan, tag_parent.id, tag)\n      local resolver = _capTagResolve[tag_parent.id]\n      if resolver then\n         resolver(skein.tags, tag_parent, tag, skein.note)\n      else\n         s:halt(\"no resolver function for %s\", tag_parent.id)\n      end\n   else\n      skein.note(\"line %d: miniscule tag %s on %s\", line, tag, tag_parent.id)\n      local resolver = _minTagResolve[tag_parent.id]\n      if resolver then\n         resolver(skein.tags, tag_parent, tag, skein.note)\n      else\n         s:halt(\"no resolver function for %s\", tag_parent.id)\n      end\n   end\nend\n\nlocal function Tagger(skein)\n   local doc = assert(skein.source.doc, \"No doc found on skein\")\n   local tags = {}\n   skein.tags = tags\n   for node in doc:walk() do\n      if node.id == \'hashtag\' then\n         hashtagAction(node, skein)\n      end\n   end\n\n   return skein\nend\n\n\n\n\n\n\nreturn function(skein)\n   if not skein.source.doc then\n      skein:spin()\n   end\n   local ok, res = xpcall(function() return Tagger(skein) end, debug.traceback)\n   if ok then return skein end\n   skein.note(\"error: %s\", res)\n   s:warn(res)\n   return skein\nend\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "tag/tagger",
branch = "orb-scry",
},
  { 
hash = "73180a02eee676742435596eb800fd301d6203082a197207f90c43928c4a8dc0",
binary = "\n\n\n\n\n\n\n\n\n\nlocal sh = require \"lash:lash\"\nlocal Dir = require \"fs:directory\"\nlocal lines = assert(require \"core:core/string\" . lines)\nlocal insert = assert(table.insert)\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal spawn = require \"proc:spawn\"\n\nlocal function gitInfo(path)\n   local git_info = {}\n   if Dir(path..\"/.git\"):exists() then\n      coroutine.wrap(function()\n      git_info.is_repo = true\n      git_info.with_spawn = true\n\n      local git_branch = spawn(\"git\", {\"branch\", cwd = path})\n      local branches = assert(git_branch:read())\n      s:verb \"returned with branches:\"\n      for branch in lines(branches) do\n         s:verb(branch)\n         if branch:sub(1,1) == \"*\" then\n            git_info.branch = branch:sub(3)\n         end\n      end\n\n      local git_remote = spawn(\"git\", {\"remote\", cwd = path})\n      local remotes = git_remote:read()\n      s:verb \"return with remotes: \"\n      git_info.remotes = {}\n      if remotes then\n         for remote in lines(remotes) do\n            s:verb(\"fetching url for %s\", remote)\n            local url = spawn(\"git\", {\"remote\", \"get-url\", remote, cwd = path})\n                           :read()\n            s:verb(\"back with url: %s\", url)\n            if remote == \"origin\" then\n               git_info.url = url\n            end\n            insert(git_info.remotes, {remote, url})\n         end\n         if not git_info.url then\n            git_info.url = git_info.remotes[1] and git_info.remotes[1][2]\n         end\n      end\n      git_info.commit_hash = spawn(\"git\", {\"rev-parse\", \"HEAD\", cwd = path})\n                                :read()\n      s:verb(\"the commit hash is %s, that\'s all folks!\", git_info.commit_hash)\n      git_info.complete = true\n   end)()\n\n   else\n      git_info.is_repo = false\n   end\n   return git_info\nend\n\nreturn gitInfo\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "util/gitinfo",
branch = "orb-scry",
},
  { 
hash = "f37c743cf8a85f1251eadf23d57db7f64b1bb4820d06889709d0a6b2640ea44e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\ncore = require \"core:core\"\n\n\n\n\n\n\nlocal Orb = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(_Bridge.bridge_home, \"Missing bridge home\")\n\n_Bridge.orb_home = _Bridge.bridge_home .. \"/orb\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrb.lume = require \"orb:lume/lume\"\n\n\n\ncore = nil\n\nreturn Orb\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "orb",
branch = "orb-scry",
},
  { 
hash = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function toSectionAnchor(str)\n   \nend\n\n",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function toSectionAnchor(str)\n   \nend\n\n",
vc_hash = "15514b4e340e97adb69656eab99bcf236149b9ad\n",
name = "section-anchor",
branch = "orb-scry",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "palette",
    repo = "https://gitlab.com/bridgetools/palette.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "634668058b27d002c84aca280c8207bbb28844ef73d52e9cf99524238bb0eaca",
binary = "\n\nstatus = require \"status:status\"\nread = require \"orb:manifest/read\"\n\npalette = require \"anterm:palette\"\ncolors = require \"singletons:color\"\nuv = require \"luv\"\n\nfunction show_colors ()\n\tfor k, v in pairs(colors.color) do\n\t\tprint (k, v)\n\tend\nend\n--> show_colors()\n\ntoml = read(\'manifest.orb\')\npalette = palette()\n\nfor c, i in pairs(toml.data) do\n\tcolors.color[c] = toml.data[c].value\nend\n\nshow_colors()\n\n",
vc_hash = "596c11ccb1fc30984eba12a88928582a9291e8b3\n",
name = "palette",
branch = "trunk",
},
  { 
hash = "b6cf25fce31c015d586d74447b27420b78a9ef3bf72629bf0c4ed397dfa78e4b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npalette = require \"anterm:palette\"\nread = require \"orb:manifest/read\"\n-- custom_palette = read(\'manifest.orb\').palette\n\n\n\n\n\nPalette = palette()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction destiny (custom)\n\ttemp = {}\n\tlocal l = #custom\n\twhile l > 0 do\n\t\ttable.insert(temp, {custom[l].name, custom[l].value})\n\t\tassert(Palette:change(custom[l].name, custom[l].value), err)\n\t\tl = l - 1\n\tend\n\treturn temp\nend\n\n",
vc_hash = "596c11ccb1fc30984eba12a88928582a9291e8b3\n",
name = "pixel_flip",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "proc",
    repo = "git@gitlab.com:bridgetools/proc.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "c12be4124688a2aaf7005de010449ed0ebf16f5e54343eab60eefce0da5b596f",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal uv = require \"luv\"\n\nlocal meta = core.cluster.meta\n\n\n\nlocal Response = require \"cluster:response\"\n\n\n\n\n\n\nlocal Process = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal isyieldable = assert(coroutine.isyieldable)\n\nlocal function canAsync(process)\n   return isyieldable()\n          and uv.loop_alive()\n          and (not process.blocking)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function new(path, opt)\n   opt = opt or {}\n   local process = setmetatable({}, Process)\n   if not opt.stdio then\n      local stdio = {uv.new_pipe(), uv.new_pipe(), uv.new_pipe()}\n      opt.stdio = stdio\n      -- only close stdio if we created it\n      process.our_pipes = true\n      process.stdin = stdio[1]\n      process.stdout = stdio[2]\n      process.stderr = stdio[3]\n   end\n   -- copy over args if the array style is used\n   opt.args = opt.args or {}\n   -- don\'t mix and match!\n   for i, arg in ipairs(opt) do\n      insert(opt.args, arg)\n      opt[i] = nil -- no advantage to leaving them here\n   end\n\n   -- check for blocking\n   if opt.block then\n      process.blocking = true\n   end\n\n   local handle, pid = uv.spawn(path,\n                                opt,\n                                function(code, signal)\n                                   process:onexit(code, signal)\n                                end)\n   process.handle, process.pid = handle, pid\n   if not process.handle then\n      -- didn\'t work and we don\'t get told why\n      process.success = false\n      process.didnotrun = true\n      return process\n   end\n\n   -- start the readers on the same cycle\n   process.__inbox = {}\n   process.__errbox = {}\n   process.pending = true\n\n   uv.read_start(process.stdout, function(err, data)\n     process.pending = false\n     assert(not err, err)\n     insert(process.__inbox, data)\n   end)\n\n   uv.read_start(process.stderr, function(err, data)\n      process.pending = false\n      assert(not err, err)\n      insert(process.__errbox, data)\n   end)\n\n   return process\nend\n\nProcess.idEst = new\n\n\n\n\n\n\n\n\nfunction Process.canRead(process)\n   return (not process.pending) or process.exited\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat, clear = assert(table.concat), assert(table.clear)\n\nlocal function _pop(process, field)\n   if process.exited and #process[field] == 0 then return nil end\n   local data = concat(process[field])\n   clear(process[field])\n   return data\nend\n\n\n\nlocal running, yield, resume = assert(coroutine.running),\n                               assert(coroutine.yield),\n                               assert(coroutine.resume)\n\nlocal function reader(field)\n   return function (process)\n      if process.didnotrun then\n         return nil, \"process failed to run\"\n      end\n      if process:canRead() then\n         return _pop(process, field)\n      elseif canAsync(process) then\n         -- set up a Response\n         local co = running()\n         local check = uv.new_check()\n         local response = Response(check)\n         check:start(function()\n            -- diagnostic flag which may be useful later\n            process.jumped = true\n            if process:canRead() then\n               check:stop()\n               return response:respond(_pop(process, field))\n            end\n         end)\n         return yield(response)\n      else\n         return _pop(process, field)\n      end\n   end\nend\n\n\n\nProcess.read = reader \'__inbox\'\nProcess.err = reader \'__errbox\'\n\n\n\n\nfunction Process.write(process, str)\n   if process.exited or process.didnotrun then\n      local err = \"\"\n      if process.exited then\n         err = \"attempt to write after process has exited\"\n      elseif process.didnotrun then\n         err = \"attempt to write to a process which never spawned\"\n      end\n      error(err)\n   end\n   -- we want to skip any reads on the same tick as a write, so we set the\n   -- pending flag again\n   process.pending = true\n   uv.write(process.stdin, str)\nend\n\n\n\n\n\n\nfunction Process.onexit(process, code, signal)\n   process.exited = true\n   process.success = code == 0\n   process.code = code\n   process.signal = signal\n   uv.shutdown(process.stdin, function()\n         process.handle:close()\n         process.pending = false\n         process.handle, process.pid = nil, nil\n         if process.our_pipes then\n            process.our_pipes = nil\n            -- we only clean up automatically if we created the pipes\n            process.stdout:close(function() process.stdout = nil end)\n            process.stdin:close(function() process.stdin = nil end)\n            process.stderr:close(function() process.stderr = nil end)\n\n         end\n   end)\nend\n\nProcess.exit = Process.onexit\n\n\n\n\nreturn new\n\n",
vc_hash = "bb5cb0f7696724c14af82325c1b6816ff8a58444\n",
name = "spawn",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/pylon\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "pylon",
    repo = "https://gitlab.com/special-circumstance/pylon\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "2135445af2d2b594606851b3e58109c2d79ee21cb259de306bfb80f6de98bda3",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\n\n\n\n\n\nif bridge.modules_conn then\n   bridge.modules_conn:pclose()\n\nend\n\n\n\n\n\n\n\n\n\n\nif bridge.status_on then\n   require \"status:status\" :close()\nend\n\n\n\n\n\n\nos.exit(bridge.retcode)\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "afterward",
branch = "voltron-table",
},
  { 
hash = "6ee3c73da4c3737de537bceb85407a75c7a8bbfbbf5e17484de6021d3545452b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npack = table.pack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"table.clear\"\nrequire \"table.new\"\nrequire \"table.isempty\"\nrequire \"table.isarray\"\nrequire \"table.nkeys\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal require = require\n\nfunction use(...)\n   local req = ...\n   if not req then return end\n   return require(req), use(select(2, ...))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge = {}\n\n-- using rawset here to express intention\nrawset(_G, \"_Bridge\", bridge)\n\n\n\n\n\n\n\n\n\n\nbridge.retcode = 0\n\n\n\n\n\n\nbridge.bridge_modules = { }\nbridge.loaded = { }\nbridge.load_hashes = { }\n\n\n\n\n\n\n\n\n\nbridge.is_tty = require \"luv\" . guess_handle(1) == \'tty\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal home_dir = os.getenv \"HOME\"\nlocal bridge_modules = os.getenv \"BRIDGE_MODULES\"\nlocal bridge_home = os.getenv \"BRIDGE_HOME\"\n\n   -- use BRIDGE_HOME if we have it\nif not bridge_home then\n   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"\n   if xdg_data_home then\n      bridge_home = xdg_data_home .. \"/bridge\"\n   else\n      bridge_home = home_dir .. \"/.local/share/bridge\"\n   end\nend\n\nif not bridge_modules then\n   bridge_modules = bridge_home.. \"/bridge.modules\"\nend\n\nbridge.bridge_home = bridge_home\nbridge.bridge_modules_home = bridge_modules\n\n\n\n\n\nlocal ok, bridge_conn = pcall(sql.open, bridge_modules, \"rw\")\nif ok then\n   bridge.modules_conn = bridge_conn\nelse\n   print \"no bridge.modules\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _green = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = nil\n\n\n\n\n\nlocal No = newproxy()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _nil(state)\n   if state == nil or\n      state == true or\n      state == false then\n      return state\n   elseif state == 1 then\n      base = nil\n      return 1\n   else\n      return No, \"illegal transition nil -> \" .. tostring(state)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _true(state)\n   if state == nil or\n      state == true or\n      state == false then\n      return state\n   elseif state == 1 then\n      base = true\n      return 1\n   else\n      return No, \"illegal transition true -> \" .. tostring(state)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function _false(state)\n   if state == true or\n      state == false then\n      return state\n   else\n      return No, \"illegal transition false -> \" .. tostring(state)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _integer(state)\n   if state == 1 then\n      return _green + 1\n   elseif state == - 1 then\n      if _green > 1 then\n         return _green - 1\n      elseif _green == 1 then\n         return _base\n      else\n         return No, \"illegal n \" .. tostring(n)\n      end\n   elseif state == true then\n      _base = true\n      return _green\n   elseif state == nil then\n      _base = nil\n      return _green\n   elseif state == false then\n      return false\n   else\n      return No, \"illegal transition integer<n> -> \" .. tostring(n)\n   end\nend\n\n\n\n\n\n\n\n\nlocal _S = _nil\n\nlocal function greenIndex(state)\n   -- we /can/ use the error messages but don\'t need them\n   local transit = _S(state)\n\n   if transit == nil then\n      _S = _nil\n   elseif transit == true then\n      _S = _true\n   elseif transit == false then\n      _S = _false\n   elseif type(transit) == \'number\' then\n      _S = _Integer\n   end\n   if transit ~= No then\n      _green = transit\n   end\nend\n\n\n\n\n\n\n\n\nbridge.green_states = { Nil = _nil,\n                        True = _true,\n                        False = _false,\n                        greenIndex = greenIndex,\n                        Integer = _integer }\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage.preload.bridge = function() return bridge end\n\n\n\n\n\n\nend\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "bridge",
branch = "voltron-table",
},
  { 
hash = "65873934c6881e318b138540aad11d16a6d52f38c0be251055b8a52680fed3ed",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\nlocal bytecode_by_module = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nWHERE module.name = :name\nORDER BY module.time desc limit 1\n;\n]]\n\nlocal bytecode_by_module_and_project = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nINNER JOIN project\nON project.project_id = module.project\nWHERE project.name = :project_name\nAND module.name = :module_name\nORDER BY module.time desc limit 1\n;\n]]\n\n\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function resultMap(result)\n   if result == nil then return nil end\n   return toRow(result)\nend\n\nlocal function modNames(mod_name)\n   local project, mod = string.match(mod_name, \"(.*):(.*)\")\n   if not mod then\n      mod = mod_name\n   end\n   -- might be \"module/module\":\n   local mod_double = mod .. \"/\" .. mod\n   -- might be \"project:module\" -> \"project/module\"\n   local proj_double = \"\"\n   if project then\n      proj_double = project .. \"/\" .. mod\n   end\n   return project, mod, proj_double, mod_double\nend\n\n_Bridge.modNames = modNames\n\n_Bridge.dbLoaded = 1\n\nlocal function loaderGen(conn)\n   -- check that we have a database conn\n   if not conn then error(\"sql connection failed\") end\n   -- make prepared statements\n   local module_stmt = conn:prepare(bytecode_by_module)\n   local project_stmt = conn:prepare(bytecode_by_module_and_project)\n   -- return loader\n\n   return function (mod_name)\n      package.bridge_loaded = package.bridge_loaded or {}\n      -- split the module into project and modname\n      local bytecode = nil\n      local project, mod, proj_double, mod_double = modNames(mod_name)\n      if project then\n         -- retrieve bytecode by project and module\n         bytecode = resultMap(project_stmt :bind(project, mod) :resultset())\n         if not bytecode then\n            -- try mod_double\n            project_stmt:reset()\n            bytecode = resultMap(project_stmt :bind(project, mod_double)\n                                    :resultset())\n         end\n         if not bytecode then\n            -- try proj_double\n            project_stmt:reset()\n            bytecode = resultMap(project_stmt :bind(project, proj_double)\n                                    :resultset())\n         end\n         project_stmt:reset()\n      else\n         -- retrieve by bare module name\n         bytecode = resultMap(module_stmt :bind(mod) :resultset())\n         if not bytecode then\n            module_stmt:reset()\n            bytecode = resultMap(module_stmt :bind(mod_double) :resultset())\n         end\n         module_stmt:reset()\n      end\n      if bytecode then\n         local binary, hash = bytecode.binary, bytecode.hash\n         -- return a module-loading closure if already in scope\n         if _Bridge.loaded[hash] then\n            return function()\n               return package.loaded[_Bridge.loaded[hash]]\n            end\n         end\n         _Bridge.dbLoaded = _Bridge.dbLoaded + 1\n         local loadFn, errmsg = load(binary, \"@\" .. mod_name)\n         if loadFn then\n            _Bridge.loaded[hash] = mod_name\n            _Bridge.load_hashes[mod_name] = hash\n            return loadFn\n         else\n             error(errmsg)\n         end\n      else\n         return nil, (\"unable to load: \" .. mod_name)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nassert(_Bridge.modules_conn, \"missing bridge modules conn!\")\ntable.insert(package.loaders, 2, loaderGen(_Bridge.modules_conn))\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n   local getinfo, error, rawset, rawget = debug.getinfo, error, rawset, rawget\n   local strict = {}\n\n   local function what ()\n      local d = getinfo(3, \"S\")\n      return d and d.what or \"C\"\n   end\n\n   --- make an existing table strict.\n   -- @string name name of table (optional)\n   -- @tab[opt] mod table - if `nil` then we\'ll return a new table\n   -- @tab[opt] predeclared - table of variables that are to be considered predeclared.\n   -- @return the given table, or a new table\n   stricture = function (name,mod,predeclared)\n      local mt, old_newindex, old_index, old_index_type, global, closed\n      if predeclared then\n         global = predeclared.__global\n         closed = predeclared.__closed\n      end\n      if type(mod) == \'table\' then\n         mt = getmetatable(mod)\n         if mt and rawget(mt,\'__declared\') then return end -- already patched...\n      else\n         mod = {}\n      end\n      if mt == nil then\n         mt = {}\n         setmetatable(mod, mt)\n      else\n         old_newindex = mt.__newindex\n         old_index = mt.__index\n         old_index_type = type(old_index)\n      end\n      mt.__declared = predeclared or {}\n      mt.__newindex = function(t, n, v)\n         if old_newindex then\n            old_newindex(t, n, v)\n            if rawget(t,n)~=nil then return end\n         end\n         if not mt.__declared[n] then\n            if global then\n               local w = what()\n               if w ~= \"main\" and w ~= \"C\" then\n                  error(\"assign to undeclared global \'\"..n..\"\'\", 2)\n               end\n            end\n            mt.__declared[n] = true\n         end\n         rawset(t, n, v)\n      end\n      mt.__index = function(t,n)\n         if not mt.__declared[n] and what() ~= \"C\" then\n            if old_index then\n               if old_index_type == \"table\" then\n                  local fallback = old_index[n]\n                  if fallback ~= nil then\n                     return fallback\n                  end\n               else\n                  local res = old_index(t, n)\n                     if res ~= nil then\n                        return res\n                     end\n                  end\n               end\n               local msg = \"variable \'\"..n..\"\' is not declared\"\n               if name then\n                  msg = msg .. \" in \'\"..name..\"\'\"\n               end\n               error(msg, 2)\n            end\n         return rawget(t, n)\n      end\n\n      return mod\n   end\nend\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "preamble",
branch = "voltron-table",
},
  { 
hash = "44fd1ab7ce4216476a4312ae5210f871c37884fbc0ed7210d2ae9e4e0e31dd7e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\n\n\n\ndo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstricture(nil,_G,{_PROMPT=true,__global=true})\nstricture = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, C, Cg, Ct, R, match = L.P, L.C, L.Cg, L.Ct, L.R, L.match\nlocal format = assert(string.format)\nlocal MAX_INT = 9007199254740991\n\nlocal function cast_to_int(str_val)\n   local num = tonumber(str_val)\n   if num > MAX_INT then\n      return nil, \"Version numbers cannot exceed 2^53 - 1, \"\n             .. str_val .. \" is invalid\"\n   end\n   return num\nend\n\nlocal function parse_version(str)\n   local major  = Cg(R\"09\"^1, \"major\")\n   local minor  = Cg(R\"09\"^1, \"minor\")\n   local patch  = Cg(R\"09\"^1, \"patch\")\n   local kelvin = P\"[\" * Cg(R\"09\"^1, \"kelvin\") * P\"]\"\n   local knuth  = Cg(R\"09\"^1, \"knuth\") * P\"..\"\n   local patt = Ct( major\n                  * (P\".\" * minor)\n                  * (P\".\" * (kelvin + knuth + patch) + P(-1)) )\n                  * P(-1)\n   local ver = match(patt, str)\n   if not ver then\n      if match(R\"09\"^1 * P\".\"^-1 * P(-1), str) then\n         return nil, \"Must provide at least major and minor version numbers\"\n      else\n         return nil, \"Invalid --version format: \" .. str\n      end\n   end\n   -- Cast to number\n   for k,v in pairs(ver) do\n      ver[k] = cast_to_int(v)\n   end\n   -- make alternate patch forms into flags\n   if ver.kelvin then\n      ver.patch = ver.kelvin\n      ver.kelvin = true\n   elseif ver.knuth then\n      ver.patch = ver.knuth\n      ver.knuth = true\n   end\n\n   return ver\nend\n\nbridge.parse_version = parse_version\n\n\n\n\n\n\n\n\n\n\n\nlocal function dataload(lua_tab)\n   local f, err = loadstring(\"return \" .. lua_tab)\n   if not f then\n      return f, err\n   end\n   setfenv(f, {})\n   local ok, maybe_tab = pcall(f)\n   if not ok then\n      return ok, maybe_tab\n   elseif type(maybe_tab) == \'table\' then\n      return maybe_tab\n   else\n      return nil, \"bad lua data of type \" .. type(maybe_tab)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function open_range_fn(open)\n   return { tonumber(open:sub(1, -3)), \"#\" }\nend\n\nlocal num = C(R\"09\"^1) / tonumber\nlocal range = Ct((num * \"..\" * num))\nlocal open_range = C(num * \"..\") / open_range_fn\nlocal entry = range + num\n\nlocal list_p = Ct(P\"[\" * (P\" \"^0 * (range + num) * P\" \"^0 * P\",\")^0\n               * (P\" \"^0 * (range + open_range + num) * P\" \"^0)^-1 * P\"]\")\n\nlocal function parse_list(str)\n   local list = match(list_p, str)\n   if not list then\n      list = tonumber(str)\n      if list then return list end\n      return str\n   end\n\n   return list\nend\n\nbridge.parse_list = parse_list\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function parse_session_identifier(name)\n   return name:find(\"^%s*%d+%s*$\") and tonumber(name) or name\nend\n\nlocal function validate_session_name(name)\n   -- check if the string is only integers with possible whitespace padding\n   if name:find(\"^%s*%d+%s*$\") then\n      return nil, \"Can\'t give a session an integer name such as \" .. name .. \".\"\n   end\n   return name\nend\n\n\n\n\n\n\n\nlocal floor = assert(math.floor)\n\nlocal function isint(arg)\n   local num = tonumber(arg)\n   if num then\n      return floor(num)\n   else\n      return nil, arg .. \" isn\'t a number from Lua\'s perspective.\"\n   end\nend\n\n\n\n\n\n\n\nlocal brParse = require \"argparse\" ()\n\nbridge.brParse = brParse\n\nbrParse\n   : require_command (false)\n   : name \"br\"\n   : description (\"The bridge tools suite for repl-driven \"\n                  .. \"literate programming.\\n\\n\"\n                  .. \"To view help for each command, type br <command> -h.\")\n   : epilog (\"To run user-installed projects, type br <project> with \"\n             .. \"any arguments.\\n\\n\"\n             .. \"For more info, see https://special-circumstanc.es\")\n   : command_target \"verb\"\n   : help_description_margin(25)\n   : help_max_width(80)\n\nbrParse\n   : option \"-f\" \"--file\"\n      : description \"Run a file. Lua only, for now.\"\n      : args(1)\n      : overwrite(false)\n\nbrParse :mutex(\n   brParse\n   : option \"--freeze\"\n      : description \"Cache the verb given for faster loading.\"\n      : args(1)\n      : overwrite(false)\n      : argname \"\'verb\'\",\n   brParse\n     : option \"--thaw\"\n     : description \"Load the verb from individual modules.\"\n     : args(1)\n     : overwrite(false)\n     : argname \"\'verb\'\"\n\n)\n\nbrParse : flag \"--no-jit\" : description \"Turn off the JIT.\"\n\n\nbrParse\n   : flag \"--show-args\"\n      : description \"Display the args table. For development purposes.\"\n\nbrParse\n   : option \"--inject-args\"\n   : description (\"Take a valid Lua table and add the contents to the parsed\"\n              .. \" arguments. Will print results as above.\")\n   : convert(dataload)\n   : args(1)\n   : overwrite(false)\n\nbrParse\n  : flag \"-v --verbose\"\n    : description \"Verbose output (vv for very verbose).\"\n    : count \"0-2\"\n\nbrParse\n  : flag \"-t --terse\"\n  : description \"Terse output.\"\n\nlocal orb_c = brParse : command \"orb o\"\n                         : description \"Literate compiler for Orb format.\"\n\norb_c\n   : require_command (false)\n\norb_c\n  : flag \"-P --pedantic\"\n    : description \"Perform all filters, linting, crash on errors, etc.\"\n\norb_c\n   : command \"serve\"\n      : description \"Launch the Orb server.\"\n\norb_c\n   : command \"revert\"\n   : description \"Revert the latest compiled changes in project.\"\n   : option \"-p --project\"\n      : description \"Project to revert.\"\n      : args(1)\n\norb_c\n   : command \"scry\"\n   : description \"Performs analysis on knit Lua documents. Experimental!\"\n\n\nlocal helm_c = brParse\n                  : command \"helm i\"\n                     : description \"Launch helm, the \'i\'nteractive REPL.\"\n                     : help_description_margin(35)\n\nhelm_c\n   : option \"-s --session\"\n      : description \"Start the repl with a given, named session.\"\n      : convert(parse_session_identifier)\n      : args(1)\n\nhelm_c\n   : option \"-n --new-session\"\n      : description \"Begin a new, named session.\"\n      : convert(validate_session_name)\n      : args(1)\n\nhelm_c\n   : flag \"-r --restart\"\n   : description \"Restart helm and execute all lines from the last run.\"\n\nhelm_c\n   : flag \"-R --run\"\n   : description \"Edit the last run then restart.\"\n\nhelm_c\n   : option \"-b --back\"\n   : description \"Replay the last <number> lines.\"\n   : convert(isint)\n   : args(1)\n\nhelm_c\n   : flag \"-l --listen\"\n   : description ( \"Open with a listener, which compiles files on save and \"\n                .. \"restarts the session.\" )\n\n\nlocal export_c = brParse\n                    : command \"export\"\n                    : description \"Export a project from the database.\"\n\nexport_c\n   : argument \"project\"\n     : description \"Project or projects to export\"\n     : args \"?\"\n\nexport_c\n  : option \"-o\" \"--outfile\"\n     : description (\"A file to export projects to.\"\n                 .. \"Defaults to ./<project>.bundle\")\n     : args(1)\n\nexport_c\n   : option \"-v\" \"--version\"\n      : description \"Version of the project to export\"\n      : convert(parse_version)\n      : args(1)\n\nexport_c\n   : flag \"-a\" \"--all\"\n      : description ( \"Export all projects.\"\n                   .. \"Latest bundles if no version is specified.\" )\n\n\nlocal import_c = brParse\n                    : command \"import\"\n                    : description \"Import a project from a bundle file.\"\n\nimport_c\n   : argument \"file\"\n   : description \"a bundled project file or files\"\n   : args \"+\"\n\nlocal session_c = brParse\n                    : command \"session s\"\n                    : description (\"Session runner. Provides unit tests\"\n                        .. \" derived from helm sessions. With no arguments,\"\n                        .. \" runs all accepted sessions for the project\"\n                        .. \" at pwd.\")\n                    : require_command(false)\n\nsession_c\n   : flag \"--all\"\n   : description(\"Run all accepted sessions in the database,\"\n                 .. \" for every project.\")\n\nsession_c\n   : flag \"--total\"\n   : description(\"Run every session in the database, no exceptions.\")\n\nsession_c\n   : flag \"-E\" \"--every\"\n   : description \"Run every session for a given project.\"\n\nsession_c\n   : option \"-s\" \"--some\"\n   : description \"Run only the indicated sessions, by name, number, or list.\"\n   : convert(parse_list)\n   : args(1)\n\nsession_c\n   : flag \"-S\" \"--show-results\"\n   : description \"Print all results for premises.\"\n\nlocal session_list_c = session_c\n                          : command \"list l\"\n                          : description (\"List (accepted) sessions. \"\n                             .. \"Defaults to current project.\")\n\nsession_list_c\n    : option \"-l --latest\"\n    : description \"List the n most recent accepted sessions, default 5.\"\n    : args \"?\"\n    : argname \"<n>\"\n\nsession_list_c\n    : flag \"-a --all\"\n    : description \"List all sessions including deprecated sessions.\"\n    : action(function(args) args.list_all = true end)\n\nlocal function add_range_arg(cmd, arg_name)\n   cmd\n      : argument(arg_name)\n      : description (\"A session title, session number, or list of session \"\n         .. \"numbers/ranges e.g. [1,3,5..6,8..].\")\n      : convert(parse_list)\n      : args(1)\nend\n\nlocal session_update_c = session_c\n         : command \"update u\"\n         : description (\"Update session(s) premises to accept latest \"\n                        .. \"results.\")\nadd_range_arg(session_update_c, \"to_update\")\n\nlocal session_delete_c = session_c\n         : command \"delete d\"\n         : description (\"Delete listed sessions. \"\n                     .. \"Will only delete a deprecated session.\")\nadd_range_arg(session_delete_c, \"to_delete\")\n\nlocal session_force_delete_c = session_c\n                                  : command \"force-delete D\"\n                                  : description\n                                     (\"Delete listed sessions, including \"\n                                      .. \"accepted sessions.\")\nadd_range_arg(session_force_delete_c, \"to_delete\")\n\nlocal session_accept_c = session_c\n         : command \"accept a\"\n         : description \"Mark a session or list as accepted.\"\nadd_range_arg(session_accept_c, \"to_accept\")\n\nlocal session_deprecate_c = session_c\n         : command \"deprecate p\"\n         : description(\"dePrecate a session, or list of sessions, which will \"\n                     ..\"no longer be run with `br session`.\")\nadd_range_arg(session_deprecate_c, \"to_deprecate\")\n\nlocal session_rename_c = session_c\n         : command \"rename r\"\n         : description \"Give a session a new title.\"\n\nsession_rename_c\n  : argument \"old_name\"\n  : description \"The title or number of an existing session to rename.\"\n  : convert(parse_session_identifier)\n\nsession_rename_c\n  : argument \"new_name\"\n  : description \"The new title for the session.\"\n  : convert(validate_session_name)\n\nlocal session_export_c = session_c\n         : command \"export e\"\n         : description \"Export a session or list of sessions.\"\nadd_range_arg(session_export_c, \"to_export\")\n\nsession_export_c\n   : option \"-o\" \"--outfile\"\n   : description \"A file path. Defaults to stdout if not provided.\"\n   : args(1)\n\nlocal session_import_c = session_c\n         : command \"import i\"\n         : description (\"Import sessions from a bundle file, into the project \"\n                     .. \"named in the bundle.\")\n\nsession_import_c\n   : argument \"infile\"\n   : description \"A session bundle file. Defaults to stdin if not provided.\"\n   : args \"?\"\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\ncollectgarbage()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\n\nlocal verbs = { s = true, o = true, i = true}\n\nfunction verbs.orb(args)\n   if args.revert then\n      local revert = require \"bundle:revert\"\n      revert()\n   else\n       local orb = require \"orb\"\n       local lume = orb.lume(uv.cwd())\n       lume:run()\n       if args.serve then\n          lume:serve()\n       end\n   end\nend\n\nfunction verbs.session(args)\n   local session = assert(require \"valiant:session\" . session)\n   session(args)\nend\n\nfunction verbs.helm(args)\n   bridge.helm = true\n   local helm = require \"helm:helm\"\n   helm()\nend\n\nfunction verbs.export(args)\n   if (not args.project) and (not args.all) then\n      error \"at least one project required without --all flag\"\n   end\n   local bundle\n   if not args.all then\n      bundle = require \"bundle:export\".export(args.project,\n                                                 args.version)\n   else\n      bundle = require \"bundle:export\".exportAll(args.version)\n   end\n   if args.outfile then\n      local file = io.open(args.outfile, \"w+\")\n      if not file then\n         error(\"unable to open \" .. args.outfile)\n      end\n      file:write(bundle)\n      file:close()\n   else\n      local bundle_name = args.project or \"all_modules\"\n      local outfilepath = \"./\" .. bundle_name .. \".bundle\"\n      local file = io.open(outfilepath, \"w+\")\n      if not file then\n         error(\"unable to open \" .. outfilepath)\n      end\n      file:write(bundle)\n      file:close()\n   end\nend\n\n\nlocal import = assert(bridge.import)\n\nfunction verbs.import(args)\n   for _, file in ipairs(args.file) do\n      import(file)\n   end\nend\n\n\n\n\n\nlocal get_voltron = [[\nSELECT voltron FROM voltron WHERE name = :name\nORDER BY TIME DESC LIMIT 1;\n]]\n\nlocal thaw_voltron = [[\nUPDATE voltron SET active = 0 WHERE name = :name;\n]]\n\n\n\n\n\n\n\n\n\n\nif rawget(_G, \"arg\") ~= nil then\n   -- shim the arg array to emulate the \"lua <scriptname>\" calling\n   -- convention which argparse expects\n   table.insert(arg, 0, \"\")\n\n   -- check for custom command\n   local first_verb, lead_char = nil, string.sub(arg[1], 1, 1)\n   first_verb = lead_char ~= \'-\' and arg[1] or nil\n\n   if first_verb and not(verbs[first_verb]) then\n      -- needs a rewrite\n      -- annoying, because \"arg\" is magic in argparse\n      -- so:\n      -- first get everything after the verb out of arg\n      -- allow brParse code to run\n      -- if we have a first_verb, then at the end of the\n      -- decision tree, replace the contents of arg with\n      -- the saved contents from before\n      -- summon custom arg parse if it exists, call it\n      -- run custom project, again, if it exists\n      -- question our life choices\n      local verb, args = table.remove(arg, 1), nil\n      local ok, argP = pcall(require, verb .. \":argparse\")\n      if ok then\n         args = argP:parse()\n      end\n      local ok, mod = pcall(require, verb .. \":\" .. verb)\n      if ok then\n         mod(args)\n      else\n         print(\"Can\'t find a project \" .. first_verb .. \".\")\n      end\n   else\n      bridge.args = bridge.brParse:parse()\n      local args = bridge.args\n\n      -- no JIT? kill it and make it stay dead, like this:\n      if args.no_jit then\n         local jit = require \"jit\"\n         -- kill it\n         jit.off()\n         -- so it /stays dead/\n         jit.on = function() end\n      end\n\n      -- inject any arguments\n      if args.inject_args then\n         local inject = args.inject_args\n         args.inject_args = nil\n         for k, v in pairs(inject) do\n            args[k] = v\n         end\n      end\n\n      -- show arguments if so requested\n      if args.show_args then\n         args.show_args = nil -- no reason to include this\n         local ts = require \"repr:repr\" . ts\n         print(ts(args))\n      end\n\n      -- check for and dispatch verbosity flags\n      if args.terse or (args.verbose > 0) then\n         local S = require \"status:status\"\n         if args.verbose == 1 then\n            S.Verbose = true\n         elseif args.verbose == 2 then\n            S.Boring = true\n         elseif args.terse then\n            S.Chatty = false\n            S.Verbose = false\n         end\n      end\n\n      -- freeze or thaw\n      if args.freeze then\n         print(\"Assembling modules of \" .. args.freeze)\n         local voltron = require \"voltron:voltron\"\n         voltron(args.freeze):voltron()\n         print \"ok\"\n         goto bottom\n      elseif args.thaw then\n         bridge.modules_conn\n             :prepare(thaw_voltron) :bind(args.thaw) :value()\n         print \"ok\"\n         goto bottom\n      end\n\n      -- load bridge verbs\n      if verbs[args.verb] then\n         if bridge.volts[args.verb] then\n            local voltstr = bridge.modules_conn :prepare(get_voltron)\n                              :bind(args.verb) :value()\n            local voltload = require \"voltron:load\"\n            voltload(voltstr)\n         end\n         verbs[args.verb](args)\n      elseif args.file then\n         if args.file:sub(-4, -1) == \".lua\" then\n            dofile(args.file)\n         end\n         -- #todo handle .orb files here\n      else\n         -- no further arguments, just exit\n      end\n   end\n   :: bottom ::\nend\n\n\n\n\n\n\n\n\nif uv.loop_alive() and (not uv.loop_mode()) then\n   uv.run \'default\'\nend\n\n\n\n\n\n\n\n\nend\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "load",
branch = "voltron-table",
},
  { 
hash = "89b37e4e1714334792343dc40f7edf190f5bcaa553ac2028062dd93d65301091",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage.preload.argparse = (function ()\n-- The MIT License (MIT)\n\n-- Copyright (c) 2013 - 2018 Peter Melnichenko\n--                      2019 Paul Ouellette\n\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n-- the Software, and to permit persons to whom the Software is furnished to do so,\n-- subject to the following conditions:\n\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nlocal function deep_update(t1, t2)\n   for k, v in pairs(t2) do\n      if type(v) == \"table\" then\n         v = deep_update({}, v)\n      end\n\n      t1[k] = v\n   end\n\n   return t1\nend\n\n-- A property is a tuple {name, callback}.\n-- properties.args is number of properties that can be set as arguments\n-- when calling an object.\nlocal function class(prototype, properties, parent)\n   -- Class is the metatable of its instances.\n   local cl = {}\n   cl.__index = cl\n\n   if parent then\n      cl.__prototype = deep_update(deep_update({}, parent.__prototype), prototype)\n   else\n      cl.__prototype = prototype\n   end\n\n   if properties then\n      local names = {}\n\n      -- Create setter methods and fill set of property names.\n      for _, property in ipairs(properties) do\n         local name, callback = property[1], property[2]\n\n         cl[name] = function(self, value)\n            if not callback(self, value) then\n               self[\"_\" .. name] = value\n            end\n\n            return self\n         end\n\n         names[name] = true\n      end\n\n      function cl.__call(self, ...)\n         -- When calling an object, if the first argument is a table,\n         -- interpret keys as property names, else delegate arguments\n         -- to corresponding setters in order.\n         if type((...)) == \"table\" then\n            for name, value in pairs((...)) do\n               if names[name] then\n                  self[name](self, value)\n               end\n            end\n         else\n            local nargs = select(\"#\", ...)\n\n            for i, property in ipairs(properties) do\n               if i > nargs or i > properties.args then\n                  break\n               end\n\n               local arg = select(i, ...)\n\n               if arg ~= nil then\n                  self[property[1]](self, arg)\n               end\n            end\n         end\n\n         return self\n      end\n   end\n\n   -- If indexing class fails, fallback to its parent.\n   local class_metatable = {}\n   class_metatable.__index = parent\n\n   function class_metatable.__call(self, ...)\n      -- Calling a class returns its instance.\n      -- Arguments are delegated to the instance.\n      local object = deep_update({}, self.__prototype)\n      setmetatable(object, self)\n      return object(...)\n   end\n\n   return setmetatable(cl, class_metatable)\nend\n\nlocal function typecheck(name, types, value)\n   for _, type_ in ipairs(types) do\n      if type(value) == type_ then\n         return true\n      end\n   end\n\n   error((\"bad property \'%s\' (%s expected, got %s)\"):format(name, table.concat(types, \" or \"), type(value)))\nend\n\nlocal function typechecked(name, ...)\n   local types = {...}\n   return {name, function(_, value) typecheck(name, types, value) end}\nend\n\nlocal multiname = {\"name\", function(self, value)\n   typecheck(\"name\", {\"string\"}, value)\n\n   for alias in value:gmatch(\"%S+\") do\n      self._name = self._name or alias\n      table.insert(self._aliases, alias)\n   end\n\n   -- Do not set _name as with other properties.\n   return true\nend}\n\nlocal function parse_boundaries(str)\n   if tonumber(str) then\n      return tonumber(str), tonumber(str)\n   end\n\n   if str == \"*\" then\n      return 0, math.huge\n   end\n\n   if str == \"+\" then\n      return 1, math.huge\n   end\n\n   if str == \"?\" then\n      return 0, 1\n   end\n\n   if str:match \"^%d+%-%d+$\" then\n      local min, max = str:match \"^(%d+)%-(%d+)$\"\n      return tonumber(min), tonumber(max)\n   end\n\n   if str:match \"^%d+%+$\" then\n      local min = str:match \"^(%d+)%+$\"\n      return tonumber(min), math.huge\n   end\nend\n\nlocal function boundaries(name)\n   return {name, function(self, value)\n      typecheck(name, {\"number\", \"string\"}, value)\n\n      local min, max = parse_boundaries(value)\n\n      if not min then\n         error((\"bad property \'%s\'\"):format(name))\n      end\n\n      self[\"_min\" .. name], self[\"_max\" .. name] = min, max\n   end}\nend\n\nlocal actions = {}\n\nlocal option_action = {\"action\", function(_, value)\n   typecheck(\"action\", {\"function\", \"string\"}, value)\n\n   if type(value) == \"string\" and not actions[value] then\n      error((\"unknown action \'%s\'\"):format(value))\n   end\nend}\n\nlocal option_init = {\"init\", function(self)\n   self._has_init = true\nend}\n\nlocal option_default = {\"default\", function(self, value)\n   if type(value) ~= \"string\" then\n      self._init = value\n      self._has_init = true\n      return true\n   end\nend}\n\nlocal add_help = {\"add_help\", function(self, value)\n   typecheck(\"add_help\", {\"boolean\", \"string\", \"table\"}, value)\n\n   if self._help_option_idx then\n      table.remove(self._options, self._help_option_idx)\n      self._help_option_idx = nil\n   end\n\n   if value then\n      local help = self:flag()\n         :description \"Show this help message and exit.\"\n         :action(function()\n            print(self:get_help())\n            os.exit(0)\n         end)\n\n      if value ~= true then\n         help = help(value)\n      end\n\n      if not help._name then\n         help \"-h\" \"--help\"\n      end\n\n      self._help_option_idx = #self._options\n   end\nend}\n\nlocal Parser = class({\n   _arguments = {},\n   _options = {},\n   _commands = {},\n   _mutexes = {},\n   _groups = {},\n   _require_command = true,\n   _handle_options = true\n}, {\n   args = 3,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   add_help\n})\n\nlocal Command = class({\n   _aliases = {}\n}, {\n   args = 3,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"summary\", \"string\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   typechecked(\"hidden\", \"boolean\"),\n   add_help\n}, Parser)\n\nlocal Argument = class({\n   _minargs = 1,\n   _maxargs = 1,\n   _mincount = 1,\n   _maxcount = 1,\n   _defmode = \"unused\",\n   _show_default = true\n}, {\n   args = 5,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n})\n\nlocal Option = class({\n   _aliases = {},\n   _mincount = 0,\n   _overwrite = true\n}, {\n   args = 6,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   boundaries(\"count\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"overwrite\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n}, Argument)\n\nfunction Parser:_inherit_property(name, default)\n   local element = self\n\n   while true do\n      local value = element[\"_\" .. name]\n\n      if value ~= nil then\n         return value\n      end\n\n      if not element._parent then\n         return default\n      end\n\n      element = element._parent\n   end\nend\n\nfunction Argument:_get_argument_list()\n   local buf = {}\n   local i = 1\n\n   while i <= math.min(self._minargs, 3) do\n      local argname = self:_get_argname(i)\n\n      if self._default and self._defmode:find \"a\" then\n         argname = \"[\" .. argname .. \"]\"\n      end\n\n      table.insert(buf, argname)\n      i = i+1\n   end\n\n   while i <= math.min(self._maxargs, 3) do\n      table.insert(buf, \"[\" .. self:_get_argname(i) .. \"]\")\n      i = i+1\n\n      if self._maxargs == math.huge then\n         break\n      end\n   end\n\n   if i < self._maxargs then\n      table.insert(buf, \"...\")\n   end\n\n   return buf\nend\n\nfunction Argument:_get_usage()\n   local usage = table.concat(self:_get_argument_list(), \" \")\n\n   if self._default and self._defmode:find \"u\" then\n      if self._maxargs > 1 or (self._minargs == 1 and not self._defmode:find \"a\") then\n         usage = \"[\" .. usage .. \"]\"\n      end\n   end\n\n   return usage\nend\n\nfunction actions.store_true(result, target)\n   result[target] = true\nend\n\nfunction actions.store_false(result, target)\n   result[target] = false\nend\n\nfunction actions.store(result, target, argument)\n   result[target] = argument\nend\n\nfunction actions.count(result, target, _, overwrite)\n   if not overwrite then\n      result[target] = result[target] + 1\n   end\nend\n\nfunction actions.append(result, target, argument, overwrite)\n   result[target] = result[target] or {}\n   table.insert(result[target], argument)\n\n   if overwrite then\n      table.remove(result[target], 1)\n   end\nend\n\nfunction actions.concat(result, target, arguments, overwrite)\n   if overwrite then\n      error(\"\'concat\' action can\'t handle too many invocations\")\n   end\n\n   result[target] = result[target] or {}\n\n   for _, argument in ipairs(arguments) do\n      table.insert(result[target], argument)\n   end\nend\n\nfunction Argument:_get_action()\n   local action, init\n\n   if self._maxcount == 1 then\n      if self._maxargs == 0 then\n         action, init = \"store_true\", nil\n      else\n         action, init = \"store\", nil\n      end\n   else\n      if self._maxargs == 0 then\n         action, init = \"count\", 0\n      else\n         action, init = \"append\", {}\n      end\n   end\n\n   if self._action then\n      action = self._action\n   end\n\n   if self._has_init then\n      init = self._init\n   end\n\n   if type(action) == \"string\" then\n      action = actions[action]\n   end\n\n   return action, init\nend\n\n-- Returns placeholder for `narg`-th argument.\nfunction Argument:_get_argname(narg)\n   local argname = self._argname or self:_get_default_argname()\n\n   if type(argname) == \"table\" then\n      return argname[narg]\n   else\n      return argname\n   end\nend\n\nfunction Argument:_get_choices_list()\n   return \"{\" .. table.concat(self._choices, \",\") .. \"}\"\nend\n\nfunction Argument:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self._name .. \">\"\n   end\nend\n\nfunction Option:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self:_get_default_target() .. \">\"\n   end\nend\n\n-- Returns labels to be shown in the help message.\nfunction Argument:_get_label_lines()\n   if self._choices then\n      return {self:_get_choices_list()}\n   else\n      return {self._name}\n   end\nend\n\nfunction Option:_get_label_lines()\n   local argument_list = self:_get_argument_list()\n\n   if #argument_list == 0 then\n      -- Don\'t put aliases for simple flags like `-h` on different lines.\n      return {table.concat(self._aliases, \", \")}\n   end\n\n   local longest_alias_length = -1\n\n   for _, alias in ipairs(self._aliases) do\n      longest_alias_length = math.max(longest_alias_length, #alias)\n   end\n\n   local argument_list_repr = table.concat(argument_list, \" \")\n   local lines = {}\n\n   for i, alias in ipairs(self._aliases) do\n      local line = (\" \"):rep(longest_alias_length - #alias) .. alias .. \" \" .. argument_list_repr\n\n      if i ~= #self._aliases then\n         line = line .. \",\"\n      end\n\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nfunction Command:_get_label_lines()\n   return {table.concat(self._aliases, \", \")}\nend\n\nfunction Argument:_get_description()\n   if self._default and self._show_default then\n      if self._description then\n         return (\"%s (default: %s)\"):format(self._description, self._default)\n      else\n         return (\"default: %s\"):format(self._default)\n      end\n   else\n      return self._description or \"\"\n   end\nend\n\nfunction Command:_get_description()\n   return self._summary or self._description or \"\"\nend\n\nfunction Option:_get_usage()\n   local usage = self:_get_argument_list()\n   table.insert(usage, 1, self._name)\n   usage = table.concat(usage, \" \")\n\n   if self._mincount == 0 or self._default then\n      usage = \"[\" .. usage .. \"]\"\n   end\n\n   return usage\nend\n\nfunction Argument:_get_default_target()\n   return self._name\nend\n\nfunction Option:_get_default_target()\n   local res\n\n   for _, alias in ipairs(self._aliases) do\n      if alias:sub(1, 1) == alias:sub(2, 2) then\n         res = alias:sub(3)\n         break\n      end\n   end\n\n   res = res or self._name:sub(2)\n   return (res:gsub(\"-\", \"_\"))\nend\n\nfunction Option:_is_vararg()\n   return self._maxargs ~= self._minargs\nend\n\nfunction Parser:_get_fullname(exclude_root)\n   local parent = self._parent\n   if exclude_root and not parent then\n      return \"\"\n   end\n   local buf = {self._name}\n\n   while parent do\n      if not exclude_root or parent._parent then\n         table.insert(buf, 1, parent._name)\n      end\n      parent = parent._parent\n   end\n\n   return table.concat(buf, \" \")\nend\n\nfunction Parser:_update_charset(charset)\n   charset = charset or {}\n\n   for _, command in ipairs(self._commands) do\n      command:_update_charset(charset)\n   end\n\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         charset[alias:sub(1, 1)] = true\n      end\n   end\n\n   return charset\nend\n\nfunction Parser:argument(...)\n   local argument = Argument(...)\n   table.insert(self._arguments, argument)\n   return argument\nend\n\nfunction Parser:option(...)\n   local option = Option(...)\n   table.insert(self._options, option)\n   return option\nend\n\nfunction Parser:flag(...)\n   return self:option():args(0)(...)\nend\n\nfunction Parser:command(...)\n   local command = Command():add_help(true)(...)\n   command._parent = self\n   table.insert(self._commands, command)\n   return command\nend\n\nfunction Parser:mutex(...)\n   local elements = {...}\n\n   for i, element in ipairs(elements) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument, (\"bad argument #%d to \'mutex\' (Option or Argument expected)\"):format(i))\n   end\n\n   table.insert(self._mutexes, elements)\n   return self\nend\n\nfunction Parser:group(name, ...)\n   assert(type(name) == \"string\", (\"bad argument #1 to \'group\' (string expected, got %s)\"):format(type(name)))\n\n   local group = {name = name, ...}\n\n   for i, element in ipairs(group) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument or mt == Command,\n         (\"bad argument #%d to \'group\' (Option or Argument or Command expected)\"):format(i + 1))\n   end\n\n   table.insert(self._groups, group)\n   return self\nend\n\nlocal usage_welcome = \"Usage: \"\n\nfunction Parser:get_usage()\n   if self._usage then\n      return self._usage\n   end\n\n   local usage_margin = self:_inherit_property(\"usage_margin\", #usage_welcome)\n   local max_usage_width = self:_inherit_property(\"usage_max_width\", 70)\n   local lines = {usage_welcome .. self:_get_fullname()}\n\n   local function add(s)\n      if #lines[#lines]+1+#s <= max_usage_width then\n         lines[#lines] = lines[#lines] .. \" \" .. s\n      else\n         lines[#lines+1] = (\" \"):rep(usage_margin) .. s\n      end\n   end\n\n   -- Normally options are before positional arguments in usage messages.\n   -- However, vararg options should be after, because they can\'t be reliable used\n   -- before a positional argument.\n   -- Mutexes come into play, too, and are shown as soon as possible.\n   -- Overall, output usages in the following order:\n   -- 1. Mutexes that don\'t have positional arguments or vararg options.\n   -- 2. Options that are not in any mutexes and are not vararg.\n   -- 3. Positional arguments - on their own or as a part of a mutex.\n   -- 4. Remaining mutexes.\n   -- 5. Remaining options.\n\n   local elements_in_mutexes = {}\n   local added_elements = {}\n   local added_mutexes = {}\n   local argument_to_mutexes = {}\n\n   local function add_mutex(mutex, main_argument)\n      if added_mutexes[mutex] then\n         return\n      end\n\n      added_mutexes[mutex] = true\n      local buf = {}\n\n      for _, element in ipairs(mutex) do\n         if not element._hidden and not added_elements[element] then\n            if getmetatable(element) == Option or element == main_argument then\n               table.insert(buf, element:_get_usage())\n               added_elements[element] = true\n            end\n         end\n      end\n\n      if #buf == 1 then\n         add(buf[1])\n      elseif #buf > 1 then\n         add(\"(\" .. table.concat(buf, \" | \") .. \")\")\n      end\n   end\n\n   local function add_element(element)\n      if not element._hidden and not added_elements[element] then\n         add(element:_get_usage())\n         added_elements[element] = true\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      local is_vararg = false\n      local has_argument = false\n\n      for _, element in ipairs(mutex) do\n         if getmetatable(element) == Option then\n            if element:_is_vararg() then\n               is_vararg = true\n            end\n         else\n            has_argument = true\n            argument_to_mutexes[element] = argument_to_mutexes[element] or {}\n            table.insert(argument_to_mutexes[element], mutex)\n         end\n\n         elements_in_mutexes[element] = true\n      end\n\n      if not is_vararg and not has_argument then\n         add_mutex(mutex)\n      end\n   end\n\n   for _, option in ipairs(self._options) do\n      if not elements_in_mutexes[option] and not option:_is_vararg() then\n         add_element(option)\n      end\n   end\n\n   -- Add usages for positional arguments, together with one mutex containing them, if they are in a mutex.\n   for _, argument in ipairs(self._arguments) do\n      -- Pick a mutex as a part of which to show this argument, take the first one that\'s still available.\n      local mutex\n\n      if elements_in_mutexes[argument] then\n         for _, argument_mutex in ipairs(argument_to_mutexes[argument]) do\n            if not added_mutexes[argument_mutex] then\n               mutex = argument_mutex\n            end\n         end\n      end\n\n      if mutex then\n         add_mutex(mutex, argument)\n      else\n         add_element(argument)\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      add_mutex(mutex)\n   end\n\n   for _, option in ipairs(self._options) do\n      add_element(option)\n   end\n\n   if #self._commands > 0 then\n      if self._require_command then\n         add(\"<command>\")\n      else\n         add(\"[<command>]\")\n      end\n\n      add(\"...\")\n   end\n\n   return table.concat(lines, \"\\n\")\nend\n\nlocal function split_lines(s)\n   if s == \"\" then\n      return {}\n   end\n\n   local lines = {}\n\n   if s:sub(-1) ~= \"\\n\" then\n      s = s .. \"\\n\"\n   end\n\n   for line in s:gmatch(\"([^\\n]*)\\n\") do\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nlocal function autowrap_line(line, max_length)\n   -- Algorithm for splitting lines is simple and greedy.\n   local result_lines = {}\n\n   -- Preserve original indentation of the line, put this at the beginning of each result line.\n   -- If the first word looks like a list marker (\'*\', \'+\', or \'-\'), add spaces so that starts\n   -- of the second and the following lines vertically align with the start of the second word.\n   local indentation = line:match(\"^ *\")\n\n   if line:find(\"^ *[%*%+%-]\") then\n      indentation = indentation .. \" \" .. line:match(\"^ *[%*%+%-]( *)\")\n   end\n\n   -- Parts of the last line being assembled.\n   local line_parts = {}\n\n   -- Length of the current line.\n   local line_length = 0\n\n   -- Index of the next character to consider.\n   local index = 1\n\n   while true do\n      local word_start, word_finish, word = line:find(\"([^ ]+)\", index)\n\n      if not word_start then\n         -- Ignore trailing spaces, if any.\n         break\n      end\n\n      local preceding_spaces = line:sub(index, word_start - 1)\n      index = word_finish + 1\n\n      if (#line_parts == 0) or (line_length + #preceding_spaces + #word <= max_length) then\n         -- Either this is the very first word or it fits as an addition to the current line, add it.\n         table.insert(line_parts, preceding_spaces) -- For the very first word this adds the indentation.\n         table.insert(line_parts, word)\n         line_length = line_length + #preceding_spaces + #word\n      else\n         -- Does not fit, finish current line and put the word into a new one.\n         table.insert(result_lines, table.concat(line_parts))\n         line_parts = {indentation, word}\n         line_length = #indentation + #word\n      end\n   end\n\n   if #line_parts > 0 then\n      table.insert(result_lines, table.concat(line_parts))\n   end\n\n   if #result_lines == 0 then\n      -- Preserve empty lines.\n      result_lines[1] = \"\"\n   end\n\n   return result_lines\nend\n\n-- Automatically wraps lines within given array,\n-- attempting to limit line length to `max_length`.\n-- Existing line splits are preserved.\nlocal function autowrap(lines, max_length)\n   local result_lines = {}\n\n   for _, line in ipairs(lines) do\n      local autowrapped_lines = autowrap_line(line, max_length)\n\n      for _, autowrapped_line in ipairs(autowrapped_lines) do\n         table.insert(result_lines, autowrapped_line)\n      end\n   end\n\n   return result_lines\nend\n\nfunction Parser:_get_element_help(element)\n   local label_lines = element:_get_label_lines()\n   local description_lines = split_lines(element:_get_description())\n\n   local result_lines = {}\n\n   -- All label lines should have the same length (except the last one, it has no comma).\n   -- If too long, start description after all the label lines.\n   -- Otherwise, combine label and description lines.\n\n   local usage_margin_len = self:_inherit_property(\"help_usage_margin\", 3)\n   local usage_margin = (\" \"):rep(usage_margin_len)\n   local description_margin_len = self:_inherit_property(\"help_description_margin\", 25)\n   local description_margin = (\" \"):rep(description_margin_len)\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if help_max_width then\n      local description_max_width = math.max(help_max_width - description_margin_len, 10)\n      description_lines = autowrap(description_lines, description_max_width)\n   end\n\n   if #label_lines[1] >= (description_margin_len - usage_margin_len) then\n      for _, label_line in ipairs(label_lines) do\n         table.insert(result_lines, usage_margin .. label_line)\n      end\n\n      for _, description_line in ipairs(description_lines) do\n         table.insert(result_lines, description_margin .. description_line)\n      end\n   else\n      for i = 1, math.max(#label_lines, #description_lines) do\n         local label_line = label_lines[i]\n         local description_line = description_lines[i]\n\n         local line = \"\"\n\n         if label_line then\n            line = usage_margin .. label_line\n         end\n\n         if description_line and description_line ~= \"\" then\n            line = line .. (\" \"):rep(description_margin_len - #line) .. description_line\n         end\n\n         table.insert(result_lines, line)\n      end\n   end\n\n   return table.concat(result_lines, \"\\n\")\nend\n\nlocal function get_group_types(group)\n   local types = {}\n\n   for _, element in ipairs(group) do\n      types[getmetatable(element)] = true\n   end\n\n   return types\nend\n\nfunction Parser:_add_group_help(blocks, added_elements, label, elements)\n   local buf = {label}\n\n   for _, element in ipairs(elements) do\n      if not element._hidden and not added_elements[element] then\n         added_elements[element] = true\n         table.insert(buf, self:_get_element_help(element))\n      end\n   end\n\n   if #buf > 1 then\n      table.insert(blocks, table.concat(buf, (\"\\n\"):rep(self:_inherit_property(\"help_vertical_space\", 0) + 1)))\n   end\nend\n\nfunction Parser:get_help()\n   if self._help then\n      return self._help\n   end\n\n   local blocks = {self:get_usage()}\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if self._description then\n      local description = self._description\n\n      if help_max_width then\n         description = table.concat(autowrap(split_lines(description), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, description)\n   end\n\n   -- 1. Put groups containing arguments first, then other arguments.\n   -- 2. Put remaining groups containing options, then other options.\n   -- 3. Put remaining groups containing commands, then other commands.\n   -- Assume that an element can\'t be in several groups.\n   local groups_by_type = {\n      [Argument] = {},\n      [Option] = {},\n      [Command] = {}\n   }\n\n   for _, group in ipairs(self._groups) do\n      local group_types = get_group_types(group)\n\n      for _, mt in ipairs({Argument, Option, Command}) do\n         if group_types[mt] then\n            table.insert(groups_by_type[mt], group)\n            break\n         end\n      end\n   end\n\n   local default_groups = {\n      {name = \"Arguments\", type = Argument, elements = self._arguments},\n      {name = \"Options\", type = Option, elements = self._options},\n      {name = \"Commands\", type = Command, elements = self._commands}\n   }\n\n   local added_elements = {}\n\n   for _, default_group in ipairs(default_groups) do\n      local type_groups = groups_by_type[default_group.type]\n\n      for _, group in ipairs(type_groups) do\n         self:_add_group_help(blocks, added_elements, group.name .. \":\", group)\n      end\n\n      local default_label = default_group.name .. \":\"\n\n      if #type_groups > 0 then\n         default_label = \"Other \" .. default_label:gsub(\"^.\", string.lower)\n      end\n\n      self:_add_group_help(blocks, added_elements, default_label, default_group.elements)\n   end\n\n   if self._epilog then\n      local epilog = self._epilog\n\n      if help_max_width then\n         epilog = table.concat(autowrap(split_lines(epilog), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, epilog)\n   end\n\n   return table.concat(blocks, \"\\n\\n\")\nend\n\nfunction Parser:add_help_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_help_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local help = self:command()\n      :description \"Show help for commands.\"\n   help:argument \"command\"\n      :description \"The command to show help for.\"\n      :args \"?\"\n      :action(function(_, _, cmd)\n         if not cmd then\n            print(self:get_help())\n            os.exit(0)\n         else\n            for _, command in ipairs(self._commands) do\n               for _, alias in ipairs(command._aliases) do\n                  if alias == cmd then\n                     print(command:get_help())\n                     os.exit(0)\n                  end\n               end\n            end\n         end\n         help:error((\"unknown command \'%s\'\"):format(cmd))\n      end)\n\n   if value then\n      help = help(value)\n   end\n\n   if not help._name then\n      help \"help\"\n   end\n\n   help._is_help_command = true\n   return self\nend\n\nfunction Parser:_is_shell_safe()\n   if self._basename then\n      if self._basename:find(\"[^%w_%-%+%.]\") then\n         return false\n      end\n   else\n      for _, alias in ipairs(self._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n   end\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n      if option._choices then\n         for _, choice in ipairs(option._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, argument in ipairs(self._arguments) do\n      if argument._choices then\n         for _, choice in ipairs(argument._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, command in ipairs(self._commands) do\n      if not command:_is_shell_safe() then\n         return false\n      end\n   end\n   return true\nend\n\nfunction Parser:add_complete(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:option()\n      :description \"Output a shell completion script for the specified shell.\"\n      :args(1)\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"--completion\"\n   end\n\n   return self\nend\n\nfunction Parser:add_complete_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:command()\n      :description \"Output a shell completion script.\"\n   complete:argument \"shell\"\n      :description \"The shell to output a completion script for.\"\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"completion\"\n   end\n\n   return self\nend\n\nlocal function base_name(pathname)\n   return pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\") or pathname\nend\n\nlocal function get_short_description(element)\n   local short = element:_get_description():match(\"^(.-)%.%s\")\n   return short or element:_get_description():match(\"^(.-)%.?$\")\nend\n\nfunction Parser:_get_options()\n   local options = {}\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         table.insert(options, alias)\n      end\n   end\n   return table.concat(options, \" \")\nend\n\nfunction Parser:_get_commands()\n   local commands = {}\n   for _, command in ipairs(self._commands) do\n      for _, alias in ipairs(command._aliases) do\n         table.insert(commands, alias)\n      end\n   end\n   return table.concat(commands, \" \")\nend\n\nfunction Parser:_bash_option_args(buf, indent)\n   local opts = {}\n   for _, option in ipairs(self._options) do\n      if option._choices or option._minargs > 0 then\n         local compreply\n         if option._choices then\n            compreply = \'COMPREPLY=($(compgen -W \"\' .. table.concat(option._choices, \" \") .. \'\" -- \"$cur\"))\'\n         else\n            compreply = \'COMPREPLY=($(compgen -f -- \"$cur\"))\'\n         end\n         table.insert(opts, (\" \"):rep(indent + 4) .. table.concat(option._aliases, \"|\") .. \")\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. compreply)\n         table.insert(opts, (\" \"):rep(indent + 8) .. \"return 0\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. \";;\")\n      end\n   end\n\n   if #opts > 0 then\n      table.insert(buf, (\" \"):rep(indent) .. \'case \"$prev\" in\')\n      table.insert(buf, table.concat(opts, \"\\n\"))\n      table.insert(buf, (\" \"):rep(indent) .. \"esac\\n\")\n   end\nend\n\nfunction Parser:_bash_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \'args=(\"${args[@]:1}\")\')\n   table.insert(buf, (\" \"):rep(indent) .. \'for arg in \"${args[@]}\"; do\')\n   table.insert(buf, (\" \"):rep(indent + 4) .. \'case \"$arg\" in\')\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. table.concat(command._aliases, \"|\") .. \")\")\n      if self._parent then\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"$cmd \' .. command._name .. \'\"\')\n      else\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"\' .. command._name .. \'\"\')\n      end\n      table.insert(buf, (\" \"):rep(indent + 12) .. \'opts=\"$opts \' .. command:_get_options() .. \'\"\')\n      command:_bash_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n      table.insert(buf, (\" \"):rep(indent + 12) .. \";;\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"esac\")\n   table.insert(buf, (\" \"):rep(indent) .. \"done\")\nend\n\nfunction Parser:_bash_cmd_completions(buf)\n   local cmd_buf = {}\n   if self._parent then\n      self:_bash_option_args(cmd_buf, 12)\n   end\n   if #self._commands > 0 then\n      table.insert(cmd_buf, (\" \"):rep(12) .. \'COMPREPLY=($(compgen -W \"\' .. self:_get_commands() .. \'\" -- \"$cur\"))\')\n   elseif self._is_help_command then\n      table.insert(cmd_buf, (\" \"):rep(12)\n         .. \'COMPREPLY=($(compgen -W \"\'\n         .. self._parent:_get_commands()\n         .. \'\" -- \"$cur\"))\')\n   end\n   if #cmd_buf > 0 then\n      table.insert(buf, (\" \"):rep(8) .. \"\'\" .. self:_get_fullname(true) .. \"\')\")\n      table.insert(buf, table.concat(cmd_buf, \"\\n\"))\n      table.insert(buf, (\" \"):rep(12) .. \";;\")\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_bash_cmd_completions(buf)\n   end\nend\n\nfunction Parser:get_bash_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {([[\n_%s() {\n    local IFS=$\' \\t\\n\'\n    local args cur prev cmd opts arg\n    args=(\"${COMP_WORDS[@]}\")\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    opts=\"%s\"\n]]):format(self._basename, self:_get_options())}\n\n   self:_bash_option_args(buf, 4)\n   self:_bash_get_cmd(buf, 4)\n   if #self._commands > 0 then\n      table.insert(buf, \"\")\n      table.insert(buf, (\" \"):rep(4) .. \'case \"$cmd\" in\')\n      self:_bash_cmd_completions(buf)\n      table.insert(buf, (\" \"):rep(4) .. \"esac\\n\")\n   end\n\n   table.insert(buf, ([=[\n    if [[ \"$cur\" = -* ]]; then\n        COMPREPLY=($(compgen -W \"$opts\" -- \"$cur\"))\n    fi\n}\n\ncomplete -F _%s -o bashdefault -o default %s\n]=]):format(self._basename, self._basename))\n\n   return table.concat(buf, \"\\n\")\nend\n\nfunction Parser:_zsh_arguments(buf, cmd_name, indent)\n   if self._parent then\n      table.insert(buf, (\" \"):rep(indent) .. \"options=(\")\n      table.insert(buf, (\" \"):rep(indent + 2) .. \"$options\")\n   else\n      table.insert(buf, (\" \"):rep(indent) .. \"local -a options=(\")\n   end\n\n   for _, option in ipairs(self._options) do\n      local line = {}\n      if #option._aliases > 1 then\n         if option._maxcount > 1 then\n            table.insert(line, \'\"*\"\')\n         end\n         table.insert(line, \"{\" .. table.concat(option._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\')\n         if option._maxcount > 1 then\n            table.insert(line, \"*\")\n         end\n         table.insert(line, option._name)\n      end\n      if option._description then\n         local description = get_short_description(option):gsub(\'[\"%]:`$]\', \"\\\\%0\")\n         table.insert(line, \"[\" .. description .. \"]\")\n      end\n      if option._maxargs == math.huge then\n         table.insert(line, \":*\")\n      end\n      if option._choices then\n         table.insert(line, \": :(\" .. table.concat(option._choices, \" \") .. \")\")\n      elseif option._maxargs > 0 then\n         table.insert(line, \": :_files\")\n      end\n      table.insert(line, \'\"\')\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(line))\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \")\")\n   table.insert(buf, (\" \"):rep(indent) .. \"_arguments -s -S \\\\\")\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"$options \\\\\")\n\n   if self._is_help_command then\n      table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :(\' .. self._parent:_get_commands() .. \')\" \\\\\')\n   else\n      for _, argument in ipairs(self._arguments) do\n         local spec\n         if argument._choices then\n            spec = \": :(\" .. table.concat(argument._choices, \" \") .. \")\"\n         else\n            spec = \": :_files\"\n         end\n         if argument._maxargs == math.huge then\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*\' .. spec .. \'\" \\\\\')\n            break\n         end\n         for _ = 1, argument._maxargs do\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"\' .. spec .. \'\" \\\\\')\n         end\n      end\n\n      if #self._commands > 0 then\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :_\' .. cmd_name .. \'_cmds\" \\\\\')\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*:: :->args\" \\\\\')\n      end\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"&& return 0\")\nend\n\nfunction Parser:_zsh_cmds(buf, cmd_name)\n   table.insert(buf, \"\\n_\" .. cmd_name .. \"_cmds() {\")\n   table.insert(buf, \"  local -a commands=(\")\n\n   for _, command in ipairs(self._commands) do\n      local line = {}\n      if #command._aliases > 1 then\n         table.insert(line, \"{\" .. table.concat(command._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\' .. command._name)\n      end\n      if command._description then\n         table.insert(line, \":\" .. get_short_description(command):gsub(\'[\"`$]\', \"\\\\%0\"))\n      end\n      table.insert(buf, \"    \" .. table.concat(line) .. \'\"\')\n   end\n\n   table.insert(buf, \'  )\\n  _describe \"command\" commands\\n}\')\nend\n\nfunction Parser:_zsh_complete_help(buf, cmds_buf, cmd_name, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   self:_zsh_cmds(cmds_buf, cmd_name)\n   table.insert(buf, \"\\n\" .. (\" \"):rep(indent) .. \"case $words[1] in\")\n\n   for _, command in ipairs(self._commands) do\n      local name = cmd_name .. \"_\" .. command._name\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(command._aliases, \"|\") .. \")\")\n      command:_zsh_arguments(buf, name, indent + 4)\n      command:_zsh_complete_help(buf, cmds_buf, name, indent + 4)\n      table.insert(buf, (\" \"):rep(indent + 4) .. \";;\\n\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"esac\")\nend\n\nfunction Parser:get_zsh_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {(\"#compdef %s\\n\"):format(self._basename)}\n   local cmds_buf = {}\n   table.insert(buf, \"_\" .. self._basename .. \"() {\")\n   if #self._commands > 0 then\n      table.insert(buf, \"  local context state state_descr line\")\n      table.insert(buf, \"  typeset -A opt_args\\n\")\n   end\n   self:_zsh_arguments(buf, self._basename, 2)\n   self:_zsh_complete_help(buf, cmds_buf, self._basename, 2)\n   table.insert(buf, \"\\n  return 1\")\n   table.insert(buf, \"}\")\n\n   local result = table.concat(buf, \"\\n\")\n   if #cmds_buf > 0 then\n      result = result .. \"\\n\" .. table.concat(cmds_buf, \"\\n\")\n   end\n   return result .. \"\\n\\n_\" .. self._basename .. \"\\n\"\nend\n\nlocal function fish_escape(string)\n   return string:gsub(\"[\\\\\']\", \"\\\\%0\")\nend\n\nfunction Parser:_fish_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"set -e cmdline[1]\")\n   table.insert(buf, (\" \"):rep(indent) .. \"for arg in $cmdline\")\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"switch $arg\")\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. \"case \" .. table.concat(command._aliases, \" \"))\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"set cmd $cmd \" .. command._name)\n      command:_fish_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"end\")\n   table.insert(buf, (\" \"):rep(indent) .. \"end\")\nend\n\nfunction Parser:_fish_complete_help(buf, basename)\n   local prefix = \"complete -c \" .. basename\n   table.insert(buf, \"\")\n\n   for _, command in ipairs(self._commands) do\n      local aliases = table.concat(command._aliases, \" \")\n      local line\n      if self._parent then\n         line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n            :format(prefix, basename, self:_get_fullname(true), aliases)\n      else\n         line = (\"%s -n \'__fish_%s_using_command\' -xa \'%s\'\"):format(prefix, basename, aliases)\n      end\n      if command._description then\n         line = (\"%s -d \'%s\'\"):format(line, fish_escape(get_short_description(command)))\n      end\n      table.insert(buf, line)\n   end\n\n   if self._is_help_command then\n      local line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n         :format(prefix, basename, self:_get_fullname(true), self._parent:_get_commands())\n      table.insert(buf, line)\n   end\n\n   for _, option in ipairs(self._options) do\n      local parts = {prefix}\n\n      if self._parent then\n         table.insert(parts, \"-n \'__fish_\" .. basename .. \"_seen_command \" .. self:_get_fullname(true) .. \"\'\")\n      end\n\n      for _, alias in ipairs(option._aliases) do\n         if alias:match(\"^%-.$\") then\n            table.insert(parts, \"-s \" .. alias:sub(2))\n         elseif alias:match(\"^%-%-.+\") then\n            table.insert(parts, \"-l \" .. alias:sub(3))\n         end\n      end\n\n      if option._choices then\n         table.insert(parts, \"-xa \'\" .. table.concat(option._choices, \" \") .. \"\'\")\n      elseif option._minargs > 0 then\n         table.insert(parts, \"-r\")\n      end\n\n      if option._description then\n         table.insert(parts, \"-d \'\" .. fish_escape(get_short_description(option)) .. \"\'\")\n      end\n\n      table.insert(buf, table.concat(parts, \" \"))\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_fish_complete_help(buf, basename)\n   end\nend\n\nfunction Parser:get_fish_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {}\n\n   if #self._commands > 0 then\n      table.insert(buf, ([[\nfunction __fish_%s_print_command\n    set -l cmdline (commandline -poc)\n    set -l cmd]]):format(self._basename))\n      self:_fish_get_cmd(buf, 4)\n      table.insert(buf, ([[\n    echo \"$cmd\"\nend\n\nfunction __fish_%s_using_command\n    test (__fish_%s_print_command) = \"$argv\"\n    and return 0\n    or return 1\nend\n\nfunction __fish_%s_seen_command\n    string match -q \"$argv*\" (__fish_%s_print_command)\n    and return 0\n    or return 1\nend]]):format(self._basename, self._basename, self._basename, self._basename))\n   end\n\n   self:_fish_complete_help(buf, self._basename)\n   return table.concat(buf, \"\\n\") .. \"\\n\"\nend\n\nlocal function get_tip(context, wrong_name)\n   local context_pool = {}\n   local possible_name\n   local possible_names = {}\n\n   for name in pairs(context) do\n      if type(name) == \"string\" then\n         for i = 1, #name do\n            possible_name = name:sub(1, i - 1) .. name:sub(i + 1)\n\n            if not context_pool[possible_name] then\n               context_pool[possible_name] = {}\n            end\n\n            table.insert(context_pool[possible_name], name)\n         end\n      end\n   end\n\n   for i = 1, #wrong_name + 1 do\n      possible_name = wrong_name:sub(1, i - 1) .. wrong_name:sub(i + 1)\n\n      if context[possible_name] then\n         possible_names[possible_name] = true\n      elseif context_pool[possible_name] then\n         for _, name in ipairs(context_pool[possible_name]) do\n            possible_names[name] = true\n         end\n      end\n   end\n\n   local first = next(possible_names)\n\n   if first then\n      if next(possible_names, first) then\n         local possible_names_arr = {}\n\n         for name in pairs(possible_names) do\n            table.insert(possible_names_arr, \"\'\" .. name .. \"\'\")\n         end\n\n         table.sort(possible_names_arr)\n         return \"\\nDid you mean one of these: \" .. table.concat(possible_names_arr, \" \") .. \"?\"\n      else\n         return \"\\nDid you mean \'\" .. first .. \"\'?\"\n      end\n   else\n      return \"\"\n   end\nend\n\nlocal ElementState = class({\n   invocations = 0\n})\n\nfunction ElementState:__call(state, element)\n   self.state = state\n   self.result = state.result\n   self.element = element\n   self.target = element._target or element:_get_default_target()\n   self.action, self.result[self.target] = element:_get_action()\n   return self\nend\n\nfunction ElementState:error(fmt, ...)\n   self.state:error(fmt, ...)\nend\n\nfunction ElementState:convert(argument, index)\n   local converter = self.element._convert\n\n   if converter then\n      local ok, err\n\n      if type(converter) == \"function\" then\n         ok, err = converter(argument)\n      elseif type(converter[index]) == \"function\" then\n         ok, err = converter[index](argument)\n      else\n         ok = converter[argument]\n      end\n\n      if ok == nil then\n         self:error(err and \"%s\" or \"malformed argument \'%s\'\", err or argument)\n      end\n\n      argument = ok\n   end\n\n   return argument\nend\n\nfunction ElementState:default(mode)\n   return self.element._defmode:find(mode) and self.element._default\nend\n\nlocal function bound(noun, min, max, is_max)\n   local res = \"\"\n\n   if min ~= max then\n      res = \"at \" .. (is_max and \"most\" or \"least\") .. \" \"\n   end\n\n   local number = is_max and max or min\n   return res .. tostring(number) .. \" \" .. noun ..  (number == 1 and \"\" or \"s\")\nend\n\nfunction ElementState:set_name(alias)\n   self.name = (\"%s \'%s\'\"):format(alias and \"option\" or \"argument\", alias or self.element._name)\nend\n\nfunction ElementState:invoke()\n   self.open = true\n   self.overwrite = false\n\n   if self.invocations >= self.element._maxcount then\n      if self.element._overwrite then\n         self.overwrite = true\n      else\n         local num_times_repr = bound(\"time\", self.element._mincount, self.element._maxcount, true)\n         self:error(\"%s must be used %s\", self.name, num_times_repr)\n      end\n   else\n      self.invocations = self.invocations + 1\n   end\n\n   self.args = {}\n\n   if self.element._maxargs <= 0 then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:check_choices(argument)\n   if self.element._choices then\n      for _, choice in ipairs(self.element._choices) do\n         if argument == choice then\n            return\n         end\n      end\n      local choices_list = \"\'\" .. table.concat(self.element._choices, \"\', \'\") .. \"\'\"\n      local is_option = getmetatable(self.element) == Option\n      self:error(\"%s%s must be one of %s\", is_option and \"argument for \" or \"\", self.name, choices_list)\n   end\nend\n\nfunction ElementState:pass(argument)\n   self:check_choices(argument)\n   argument = self:convert(argument, #self.args + 1)\n   table.insert(self.args, argument)\n\n   if #self.args >= self.element._maxargs then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:complete_invocation()\n   while #self.args < self.element._minargs do\n      self:pass(self.element._default)\n   end\nend\n\nfunction ElementState:close()\n   if self.open then\n      self.open = false\n\n      if #self.args < self.element._minargs then\n         if self:default(\"a\") then\n            self:complete_invocation()\n         else\n            if #self.args == 0 then\n               if getmetatable(self.element) == Argument then\n                  self:error(\"missing %s\", self.name)\n               elseif self.element._maxargs == 1 then\n                  self:error(\"%s requires an argument\", self.name)\n               end\n            end\n\n            self:error(\"%s requires %s\", self.name, bound(\"argument\", self.element._minargs, self.element._maxargs))\n         end\n      end\n\n      local args\n\n      if self.element._maxargs == 0 then\n         args = self.args[1]\n      elseif self.element._maxargs == 1 then\n         if self.element._minargs == 0 and self.element._mincount ~= self.element._maxcount then\n            args = self.args\n         else\n            args = self.args[1]\n         end\n      else\n         args = self.args\n      end\n\n      self.action(self.result, self.target, args, self.overwrite)\n   end\nend\n\nlocal ParseState = class({\n   result = {},\n   options = {},\n   arguments = {},\n   argument_i = 1,\n   element_to_mutexes = {},\n   mutex_to_element_state = {},\n   command_actions = {}\n})\n\nfunction ParseState:__call(parser, error_handler)\n   self.parser = parser\n   self.error_handler = error_handler\n   self.charset = parser:_update_charset()\n   self:switch(parser)\n   return self\nend\n\nfunction ParseState:error(fmt, ...)\n   self.error_handler(self.parser, fmt:format(...))\nend\n\nfunction ParseState:switch(parser)\n   self.parser = parser\n\n   if parser._action then\n      table.insert(self.command_actions, {action = parser._action, name = parser._name})\n   end\n\n   for _, option in ipairs(parser._options) do\n      option = ElementState(self, option)\n      table.insert(self.options, option)\n\n      for _, alias in ipairs(option.element._aliases) do\n         self.options[alias] = option\n      end\n   end\n\n   for _, mutex in ipairs(parser._mutexes) do\n      for _, element in ipairs(mutex) do\n         if not self.element_to_mutexes[element] then\n            self.element_to_mutexes[element] = {}\n         end\n\n         table.insert(self.element_to_mutexes[element], mutex)\n      end\n   end\n\n   for _, argument in ipairs(parser._arguments) do\n      argument = ElementState(self, argument)\n      table.insert(self.arguments, argument)\n      argument:set_name()\n      argument:invoke()\n   end\n\n   self.handle_options = parser._handle_options\n   self.argument = self.arguments[self.argument_i]\n   self.commands = parser._commands\n\n   for _, command in ipairs(self.commands) do\n      for _, alias in ipairs(command._aliases) do\n         self.commands[alias] = command\n      end\n   end\nend\n\nfunction ParseState:get_option(name)\n   local option = self.options[name]\n\n   if not option then\n      self:error(\"unknown option \'%s\'%s\", name, get_tip(self.options, name))\n   else\n      return option\n   end\nend\n\nfunction ParseState:get_command(name)\n   local command = self.commands[name]\n\n   if not command then\n      if #self.commands > 0 then\n         self:error(\"unknown command \'%s\'%s\", name, get_tip(self.commands, name))\n      else\n         self:error(\"too many arguments\")\n      end\n   else\n      return command\n   end\nend\n\nfunction ParseState:check_mutexes(element_state)\n   if self.element_to_mutexes[element_state.element] then\n      for _, mutex in ipairs(self.element_to_mutexes[element_state.element]) do\n         local used_element_state = self.mutex_to_element_state[mutex]\n\n         if used_element_state and used_element_state ~= element_state then\n            self:error(\"%s can not be used together with %s\", element_state.name, used_element_state.name)\n         else\n            self.mutex_to_element_state[mutex] = element_state\n         end\n      end\n   end\nend\n\nfunction ParseState:invoke(option, name)\n   self:close()\n   option:set_name(name)\n   self:check_mutexes(option, name)\n\n   if option:invoke() then\n      self.option = option\n   end\nend\n\nfunction ParseState:pass(arg)\n   if self.option then\n      if not self.option:pass(arg) then\n         self.option = nil\n      end\n   elseif self.argument then\n      self:check_mutexes(self.argument)\n\n      if not self.argument:pass(arg) then\n         self.argument_i = self.argument_i + 1\n         self.argument = self.arguments[self.argument_i]\n      end\n   else\n      local command = self:get_command(arg)\n      self.result[command._target or command._name] = true\n\n      if self.parser._command_target then\n         self.result[self.parser._command_target] = command._name\n      end\n\n      self:switch(command)\n   end\nend\n\nfunction ParseState:close()\n   if self.option then\n      self.option:close()\n      self.option = nil\n   end\nend\n\nfunction ParseState:finalize()\n   self:close()\n\n   for i = self.argument_i, #self.arguments do\n      local argument = self.arguments[i]\n      if #argument.args == 0 and argument:default(\"u\") then\n         argument:complete_invocation()\n      else\n         argument:close()\n      end\n   end\n\n   if self.parser._require_command and #self.commands > 0 then\n      self:error(\"a command is required\")\n   end\n\n   for _, option in ipairs(self.options) do\n      option.name = option.name or (\"option \'%s\'\"):format(option.element._name)\n\n      if option.invocations == 0 then\n         if option:default(\"u\") then\n            option:invoke()\n            option:complete_invocation()\n            option:close()\n         end\n      end\n\n      local mincount = option.element._mincount\n\n      if option.invocations < mincount then\n         if option:default(\"a\") then\n            while option.invocations < mincount do\n               option:invoke()\n               option:close()\n            end\n         elseif option.invocations == 0 then\n            self:error(\"missing %s\", option.name)\n         else\n            self:error(\"%s must be used %s\", option.name, bound(\"time\", mincount, option.element._maxcount))\n         end\n      end\n   end\n\n   for i = #self.command_actions, 1, -1 do\n      self.command_actions[i].action(self.result, self.command_actions[i].name)\n   end\nend\n\nfunction ParseState:parse(args)\n   for _, arg in ipairs(args) do\n      local plain = true\n\n      if self.handle_options then\n         local first = arg:sub(1, 1)\n\n         if self.charset[first] then\n            if #arg > 1 then\n               plain = false\n\n               if arg:sub(2, 2) == first then\n                  if #arg == 2 then\n                     if self.options[arg] then\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     else\n                        self:close()\n                     end\n\n                     self.handle_options = false\n                  else\n                     local equals = arg:find \"=\"\n                     if equals then\n                        local name = arg:sub(1, equals - 1)\n                        local option = self:get_option(name)\n\n                        if option.element._maxargs <= 0 then\n                           self:error(\"option \'%s\' does not take arguments\", name)\n                        end\n\n                        self:invoke(option, name)\n                        self:pass(arg:sub(equals + 1))\n                     else\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     end\n                  end\n               else\n                  for i = 2, #arg do\n                     local name = first .. arg:sub(i, i)\n                     local option = self:get_option(name)\n                     self:invoke(option, name)\n\n                     if i ~= #arg and option.element._maxargs > 0 then\n                        self:pass(arg:sub(i + 1))\n                        break\n                     end\n                  end\n               end\n            end\n         end\n      end\n\n      if plain then\n         self:pass(arg)\n      end\n   end\n\n   self:finalize()\n   return self.result\nend\n\nfunction Parser:error(msg)\n   io.stderr:write((\"%s\\n\\nError: %s\\n\"):format(self:get_usage(), msg))\n   os.exit(1)\nend\n\n-- Compatibility with strict.lua and other checkers:\nlocal default_cmdline = rawget(_G, \"arg\") or {}\n\nfunction Parser:_parse(args, error_handler)\n   return ParseState(self, error_handler):parse(args or default_cmdline)\nend\n\nfunction Parser:parse(args)\n   return self:_parse(args, self.error)\nend\n\nlocal function xpcall_error_handler(err)\n   return tostring(err) .. \"\\noriginal \" .. debug.traceback(\"\", 2):sub(2)\nend\n\nfunction Parser:pparse(args)\n   local parse_error\n\n   local ok, result = xpcall(function()\n      return self:_parse(args, function(_, err)\n         parse_error = err\n         error(err, 0)\n      end)\n   end, xpcall_error_handler)\n\n   if ok then\n      return true, result\n   elseif not parse_error then\n      error(result, 0)\n   else\n      return false, parse_error\n   end\nend\n\nlocal argparse = {}\n\nargparse.version = \"0.7.0\"\n\nsetmetatable(argparse, {__call = function(_, ...)\n   return Parser(default_cmdline[0]):add_help(true)(...)\nend})\n\nreturn argparse\n\nend)\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "argparse",
branch = "voltron-table",
},
  { 
hash = "c67a6ddf7bfe81075396515e372b4e99454d8b49f7a373a7243a2375c2300dae",
binary = "\n\n\n\n\n\n\n\n\n\n\nprint \"what does this do?\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n   if flip() then\n      return \"came up true\"\n   else\n      return \"came up false\"\n   end\nend\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "inline-run-mode",
branch = "voltron-table",
},
  { 
hash = "249fbf617adc3149455f33a2df1752e08545ba8f87250cea696fc8aec68d0c17",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sqlayer = {}\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\n\njit.off(true, true)\n\n\n\n\n\n\nlocal ffi  = require \"ffi\"\nlocal bit  = require \"bit\"\nlocal uv   = require \"luv\"\n\n\n\n\n\n\nlocal insert = table.insert\n\n-- CREDIT: Steve Dovan snippet.\nlocal function split(s, re)\n local i1, ls = 1, { }\n if not re then re = \'%s+\' end\n if re == \'\' then return { s } end\n while true do\n   local i2, i3 = s:find(re, i1)\n   if not i2 then\n     local last = s:sub(i1)\n     if last ~= \'\' then insert(ls, last) end\n     if #ls == 1 and ls[1] == \'\' then\n       return  { }\n     else\n       return ls\n     end\n   end\n   insert(ls, s:sub(i1, i2 - 1))\n   i1 = i3 + 1\n end\nend\n\nlocal function trim(s)\n return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\nend\n\nlocal function err(code, msg)\n error(\"ljsqlite3[\"..code..\"] \"..msg .. \"\\n\" .. debug.traceback())\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Codes --------------------------------------------------------------------\nlocal sqlconstants = {} -- SQLITE_* and OPEN_* declarations.\nlocal codes = {\n   [0] = \"OK\", \"ERROR\", \"INTERNAL\", \"PERM\", \"ABORT\", \"BUSY\", \"LOCKED\", \"NOMEM\",\n   \"READONLY\", \"INTERRUPT\", \"IOERR\", \"CORRUPT\", \"NOTFOUND\", \"FULL\", \"CANTOPEN\",\n   \"PROTOCOL\", \"EMPTY\", \"SCHEMA\", \"TOOBIG\", \"CONSTRAINT\", \"MISMATCH\", \"MISUSE\",\n   \"NOLFS\", \"AUTH\", \"FORMAT\", \"RANGE\", \"NOTADB\", [100] = \"ROW\", [101] = \"DONE\"\n} -- From 0 to 26.\n\ndo\n   local types = { \"INTEGER\", \"FLOAT\", \"TEXT\", \"BLOB\", \"NULL\" } -- From 1 to 5.\n\n   local opens = {\n     READONLY =        0x00000001;\n     READWRITE =       0x00000002;\n     CREATE =          0x00000004;\n     DELETEONCLOSE =   0x00000008;\n     EXCLUSIVE =       0x00000010;\n     AUTOPROXY =       0x00000020;\n     URI =             0x00000040;\n     MAIN_DB =         0x00000100;\n     TEMP_DB =         0x00000200;\n     TRANSIENT_DB =    0x00000400;\n     MAIN_JOURNAL =    0x00000800;\n     TEMP_JOURNAL =    0x00001000;\n     SUBJOURNAL =      0x00002000;\n     MASTER_JOURNAL =  0x00004000;\n     NOMUTEX =         0x00008000;\n     FULLMUTEX =       0x00010000;\n     SHAREDCACHE =     0x00020000;\n     PRIVATECACHE =    0x00040000;\n     WAL =             0x00080000;\n   }\n\n   local t = sqlconstants\n   local pre = \"static const int32_t SQLITE_\"\n   for i=0,26    do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n   for i=100,101 do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n   for i=1,5     do t[#t+1] = pre..types[i]..\"=\"..i..\";\\n\" end\n   pre = pre..\"OPEN_\"\n   for k,v in pairs(opens) do\n      t[#t+1] = pre..k..\"=\"..bit.tobit(v)..\";\\n\"\n   end\nend\n\n-- Cdef ---------------------------------------------------------------------\n-- SQLITE_*, OPEN_*\n\nffi.cdef(table.concat(sqlconstants))\n\n\n\n\n\n\n\nffi.cdef  [[\n\n// Typedefs.\ntypedef struct sqlite3 sqlite3;\ntypedef struct sqlite3_stmt sqlite3_stmt;\ntypedef void (*sqlite3_destructor_type)(void*);\ntypedef struct sqlite3_context sqlite3_context;\ntypedef struct Mem sqlite3_value;\n\n// Get informative error message.\nconst char *sqlite3_errmsg(sqlite3*);\n\n// Connection.\nint sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags,\n const char *zVfs);\nint sqlite3_close(sqlite3*);\nint sqlite3_busy_timeout(sqlite3*, int ms);\n\n// Statement.\nint sqlite3_prepare_v2(sqlite3 *conn, const char *zSql, int nByte,\n                       sqlite3_stmt **ppStmt, const char **pzTail);\nint sqlite3_step(sqlite3_stmt*);\nint sqlite3_reset(sqlite3_stmt *pStmt);\nint sqlite3_finalize(sqlite3_stmt *pStmt);\n\n// Extra functions for SELECT.\nint sqlite3_column_count(sqlite3_stmt *pStmt);\nconst char *sqlite3_column_name(sqlite3_stmt*, int N);\nint sqlite3_column_type(sqlite3_stmt*, int iCol);\n\n// Get value from SELECT.\nint64_t sqlite3_column_int64(sqlite3_stmt*, int iCol);\ndouble sqlite3_column_double(sqlite3_stmt*, int iCol);\nint sqlite3_column_bytes(sqlite3_stmt*, int iCol);\nconst unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\nconst void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\n\n// Set value in bind.\nint sqlite3_bind_int64(sqlite3_stmt*, int, int64_t);\nint sqlite3_bind_double(sqlite3_stmt*, int, double);\nint sqlite3_bind_null(sqlite3_stmt*, int);\nint sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));\nint sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\n\nint sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *name);\nconst char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\nint sqlite3_bind_parameter_count(sqlite3_stmt*);\n\n// Clear bindings.\nint sqlite3_clear_bindings(sqlite3_stmt*);\n\n// Get value in callbacks.\nint sqlite3_value_type(sqlite3_value*);\nint64_t sqlite3_value_int64(sqlite3_value*);\ndouble sqlite3_value_double(sqlite3_value*);\nint sqlite3_value_bytes(sqlite3_value*);\nconst unsigned char *sqlite3_value_text(sqlite3_value*); //Not used.\nconst void *sqlite3_value_blob(sqlite3_value*);\n\n// Set value in callbacks.\nvoid sqlite3_result_error(sqlite3_context*, const char*, int);\nvoid sqlite3_result_int64(sqlite3_context*, int64_t);\nvoid sqlite3_result_double(sqlite3_context*, double);\nvoid sqlite3_result_null(sqlite3_context*);\nvoid sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\nvoid sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\n\n// Persistency of data in callbacks (here just a pointer for tagging).\nvoid *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\n\n// Typedefs for callbacks.\ntypedef void (*ljsqlite3_cbstep)(sqlite3_context*,int,sqlite3_value**);\ntypedef void (*ljsqlite3_cbfinal)(sqlite3_context*);\n\n// Posix/libc sleep function, for non-blocking waits outside of event loops\nunsigned int sleep(unsigned int seconds);\n\nint usleep(int useconds); //pass in microseconds\n\n// Register callbacks.\nint sqlite3_create_function(\n    sqlite3 *conn,\n    const char *zFunctionName,\n    int nArg,\n    int eTextRep,\n    void *pApp,\n    void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n    void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n    void (*xFinal)(sqlite3_context*)\n);\n]]\n\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\n\nlocal transient = ffi.cast(\"sqlite3_destructor_type\", -1)\nlocal int64_ct = ffi.typeof(\"int64_t\")\n\nlocal blob_mt = {} -- For tagging only.\n\nlocal function blob(str)\n return setmetatable({ str }, blob_mt)\nend\n\nlocal connstmt = {} -- Statements for a conn.\nlocal conncb = {} -- Callbacks for a conn.\nlocal aggregatestate = {} -- Aggregate states.\n\nlocal stmt_step\n\nlocal stmt_mt, stmt_ct = {}\nstmt_mt.__index = stmt_mt\n\nlocal conn_mt, conn_ct = {}\nconn_mt.__index = conn_mt\n\n-- Checks ----------------------------------------------------------------------\n\n-- Helper function to get error msg and code from sqlite.\nlocal function codemsg(pconn, code)\n   return codes[code]:lower(), ffi.string(ffi.C.sqlite3_errmsg(pconn))\nend\n\n-- Throw error for a given connection.\nlocal function E_conn(pconn, code)\n   local code, msg = codemsg(pconn, code)\n   err(code, msg)\nend\n\n-- Test code is OK or throw error for a given connection.\nlocal function T_okcode(pconn, code)\n   if code ~= ffi.C.SQLITE_OK then\n      E_conn(pconn, code)\n   end\nend\n\nlocal function T_open(x)\n   if x._closed then\n      err(\"misuse\", \"object is closed\")\n   end\nend\n\n-- Getters / Setters to minimize code duplication ------------------------------\nlocal sql_get_code = [=[\nreturn function(stmt_or_value <opt_i>)\n local t = ffi.C.sqlite3_<variant>_type(stmt_or_value <opt_i>)\n if t == ffi.C.SQLITE_INTEGER then\n   return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>)\n elseif t == ffi.C.SQLITE_FLOAT then\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>)\n elseif t == ffi.C.SQLITE_TEXT then\n   local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n   return ffi.string(ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>), nb)\n elseif t == ffi.C.SQLITE_BLOB then\n   local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n   return ffi.string(ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>), nb)\n elseif t == ffi.C.SQLITE_NULL then\n   return nil\n else\n   err(\"constraint\", \"unexpected SQLite3 type\")\n end\nend\n]=]\n\nlocal sql_set_code = [=[\nreturn function(stmt_or_value, v <opt_i>)\n local t = type(v)\n if t == \"table\" then\n    --  Convert on a __todb metamethod\n    local t_M = getmetatable(v)\n    local method = t_M and t_M.__todb\n    if method then\n       v = method(v)\n       t = \"string\"\n    end\n end\n if ffi.istype(int64_ct, v) then\n   return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>, v)\n elseif t == \"number\" then\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, v)\n elseif t == \"string\" then\n   return ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>, v, #v,\n     transient)\n elseif t == \"table\" and getmetatable(v) == blob_mt then\n   v = v[1]\n   return ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>, v, #v,\n     transient)\n elseif t == \"boolean\" then\n   local bool_num = v and 1 or 0\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, bool_num)\n elseif t == \"nil\" then\n   return ffi.C.sqlite3_<variant>_null(stmt_or_value <opt_i>)\n else\n   err(\"constraint\", \"unexpected Lua type \" .. t)\n end\nend\n]=]\n\n-- Environment for setters/getters.\nlocal sql_env = {\n   sql          = sql,\n   transient    = transient,\n   ffi          = ffi,\n   int64_ct     = int64_ct,\n   blob_mt      = blob_mt,\n   getmetatable = getmetatable,\n   err          = err,\n   type         = type,\n   tostring     = tostring\n}\n\nlocal function sql_format(s, variant, index)\n   return s:gsub(\"<variant>\", variant):gsub(\"<opt_i>\", index)\nend\n\nlocal function loadcode(s, env)\n   local ret = assert(loadstring(s))\n   if env then setfenv(ret, env) end\n   return ret()\nend\n\n-- Must always be called from *:_* function due to error level 4.\nlocal get_column = loadcode(sql_format(sql_get_code, \"column\", \",i\"),   sql_env)\nlocal get_value  = loadcode(sql_format(sql_get_code, \"value\" , \"  \"),   sql_env)\nlocal set_column = loadcode(sql_format(sql_set_code, \"bind\"  , \",i\"),   sql_env)\nlocal set_value  = loadcode(sql_format(sql_set_code, \"result\", \"  \"),   sql_env)\n\n-- Connection ------------------------------------------------------------------\nlocal open_modes = {\n   ro = ffi.C.SQLITE_OPEN_READONLY,\n   rw = ffi.C.SQLITE_OPEN_READWRITE,\n   rwc = bit.bor(ffi.C.SQLITE_OPEN_READWRITE, ffi.C.SQLITE_OPEN_CREATE)\n}\n\nlocal conn_map = setmetatable({}, { __mode = \'kv\' })\n\nlocal function open(str, mode)\n   mode = mode or \"rwc\"\n   mode = open_modes[mode]\n   if not mode then\n      err(\"constraint\", \"argument #2 to open must be ro, rw, or rwc\")\n   end\n   local aptr = ffi.new(\"sqlite3*[1]\")\n   -- Usually aptr is set even if error code, so conn always needs to be closed.\n   local code = ffi.C.sqlite3_open_v2(str, aptr, mode, nil)\n   local conn = conn_ct(aptr[0], false)\n   -- Must create this anyway due to conn:close() function.\n   connstmt[conn] = setmetatable({}, { __mode = \"k\" })\n   conncb[conn] = { scalar = {}, step = {}, final = {} }\n   if code ~= ffi.C.SQLITE_OK then\n      local code, msg = codemsg(conn._ptr, code) -- Before closing!\n      conn:close() -- Free resources, should not fail here in this case!\n      err(code, msg)\n   end\n   conn_map[conn] = str\n   return conn\nend\n\nfunction conn_mt:close() T_open(self)\n  -- Close all stmt linked to conn.\n   for k,_ in pairs(connstmt[self]) do if not k._closed then k:close() end end\n    -- Close all callbacks linked to conn.\n   for _,v in pairs(conncb[self].scalar) do v:free() end\n   for _,v in pairs(conncb[self].step)   do v:free() end\n   for _,v in pairs(conncb[self].final)  do v:free() end\n   local code = ffi.C.sqlite3_close(self._ptr)\n   T_okcode(self._ptr, code)\n   connstmt[self] = nil -- Table connstmt is not weak, need to clear manually.\n   conncb[self] = nil\n   self._closed = true -- Set only if close succeded.\nend\n\nfunction conn_mt:__gc()\n   if not self._closed then self:close() end\nend\n\nfunction conn_mt:prepare(stmtstr)\n   local aptr = ffi.new(\"sqlite3_stmt*[1]\")\n   -- If error code aptr NULL, so no need to close anything.\n   local code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n   if (code == ffi.C.SQLITE_BUSY or code == ffi.C.SQLITE_LOCKED) then\n      -- are we in a coro loop?\n      local thread, main = coroutine.running()\n      local async = (not main) and uv.loop_alive()\n      if not async then\n         local retrying = true\n         local count = 1\n         while retrying do\n             -- sleep 0.2 seconds (200000) microseconds\n             ffi.C.usleep(200000)\n             code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n             if code == ffi.C.SQLITE_OK or count >= 100 then\n               retrying = false\n             end\n             count = count + 1\n         end\n      else\n         -- async retry\n         local idle = uv.new_idle()\n         idle:start(function()\n            code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n            if code == ffi.C.SQLITE_OK then\n               -- resume the thread\n               local stmt = stmt_ct(aptr[0], false, self._ptr, code)\n               connstmt[self][stmt] = true\n               idle:stop()\n               coroutine.resume(thread, stmt)\n            elseif not (code == ffi.C.SQLITE_BUSY\n                        or code == ffi.C.SQLITE_LOCKED) then\n               idle:stop()\n               T_okcode(self._ptr, code)\n            end\n            return nil\n         end)\n         return coroutine.yield()\n      end\n   end\n   T_okcode(self._ptr, code)\n   local stmt = stmt_ct(aptr[0], false, self._ptr, code)\n   connstmt[self][stmt] = true\n   return stmt\nend\n\n-- Connection exec, __call, rowexec --------------------------------------------\nfunction conn_mt:exec(commands, get) T_open(self)\n   get = get or \'ihk\'\n   local cmd1 = split(commands, \";\")\n   local res, n\n   for i=1,#cmd1 do\n      local cmd = trim(cmd1[i])\n      if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         res, n = stmt:resultset(get)\n         stmt:close()\n      end\n   end\n   return res, n -- Only last record is returned.\nend\n\nfunction conn_mt:rowexec(command) T_open(self)\n   local stmt = self:prepare(command)\n   local res = stmt:_step()\n   if stmt:_step() then\n      err(\"misuse\", \"multiple records returned, 1 expected\")\n   end\n   stmt:close()\n   if res then\n      return unpack(res)\n   else\n      return nil\n   end\nend\n\nfunction conn_mt:__call(commands, out) T_open(self)\n   out = out or print\n   local cmd1 = split(commands, \";\")\n   for c=1,#cmd1 do\n      local cmd = trim(cmd1[c])\n      if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         local ret, n = stmt:resultset(\'hik\')\n         if ret then -- All the results get handled, not only last one.\n            out(unpack(ret[0])) -- Headers are printed.\n            for i=1,n do\n               local o = {}\n               for j=1,#ret[0] do\n                  local v = ret[j][i]\n                  -- Empty strings for NULLs\n                  if type(v) == \"nil\" then v = \"\" end\n                  o[#o+1] = tostring(v)\n               end\n               out(unpack(o))\n            end\n         end\n         stmt:close()\n      end\n   end\nend\n\n-- Callbacks -------------------------------------------------------------------\n-- Update (one of) callbacks registry for sqlite functions.\nlocal function updatecb(self, where, name, f)\n   local cbs = conncb[self][where]\n   if cbs[name] then -- Callback already present, free old one.\n      cbs[name]:free()\n   end\n   cbs[name] = f -- Could be nil and that\'s fine.\nend\n\n-- Return manually casted callback that sqlite expects, scalar.\nlocal function scalarcb(name, f)\n   local values = {} -- Conversion buffer.\n   local function sqlf(context, nvalues, pvalues)\n      -- Indexing 0,N-1.\n      for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n      -- Throw error via sqlite function if necessary.\n      local ok, result = pcall(f, unpack(values, 1, nvalues))\n      if not ok then\n         local msg = \"Lua registered scalar function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      else\n         set_value(context, result)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\nend\n\n-- Return the state for aggregate case (created via initstate()). We use the ptr\n-- returned from aggregate_context() for tagging only, all the state data is\n-- handled from Lua side.\nlocal function getstate(context, initstate, size)\n   -- Only pointer address relevant for indexing, size irrelevant.\n   local ptr = ffi.C.sqlite3_aggregate_context(context, size)\n   local pid = tonumber(ffi.cast(\"intptr_t\",ptr))\n   local state = aggregatestate[pid]\n   if type(state) == \"nil\" then\n      state = initstate()\n      aggregatestate[pid] = state\n   end\n   return state, pid\nend\n\n-- Return manually casted callback that sqlite expects, stepper for aggregate.\nlocal function stepcb(name, f, initstate)\n   local values = {} -- Conversion buffer.\n   local function sqlf(context, nvalues, pvalues)\n      -- Indexing 0,N-1.\n      for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n      local state = getstate(context, initstate, 1)\n      -- Throw error via sqlite function if necessary.\n      local ok, result = pcall(f, state, unpack(values, 1, nvalues))\n      if not ok then\n         local msg = \"Lua registered step function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\nend\n\n-- Return manually casted callback that sqlite expects, finalizer for aggregate.\nlocal function finalcb(name, f, initstate)\n   local function sqlf(context)\n      local state, pid = getstate(context, initstate, 0)\n      aggregatestate[pid] = nil -- Clear the state.\n      local ok, result = pcall(f, state)\n      -- Throw error via sqlite function if necessary.\n      if not ok then\n         local msg = \"Lua registered final function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      else\n         set_value(context, result)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbfinal\", sqlf)\nend\n\nfunction conn_mt:setscalar(name, f) T_open(self)\n   jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n   local cbf = f and scalarcb(name, f) or nil\n   local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n      cbf, nil, nil) -- If cbf nil this clears the function is sqlite.\n   T_okcode(self._ptr, code)\n   updatecb(self, \"scalar\", name, cbf) -- Update and clear old.\nend\n\nfunction conn_mt:setaggregate(name, initstate, step, final) T_open(self)\n   jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n   local cbs = step  and stepcb (name, step,  initstate) or nil\n   local cbf = final and finalcb(name, final, initstate) or nil\n   local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n      nil, cbs, cbf) -- If cbs, cbf nil this clears the function is sqlite.\n   T_okcode(self._ptr, code)\n   updatecb(self, \"step\", name, cbs) -- Update and clear old.\n   updatecb(self, \"final\", name, cbf) -- Update and clear old.\nend\n\nconn_ct = ffi.metatype(\"struct { sqlite3* _ptr; bool _closed; }\", conn_mt)\n\n-- Statement -------------------------------------------------------------------\nfunction stmt_mt:reset() T_open(self)\n   -- Ignore possible error code, it would be repetition of error raised during\n   -- most recent evaluation of statement which would have been raised already.\n   ffi.C.sqlite3_reset(self._ptr)\n   self._code = ffi.C.SQLITE_OK -- Always succeds.\n   return self\nend\n\nfunction stmt_mt:close() T_open(self)\n   -- Ignore possible error code, it would be repetition of error raised during\n   -- most recent evaluation of statement which would have been raised already.\n   ffi.C.sqlite3_finalize(self._ptr)\n   self._code = ffi.C.SQLITE_OK -- Always succeds.\n   self._closed = true -- Must be called exaclty once.\nend\n\nfunction stmt_mt:__gc()\n   if not self._closed then self:close() end\nend\n\n-- Statement step, resultset ---------------------------------------------------\nfunction stmt_mt:_ncol()\n   return ffi.C.sqlite3_column_count(self._ptr)\nend\n\nfunction stmt_mt:_header(h)\n   for i=1,self:_ncol() do -- Here indexing 0,N-1.\n      h[i] = ffi.string(ffi.C.sqlite3_column_name(self._ptr, i - 1))\n   end\nend\n\nlocal function _retry(action, self, row, header)\n   -- blocking first\n   local retrying = true\n   local count = 1\n   while retrying do\n      -- 0.2 seconds\n      ffi.C.usleep(200000)\n      local row, header = action(self, row, header)\n      if row ~= false then\n         return row, header\n      end\n      count = count + 1\n      if not (self._code == ffi.C.SQLITE_BUSY\n              or self._code == ffi.C.SQLITE_LOCKED) then\n         E_conn(self._conn, self._code)\n      end\n      if count >= 100 then\n         retrying = false\n      end\n   end\n   E_conn(self._conn, self._code)\nend\n\nlocal function _stepGen(action)\n   return function(self, row, header)\n      local row, header = action(self, row, header)\n      if row ~= false then\n         return row, header\n      end\n      if self._code == ffi.C.SQLITE_BUSY\n         or self._code == ffi.C.SQLITE_LOCKED then\n         -- retries are stubbed out because untested\n         E_conn(self._conn, self._code)\n         -- _retry(action, self, row, header)\n      else  -- Other codes are errors we can\'t recover from.\n         E_conn(self._conn, self._code)\n      end\n   end\nend\n\nlocal function step_action(self, row, header)\n   -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n   if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n   self._code = ffi.C.sqlite3_step(self._ptr)\n   if self._code == ffi.C.SQLITE_ROW then\n      -- All the sql.* functions called never errors here.\n      row = row or {}\n      for i=1,self:_ncol() do\n         row[i] = get_column(self._ptr, i - 1)\n      end\n      if header then self:_header(header) end\n      return row, header\n   elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now.\n      return nil\n   else\n      return false\n   end\nend\n\nstmt_step = _stepGen(step_action)\n\nstmt_mt._step = stmt_step\n\nlocal function stepkv_action(self, row, header)\n   -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n   if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n   self._code = ffi.C.sqlite3_step(self._ptr)\n   if self._code == ffi.C.SQLITE_ROW then\n      row = row or {}\n      for i = 0, self:_ncol() - 1 do\n         local col = ffi.string(ffi.C.sqlite3_column_name(self._ptr, i))\n         row[col] = get_column(self._ptr, i)\n      end\n      if header then self:_header(header) end\n      return row, header\n   elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now.\n      return nil\n   else\n      return false\n   end\nend\n\nstmt_mt.stepkv = _stepGen(stepkv_action)\n\nfunction stmt_mt:step(row, header) T_open(self)\n   return self:_step(row, header)\nend\n\n\n-- iterator for rows\nfunction stmt_mt:irows(maxrecords) T_open(self)\n   maxrecords = maxrecords or math.huge\n   if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n       err(\"constraint\", \"argument #2 to resultset must be >= 1\")\n   end\n   local n = 1\n   return function()\n       if n > maxrecords then return nil end\n       local row = self:step()\n       if row then\n         return row\n       else\n         self:clearbind():reset()\n         return nil\n       end\n   end\nend\n\nfunction stmt_mt:resultset(get, maxrecords) T_open(self)\n   get = get or \"k\"\n   maxrecords = maxrecords or math.huge\n   if maxrecords < 1 then\n      err(\"constraint\", \"argument #2 to resultset must be >= 1\")\n   end\n   local hash, hasi, hask = get:find(\"h\"), get:find(\"i\"), get:find(\"k\")\n   local r, h = self:_step({}, {})\n   if not r then return nil, 0 end -- No records case.\n   -- First record, o is a temporary table used to get records.\n   local o = hash and { [0] = h } or {}\n   for i=1,#h do o[i] = { r[i] } end\n   -- Other records.\n   local n = 1\n   while n < maxrecords and self:_step(r) do\n      n = n + 1\n      for i=1,#h do o[i][n] = r[i] end\n   end\n\n   local out = { [0] = o[0] } -- Eventually copy colnames.\n   if hasi then -- Use numeric indexes.\n      for i=1,#h do out[i] = o[i] end\n   end\n   if hask then -- Use colnames indexes.\n      for i=1,#h do out[h[i]] = o[i] end\n   end\n   return out, n\nend\n\n   function stmt_mt:rows(maxrecords) T_open(self)\n      maxrecords = maxrecords or math.huge\n      if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n         err(\"constraint\", \"argument to rows must be >= 1\")\n      end\n      local n = 1\n      return function()\n         if n > maxrecords then return nil end\n         local r = self:stepkv()\n         if r then\n            n = n + 1\n            return r\n         else\n            self:clearbind():reset()\n            return nil\n         end\n      end\n   end\n\n   function stmt_mt:cols(maxrecords) T_open(self)\n      maxrecords = maxrecords or math.huge\n      if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n         err(\"constraint\", \"argument to cols must be >= 1\")\n      end\n      local row, ncol, n = {}, self:_ncol(), 0\n      return function()\n         if n >= maxrecords then return nil end\n         -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n         if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n         -- reset container\n         for i = 1, ncol do\n            row[i] = nil\n         end\n         self._code = ffi.C.sqlite3_step(self._ptr)\n         if self._code == ffi.C.SQLITE_ROW then\n            n = n + 1\n            for i = 1, ncol do\n               row[i] = get_column(self._ptr, i - 1)\n            end\n            return n, unpack(row, 1, ncol)\n         elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now\n            self:clearbind():reset()\n            return nil\n         else -- If code not DONE or ROW then it\'s error.\n            E_conn(self._conn, self._code)\n         end\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction stmt_mt:value() T_open(self)\n   local result, val = self:_step(), nil\n   if result then\n      val = result[1]\n   end\n   self:clearbind():reset()\n   return val\nend\n\n\n\n\n\n\n\n\nfunction stmt_mt:row() T_open(self)\n   local row, header = self:stepkv()\n   self :clearbind() :reset()\n   return row, header\nend\n\n\n\n-- Statement bind --------------------------------------------------------------\nfunction stmt_mt:_bind1(i, v)\n  local code = set_column(self._ptr, v, i) -- Here indexing 1,N.\n  T_okcode(self._conn, code)\n  return self\nend\n\nfunction stmt_mt:bind1(i, v) T_open(self)\n  return self:_bind1(i, v)\nend\n\nfunction stmt_mt:bind(...) T_open(self)\n  for i=1,select(\"#\", ...) do self:_bind1(i, select(i, ...)) end\n  return self\nend\n\nfunction stmt_mt:bindkv(t) T_open(self)\n   local ncol = ffi.C.sqlite3_bind_parameter_count(self._ptr)\n   for i = 1, ncol do\n      local param = ffi.C.sqlite3_bind_parameter_name(self._ptr, i)\n      -- params of form :NNN eg :123 can have holes, so we check for NULL:\n      if param ~= nil then\n         param = ffi.string(param):sub(2)\n         if t[param] then\n            self:_bind1(i, t[param])\n         end\n      end\n   end\n   return self\nend\n\nfunction stmt_mt:clearbind() T_open(self)\n  local code = ffi.C.sqlite3_clear_bindings(self._ptr)\n  T_okcode(self._conn, code)\n  return self\nend\n\nstmt_ct = ffi.metatype([[struct {\n  sqlite3_stmt* _ptr;\n  bool          _closed;\n  sqlite3*      _conn;\n  int32_t       _code;\n}]], stmt_mt)\n\n\n\n   sqlayer.open = open\n   sqlayer.blob = blob\n\n\n\n\n\n\n\n\n\n\n   local pcall = assert (pcall)\n   local gsub = assert(string.gsub)\n   local format = assert(string.format)\n\n\n\n\n\n\n\n\n  function sqlayer.conn_path(conn)\n     return conn_map[conn]\n  end\n\n\n\n\n\n\n\n\nlocal istype = assert(ffi.istype)\n\nfunction sqlayer.isconn(conn)\n   return istype(conn_ct, conn)\nend\n\n\n\n\n\n\n\n   local function san(str)\n      return gsub(str, \"\'\", \"\'\'\")\n   end\n\n   sqlayer.san = san\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.format(str, ...)\n      local argv = {...}\n      str = gsub(str, \"%%s\", \"\'%%s\'\"):gsub(\"\'\'%%s\'\'\", \"\'%%s\'\")\n      for i, v in ipairs(argv) do\n         if type(v) == \"string\" then\n            argv[i] = san(v)\n         elseif type(v) == \"cdata\" then\n            -- assume this is a number of some kind\n            argv[i] = tonumber(v)\n         else\n            argv[i] = v\n         end\n      end\n      local success, ret = pcall(format, str, unpack(argv))\n      if success then\n         return ret\n      else\n         return success, ret\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.pexec(conn, stmt, col_str)\n      -- conn:exec(stmt)\n      col_str = col_str or \"hik\"\n      local success, result, nrow = pcall(conn.exec, conn, stmt, col_str)\n      if success then\n         return result, nrow\n      else\n         return false, result\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.lastRowId(conn)\n      local result = conn:rowexec \"SELECT CAST(last_insert_rowid() AS REAL)\"\n      return result\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.unwrapKey(result_set)\n   if result_set and result_set[1] and result_set[1][1] then\n      local id = result_set[1][1]\n      if type(id) == \"cdata\" then\n         return tonumber(id)\n      else\n         return id\n      end\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.toRow(sql_result, num)\n   if not sql_result then return nil end\n   local one_result = false\n   local result_tab = {}\n   if not num then\n      num = 1\n      one_result = true\n   end\n   assert(type(num) == \"number\")\n   for key, column in pairs(sql_result) do\n      if type(key) == \"string\" then\n         for i = 1, num do\n            local v = type(column[i]) == \"cdata\"\n                      and tonumber(column[i])\n                      or column[i]\n            result_tab[i] = result_tab[i] or {}\n            result_tab[i][key] = v\n         end\n      end\n   end\n   if one_result then\n      return result_tab[1]\n   else\n      return result_tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migrate(conn, migration, s, ...)\n   if type(migration) == \'function\' then\n      migration(conn, s, ...)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            s:verb(step)\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, s, ...)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nlocal format = assert(string.format)\nlocal open = assert(open)\n\nfunction sqlayer.boot(conn, migrations, ...)\n   conn = type(conn) == \'string\' and open(conn, \'rwc\') or conn\n   -- bail early with no migrations\n   if not migrations then return conn end\n   local version = #migrations\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      local s = require \"status:status\" (io.stdout, io.stderr)\n      s.verbose = true -- probably not the correct default\n      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         s:chat(\"Performing migration %d\", i)\n         migrate(conn, migrations[i], s, ...)\n      end\n      conn:exec \"COMMIT;\"\n      s:chat \"Cleaning up...\"\n      conn:exec \"VACUUM;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n      s:chat(\"Migrations completed, your version is %d\", version)\n   elseif user_version > version then\n      error(format(\"Error: database version is %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local pragma_pre = \"PRAGMA \"\n\n   -- Builds and returns a pragma string\n   local function __pragma(prag, value)\n      local val\n      if value == nil then\n         return pragma_pre .. prag .. \";\"\n      end\n      if type(value) == \"boolean\" then\n         val = value and \" = 1\" or \" = 0\"\n      elseif type(value) == \"string\" then\n         val = \"(\'\" .. san(value) .. \"\')\"\n      elseif type(value) == \"number\" then\n         val = \" = \" .. tostring(value)\n      else\n         error(\"illegal value of type \"\n               .. type(value) .. \", \"\n               .. tostring(value))\n      end\n      return pragma_pre .. prag .. val .. \";\"\n   end\n\n   -- Sets a pragma and checks its new value\n   local function _prag_set(conn, prag)\n      return function(value)\n         local prag_str = __pragma(prag, value)\n         conn:exec(prag_str)\n         -- cast booleans results to Lua booleans,\n         -- otherwise return the (string) result\n         local answer = conn:exec(pragma_pre .. prag .. \";\", \"i\")\n         if answer[1] and answer[1][1] then\n            if answer[1][1] == 1 then\n               return true\n            elseif answer[1][1] == 0 then\n               return false\n            else\n               return answer[1][1]\n            end\n         end\n      end\n   end\n\n\n\n\n\n\n   local function new_conn_index(conn, key)\n      local function _prag_index(_, prag)\n         return _prag_set(conn, prag)\n      end\n      if key == \"pragma\" then\n         return setmetatable({}, {__index = _prag_index})\n      else\n         return conn_mt[key]\n      end\n   end\n\n   conn_mt.__index = new_conn_index\n\n\n\n\n\n\n\n\n\n  local close = conn_mt.close\n\n  function conn_mt.pclose(conn)\n     local uv = require \"luv\"\n     local loop_alive = uv.loop_alive()\n     local close_idler = uv.new_idle()\n     close_idler:start(function()\n       local success = pcall(close, conn)\n       if not success then\n         return nil\n       else\n         close_idler:stop()\n       end\n     end)\n     if not loop_alive then\n        uv.run \'default\'\n     end\n  end\n\n\n\n\n\n\n\n\n\n\n\nlocal _sql = sqlayer\npackage.preload.sql = function() return _sql end\n\n\n\n\n\n\njit.on()\nend\nsql = sqlayer\nsqlayer = nil\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "sql",
branch = "voltron-table",
},
  { 
hash = "032c441fd38b660a78e17ea7466109f3a447384f0d66215d331a1eef99f67629",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\nlocal new_modules = false\n\n\n\n\n\n\n\n\n\n\n\n\nlocal stmts = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nstmts.create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY,\n   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,\n   repo STRING,\n   repo_type STRING DEFAULT \'git\',\n   repo_alternates STRING,\n   home STRING,\n   website STRING\n);\n]]\n\n\n\n\nstmts.create_version_table = [[\nCREATE TABLE IF NOT EXISTS version (\n   version_id INTEGER PRIMARY KEY,\n   stage STRING DEFAULT \'SNAPSHOT\' COLLATE NOCASE,\n   edition STRING default \'\',\n   special STRING DEFAULT \'no\' COLLATE NOCASE,\n   major INTEGER DEFAULT 0,\n   minor INTEGER DEFAULT 0,\n   patch INTEGER DEFAULT 0,\n   project INTEGER NOT NULL,\n   UNIQUE (project, stage, edition, special, major, minor, patch)\n      ON CONFLICT IGNORE,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\nstmts.create_bundle_table = [[\nCREATE TABLE IF NOT EXISTS bundle (\n   bundle_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n);\n]]\n\n\n\n\nstmts.create_code_table = [[\nCREATE TABLE IF NOT EXISTS code (\n   code_id INTEGER PRIMARY KEY,\n   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,\n   binary BLOB NOT NULL\n);\n]]\n\n\n\n\nstmts.create_module_table = [[\nCREATE TABLE IF NOT EXISTS module (\n   module_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   name STRING NOT NULL,\n   type STRING DEFAULT \'luaJIT-2.1-bytecode\',\n   branch STRING,\n   vc_hash STRING,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   bundle INTEGER,\n   code INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE RESTRICT\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n   FOREIGN KEY (bundle)\n      REFERENCES bundle (bundle_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (code)\n      REFERENCES code (code_id)\n);\n]]\n\n\n\n\n\n\n\nstmts.create_module_table_index = [[\nCREATE INDEX IF NOT EXISTS module_time_idx ON module (time DESC, name);\n]]\n\n\n\n\nstmts.create_voltron_table = [[\nCREATE TABLE IF NOT EXISTS voltron (\n   voltron_id INTEGER PRIMARY KEY,\n   voltron LUATEXT NOT NULL,\n   name TEXT NOT NULL,\n   project INTEGER,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   active INTEGER NOT NULL DEFAULT 1 CHECK (active = 0 or active = 1),\n   -- add version in a real migration\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new_modules_db(conn_home)\n   local yes, conn;\n   if type(conn_home) == \'string\' then\n      yes, conn = pcall(sql.open, conn_home, \'rwc\')\n      if not yes then\n         error(\"Could not create \" .. conn_home\n               .. \", consider creating the directory or setting\"\n               .. \" $BRIDGE_MODULES.\")\n      end\n   end\n   if conn then\n      conn:exec(stmts.create_project_table)\n      conn:exec(stmts.create_version_table)\n      conn:exec(stmts.create_bundle_table)\n      conn:exec(stmts.create_code_table)\n      conn:exec(stmts.create_module_table)\n      conn:exec(stmts.create_module_table_index)\n      conn:exect(stmts.create_voltron_table)\n   end\n\n   return conn\nend\n\n_Bridge.new_modules_db = new_modules_db\n\nif not _Bridge.modules_conn then\n   _Bridge.modules_conn = new_modules_db(_Bridge.bridge_modules_home)\n   new_modules = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   setfenv(bundles, {})\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n_Bridge.import = import\n\n\n\n\n\n\n\n\nif new_modules then\n   print \"importing modules bundle\"\n   import(\"all_modules.bundle\")\nend\n\n\n\n\n\n\nlocal check_voltron = [[\nSELECT name\nFROM sqlite_master\nWHERE type = \'table\' AND name = \'voltron\'\n;\n]]\n\nlocal get_voltron_names = [[\nSELECT name FROM voltron WHERE active = 1;\n]]\n\n\n\n\nlocal conn = _Bridge.modules_conn\n\nlocal has_voltron = conn:prepare(check_voltron) :value()\n\nif not has_voltron then\n   conn:exec(stmts.create_module_table_index)\n   conn:exec(stmts.create_voltron_table)\n   _Bridge.volts = {}\nelse\n   local volts = {}\n   for i, name in conn:prepare(get_voltron_names) :cols() do\n      volts[name] = true\n   end\n   _Bridge.volts = volts\nend\n\n\n\n\n\n\nend\n\n",
vc_hash = "51a7c3f4e8750df0b34b61ae807ebb6054d695ed\n",
name = "modules",
branch = "voltron-table",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/core.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "qor",
    repo = "git@gitlab.com:special-circumstance/core.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "f58508da224a283c9334e3a54d24409330ee56b4d2f1f39092e09dfec99734f4",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:_base\"\nlocal iscallable = assert(_base.iscallable)\n\n\n\n\n\n\nlocal act = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __act_mth_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.borrowmethod(actor, method)\n   assert(iscallable(method) or type(method) == \'string\',\n          \"#2 for borrowmethod must be string or callable\")\n   local uid = {}\n   __act_mth_attr[uid] = actor\n   actor = nil\n   if type(method) == \'string\' then\n      -- return a lookup function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return _actor[method](_actor, ...)\n      end\n   else\n      -- return a direct-call function\n      return function(...)\n         local _actor = __act_mth_attr[uid]\n         if not _actor then\n            error \"actor has gone out of scope\"\n         end\n         return method(_actor, ...)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal __act_getter_attr = setmetatable({}, { __mode = \'kv\' })\n\nfunction act.getter(actor, slot)\n   local uid = {}\n   __act_getter_attr[uid] = actor\n   actor = nil\n   return function()\n             local _actor = __act_getter_attr[uid]\n             if not _actor then\n                error \"actor has gone out of scope\"\n             end\n             return _actor[slot]\n          end\nend\n\n\n\n\n\n\n\n\n\nlocal gmatch = assert(string.gmatch)\nlocal function dispatchmessage(actor, msg)\n   local result\n   while msg do\n      -- #todo replace this with construction-time translation to nested message?\n      if msg.sendto then\n         for prop in gmatch(msg.sendto, \"([^.]+)[.]?\") do\n            actor = actor[prop]\n         end\n      end\n      if msg.property then\n         result = pack(actor[msg.property])\n      elseif msg.call == true then\n         result = pack(actor(unpack(msg)))\n      elseif msg.call then\n         local fn = actor[msg.call]\n         if not fn then\n            -- #todo this leaves out useful information in the case of a\n            -- nested message, and also doesn\'t know how to represent the\n            -- starting/root actor. We really want to stringify the whole\n            -- chain in a meaningful way\n            error(\"attempt to call a nil function \" .. msg.call\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(unpack(msg)))\n      elseif msg.method then\n         local fn = actor[msg.method]\n         if not fn then\n            -- Similar concern as with .call, also this is annoyingly similar\n            error(\"attempt to call a nil method \" .. msg.method\n                  .. \" on \" .. tostring(msg.sendto))\n         end\n         result = pack(fn(actor, unpack(msg)))\n      else\n         error(\"Message must have one of property, call, or method: \" .. (require \"repr:repr\".ts(msg)))\n      end\n      actor = result[1]\n      msg = msg.message\n   end\n   return unpack(result)\nend\nact.dispatchmessage = dispatchmessage\n\n\n\n\n\nreturn act\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/cluster/actor",
branch = "the-big-refactor",
},
  { 
hash = "d19df2dcc1031aebb22e2ee17b675a51c1e7f2d2cf9620379c4e21ac88e81b4e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal elpatt = require \"espalier:elpatt\"\nlocal C, P, R, S = assert(L.C), assert(L.P), assert(L.R), assert(L.S)\nlocal gsub, M = assert(elpatt.gsub), assert(elpatt.M)\n\n\n\n\nlocal escape_module = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_map = {\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nlocal function _generic_escape(ch)\n   return (\"\\\\x%02x\"):format(ch:byte())\nend\n\nlocal needs_escape = M(escape_map) + (R\"\\x00\\x1f\" + P\"\\x7f\") / _generic_escape\n\nfunction escape_module.escape(str, quotes)\n   local patt = needs_escape\n   if quotes then\n      patt = S(quotes) / \"\\\\%0\" + patt\n   end\n   return gsub(str, patt)\nend\n\nfunction escape_module.escape_char(ch, quotes)\n   local escaped = escape_map[ch]\n   if escaped then\n      return escaped\n   elseif quotes and quotes:find(ch) then\n      return \"\\\\\" .. ch\n   elseif ch:find(\"%c\") then\n      return _generic_escape(ch)\n   else\n      return ch\n   end\nend\n\n\n\n\n\n\n\n\nlocal char = assert(string.char)\n\nlocal unescape_map = {}\nfor k, v in pairs(escape_map) do\n   unescape_map[v] = k\nend\n\nlocal higit = R\"09\" + R\"af\"\n\nlocal escaped_char = M(unescape_map) +\n                     (P\"\\\\\" * C(S\"\'\\\"[]\")) / 1 +\n                     (P\"\\\\x\" * C(higit * higit)) / function(hex)\n                        return char(tonumber(\"0x\" .. hex))\n                     end\n\nfunction escape_module.unescape(str)\n   return gsub(str, escaped_char)\nend\n\n\n\nreturn escape_module\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/string/escape",
branch = "the-big-refactor",
},
  { 
hash = "bc509c41590807b8fb366915ae5ecde7ed2d9f5d109c5bc7bb86eb2deccacf8b",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal _Message_fields = {\n   method  = true,\n   message = true,\n   sendto  = true,\n   call    = true,\n}\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/cluster/mold",
branch = "the-big-refactor",
},
  { 
hash = "7e64796a80b79f1e3f3924a93fa562a66218b47a73a056c2d4516062dc375b5d",
binary = "\n\n\n\n\n\n\nPrint = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\nlocal floor, max = assert(math.floor), assert(math.max)\nlocal inbounds = assert(require \"core:math\" . inbounds)\n\nlocal split_at = {}\nfor _, v in ipairs{\" \", \"-\", \"(\", \"{\", \"[\"} do\n   split_at[v] = v == \" \" and -1 or 0\nend\n\nfunction Print.breakascii(str, width)\n   if #str <= width then\n      return str, 1, #str\n   end\n   local lines = {}\n   local actual_width = 0\n   local left = 1\n   local min_width = floor(width / 2)\n   while left <= #str do\n      local min_right = left + min_width - 1\n      local max_right = left + width - 1\n      local line\n      if max_right >= #str then\n         line = str:sub(left)\n         lines[#lines + 1] = line\n         actual_width = max(actual_width, #line)\n         break\n      end\n      local split_index, offset\n      -- Check one past the max width because we might be able to\n      -- remove a trailing space\n      for i = max_right + 1, min_right, -1 do\n         offset = split_at[str:sub(i, i)]\n         -- But now we do need to check if we\'ll actually be in bounds\n         if offset and inbounds(i + offset, min_right, max_right) then\n            split_index = i\n            break\n         end\n      end\n      if not split_index then\n         -- Didn\'t find a natural breakpoint, just chop at the max width\n         split_index = max_right\n         offset = 0\n      end\n      line = str:sub(left, split_index + offset)\n      lines[#lines + 1] = line\n      actual_width = max(actual_width, #line)\n      left = split_index + 1\n   end\n   return concat(lines, \"\\n\"), #lines, actual_width\nend\n\n\n\n\nfunction Print.center(str, width)\n   local diff = width - #str\n   local lmargin, rmargin\n   if diff % 2 ~= 0 then\n      lmargin, rmargin = math.floor(diff / 2), math.floor(diff / 2) + 1\n   else\n      lmargin, rmargin = diff / 2, diff / 2\n   end\n   return  (\" \"):rep(lmargin) .. str .. (\" \"):rep(rmargin)\nend\n\n\n\n\nreturn Print\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/string/print",
branch = "the-big-refactor",
},
  { 
hash = "6a3854d3a1d0f3ed3488c615d9bea90623c6f6ac3ae4e8cb6734a9274f724766",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal s   = require \"status:status\"\ns.verbose = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function beats(roshambo, champ, loser)\n   --needs check for opposite condition,\n   --which is nilled out.\n   if roshambo._beats[loser] and\n      roshambo._beats[loser][champ] then\n      roshambo:pr \"reversal of fortune\"\n      roshambo._beats[loser] = roshambo._beats[loser] - champ\n      roshambo:pr(roshambo._beats[loser])\n   end\n   champion = roshambo._beats[champ]\n   if champion then\n      champion = champion + Set{loser}\n   else\n      champion = Set{loser}\n   end\n   roshambo._beats[champ] = champion\n   roshambo:pr(champ..\" beats \"..tostring(roshambo._beats[champ]))\nend\n\n\n\n\n\n\nlocal function duel(roshambo,champ,challenge)\n   if roshambo._duel_with then\n      roshambo:pr \"it\'s a duel!\"\n      local winner, loser = roshambo:_duel_with(champ,challenge)\n      roshambo:beats(winner,loser)\n      return winner, loser\n   else\n      roshambo:pr \"victory by fiat\"\n      roshambo:beats(champ,challenge)\n      return champ, challenge\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function duel_with(roshambo, fn)\n   roshambo._duel_with = fn\nend\n\n\n\n\n\n\n\n\nlocal function fight(roshambo, champ, challenge)\n   if roshambo._beats[champ] then\n      if roshambo._beats[champ](challenge) then\n          roshambo:pr(tostring(champ)..\" wins\")\n          return champ, challenge\n      elseif roshambo._beats[challenge] then\n         if roshambo._beats[challenge](champ) then\n            roshambo:pr(tostring(challenge)..\" wins\")\n            return challenge, champ\n         end\n      else --duel here\n         s:verb(tostring(challenge) .. \" not found\")\n         return duel(roshambo,champ,challenge)\n      end\n   else --duel here as well\n      s:verb(tostring(champ)..\" not found\")\n      return duel(roshambo, champ, challenge)\n   end\nend\n\n\n\n\n\n\n\n\nfunction roshambo_sort(roshambo, champ, challenge)\n   local victor = fight(roshambo, champ, challenge)\n   return victor == champ and true or false\nend\n\nlocal R = {}\nR.fight = fight\nR.beats = beats\nR.duel_with = duel_with\nR.sort  = roshambo_sort\n--- an alias for fight\n-- @function __call\n-- @param champ\n-- @param challenge\n-- @within metamethods\nR[\"__call\"] = fight\nR[\"__index\"] = R\nsetmetatable(R,{}) -- clu.Meta\n\n--- instantiates a roshambo\n-- @function Roshambo\n-- @param init a optional table of champ/loser key/value pairs.\n-- @return an instance of roshambo\nlocal function Roshambo(init)\n   local rosh = {}\n   rosh._beats = {}\n   if init then\n      if type(init) == \"table\" then\n         for i,v in pairs(init) do\n            rosh._beats[i] = Set{v}\n         end\n      else\n         error(\"Roshambo must be initialized with a table\")\n      end\n   end\n   setmetatable(rosh,R)\n   rosh.foo = \"bar\"\n   return rosh\nend\n\n\n\nreturn Roshambo\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/cluster/roshambo",
branch = "the-big-refactor",
},
  { 
hash = "f23d44c292b49e44bc14ec382f5cb86c35b8954d9a33dc2eca06c5720f57c057",
binary = "\n\n\n\n\n\n\n\n\n\nlocal _base = {}\n\n\n\n\n\n\n\n\n\n\nfunction _base.no_op()\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction _base.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction _base.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...), 2)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction _base.iscallable(val)\n   if type(val) == \'function\' then return true end\n   if type(val) == \'table\' then\n      local M = getmetatable(val)\n      if M and rawget(M, \"__call\") then\n         return true\n      end\n   end\n   return false\nend\n\n\n\n\n\n\n\n\n\n\nlocal newproxy = newproxy or function() return {} end\n\n\n\nfunction _base.unique()\n   return newproxy()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function lazy_load_gen(requires)\n   local name = requires[1] or \"generic codex you really should name\"\n   requires[1] = nil\n   return function(tab, key)\n      if requires[key] then\n         -- put the return on the core table\n         tab[key] = require(requires[key])\n         return tab[key]\n      else\n         error(name .. \" doesn\'t have a module \'\" .. tostring(key) .. \"\'\")\n      end\n   end\nend\n\n\n\n\n\nlocal function call_gen(requires)\n   return function(tab, env)\n      local _;\n      for k in pairs(requires) do\n         _ = tab[k]\n         if env then\n            -- assign the now cached value as a global or at least slot\n            env[k] = tab[k]\n         end\n      end\n      return tab\n   end\nend\n\n\n\n\n\nfunction _base.lazyloader(lazy_table)\n   return setmetatable({}, { __index = lazy_load_gen(lazy_table),\n                             __call  = call_gen(lazy_table) })\nend\n\n\n\nreturn _base\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/_base",
branch = "the-big-refactor",
},
  { 
hash = "f868d34e44d34823548425f0089b11ac8612f5f5b238cca9298c3173d54c0b59",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal act = require \"core:core/cluster/actor\"\n\n\n\n\n\n\nlocal cluster = {}\n\nfor k, v in pairs(act) do\n   cluster[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal isempty = table.isempty\n                or\n                function(tab)\n                   local empty = true\n                   for _, __ in next, tab, nil do\n                      empty = false\n                      break\n                   end\n                   return empty\n                end\n\nfunction cluster.meta(Meta)\n   Meta = Meta or {}\n\n   -- decoration\n   if Meta\n      and type(Meta) == \'table\'\n      and isempty(Meta) then\n\n      Meta.__index = Meta\n      return Meta\n   end\n\n   -- inheritance\n   if Meta and Meta.__index then\n      local tab = {}\n      for field, value in next, Meta, nil do\n         if sub(field, 1, 2) == \"__\" then\n            tab[field] = value\n         end\n      end\n      if Meta.__meta then\n         tab.__meta = tab.__meta or {}\n         for _, __ in next, Meta.__meta, nil do\n            tab.__meta[_] = __\n         end\n      end\n      tab.__index = tab\n      return setmetatable(tab, Meta)\n   end\n\n   error (\"cannot make metatable from type\" .. type(Meta))\nend\n\n\n\n\n\n\n\n\nlocal s;\n\nfunction cluster.Meta(Meta)\n   s = s or require \"status:status\" ()\n   local trace = debug.traceback(\"\", 2):sub(2)\n   -- clip the relevant line\n   local nl_idx = trace:find(\"\\n\")\n   trace = trace:sub(nl_idx + 1)\n   nl_idx = trace:find(\"\\n\")\n   s:warn(\"use of Meta is deprecated, use meta: %s\", trace:sub(1, nl_idx - 1))\n   return cluster.meta(Meta)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.constructor(mt, new, instance)\n   instance = instance or {}\n   if new then\n      mt.__call = new\n   elseif not mt.__call then\n      error \"nil metatable passed to constructor without __call metamethod\"\n   end\n\n   local constructor = setmetatable(instance, mt)\n   mt.idEst = constructor\n   return constructor\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\n\n\nfunction cluster.methodchain(method, key_method)\n\n   -- per-method cache of the value-caller\n   local _cache = {}\n\n   local function value__call(value_catch, value, ...)\n      method(value_catch[1], value_catch[2], value, ...)\n      value_catch[2] = nil\n      return remove(value_catch)\n   end\n\n   return function (obj, first)\n      local launch;\n\n      if key_method then\n         obj, first = key_method(obj, first)\n      end\n      if #_cache == 0 then\n         _cache[1], _cache[2] = obj, first\n         launch = _cache\n      else\n         launch = {obj, first}\n         -- we do this optimistically, figuring most method chains complete\n         -- and ones which don\'t, might not\n         _cache = launch\n      end\n      return setmetatable(launch, { __call = value__call })\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.indexafter(idx_fn, idx_super)\n   if type(idx_super) == \'table\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super[key]\n         end\n      end\n   elseif type(idx_super) == \'function\' then\n      return function(tab, key)\n         local val = idx_fn(tab, key)\n         if val then\n            return val\n         else\n            return idx_super(tab,key)\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _instances = setmetatable({}, { __mode = \'k\'})\n\nfunction cluster.instancememo(instance, message)\n   local memos = { [message] = {} }\n   -- grab the method, we\'re going to need it later\n   local method = instance[message]\n   _instances[instance] = memos\n   local function memo_method(inst, p, ...)\n      local param_set = assert(_instances[inst][message],\n                             \"missing instance or message\")\n      local results = param_set[p]\n      if results then return unpack(results) end\n\n      results = pack(method(inst, p, ...))\n      param_set[p] = results\n      return unpack(results)\n   end\n   instance[message] = memo_method\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--| if =fn= exists, bind fn(obj, ...)\nlocal function _maybe_bind(obj, fn)\n  if not fn then return nil end\n  return function(...)\n     return fn(obj, ...)\n  end\nend\n\nlocal function _get_idx(obj)\n   local M = getmetatable(obj)\n   return M and M.__index\nend\n\nfunction cluster.super(obj, field)\n   local super_idx\n   -- If the object has such a field directly, consider the implementation\n   -- from the metatable to be the \"super\" implementation\n   if rawget(obj, field) then\n      super_idx = _get_idx(obj)\n   -- Otherwise, look one step further up the inheritance chain\n   else\n      local M_idx = _get_idx(obj)\n      super_idx = type(M_idx) == \'table\' and _get_idx(M_idx) or nil\n   end\n   if super_idx then\n      return type(super_idx) == \'table\'\n         and _maybe_bind(obj, super_idx[field])\n         or  _maybe_bind(obj, super_idx(obj, field))\n   end\n   -- No superclass, or our class uses an __index function so we can\'t\n   -- meaningfully figure out what to do\n   return nil\nend\n\n\n\n\nreturn cluster\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/cluster",
branch = "the-big-refactor",
},
  { 
hash = "7778f705f988c9639f8c8437b62e03d05cd804044b28832b9e18f2d2cb1d49ee",
binary = "\n\n\nlocal coro = {}\n\n\n\n\nlocal _base = require \"core:core/_base\"\nlocal thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\nlocal function is_coro(_, coro)\n   return type(coro) == \'thread\'\nend\n\n\n\n\n\n\n\n\n\nlocal coro = setmetatable({}, { __call = is_coro })\n\nfor k,v in next, coroutine do\n   coro[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction coro.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction coro.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction coro.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coro.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal running, yield = assert(coroutine.running), assert(coroutine.yield)\n\nfunction coro.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\n\nreturn coro\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/coro",
branch = "the-big-refactor",
},
  { 
hash = "182dbe5f5f2e85862309595472a01c22cfd726b23fa491ef25901741571e1c70",
binary = "\n\n\n\n\nlocal Debug = {}\n\nfor k,v in pairs(assert(debug)) do\n   Debug[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal getupvalue, getinfo = assert(debug.getupvalue), assert(debug.getinfo)\n\nlocal function _findrefs(copies, val, dupes, subject)\n   if dupes[subject] then return end\n   dupes[subject] = true\n   local function test_one(test, container)\n      -- check key first\n      if rawequal(test, val) then\n         copies[#copies + 1] = container\n         copies.n = copies.n + 1\n      end\n      if type(test) == \'table\' then\n         if not dupes[test] then\n            _findrefs(copies, val, dupes, test)\n         end\n      elseif type(test) == \'function\' then\n         -- look in the upvalues\n         if not copies[test] then\n            dupes[test] = true\n            local name, ups, idx = \"\", true, 1\n            while ups ~= nil do\n               name, ups = getupvalue(test, idx)\n               if name == nil then\n                  ups = nil\n               else\n                  if ups == val then\n                     copies[#copies + 1] = debug.getinfo(test)\n                     copies.n = copies.n + 1\n                  end\n                  if type(ups) == \'table\' or type(ups) == \'function\'\n                     and (not dupes[ups]) then\n                     _findrefs(copies, val, dupes, ups)\n                  end\n                  idx = idx + 1\n               end\n            end\n         end\n         dupes[test] = true\n      end\n   end\n   if type(subject) == \'function\' then\n      test_one(subject)\n   elseif type(subject) == \'table\' then\n      for k, v in next, subject do\n         test_one(k, subject)\n         test_one(v, subject)\n      end\n      local _M = getmetatable(subject)\n      if _M then\n         _findrefs(copies, val, dupes, _M)\n      end\n   end\n   return copies\nend\n\nfunction Debug.findrefs(val)\n   local dupes = {}\n   return unpack(_findrefs({n = 0}, val, dupes, getfenv(1)))\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _tracer(tab)\n   return tab[1]\nend\n\nlocal lines;\nlocal function _repr(tab, window, c)\n   lines = lines or require \"core:core/string\" . lines\n   return lines(tab[1])\nend\n\nlocal __trace_M = { __repr = _repr,\n                    __tostring = _tracer}\n\nlocal traceback = assert(debug.traceback)\n\nfunction Debug.reprtrace(msg)\n   local trace;\n   if not msg then\n      trace = traceback(\"\", 2):sub(2)\n   else\n      trace = traceback(msg, 2)\n   end\n   return setmetatable({trace}, __trace_M)\nend\n\n\n\n\n\n\n\n\nlocal getlocal = assert(debug.getlocal)\nlocal insert = assert(table.insert)\n\nfunction Debug.parameters(fn)\n   local params = {}\n   local ident, i = nil, 1\n   repeat\n      ident = getlocal(fn, i)\n      insert(params, ident)\n      i = i + 1\n   until not ident\n   return params\nend\n\n\n\n\nreturn Debug\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/debug",
branch = "the-big-refactor",
},
  { 
hash = "70febee49581cca907e3f422d832a6bf4d007caf11c751c94ba8849eff6be395",
binary = "\n\n\n\n\n\n\nlocal next = assert(next) -- !\n\nlocal Env = {}\nfunction Env.fenv(...)\n   local _env = {}\n   local f = unpack(...)\n   if not f then return _env end\n   if f then\n      for k,v in next, f, nil do\n         _env[k] = v\n      end\n      return _env\n   end\nend\n\n\n\nreturn Env\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/env",
branch = "the-big-refactor",
},
  { 
hash = "0affcf165fed76240b295da57899f4247ed30e9f532022621f3428cb16d17ba0",
binary = "\n\n\n\n\n\nlocal Mod = {}\n\n\n\n\nlocal _base = require \"qor:core/_base\"\nlocal assertfmt = assert(_base.assertfmt)\nlocal require, pack, unpack = assert(require), assert(pack), assert(unpack)\n\n\n\n\n\n\n\n\nMod.lazyloader = assert(_base.lazyloader)\n\n\n\n\n\n\n\n\n\n\n\nfunction Mod.import(req_str, ...)\n   local mod = require(req_str)\n   local fields, exports = pack(...), {}\n   for i = 1, fields.n do\n       exports[i] = assert(mod[fields[i]], \"can\'t require %s\", fields[i])\n   end\n   exports.n = fields.n\n   return unpack(exports)\nend\n\n\n\n\n\n\n\n\nlocal pcall = assert(pcall)\n\nfunction Mod.request(module)\n   local ok, mod = pcall(require, module)\n   if ok then\n      return mod\n   else\n      return nil\n   end\nend\n\n\n\nreturn Mod\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/module",
branch = "the-big-refactor",
},
  { 
hash = "f497fb4d2bd1fc7a5a9ab5fe7a85d2bdfcb9bd917a5fc829c0c838a7ac983dad",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"qor:core/_base\"\nlocal unique = assert(_base.unique)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function is_fn(_, fn)\n   return type(fn) == \'function\'\nend\n\n\n\nlocal fn = setmetatable({}, { __call = is_fn })\n\n\n\n\n\n\n\n\n\nfn.no_op = _base.no_op\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.optionfirst(...)\n   local arg = pack(...)\n   local top, rx = arg[arg.n], nil\n   for i = arg.n, 2, -1 do\n      arg[i] = arg[i - 1]\n   end\n   arg[1] = top\n   return unpack(arg)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _curried = setmetatable({}, { __mode = \'k\' })\n\nlocal currier = {\n   false, -- this shouldn\'t happen\n   function(fn, a, b) -- [2]\n      return function(...)\n         return fn(a, b, ...)\n      end\n   end,\n   function(fn, a, b, c) -- [3]\n      return function(...)\n         return fn(a, b, c, ...)\n      end\n   end,\n   function(fn, a, b, c, d) -- [4]\n      return function(...)\n         return fn(a, b, c, d, ...)\n      end\n   end,\n   function(fn, a, b, c, d, e) -- [5]\n      return function(...)\n         return fn(a, b, c, d, e, ...)\n      end\n   end,\n}\n\nlocal function curry(fn, param)\n   assert(type(fn) == \'function\' or\n          type(fn) == \'table\' and getmetatable(fn).__call,\n          \'#1 of curry must be a function or callable table\')\n   local curried;\n   local pre = _curried[fn]\n   if not pre then\n      curried = function(...) return fn(param, ...) end\n      _curried[curried] = { param, n = 1 , fn = fn }\n   else\n      if pre.n <= 4 then\n         local post = {}\n         for i = 1, pre.n do\n            post[i] = pre[i]\n         end\n         post.n = pre.n + 1\n         post.fn = pre.fn\n         post[post.n] = param\n         curried = currier[post.n](post.fn, unpack(post, 1, post.n))\n         _curried[curried] = post\n      else\n         curried = function(...) return fn(param, ...) end\n      end\n   end\n\n   return curried\nend\n\nfn.curry = curry\n\n\n\n\n\n\n\n\n\nfn.thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.deferSend(obj, msg, ...)\n   assert(type(obj) == \'table\', \"#1 to deferSend must be a table\")\n   assert(type(msg) == \'string\', \"#2 to deferSend must be a string\")\n   local packed = pack(...)\n   return function()\n      return obj[msg](obj, unpack(packed))\n   end\nend\n\n\n\n\n\n\n\n\nfn.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.partial(fn, ...)\n   for i = 1, select(\'#\', ...) do\n      fn = curry(fn, select(i, ...))\n   end\n   return fn\nend\n\n\n\n\n\n\n\n\nfunction fn.compose(f, g)\n   return function(...)\n      return g(f(...))\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction fn.spread(f)\n   return function(_, ...)\n      return f(...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.itermap(fn, iter)\n   local ret, res = {}\n   while true do\n      res = pack(fn(iter()))\n      if #res == 0 then\n         return ret\n      else\n         ret[#ret + 1] = res\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _dynamics_call = setmetatable({}, {__mode = \'k\'})\nlocal _dynamics_registry  = setmetatable({}, {__mode = \'kv\'})\n\nlocal function dynamic(fn)\n   -- make a unique as key\n   local uid = unique()\n   _dynamics_call[uid] = fn\n   local function dyn_fn(...)\n      return _dynamics_call[uid](...)\n   end\n   _dynamics_registry[dyn_fn] = uid\n   return dyn_fn\nend\n\nfn.dynamic = dynamic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.patch_dynamic(dyn_fn, fn)\n   assert(_dynamics_registry[dyn_fn], \"cannot patch a non-dynamic function\")\n   local uid = _dynamics_registry[dyn_fn]\n   _dynamics_call[uid] = fn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _pre_hook, _post_hook = setmetatable({}, {__mode = \'k\'}),\n                              setmetatable({}, {__mode = \'k\'})\n\nlocal function _call_with_hooks(uid, ...)\n   local fn = _dynamics_call[uid]\n   assert(fn, \"_dynamics_call is missing a hookable function\")\n   local pre, post = _pre_hook[uid], _post_hook[uid]\n\n   if pre and post then\n      local new_arg = pack(pre(...))\n      local rets = pack(fn(unpack(new_arg)))\n      -- make into one pack, because you can only apply multiple arguments at\n      -- the end of a function call\n      for i = 1, new_arg.n do\n         rets[#rets + 1] = new_arg[i]\n      end\n      rets.n = new_arg.n + rets.n\n      return post(unpack(rets))\n   elseif pre then\n      return fn(pre(...))\n   elseif post then\n      local args, rets = pack(...), pack(fn(...))\n      -- same trick here...\n      for i = 1, rets.n do\n         args[#args + 1] = rets[i]\n      end\n      args.n = rets.n + args.n\n      return post(unpack(args))\n   else\n      return fn(...)\n   end\nend\n\nlocal function prehook(hooked, pre_hook)\n   _pre_hook[_dynamics_registry[hooked]] = pre_hook\nend\n\nlocal function posthook(hooked, post_hook)\n   _post_hook[_dynamics_registry[hooked]] = post_hook\nend\n\nfn.prehook, fn.posthook = prehook, posthook\n\nfunction fn.hookable(fn, pre, post)\n   -- make a uid, add to _dynamics_call\n   local uid = unique()\n   _dynamics_call[uid] = fn\n   local hookable = function(...)\n                       return _call_with_hooks(uid, ...)\n                    end\n   -- register the hookable in the dynamics registry\n   _dynamics_registry[hookable] = uid\n   if pre then\n      prehook(hookable, pre)\n   end\n   if post then\n      posthook(hookable, post)\n   end\n   return hookable\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfn.assertfmt = _base.assertfmt\n\n\n\nreturn fn\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/fn",
branch = "the-big-refactor",
},
  { 
hash = "4d801a1ab9d658b4b4e1bcb0682062fb4942428aa6a1508237028fc17f0690cf",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal FSet, FSet_m = {}, {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __add, __sub, __mod, __unm;\n\n\n\n\n\n\n\nlocal __len;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __eq, __lt, __lte;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function spread(fn)\n   return function(_, a)\n      return fn(a) and true or nil\n   end\nend\n\n\n\nlocal function readonly(tab, key, val)\n   error(\"can\'t assign \" .. key .. \" to a function set\")\nend\n\nlocal function new(fn)\n   local fset = setmetatable({}, { __index = spread(fn),\n                                   __add = __add,\n                                   __sub = __sub,\n                                   __mod = __mod,\n                                   __len = __len,\n                                   __unm = __unm,\n                                   -- comparators, negative\n                                   __newindex = readonly, })\n   return fset\nend\n\n\n\n\n\n\n__add = function(left, right)\n   return new(function(elem)\n      return left[elem] or right[elem]\n   end)\nend\n\n\n\n\n\n\n__sub = function(left, right)\n   return new(function(elem)\n      return (left[elem] and (not right[elem])) or nil\n   end)\nend\n\n\n\n\n\n\n__mod = function(left, right)\n   return new(function(elem)\n      return left[elem] and right[elem]\n   end)\nend\n\n\n\n\n\n\n__unm = function(set)\n   return new(function(elem)\n      return (not elem) or nil\n   end)\nend\n\n\n\n\n\n\n\n\n__len = function() error(\"can\'t take the length of a function set\") end\n\n\n\nreturn new\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/fn-set",
branch = "the-big-refactor",
},
  { 
hash = "fb4f99a719ab256e45b114060bd4bceef6e9e88cd3e2fbcfe59dd28fd452de04",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal meta = {}\n\n\n\n\n\n\n\n\n\n\nfunction meta.meta(MT, tab)\n   error \"this is no longer provided\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.metatables(tab)\n   local dupes = { tab = true }\n   local _M = tab\n   return function()\n      _M = getmetatable(_M)\n      if (_M == nil) or dupes[_M] then return nil end\n      dupes[_M] = true\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   return rawget(M, mmethod) or rawget(M, \'__\' .. mmethod)\nend\n\nmeta.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\nfunction meta.instanceof(obj, Class)\n   if type(Class) == \'string\' then\n      return type(obj) == Class\n   else\n      return type(obj) == \'table\' and obj.idEst == Class\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.weak(mode)\n   mode = mode or \'kv\'\n   return setmetatable({}, { __mode = mode })\nend\n\n\n\nreturn meta\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/meta",
branch = "the-big-refactor",
},
  { 
hash = "84de53352077953a69676f3b8722a42a4723aa9939ffdd3213c6723e2a136483",
binary = "\n\n\nlocal Math = {}\nfor k, v in pairs(math) do\n   Math[k] = v\nend\n\n\n\n\n\n\n\n\n\nfunction Math.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\n\nlocal random = assert(math.random)\n\nfunction Math.flip()\n   if random(2) == 1 then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nlocal floor = assert(math.floor)\n\nlocal function isposint(arg)\n   if type(arg) ~= \'number\' then\n      return nil, \"not a number\"\n   elseif arg <= 0 then\n      return nil, \"not positive\"\n   elseif floor(arg) ~= arg then\n      return nil, \"not integer\"\n   else\n      return arg\n   end\nend\n\nMath.isposint = isposint\n\n\n\n\n\n\n\n\nfunction Math.posint(num)\n   return assert(isposint(num))\nend\n\n\n\n\n\n\n\n\n\n\nlocal assertfmt = assert(require \"core:_base\" . assertfmt)\nfunction Math.clamp(value, lower, upper)\n   if lower and upper then\n      assertfmt(lower <= upper, \"Clamp range must be nonempty (lower <= upper), got (%d, %d)\", lower, upper)\n   end\n   if lower and value < lower then\n      value = lower\n   end\n   if upper and value > upper then\n      value = upper\n   end\n   return value\nend\n\n\n\n\nreturn Math\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/math",
branch = "the-big-refactor",
},
  { 
hash = "f28455502bf8945f2ebf329d22c885a77cce4a7d77978d5bc06d0148f7c10807",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(true)\nlocal core = require \"qor:core\"\nlocal Set, Set_Build, Set_M = {}, {}, {}\nSet.funk = true\nsetmetatable(Set, Set_Build)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_Build.__call(_new, tab)\n   assert(type(tab) == \'table\' or not tab, \"#1 to Set must be a table or nil\")\n   tab = tab or {}\n   local top = #tab\n   local shunt;  -- we need this for number keys\n   for i = 1, top do\n      local v = tab[i]\n      if type(v) == \'number\' then\n         shunt = shunt or {}\n         shunt[v] = true\n      else\n         tab[v] = true\n      end\n      tab[i] = nil\n   end\n   if shunt then\n      for v in pairs(shunt) do\n         tab[v] = true\n      end\n   end\n   return setmetatable(tab, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__call(set, ...)\n   error\n     \"don\'t use Set(...) to mutate until we can warn about =if Set(elem)!=\"\n   for i = 1, select(\'#\', ...) do\n      set[select(i, ...)] = true\n   end\nend\n\nSet.insert = Set_M.__call\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__newindex(set, key, value)\n   assert(value == true or value == nil, \"value must be true or nil\")\n   rawset(set, key, value)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninsert = assert(table.insert)\nfunction Set.remove(set, ...)\n   local removed;\n   for i = 1, select(\'#\', ...) do\n      local elem = select(i, ...)\n      if set[elem] then\n         removed = removed or {}\n         insert(removed, elem)\n         set[elem] = nil\n      end\n   end\n   if removed then\n      return(unpack(removed))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSet_M.__len = assert(table.nkeys)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fix(tab)\n   if getmetatable(tab) == Set_M then\n      return tab, true\n   else\n      return Set(tab), false\n   end\nend\n\nlocal function _binOp(left, right)\n   local l_p, r_p;\n   left, l_p = _fix(left)\n   right, r_p = _fix(right)\n   return left, right, l_p, r_p\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal F__add = getmetatable(require \"qor:core/fn-set\"()) . __add\n\n\n\nlocal function isFset(maybe)\n   local _M = getmetatable(maybe)\n   if _M and _M.__add == F__add then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nlocal clone = assert(require \"table.clone\")\n\nfunction Set_M.__add(left, right)\n   -- Set union is commutative, but we need to clone to prevent subsequent\n   -- mutation from changing the semantics\n   if isFset(right) then\n      return right + clone(left)\n   end\n   local l_isSet, r_isSet;\n   left, right, l_isSet, r_isSet = _binOp(left, right)\n   local set, other;\n   if #left > #right then\n      if l_isSet then\n         set = clone(left)\n      else\n         set = left\n      end\n      other = right\n   else\n      if r_isSet then\n         set = clone(right)\n      else\n         set = right\n      end\n      other = left\n   end\n\n   for elem in pairs(other) do\n      set[elem] = true\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\nfunction Set_M.__sub(left, right)\n   left, right =  _binOp(left, right)\n   local set = {}\n   for k in pairs(left) do\n      if not right[k] then\n         set[k] = true\n      end\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set_M.__mod(left, right)\n   left, right = _binOp(left, right)\n   local set = {}\n   for elem in pairs(left) do\n      if right[elem] then\n         set[elem] = true\n      end\n   end\n   return setmetatable(set, Set_M)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function not_missing(left, right)\n   for elem in pairs(left) do\n      if not right[elem] then\n         return false\n      end\n   end\n   return true\nend\n\n\n\nfunction Set_M.__eq(left, right)\n   if not #left == #right then return false end\n   return not_missing(left, right)\nend\n\n\n\n\n\n\n\n\nfunction Set_M.__lt(left, right)\n   if #left >= #right then return false end\n   return not_missing(left, right)\nend\n\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate, Token\nlocal sortedpairs = assert(core.table.sortedpairs)\n\nfunction Set_M.__repr(set, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n   if #set == 0 then\n      -- we have a name for this\n      local sent = false\n      return function()\n         if not sent then\n            sent = true\n            local empty = \"#{\" .. c.table(\'∅\') .. \"}\"\n            return empty\n         end\n      end\n   end\n\n   return wrap(function()\n      yield(Token(\"#{ \", { color = \"base\", event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for v, _ in sortedpairs(set) do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n         end\n         for t in tabulate(v, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn Set\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/set",
branch = "the-big-refactor",
},
  { 
hash = "9f4bd802762e0caef4221b0051a75583a3ec6e03d4463391a41146b4aa8debe2",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal assert = assert or error \"no assert\"\n\nlocal Uv = {}\n\nlocal uv = assert(require \"luv\")\n\nlocal s = require \"status:status\" ()\ns.chatty = true\n\n\n\n\n\n\n\n\n\n\nfunction Uv.deferby(event, ms)\n   ms =  ms or 0\n   local timer = uv.new_timer()\n\n   local _event = function()\n      event()\n      timer:stop()\n   end\n\n   timer:start(ms, 0, _event)\n\n   return;\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal resume = assert(coroutine.resume)\n\nfunction Uv.once(event)\n   local idle = uv.new_idle()\n   idle:start(function()\n      idle:stop()\n      idle:close()\n      s:chat(\"executing event of type %s\", type(event))\n      if type(event) == \'thread\' then\n         resume(event)\n      else\n         event()\n      end\n   end)\nend\n\n\n\n\nreturn Uv\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/uv",
branch = "the-big-refactor",
},
  { 
hash = "ab1d4cc3c38518a8601bcc974ff5b7582c8d8fdb418423584287f6404dc901d5",
binary = "\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\n\n\n\nlocal function is_table(_, tab)\n   local t = type(tab)\n   return t == \'table\'\n          and tab\n          or nil, t\nend\n\n\n\n\nlocal meta = require \"core/meta\"\nlocal Tab = setmetatable({}, { __call = is_table })\nfor k, v in pairs(table) do\n   Tab[k] = v\nend\n\n\n\n\n\n\n\n\nlocal function keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local _keys = {}\n   for k, _ in pairs(tab) do\n      _keys[#_keys + 1] = k\n   end\n\n   return _keys, #_keys\nend\n\nTab.keys = keys\n\n\n\n\n\n\n\n\n\nfunction Tab.values(tab)\n   assert(type(tab) == \"table\", \"values must receive a table\")\n   local vals = {} -- thanks scry\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal N_M = {}\nN_M.__index = N_M\n\nfunction N_M.__len(tab)\n   return tab.n\nend\n\nfunction N_M.__ipairs(tab)\n   local i = 1\n   return function()\n      if i >= tab.n then return nil end\n      i = i + 1\n      return i - 1, tab[i - 1]\n   end\nend\n\nfunction Tab.n_table(tab, djikstra)\n   tab = tab or {}\n   tab.n = 0\n   return setmetatable(tab, N_M)\nend\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction Tab.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(tab, field)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(maybeIndex, field)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if success and result ~= nil then\n            return result\n         end\n      end\n   end\n   return nil\nend\n\n\n\nlocal function _hf__index(has_field, field)\n   has_field[field] = function(tab)\n      return _hasfield(tab, field)\n   end\n   return has_field[field]\nend\n\nlocal function _hf__call(_, tab, field)\n   return _hasfield(tab, field)\nend\n\nTab.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\nfunction Tab.nonempty(tab)\n   if #tab > 0 then\n      return tab\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal clone1 = require \"table.clone\"\n\nTab.clone1 = clone1\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive, got \" .. tostring(depth))\n   if depth == 1 then\n      return setmetatable(clone1(tab), getmetatable(tab))\n   end\n   local clone = {}\n   for k,v in next, tab do\n      if type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return setmetatable(clone, getmetatable(tab))\nend\n\nTab.clone = _clone\n\n\n\n\n\n\n\n\nfunction Tab.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            -- copy the metatable after, in case it contains\n            -- __index or __newindex behaviors\n            copy = setmetatable(copy, _deep(getmetatable(val)))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.cloneinstance(tab)\n   assert(type(tab) == \"table\",\n          \"cannot cloneinstance of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            copy = setmetatable(copy, getmetatable(val))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Tab.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert (could be =insert(ret, (fn(val)))=...)\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.mutate(tab, fn, pairwise, just_value)\n   local iter;\n   if pairwise then\n      iter = pairs\n   else\n      iter = ipairs\n   end\n   for k, v in iter(tab) do\n      if just_value then\n         tab[k] = fn(v)\n      else\n         tab[k] = fn(v, k)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.getset(tab, field)\n   local ret = tab[field]\n   if ret == nil then\n      tab[field] = {}\n      return tab[field], true\n   elseif type(ret) ~= \'table\' then\n      error (\"field \" .. field .. \" is of type \" .. type(ret))\n   else\n      return ret, nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.compact(tab, n)\n   n = assert(n or tab.n, \"a numeric value must be provided for non-ntables\")\n   local cursor, slot, empty = 1, nil, nil\n   while cursor <= n do\n      slot = tab[cursor]\n      if slot == nil and empty == nil then\n         -- mark the empty position\n         empty = cursor\n      end\n      if slot ~= nil and empty ~= nil then\n         tab[empty] = slot\n         tab[cursor] = nil\n         cursor = empty\n         empty = nil\n      end\n      cursor = cursor + 1\n   end\n   if tab.n then\n      tab.n = #tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.inverse(tab)\n   local bat = {}\n   for k,v in pairs(tab) do\n      if bat[v] then\n         error(\"duplicate value on key \" .. k)\n      end\n      bat[v] = k\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function flatten(tab, level)\n   local ret, copies = {}, {}\n   local function _flat(t, depth)\n      if level and depth > level then\n         ret[#ret + 1] = t\n         return nil\n      end\n      for _,v in ipairs(t) do\n         if type(v) ~= \"table\" then\n            ret[#ret + 1] = v\n         else\n            if not copies[v] then\n               copies[v] = true\n               _flat(v, depth + 1)\n            end\n         end\n      end\n   end\n   _flat(tab, 0)\n   return ret\nend\n\nTab.flatten = flatten\n\n\n\n\n\n\n\n\n\nTab.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\nfunction Tab.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.keysort(a, b)\n   local A, B = type(a), type(b)\n   if (A == \'string\' and B == \'string\')\n      or (A == \'number\' and B == \'number\') then\n      return a < b\n   elseif A == \'number\' and B == \'string\' then\n      return false\n   elseif A == \'string\' and B == \'number\' then\n      return true\n   elseif A == \'string\' or A == \'number\' then\n      -- we want these tags at the bottom\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal keysort = assert(Tab.keysort)\nlocal nkeys, sort = assert(table.nkeys), assert(table.sort)\n\nfunction Tab.sortedpairs(tab, sorter, threshold)\n   sorter = sorter or keysort\n   if threshold and threshold > nkeys(tab) then\n      return pairs(tab)\n   end\n   local _keys = keys(tab)\n   sort(_keys, sorter)\n   local i, top = 0, #_keys\n   return function()\n      i = i + 1\n      if i > top then return nil end\n      return _keys[i], tab[_keys[i]]\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function indexed(_M)\n   return (type(_M) == \'table\')\n      and (type(_M.__index) == \'table\')\nend\n\nlocal function allkeys(tab, sorting)\n   local _M = getmetatable(tab)\n   if not indexed(_M) then\n      local _k = keys(tab)\n      if sorting then\n         sort(_k, keysort)\n      end\n      return _k\n   end\n\n   local indices = {(keys(tab))}\n   repeat\n      if indexed(_M) then\n         local _keys = keys(_M.__index)\n         insert(indices, _keys)\n      end\n      _M = getmetatable(_M.__index)\n   until not _M\n   local allkeys, seen = {}, {}\n   for i = #indices, 1, -1 do\n      if sorting then\n         sort(indices[i], keysort)\n      end\n      for j = 1, #indices[i] do\n         local k = indices[i][j]\n         if not seen[k] then\n            insert(allkeys, k)\n            seen[k] = true\n         end\n      end\n   end\n   return allkeys, #allkeys\nend\n\nTab.allkeys = allkeys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.allpairs(tab, sort)\n   local all_keys = allkeys(tab, sort)\n   local i = 0\n   return function()\n      i = i + 1\n      local k = all_keys[i]\n\n      if k == nil then return end\n\n      return k, tab[k]\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\nlocal function deleterange(tab, start, stop)\n   stop = stop or #tab\n   if start > stop then return end\n   local offset = stop - start + 1\n   for i = start, #tab do\n      tab[i] = tab[i + offset]\n   end\nend\n\nTab.deleterange = deleterange\n\n\n\n\n\n\nfunction Tab.truncate(tab, from)\n   return deleterange(tab, from)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nlocal function push(queue, x)\n   queue.tail = queue.tail + 1\n   queue[queue.tail] = x\nend\n\nlocal function pop(queue)\n   if queue.tail == queue.head then return nil end\n   queue.head = queue.head + 1\n   return queue[queue.head]\nend\n\nfunction Tab.splice(tab, index, to_add)\n   assert(type(tab) == \"table\", _e_1)\n   if to_add == nil then\n      to_add = index\n      index = nil\n   end\n   if index == nil then\n      index = #tab + 1\n   end\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n\n   index = index - 1\n   local queue = { head = 0, tail = 0}\n   local i = 1\n   -- replace elements, spilling onto queue\n   for j = 1, #to_add do\n      push(queue, tab[i + index])\n      tab[i + index] = to_add[j]\n      i = i + 1\n   end\n   -- run the queue up the remainder of the table\n   local elem = pop(queue)\n   while elem ~= nil do\n      push(queue, tab[i + index])\n      tab[i + index] = elem\n      i = i + 1\n      elem = pop(queue)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compact, splice = Tab.compact, Tab.splice\n\nfunction Tab.replace(tab, index, to_add, span)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n   span = span or #to_add\n   -- easiest to handle the three cases as distinct.\n   if span == #to_add then\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n   elseif span > #to_add then\n      local top = #tab\n      -- replace #to_add worth of elements\n      for i = index, index + #to_add - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- nil out remaining elements\n      for i = index + #to_add, index + span - 1 do\n         tab[i] = nil\n      end\n      compact(tab, top)\n   else -- if span < #to_add\n      -- replace span worth of elements\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- make a table to hold the rest, copy\n      local spill = {}\n      for i = 1, #to_add - span do\n        spill[i] = to_add[i + span]\n      end\n      splice(tab, index + span, spill)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.addall(tab, to_add)\n   for k, v in pairs (to_add) do\n      tab[k] = v\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.append(tab, ...)\n   local top = #tab\n   for i = 1, select(\'#\', ...) do\n      tab[top + i] = select(i, ...)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal isarray = assert(table.isarray)\nfunction Tab.keystovalue(tab, keys, val)\n   if isarray(tab) then\n      for _, k in ipairs(keys) do\n         tab[k] = val\n      end\n   else\n      for k in pairs(keys) do\n         tab[k] = val\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.packinto(tab, ...)\n   tab.n = select(\'#\', ...)\n   for i = 1, tab.n do\n      tab[i] = select(i, ...)\n   end\n   return tab\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.pget(tab, key)\n   local ok, val = pcall(function() return tab[key] end)\n   if ok then\n      return val\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.safeget(tab, key)\n   if type(tab) ~= \'table\' then return nil end\n   while tab ~= nil do\n      local val = rawget(tab, key)\n      if val ~= nil then return val end\n      local M = getmetatable(tab)\n      if M then\n         tab = rawget(M, \'__index\')\n         if type(tab) ~= \'table\' then\n            return nil\n         end\n      else\n         tab = nil\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.fromkeys(tab, ...)\n   local answer = {}\n   local keys = pack(...)\n   for _, k in ipairs(keys) do\n      answer[k] = tab[k]\n   end\n   return answer\nend\n\n\n\nreturn Tab\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/table",
branch = "the-big-refactor",
},
  { 
hash = "62b23f3816d39c29af894ca1fb458b7b305bd48665c46acb08dd00c5eaf95d1d",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal function is_string(_, str)\n   local t = type(str)\n   return t == \'string\'\n          and str\n          or nil, t\nend\n\n\n\n\nlocal String = setmetatable({}, { __call = is_string })\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/_base\".assertfmt\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nfor k, v in next, string do\n  String[k] = v\nend\n\n\n\n\n\n\n\n\n\nString.assertfmt = assertfmt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction String.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction String.split(str, patt)\n   local first, last = find(str, patt)\n   if first then\n      return sub(str, 1, first - 1), sub(str, last + 1)\n   else\n      return str, \"\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function findall(str, patt)\n   local find = type(str) == \'string\' and find or str.find\n   local matches = {}\n   local index = 1\n   local left, right\n   repeat\n     left, right = find(str, patt, index)\n     if left then\n        matches[#matches + 1] = {left, right}\n        index = right + 1\n     end\n   until left == nil\n   if #matches > 0 then\n      return matches\n   else\n      return nil\n   end\nend\n\nString.findall = findall\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction String.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction String.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\nString.cleave = cleave\n\n\n\n\n\n\n\n\n\n\nfunction String.isidentifier(str)\n   return find(str, \"^[a-zA-Z_][a-zA-Z0-9_]+$\") == 1\nend\n\n\n\n\n\n\n\n\nfunction String.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction String.linesnl(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local nl = find(str, \"\\n\", pos)\n      local rx = pos\n      if nl then\n         pos = nl + 1\n         return sub(str, rx, nl)\n      else\n         pos = nil\n         return sub(str, rx)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _nl_map = setmetatable({}, { __mode = \'k\' })\n\n\n\n\n\n\n\n\n\nlocal function locate(value, lower, upper)\n   if value > lower\n      and value <= upper then\n      return value - lower\n   elseif value <= lower then\n      return nil, true\n   else\n      return nil, false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function tryLine(target, linum, nl_map)\n   --   math.ceil makes this \"wobbly\" around the limits, so\n   --   we clamp accordingly\n   if linum > #nl_map then\n      linum = #nl_map\n   elseif linum < 1 then\n      linum = 1\n   end\n   local prev_nl, next_nl = nl_map[linum - 1] or 0, nl_map[linum]\n   local col, lower_than = locate(target, prev_nl, next_nl)\n   if col then\n      return linum, col\n   else\n      return nil, lower_than\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function nextLine(str, target, idx, nl_map)\n   local prev_nl, next_nl = nl_map[#nl_map] or 0,\n                            find(str, \"\\n\", idx)\n\n   if not next_nl then\n      -- this works because we pre-exclude target > #str\n      next_nl = #str + 1\n   end\n\n   nl_map[#nl_map + 1] = next_nl\n   local line, col = tryLine(target, #nl_map, nl_map)\n   if line then\n      --table.clear(nl_map)\n      return line, col\n   else\n     return nil, next_nl + 1\n   end\nend\n\n\n\n\n\n\n\n\nlocal ceil = assert(math.ceil)\n\nlocal function linepos(str, offset)\n   local nl_map;\n   assert(offset <= #str, \"can\'t find a position longer than the string!\")\n   if _nl_map[str] then\n      nl_map = _nl_map[str]\n   else\n      nl_map = {}\n      _nl_map[str] = nl_map\n   end\n   local mapped_to = nl_map[#nl_map] or 0\n\n   local line, col, idx = nil, nil, 1\n   if offset > mapped_to then\n      -- build up the map and return what we find\n      idx = mapped_to + 1\n      repeat\n         line, col = nextLine(str, offset, idx, nl_map)\n         if not line then\n            idx = col\n         end\n      until line\n   else\n      -- binary search\n      local stride = ceil(#nl_map / 2)\n      local idx = stride\n      local lower;\n      repeat\n         line, lower = tryLine(offset, idx, nl_map)\n         if not line then\n            stride = ceil(stride / 2)\n            if lower then\n               idx = idx - stride\n            else\n               idx = idx + stride\n            end\n         end\n      until line\n      -- lower is a boolean until it\'s a column\n      col = lower\n   end\n\n   return line, col\nend\n\nString.linepos = linepos\n\n\n\n\n\n\n\n\n\nfunction String.lineat(str, linum)\n   local nl_map = _nl_map[str]\n   if not nl_map then\n      -- create the whole thing\n      String.linepos(str, #str)\n      nl_map = assert(_nl_map[str])\n   end\n   local last_col = nl_map[linum]\n   -- we can signal why this doesn\'t work\n   if not last_col then return \"\" end\n\n   local first_col = (nl_map[linum - 1] or 0) + 1\n   return sub(str, first_col, last_col), first_col, last_col\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction String.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, _str_M)\nend\n\n\n\n\n\n\n\n\n\n\nfunction String.slurp(filename)\n  local f = io.open(tostring(filename), \"rb\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.spit(filename, file)\n  local f = io.open(tostring(filename), \"w+\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local ok = f:write(file)\n  f:close()\nend\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction String.splice(to_split, to_splice, index)\n   assert(type(to_split) == \"string\", \"bad argument #1 to splice: \"\n           .. \"string expected, got %s\", type(to_split))\n   assert(type(to_splice) == \"string\", \"bad argument #2 to splice: \"\n           .. \"string expected, got %s\", type(to_splice))\n   assert(type(index) == \"number\", \"bad argument #2 to splice: \"\n          .. \" number expected, got %s\", type(index))\n   assert(index >= 0 and index <= #to_split, \"splice index out of bounds\")\n   local head, tail = sub(to_split, 1, index), sub(to_split, index + 1)\n   return head .. to_splice .. tail\nend\n\n\n\nreturn String\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/string",
branch = "the-big-refactor",
},
  { 
hash = "16df2e91a541b17faeb8ede986bf1b0e95f2675a1fa6279d164f44da77cb13d8",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"qor:core/_base\"\nlocal core    = _base.lazyloader { \'core\',\n\n   cluster    = \"qor:core/cluster\",\n   coro       = \"qor:core/coro\",\n   fn         = \"qor:core/fn\",\n   debug      = \"qor:core/debug\",\n   math       = \"qor:core/math\",\n   meta       = \"qor:core/meta\",\n   [\"module\"] = \"qor:core/module\",\n   string     = \"qor:core/string\",\n   table      = \"qor:core/table\",\n   thread     = \"qor:core/thread\",\n   env        = \"qor:core/env\",\n   uv         = \"qor:core/uv\",\n   set        = \"qor:core/set\",\n}\n\ncore.unique = _base.unique\n\n\n\nreturn core\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core",
branch = "the-big-refactor",
},
  { 
hash = "be627bdbfa2ba2c08e3c485c5aea928e8998ba17524377c607ee8d2320ea0541",
binary = "\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\n\n\n\nlocal thread = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal select       = select\nlocal setmetatable = setmetatable\nlocal create       = coroutine.create\nlocal isyieldable  = coroutine.isyieldable -- luacheck: ignore\nlocal resume       = coroutine.resume\nlocal running      = coroutine.running\nlocal status       = coroutine.status\nlocal wrap         = coroutine.wrap\nlocal yield        = coroutine.yield\n\n\n\n\n\n\n\n\nlocal _tagged = setmetatable({}, {__mode = \'kv\'})\n\nlocal str_tags = setmetatable({}, {__mode = \'v\'})\n\n\n\n\n\n\nlocal unique = require \"qor:core\".unique\n\nfunction thread.nest(tag)\n\n\n\n\n\n\n\n\n\n\n\nif type(tag) == \'string\' then\n   local _tag = str_tags[tag] or unique()\n   str_tags[tag] = _tag\n   tag = _tag\nend\n\ntag = tag or unique()\n\nif _tagged[tag] then\n   return _tagged[tag]\nend\n\n\n\n\n\n\n\n\n\n\nlocal coroutine = {\n   isyieldable = isyieldable,\n   running     = running,\n   status      = status,\n}\n\n_tagged[tag] = coroutine\n\n\n\n\n\n\n\n\nlocal _ours = setmetatable({}, {__mode = \'k\'})\n\nfunction coroutine.create(f)\n   local co =  create(function(...)\n      assert(type(tag) == \'userdata\')\n      return tag, f(...)\n   end)\n   _ours[co] = true\n   return co\nend\n\nfunction coroutine.yield(...)\n   return yield(tag, ...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function for_resume(co, ok, ...)\n   if not ok then\n      return ok, ...\n   elseif tag == ... then\n      return ok, select(2, ...)\n   else\n       return for_resume(co,\n                            resume(co,\n                                      yield(...)))\n   end\nend\n\nfunction coroutine.resume(co, ...)\n   return for_resume(co,\n                        resume(co, ...))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function for_wrap(co, ...)\n   if tag == ... then\n      return select(2, ...)\n   else\n      return for_wrap(co,\n                         co(\n                            yield(...)))\n   end\nend\n\nfunction coroutine.wrap (f)\n   local co = wrap (function (...)\n      return tag, f (...)\n   end)\n   return function(...)\n      return for_wrap(co,\n                        co(...))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coroutine.ours(co)\n   return not not _ours[co]\nend\n\n\n\nreturn coroutine\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.complete(ok, co)\n   if ok and status(co) == \'dead\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.onloop()\n   local _, main = running()\n   return main and uv.loop_alive()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\nreturn thread\n\n",
vc_hash = "efbed332fb1495d991d26a151f6b2404d1b5e454\n",
name = "core/thread",
branch = "the-big-refactor",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "reason",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "367cbe1d442a80a1e2cc83080c9bd160d648827d2854c9e67f0f11cbf22c7294",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table = core.table\nlocal string = core.string\nlocal debug = core.debug\nlocal cluster = require \"cluster:cluster\"\n\n\n\nlocal kernel = require \"reason:kernel\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\ns.boring = true\nlocal c = require \"singletons:color\" . color\n\n\n\n\n\n\n\n\n\n\nlocal newproxy, weak = assert(newproxy),\n                       assert(core.meta.weak)\n\nlocal _Vars = weak \'k\'\nlocal _VarName = weak \'k\'\n\nlocal var_ct = 0\n\nlocal function Var(num)\n   num = num or 1\n   var_ct = var_ct + 1\n   local var = newproxy()\n   _Vars[var] = var_ct\n   if num <= 1 then\n      return var\n   else\n      return var, Var(num - 1)\n   end\nend\n\nlocal function isVar(maybe_var)\n   return _Vars[maybe_var]\nend\n\nlocal function varStr(var)\n   local name = _VarName[var]\n   if name then\n      return c.field(name .. \"#\" .. _Vars[var])\n   else\n      return c.field(\"_.\" .._Vars[var])\n   end\nend\n\nlocal function nameVar(name)\n   local var = Var()\n   _VarName[var] = name\n   return var\nend\n\n\n\n\n\n\nlocal _ts = require \"repr:repr\" . ts_color\n\nlocal function ts(value)\n   if isVar(value) then\n      return varStr(value)\n   else\n      return _ts(value)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal State_M, Sub_M = {}, {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function struct_eq()\n   return function(s1, s2)\n      local same = true\n      for k, v in pairs(s1) do\n         if s2[k] ~= v then\n            same = false\n            break\n         end\n      end\n      if (not same) then return false end\n      for k, v in pairs(s2) do\n         if s1[k] ~= v then\n            same = false\n            break\n         end\n      end\n      return same\n   end\nend\n\n\n\nState_M.__eq, Sub_M.__eq = struct_eq(), struct_eq()\n\n\n\n\n\n\n\n\n\nlocal lines = assert(string.lines)\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\nfunction State_M.__repr(state)\n   local repr = {\"⊰ \"}\n   for var, term in pairs(state.subs) do\n      insert(repr, ts(var) .. \" ≡ \" .. ts(term))\n      insert(repr, \"\\n\")\n   end\n   repr[#repr] = \" ⊱\"\n   return lines(concat(repr))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal clone1, clone = assert(table.clone1), assert(table.clone)\n\n\n\n\n\n\n\n\n\nlocal function isState(maybe_state)\n   assert(type(maybe_state) == \'table\')\n   return getmetatable(maybe_state) == State_M\nend\n\nlocal function isSub(maybe_sub)\n   assert(type(maybe_sub) == \'table\')\n   return getmetatable(maybe_sub) == Sub_M\nend\n\nlocal function newState(subs)\n   subs = setmetatable(subs or {}, Sub_M)\n   return setmetatable({subs = subs}, State_M)\nend\n\n\n\n\n\n\n\n\nlocal function extendSubs(subs, var, target)\n   if not isSub(subs) then\n      s:halt(\"is this: %s a stream? %s\", ts(subs), isStream(subs))\n   end\n   local new = clone(subs, 1)\n   s:bore(\"extending %s with %s\", varStr(var), ts(target))\n   new[var] = target\n   return new\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function constrain(var, var_cons, target)\n   s:verb(\"applying constraints to %s\", ts(target))\n   local pass = true\n   for _, con in ipairs(var_cons) do\n      if type(con) == \'function\' then\n         if not con(target) then\n            s:chat(\"target has failed constraint\")\n            return false\n         end\n      else\n         s:bore(\"owo what\'s this? %s\", ts(con))\n         local fn, left, right, idx = con[1], con[2], con[3], con[var]\n         local other;\n         if (idx == 1) then\n            other = right\n         else\n            other = left\n         end\n         if (other ~= nil) then\n            if (idx == 1) then\n               if not fn(target, other) then\n                  s:chat(\"target has failed relation\")\n                  return false\n               end\n            else\n               assert(idx == 2)\n               if not fn(other, target) then\n                  s:chat(\"target has failed relation\")\n                  return false\n               end\n            end\n         else\n            -- this is destructive, it should append and we should unwrap\n            -- in the assignment.\n            -- wire it up first.\n            s:bore(\"constraining %d of relation as %s = %s\", idx, ts(var), ts(target))\n            con[idx + 1] = target\n         end\n      end\n   end\n\n   return true\nend\n\n\n\n\n\nlocal function applyConstraints(target, state, var)\n   if not state then return nil end\n   s:bore(\"constraints state %s\", ts(state.cons\n      ))\n   if not isVar(target) then\n      local var_cons = state.cons and state.cons[var]\n      if var_cons then\n         s:bore(\"var_cons %s\", var_cons)\n         local cons_ok = constrain(var, var_cons, target)\n         if not cons_ok then return nil end\n      else\n         s:bore(\"no constraints to apply to %s\", ts(target))\n      end\n   end\n\n   return state\nend\n\n\n\n\n\n\nlocal function addTerm(state, var, target)\n   local subs = extendSubs(state.subs, var, target)\n   local _state = {}\n   for k, v in pairs(state) do\n      if k ~= \'subs\' then\n         _state[k] = v\n      else\n         _state[k] = subs\n      end\n   end\n   -- constrain nonvariable targets\n   setmetatable(_state, State_M)\n   if not applyConstraints(target, _state, var) then return nil end\n   return _state\nend\n\n\n\n\n\n\n\n\n\nlocal function _extendConstraint(cons, var, fn)\n   if cons then\n      local var_cons = cons[var]\n      if var_cons then\n         local new_vcons, new_cons = clone1(var_cons), {}\n         insert(new_vcons, fn)\n         for v, con in pairs(cons) do\n            if v == var then\n               new_cons[v] = new_vcons\n            else\n               new_cons[v] = clone1(con)\n            end\n         end\n         return new_cons\n      else\n         local new_cons = clone(cons)\n         new_cons[var] = {fn}\n         return new_cons\n      end\n   else\n      return {[var] = {fn}}\n   end\nend\n\nlocal function withConstraint(state, var, fn)\n   local _state = { subs = state.subs,\n                    types = state.types }\n\n   _state.cons = _extendConstraint(state.cons, var, fn)\n   s:bore(\"constraints of %s are %s\", ts(var), ts(fn))\n   return setmetatable(_state, State_M)\nend\n\n\n\n\n\n\nlocal function withRelation(state, a, b, rel)\n   local _state = { subs = state.subs,\n                    types = state.types }\n   -- the relation is the first argument, 2 and 3 are filled later\n   local bundle = {rel}\n   -- arity for each variable keyed by var\n   bundle[a] = 1\n   bundle[b] = 2\n   _state.cons = _extendConstraint(_extendConstraint(state.cons, a, bundle),\n                                   b, bundle)\n   return setmetatable(_state, State_M)\nend\n\n\n\n\n\n\n\n\n\nlocal _Stream = {\'stream\'}\n\nlocal _streams = weak \'k\'\n\nlocal function isStream(maybe_stream)\n   return _streams[maybe_stream] or false\nend\n\nlocal function Stream(...)\n   local s = {...}\n   _streams[s] = true\n   return s\nend\n\n\n\n\n\n\n\n\nlocal Contradiction = {why = \'the-contradiction\'}\n_streams[Contradiction] = true\n\n\n\n\n\n\n\n\nlocal function walk(term, state)\n   local var = isVar(term) and term or nil\n   local subs = assert(state.subs)\n   if var and subs[term] then\n      s:verb(\"recursive walk on %s gives %s\", varStr(term), ts(subs[term]))\n      return walk(subs[term], state)\n   end\n\n   return term\nend\n\n\n\n\n\n\n\n\nlocal function unify(u, v, state)\n   assert(state.subs)\n   local u_term, v_term = walk(u, state), walk(v, state)\n   s:verb(\"∪ %s <- %s, %s <- %s\", ts(u), ts(u_term), ts(v), ts(v_term))\n   if isVar(u_term) and isVar(v_term) and (u_term == v_term) then\n      return applyConstraints(u_term, state)\n   elseif isVar(u_term) then\n      return addTerm(state, u_term, v_term)\n   elseif isVar(v_term) then\n      return addTerm(state, v_term, u_term)\n   elseif u_term == v_term then\n      return applyConstraints(u_term, applyConstraints(v_term, state, v), u)\n   end\n\n   return nil\nend\n\n\n\n\n\n\n\n\nlocal slice, splice = assert(table.slice), assert(table.splice)\n\nlocal function split(stream)\n   return stream[1], slice(stream, 2)\nend\n\nlocal function reduce(fn, array, init)\n   local val, top = init, #array\n   local idx = 1\n   if val == nil then\n      val = array[1]\n      idx = 2\n   end\n   for i = idx, top do\n      val = fn(val, array[i])\n   end\n   return val\nend\n\nlocal function straighten(head, mplused)\n   local stream;\n   if isStream(head) then\n      stream = Stream()\n      splice(stream, head)\n   else\n      stream = Stream(head)\n   end\n   if type(mplused) == \'table\' then\n      assert(isStream(mplused), \"expected stream, got \" .. ts(mplused))\n      splice(stream, mplused)\n   else\n      insert(stream, mplused)\n   end\n   return stream\nend\n\n\n\n\n\n\nlocal function mplus(s1, s2)\n   if type(s1) == \'function\' then\n      return function()\n         return mplus(s2, s1())\n      end\n   end\n   if #s1 == 0 then\n      return s2\n   end\n   -- collapse: unpack?\n   local head, tail = split(s1)\n\n   return straighten(head, mplus(tail, s2))\nend\n\n\n\n\n\n\nlocal function bind(stream, goal)\n   if type(stream) == \'function\' then\n      return function()\n         bind(stream(), goal)\n      end\n   end\n   if (not stream) or #stream == 0 then\n      return Stream() -- maybe?\n   end\n\n   local head, tail = split(stream)\n   return mplus(goal(head),\n                bind(tail, goal))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal S = {}\n\n\n\n\n\n\n\n\nlocal function eq(u, v)\n   local function _eq(state)\n      local state = unify(u, v, state)\n      if state then\n         return Stream(state)\n      else\n         return Contradiction\n      end\n   end\n\n   return _eq\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal parameters = assert(debug.parameters)\nlocal mutate = assert(table.mutate)\n\nlocal function freshvars(fn)\n   local params, vars = parameters(fn), {}\n   mutate(params, nameVar)\n   local function _fresh(state)\n      state = state or newState()\n      return fn(unpack(params))(state)\n   end\n   for _, var in ipairs(params) do\n      vars[_VarName[var]] = var\n   end\n\n   return _fresh, vars\nend\n\nlocal function fresh(fn)\n   return (freshvars(fn))\nend\n\n\n\n\n\n\n\n\nlocal function disj(...)\n   local goals = pack(...)\n   if goals.n < 2 then\n      error \"disj requires at least two goals\"\n   end\n   local function _disj(state)\n      local streams = {}\n      for i = 1, goals.n do\n         insert(streams, goals[i](state))\n      end\n      return reduce(mplus, streams)\n   end\n\n   return _disj\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function conj(...)\n   local goals = pack(...)\n   if goals.n < 2 then\n      error \"conj requires at least two goals\"\n   end\n   local function _conj(state)\n      local head, tail = split(goals)\n      return reduce(bind, tail, head(state))\n   end\n\n   return _conj\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function neq(u, v)\n   local function _neq(state)\n      local a = unify(u, v, state)\n      if a == nil then\n         return Stream(state)\n      else\n         return Contradiction\n      end\n   end\n\n   return _neq\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function enbooleanate(fn, arity)\n   if arity == 1 then\n      return function(a)\n         return not not fn(a)\n      end\n   elseif arity == 2 then\n      return function(a, b)\n         return not not fn(a, b)\n      end\n   else\n      error \"excessive or missing arity, cannot enbooleanate\"\n   end\nend\n\n\n\nlocal function predicate(pred, a)\n   pred = enbooleanate(pred, 1)\n   local function _goal(state)\n      s:chat(\"trying predicate goal\")\n      local term = walk(a, state)\n      if isVar(term) then\n         s:chat(\"constraining %s with predicate\", ts(term))\n         return Stream(withConstraint(state, term, pred))\n      end\n      s:chat(\"trying predicate on %s\", ts(term))\n      if pred(term) then\n         return Stream(state)\n      end\n\n      return Contradiction\n   end\n\n   return _goal\nend\n\n\n\n\n\nlocal function predicatø(p)\n   return function(a)\n      return predicate(p, a)\n   end\nend\n\n\n\nlocal function eqt(a, of_type)\n   return predicate(function(a)\n      return type(a) == of_type\n   end, a)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function otherway(fn)\n   return function(a, b)\n      return fn(b, a)\n   end\nend\n\nlocal curry = assert(core.fn.curry)\n\nlocal function relation(rel, a, b)\n   rel = enbooleanate(rel, 2)\n   local ler = otherway(rel) -- rel(a, b) == ler(b, a)\n\n   local function _goal(state)\n      s:bore(\"trying relational goal on %s and %s\", ts(a), ts(b))\n      local a_term, b_term = walk(a, state), walk(b, state)\n      s:bore(\"results of walk: %s, %s\", ts(a_term), ts(b_term))\n      local avar, bvar = isVar(a_term), isVar(b_term)\n      s:bore(\"avar %s, bvar %s\", avar, bvar)\n      if avar and (not bvar) then\n         s:bore(\"constraining left\")\n\n         return Stream(withConstraint(state, a_term, curry(ler, b_term)))\n      elseif bvar and (not avar) then\n         s:bore(\"constraining right\")\n         return Stream(withConstraint(state, b_term, curry(rel, a_term)))\n      elseif avar and bvar then\n         -- ok.\n         -- what we have to do here is apply some form of constraint such that\n         -- as possible literal values come along we add *all of them* as\n         -- possibilities on the left and right side, and try all combinations\n         -- of two once.  Or at least try all combination of two.\n         --\n         -- really feels like I\'m missing something here.\n         return Stream(withRelation(state, a_term, b_term, rel))\n      end\n\n      if rel(a_term, b_term) then\n         return Stream(state)\n      end\n\n      return Contradiction\n   end\n\n   return _goal\nend\n\n\n\nlocal function defrel(rel)\n   return function(a, b)\n      return relation(rel, a, b)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function fieldø(a, b)\n   return relation(function(a, b)\n      return type(a) == \'table\' and a[b]\n   end, a, b)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function stateFor(vars, map)\n   local subs = {}\n   for k, v in pairs(map) do\n      subs[assert(vars[k])] =  v\n   end\n   return newState(subs)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function confirmValue(is_var, is_val, answers)\n   if not is_var then return end\n   -- go through the stream looking for state[var] == value\n   -- needs to handle function streams\n   for _, stream in ipairs(answers) do\n      s:chat(\"checking %s against %s\", ts(is_var), ts(stream))\n      s:chat(\"stream[var] -> %s\", ts(stream[is_var]))\n      if type(stream) == \'function\' then\n         local answer = stream()[1] -- should at least be Contradiction aka {}\n         if answer and answer.subs and answer.subs[is_var] == val then\n            return true\n         end\n      elseif stream.subs and stream.subs[is_var] == is_val then\n         return true\n      end\n   end\n   return false\nend\n\n\n\n\nlocal function demonstrate(goalfn, vars,  ...)\n   local answers = goalfn()\n   s:chat \"demonstrating goal\"\n   for i = 1, select(\'#\', ...) do\n      local must_be = select(i, ...)\n      s:chat(\"must be: \" .. ts(must_be))\n      for is_name, is_val in pairs(must_be) do\n         local is_var = assert(vars[is_name], \"missing var for \" .. is_name)\n         return confirmValue(is_var, is_val, answers)\n      end\n   end\n\nend\n\n\n\n\n\n\n\nreturn { fresh = fresh,\n         freshvars = freshvars,\n         conj = conj,\n         disj = disj,\n         eq = eq,\n         neq = neq,\n         eqt = eqt,\n         fieldø = fieldø,\n         predicatø = predicatø,\n         defrel = defrel,\n         demonstrate = demonstrate,\n         stateFor = stateFor,\n         ts = ts,\n         State = newState, }\n\n",
vc_hash = "35587d21f9545b212ccb52ef2deb7d5c0478be86\n",
name = "kinkan",
branch = "modular-kinkan",
},
  { 
hash = "90dff4a22a356a345d92c17a5fc35c2bbc282af740e6fcfe7c721371c935df7b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table = core.table\nlocal string = core.string\nlocal debug = core.debug\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = true\ns.boring = true\nlocal c = require \"singletons:color\" . color\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal newproxy, weak = assert(newproxy),\n                       assert(core.meta.weak)\n\nlocal _Vars = weak \'k\'\nlocal _VarName = weak \'k\'\n\nlocal var_ct = 0\n\nlocal function Var(num)\n   num = num or 1\n   var_ct = var_ct + 1\n   local var = newproxy()\n   _Vars[var] = var_ct\n   if num <= 1 then\n      return var\n   else\n      return var, Var(num - 1)\n   end\nend\n\nlocal function isVar(maybe_var)\n   return _Vars[maybe_var]\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function nameVar(name)\n   local var = Var()\n   _VarName[var] = name\n   return var\nend\n\n\nlocal function varStr(var)\n   local name = _VarName[var]\n   if name then\n      return c.field(name .. \"#\" .. _Vars[var])\n   else\n      return c.field(\"_.\" .._Vars[var])\n   end\nend\n\n\n\n\n\n\n\nlocal _ts = require \"repr:repr\" . ts_color\n\nlocal function ts(value)\n   if isVar(value) then\n      return varStr(value)\n   else\n      return _ts(value)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal State_M, Sub_M = {}, {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function struct_eq()\n   return function(s1, s2)\n      local same = true\n      for k, v in pairs(s1) do\n         if s2[k] ~= v then\n            same = false\n            break\n         end\n      end\n      if (not same) then return false end\n      for k, v in pairs(s2) do\n         if s1[k] ~= v then\n            same = false\n            break\n         end\n      end\n      return same\n   end\nend\n\n\n\nState_M.__eq, Sub_M.__eq = struct_eq(), struct_eq()\n\n\n\n\n\n\n\n\n\nlocal lines = assert(string.lines)\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\nfunction State_M.__repr(state)\n   local repr = {\"⊰ \"}\n   for var, term in pairs(state.subs) do\n      insert(repr, ts(var) .. \" ≡ \" .. ts(term))\n      insert(repr, \"\\n\")\n   end\n   repr[#repr] = \" ⊱\"\n   return lines(concat(repr))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal clone1, clone = assert(table.clone1), assert(table.clone)\n\n\n\n\n\n\n\n\n\nlocal function isState(maybe_state)\n   assert(type(maybe_state) == \'table\')\n   return getmetatable(maybe_state) == State_M\nend\n\nlocal function isSub(maybe_sub)\n   assert(type(maybe_sub) == \'table\')\n   return getmetatable(maybe_sub) == Sub_M\nend\n\nlocal function newState(subs)\n   subs = setmetatable(subs or {}, Sub_M)\n   return setmetatable({subs = subs}, State_M)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function walk(term, state)\n   local var = isVar(term) and term or nil\n   local subs = assert(state.subs)\n   if var and subs[term] then\n      s:verb(\"recursive walk on %s gives %s\", varStr(term), ts(subs[term]))\n      return walk(subs[term], state)\n   end\n\n   return term\nend\n\n\n\n\n\n\n\n\nlocal function extendSubs(subs, var, target)\n   if not isSub(subs) then\n      s:halt(\"is this: %s a stream? %s\", ts(subs), isStream(subs))\n   end\n   local new = clone(subs, 1)\n   s:bore(\"extending %s with %s\", varStr(var), ts(target))\n   new[var] = target\n   return new\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function constrain(var, var_cons, target)\n   s:verb(\"applying constraints to %s = %s\", ts(var), ts(target))\n   for _, con in ipairs(var_cons) do\n      if type(con) == \'function\' then\n         if not con(target) then\n            s:chat(\"target has failed constraint\")\n            return false\n         end\n      else\n         s:bore(\"owo what\'s this? %s\", ts(con))\n         local fn, left, right, idx = con[1], con[2], con[3], con[var]\n         local other;\n         if (idx == 1) then\n            other = right\n         else\n            other = left\n         end\n         if (other ~= nil) then\n            if (idx == 1) then\n               if not fn(target, other) then\n                  s:chat(\"target has failed relation\")\n                  return false\n               end\n            else\n               assert(idx == 2)\n               if not fn(other, target) then\n                  s:chat(\"target has failed relation\")\n                  return false\n               end\n            end\n         else\n            -- This is potentially destructive.  I haven\'t made that cause\n            -- problems yet, but it might.\n            s:bore(\"constraining %d of relation as %s = %s\", idx, ts(var), ts(target))\n            con[idx + 1] = target\n         end\n      end\n   end\n\n   return true\nend\n\n\n\n\n\n\n\n\n\n\nlocal function applyConstraints(target, state, var)\n   if not state then return nil end\n   s:bore(\"constraints state %s\", ts(state.cons))\n   if not isVar(target) then\n      local var_cons = state.cons and state.cons[var]\n      if var_cons then\n         s:bore(\"var_cons %s\", var_cons)\n         local cons_ok = constrain(var, var_cons, target)\n         if not cons_ok then return nil end\n      else\n         s:bore(\"no constraints to apply to %s\", ts(target))\n      end\n   end\n\n   return state\nend\n\n\n\n\n\n\n\n\n\nlocal function addTerm(state, var, target)\n   local subs = extendSubs(state.subs, var, target)\n   local _state = {}\n   for k, v in pairs(state) do\n      if k ~= \'subs\' then\n         _state[k] = v\n      else\n         _state[k] = subs\n      end\n   end\n   -- constrain nonvariable targets\n   setmetatable(_state, State_M)\n   if not applyConstraints(target, _state, var) then return nil end\n   return _state\nend\n\n\n\n\n\n\n\n\n\nlocal function _extendConstraint(cons, var, fn)\n   if cons then\n      local var_cons = cons[var]\n      if var_cons then\n         local new_vcons, new_cons = clone1(var_cons), {}\n         insert(new_vcons, fn)\n         for v, con in pairs(cons) do\n            if v == var then\n               new_cons[v] = new_vcons\n            else\n               new_cons[v] = clone1(con)\n            end\n         end\n         return new_cons\n      else\n         local new_cons = clone(cons)\n         new_cons[var] = {fn}\n         return new_cons\n      end\n   else\n      return {[var] = {fn}}\n   end\nend\n\nlocal function withConstraint(state, var, fn)\n   local _state = { subs = state.subs,\n                    types = state.types }\n\n   _state.cons = _extendConstraint(state.cons, var, fn)\n   s:bore(\"constraints of %s are %s\", ts(var), ts(fn))\n   return setmetatable(_state, State_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function withRelation(state, a, b, rel)\n   local _state = { subs = state.subs,\n                    types = state.types }\n   -- the relation is the first argument, 2 and 3 are filled later\n   local bundle = {rel}\n   -- arity for each variable keyed by var\n   bundle[a] = 1\n   bundle[b] = 2\n   _state.cons = _extendConstraint(_extendConstraint(state.cons, a, bundle),\n                                   b, bundle)\n   return setmetatable(_state, State_M)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _streams = weak \'k\'\n\nlocal function isStream(maybe_stream)\n   return _streams[maybe_stream] or false\nend\n\nlocal function Stream(...)\n   local s = {...}\n   _streams[s] = true\n   return s\nend\n\n\n\n\n\nlocal function fnStream(fn)\n   _streams[fn] = true\n   return fn\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Contradiction = {why = \'the-contradiction\'}\n_streams[Contradiction] = true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function unify(u, v, state)\n   assert(state.subs)\n   local u_term, v_term = walk(u, state), walk(v, state)\n   s:verb(\"∪ %s <- %s, %s <- %s\", ts(u), ts(u_term), ts(v), ts(v_term))\n   if isVar(u_term) and isVar(v_term) and (u_term == v_term) then\n      return applyConstraints(u_term, state)\n   elseif isVar(u_term) then\n      return addTerm(state, u_term, v_term)\n   elseif isVar(v_term) then\n      return addTerm(state, v_term, u_term)\n   elseif u_term == v_term then\n      return applyConstraints(u_term, applyConstraints(v_term, state, v), u)\n   end\n\n   return nil\nend\n\n\n\n\n\n\n\n\nlocal function eq(u, v)\n   local function _eq(state)\n      local state = unify(u, v, state)\n      if state then\n         return Stream(state)\n      else\n         return Contradiction\n      end\n   end\n\n   return _eq\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal slice, splice = assert(table.slice), assert(table.splice)\n\nlocal function split(stream)\n   return stream[1], slice(stream, 2)\nend\n\nlocal function straighten(head, mplused)\n   local stream;\n   if isStream(head) then\n      stream = Stream()\n      splice(stream, head)\n   else\n      stream = Stream(head)\n   end\n   if type(mplused) == \'table\' then\n      assert(isStream(mplused), \"expected stream, got \" .. ts(mplused))\n      splice(stream, mplused)\n   else\n      insert(stream, mplused)\n   end\n   return stream\nend\n\n\n\n\n\n\n\n\n\n\nlocal function mplus(s1, s2)\n   if type(s1) == \'function\' then\n      return function()\n         return mplus(s2, s1())\n      end\n   end\n\n   if #s1 == 0 then\n      return s2\n   end\n\n   local head, tail = split(s1)\n\n   return straighten(head, mplus(tail, s2))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function bind(stream, goal)\n   if type(stream) == \'function\' then\n      return function()\n         bind(stream(), goal)\n      end\n   end\n   if (not stream) or #stream == 0 then\n      return Stream() -- maybe?\n   end\n\n   local head, tail = split(stream)\n   return mplus(goal(head),\n                bind(tail, goal))\nend\n\n\n\n\n\n\n\n\n\nlocal function reduce(fn, array, init)\n   local val, top = init, #array\n   local idx = 1\n   if val == nil then\n      val = array[1]\n      idx = 2\n   end\n   for i = idx, top do\n      val = fn(val, array[i])\n   end\n   return val\nend\n\n",
vc_hash = "35587d21f9545b212ccb52ef2deb7d5c0478be86\n",
name = "kernel",
branch = "modular-kinkan",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/repr.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "repr",
    repo = "git@gitlab.com:special-circumstance/repr.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "7d35adce62f887efb0685cd1ec4e72dd9ac53ab8e1991c25e382e0df6ee5721e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core:cluster\" . Meta\nlocal Token = require \"repr:repr/token\"\nlocal Window = require \"window:window\"\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\nlocal Composer = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\nfunction Composer.indent(composer)\n   -- If the first token is the second half of a wrap--it is marked as wrapped\n   -- and has a start offset--we won\'t include any indentation\n   if composer.pos > 0 and\n      composer[1].wrapped and\n      composer[1].start > 1 then\n      return 0\n   end\n   return 2 * composer.level\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.disp(composer)\n   local disp = composer:indent()\n   for i = 1, composer.pos do\n      disp = disp + (composer[i].total_disp or 0)\n   end\n   return disp\nend\n\n\n\n\n\n\n\n\nfunction Composer.remains(composer)\n   return composer.width - composer:disp()\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.peek(composer)\n   if composer.more and not composer[composer.pos + 1] then\n      composer[composer.pos + 1] = composer.token_source()\n   end\n   if not composer[composer.pos + 1] then\n      composer.more = false\n   end\n   return composer[composer.pos + 1]\nend\n\n\n\n\n\n\n\n\n\n\nfunction Composer.advance(composer)\n   local token = composer:peek()\n   if token then\n      composer.pos = composer.pos + 1\n   end\n   return token, composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal STAGED_EVENTS = {\n   array = true,\n   map = true\n}\n\nfunction Composer.checkPushStage(composer)\n   local token = composer[composer.pos]\n   if STAGED_EVENTS[token.event] then\n      insert(composer.stages, {\n         start_token = token,\n         event = token.event,\n         long = false })\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Composer.checkPopStage(composer)\n   local token = composer[composer.pos]\n   if token.event == \"end\" then\n      local next_token = composer:peek()\n      -- If the following token is a separator, don\'t end the stage here...\n      if not (next_token and next_token.event == \"sep\") then\n         remove(composer.stages)\n      end\n   elseif token.event == \"sep\" then\n      local prev = composer[composer.pos - 1]\n      -- ...because, if we encounter a separator and the *previous* token\n      -- is an =end=, *now* it\'s time to end the stage\n      if prev and prev.event == \"end\" then\n         remove(composer.stages)\n      end\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.enterLongMode(composer)\n   for i = 1, composer.level do\n      assert(composer.stages[i].long,\n         \"Cannot print a long stage inside a short one\")\n   end\n   local long_stage_index = composer.level\n   local stage\n   repeat\n      long_stage_index = long_stage_index + 1\n      stage = composer.stages[long_stage_index]\n      assert(stage, \"No new stage to put in long mode\")\n   until not stage.long\n   stage.long = true\n   for i = long_stage_index + 1, #composer.stages do\n      composer.stages[i] = nil\n   end\n   for i, token in ipairs(composer) do\n      if token == stage.start_token then\n         composer.pos = i\n         return token, composer.stages[#composer.stages]\n      end\n   end\n   error(\"Could not find start of stage\")\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.emit(composer)\n   if composer.pos == 0 then\n      return nil\n   end\n   local output = { (\" \"):rep(composer:indent()) }\n   for i = 1, composer.pos do\n      insert(output, composer[i]:toString(composer.color))\n   end\n   -- Erase what we just copied to the output and shift\n   -- any remaining tokens back\n   for i = 1, #composer do\n      if i > composer.pos then\n         composer[i - composer.pos] = composer[i]\n      end\n      composer[i] = nil\n   end\n   composer.pos = 0\n   composer.level = #composer.stages\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\nlocal function errLine(...)\n   io.stderr:write(format(...))\n   io.stderr:write(\"\\n\")\n   io.stderr:flush()\nend\nfunction Composer.logDebugInfo(composer)\n   errLine((\"=\"):rep(40))\n   errLine(\"STAGES (level = %d):\", composer.level)\n   for i = 0, #composer.stages do\n      local stage = composer.stages[i]\n      errLine(\"%d: %s (%s)%s\",\n         i,\n         stage.event,\n         stage.long and \"long\" or \"short\",\n         i == composer.level and \" <- LEVEL\" or \"\")\n   end\n   errLine((\"-\"):rep(40))\n   errLine(\"TOKENS (width = %d, disp = %d, remains = %d):\",\n      composer.width, composer:disp(), composer:remains())\n   for i, token in ipairs(composer) do\n      errLine(\"%02d   %s%s\",\n         token.total_disp, tostring(token),\n         i == composer.pos and \" <- POS\" or \"\")\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal MIN_SPLIT_WIDTH = 20\n\nfunction Composer.splitToken(composer)\n   local token = composer[composer.pos]\n   -- Step back one token to exclude the one we\'re about to split\n   composer.pos = composer.pos - 1\n   -- Reserve one space for the ~ indicating a wrapped line\n   local remaining = composer:remains() - 1\n   token.wrapped = true\n   -- Only split strings, and only if they\'re long enough to be worth it\n   -- In the extreme event that a non-string token is longer than the\n   -- entire available width, split it too to avoid an infinite loop\n   if token.wrappable and token.total_disp > MIN_SPLIT_WIDTH\n      or token.total_disp >= composer.width then\n      token = token:split(remaining)\n      -- Pad with spaces if we were forced to split a couple chars short\n      for _ = 1, remaining - token.total_disp do\n         token:insert(\" \")\n      end\n   -- Short strings and other token types just get bumped to the next line\n   else\n      token = Token((\" \"):rep(remaining), { color = \"no_color\" })\n   end\n   -- Done splitting, step forward again\n   composer.pos = composer.pos + 1\n   insert(composer, composer.pos, token)\n   -- Leave the ~ ready to be consumed by the next advance()--we need to finish\n   -- processing the first half of the split first.\n   insert(composer, composer.pos + 1, Token(\"~\", { color = \"alert\", event = \"break\" }))\n   return token\nend\n\n\n\n\n\n\nfunction Composer.isReadyToEmit(composer)\n   local token, stage = composer[composer.pos], composer.stages[#composer.stages]\n   -- It\'s a forced break, obviously end of line\n   if token:isForceBreak() then return true end\n   -- We\'re in short mode, so no other break conditions are possible\n   if not stage.long then return false end\n   -- Break on separators, which includes after the arrow in a metatable\n   -- and after the metatable itself\n   if token.event == \"sep\" then return true end\n   -- At this point, the only possible place to break is after an opening brace\n   if token ~= stage.start_token then return false end\n   -- But not after the very outermost opening brace\n   if #composer.stages == 1 then return false end\n   -- Nor if the table has a metatable\n   local next_token = composer:peek()\n   if next_token and next_token.event == \"metatable\" then return false end\n   -- Nor after the opening brace *of* a metatable\n   local prev_token = composer[composer.pos - 1]\n   if prev_token and prev_token.event == \"metatable\" then return false end\n   -- Okay, we\'ve run the gauntlet, yes, this is a good place to stop\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.composeLine(composer)\n   repeat\n      local token = composer:advance()\n      if not token then break end\n\n      local stage = composer:checkPushStage()\n      if not stage then\n         error(\"No stage while processing: \" .. tostring(token))\n      end\n\n      if token:isForceBreak() and not stage.long then\n         token, stage = composer:enterLongMode()\n      end\n      -- If we know we are going to end the line after this token no matter\n      -- what, we can allow it to exactly fill the line--no need to reserve\n      -- space for a ~. We can also ignore any trailing spaces it may contain.\n      -- Note, we don\'t want to mess with repr lines here.\n      local reserved_space = 1\n      if composer:isReadyToEmit() and token.event ~= \"repr_line\" then\n         token:removeTrailingSpaces()\n         reserved_space = 0\n      end\n      if composer:remains() < reserved_space then\n         assert(token.event ~= \"break\", \"~ token overflowing line\")\n         if not stage.long then\n            token, stage = composer:enterLongMode()\n         -- Never wrap output from __repr--likely to do more harm than good\n         -- until/unless we can parse out color escape sequences\n         elseif token.event ~= \"repr_line\" then\n            token = composer:splitToken()\n         end\n      end\n      stage = composer:checkPopStage()\n   until composer:isReadyToEmit()\n\n   return composer:emit()\nend\n\nComposer.__call = Composer.composeLine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal window_cfg = {}\n\nwindow_cfg.field = { width = true, color = true }\nwindow_cfg.value = { depth = true, cycle = true }\nwindow_cfg.fn    = { remains = Composer.remains, case = Composer.case }\n\n\nfunction Composer.window(composer)\n   return Window(composer, window_cfg)\nend\n\n\n\n\n\n\nlocal function new(iter_gen, cfg)\n   cfg = cfg or {}\n   local function generator(val, disp_width, color)\n      assert(color, \"Must provide a color table to Composer\")\n      local width = disp_width or 80\n      local composer = setmetatable({\n         color = color,\n         width = width,\n         more = true,\n         pos = 0,\n         stages = {[0] = { long = true }},\n         level = 0,\n         long = false\n      }, Composer)\n      for k,v in pairs(cfg) do\n        composer[k] = v\n      end\n      composer.token_source = iter_gen(val, composer:window(), color)\n      return composer\n   end\n   return generator\nend\n\nComposer.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/composer",
branch = "viewer",
},
  { 
hash = "ececaf8faacbf208678d62484ec8f987a523ff5eaf312b0cc5d5b47e01e97948",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core:cluster\" . Meta\nlocal Token = require \"repr:repr/token\"\nlocal Window = require \"window:window\"\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\nlocal Composer = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\nfunction Composer.indent(composer)\n   -- If the first token is the second half of a wrap--it is marked as wrapped\n   -- and has a start offset--we won\'t include any indentation\n   if composer.pos > 0 and\n      composer[1].wrapped and\n      composer[1].start > 1 then\n      return 0\n   end\n   return 2 * composer.level\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.disp(composer)\n   local disp = composer:indent()\n   for i = 1, composer.pos do\n      disp = disp + (composer[i].total_disp or 0)\n   end\n   return disp\nend\n\n\n\n\n\n\n\n\nfunction Composer.remains(composer)\n   return composer.width - composer:disp()\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.peek(composer)\n   if composer.more and not composer[composer.pos + 1] then\n      composer[composer.pos + 1] = composer.token_source()\n   end\n   if not composer[composer.pos + 1] then\n      composer.more = false\n   end\n   return composer[composer.pos + 1]\nend\n\n\n\n\n\n\n\n\n\n\nfunction Composer.advance(composer)\n   local token = composer:peek()\n   if token then\n      composer.pos = composer.pos + 1\n   end\n   return token, composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal STAGED_EVENTS = {\n   array = true,\n   map = true\n}\n\nfunction Composer.checkPushStage(composer)\n   local token = composer[composer.pos]\n   if STAGED_EVENTS[token.event] then\n      insert(composer.stages, {\n         start_token = token,\n         event = token.event,\n         long = false })\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Composer.checkPopStage(composer)\n   local token = composer[composer.pos]\n   if token.event == \"end\" then\n      local next_token = composer:peek()\n      -- If the following token is a separator, don\'t end the stage here...\n      if not (next_token and next_token.event == \"sep\") then\n         remove(composer.stages)\n      end\n   elseif token.event == \"sep\" then\n      local prev = composer[composer.pos - 1]\n      -- ...because, if we encounter a separator and the *previous* token\n      -- is an =end=, *now* it\'s time to end the stage\n      if prev and prev.event == \"end\" then\n         remove(composer.stages)\n      end\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.enterLongMode(composer)\n   for i = 1, composer.level do\n      assert(composer.stages[i].long,\n         \"Cannot print a long stage inside a short one\")\n   end\n   local long_stage_index = composer.level\n   local stage\n   repeat\n      long_stage_index = long_stage_index + 1\n      stage = composer.stages[long_stage_index]\n      assert(stage, \"No new stage to put in long mode\")\n   until not stage.long\n   stage.long = true\n   for i = long_stage_index + 1, #composer.stages do\n      composer.stages[i] = nil\n   end\n   for i, token in ipairs(composer) do\n      if token == stage.start_token then\n         composer.pos = i\n         return token, composer.stages[#composer.stages]\n      end\n   end\n   error(\"Could not find start of stage\")\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.emit(composer)\n   if composer.pos == 0 then\n      return nil\n   end\n   local output = { (\" \"):rep(composer:indent()) }\n   for i = 1, composer.pos do\n      insert(output, composer[i]:toString(composer.color))\n   end\n   -- Erase what we just copied to the output and shift\n   -- any remaining tokens back\n   for i = 1, #composer do\n      if i > composer.pos then\n         composer[i - composer.pos] = composer[i]\n      end\n      composer[i] = nil\n   end\n   composer.pos = 0\n   composer.level = #composer.stages\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\nlocal function errLine(...)\n   io.stderr:write(format(...))\n   io.stderr:write(\"\\n\")\n   io.stderr:flush()\nend\nfunction Composer.logDebugInfo(composer)\n   errLine((\"=\"):rep(40))\n   errLine(\"STAGES (level = %d):\", composer.level)\n   for i = 0, #composer.stages do\n      local stage = composer.stages[i]\n      errLine(\"%d: %s (%s)%s\",\n         i,\n         stage.event,\n         stage.long and \"long\" or \"short\",\n         i == composer.level and \" <- LEVEL\" or \"\")\n   end\n   errLine((\"-\"):rep(40))\n   errLine(\"TOKENS (width = %d, disp = %d, remains = %d):\",\n      composer.width, composer:disp(), composer:remains())\n   for i, token in ipairs(composer) do\n      errLine(\"%02d   %s%s\",\n         token.total_disp, tostring(token),\n         i == composer.pos and \" <- POS\" or \"\")\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal MIN_SPLIT_WIDTH = 20\n\nfunction Composer.splitToken(composer, token)\n   local token = composer[composer.pos]\n   -- Step back one token to exclude the one we\'re about to split\n   composer.pos = composer.pos - 1\n   -- Reserve one space for the ~ indicating a wrapped line\n   local remaining = composer:remains() - 1\n   token.wrapped = true\n   -- Only split strings, and only if they\'re long enough to be worth it\n   -- In the extreme event that a non-string token is longer than the\n   -- entire available width, split it too to avoid an infinite loop\n   if token.wrappable and token.total_disp > MIN_SPLIT_WIDTH\n      or token.total_disp >= composer.width then\n      token = token:split(remaining)\n      -- Pad with spaces if we were forced to split a couple chars short\n      for i = 1, remaining - token.total_disp do\n         token:insert(\" \")\n      end\n   -- Short strings and other token types just get bumped to the next line\n   else\n      token = Token((\" \"):rep(remaining), { color = \"no_color\" })\n   end\n   -- Done splitting, step forward again\n   composer.pos = composer.pos + 1\n   insert(composer, composer.pos, token)\n   -- Leave the ~ ready to be consumed by the next advance()--we need to finish\n   -- processing the first half of the split first.\n   insert(composer, composer.pos + 1, Token(\"~\", { color = \"alert\", event = \"break\" }))\n   return token\nend\n\n\n\n\n\n\nfunction Composer.isReadyToEmit(composer)\n   local token, stage = composer[composer.pos], composer.stages[#composer.stages]\n   -- It\'s a forced break, obviously end of line\n   if token:isForceBreak() then return true end\n   -- We\'re in short mode, so no other break conditions are possible\n   if not stage.long then return false end\n   -- Break on separators, which includes after the arrow in a metatable\n   -- and after the metatable itself\n   if token.event == \"sep\" then return true end\n   -- At this point, the only possible place to break is after an opening brace\n   if token ~= stage.start_token then return false end\n   -- But not after the very outermost opening brace\n   if #composer.stages == 1 then return false end\n   -- Nor if the table has a metatable\n   local next_token = composer:peek()\n   if next_token and next_token.event == \"metatable\" then return false end\n   -- Nor after the opening brace *of* a metatable\n   local prev_token = composer[composer.pos - 1]\n   if prev_token and prev_token.event == \"metatable\" then return false end\n   -- Okay, we\'ve run the gauntlet, yes, this is a good place to stop\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.composeLine(composer)\n   repeat\n      local token = composer:advance()\n      if not token then break end\n\n      local stage = composer:checkPushStage()\n      if not stage then\n         error(\"No stage while processing: \" .. tostring(token))\n      end\n\n      if token:isForceBreak() and not stage.long then\n         token, stage = composer:enterLongMode()\n      end\n      -- If we know we are going to end the line after this token no matter\n      -- what, we can allow it to exactly fill the line--no need to reserve\n      -- space for a ~. We can also ignore any trailing spaces it may contain.\n      -- Note, we don\'t want to mess with repr lines here.\n      local reserved_space = 1\n      if composer:isReadyToEmit() and token.event ~= \"repr_line\" then\n         token:removeTrailingSpaces()\n         reserved_space = 0\n      end\n      if composer:remains() < reserved_space then\n         assert(token.event ~= \"break\", \"~ token overflowing line\")\n         if not stage.long then\n            token, stage = composer:enterLongMode()\n         -- Never wrap output from __repr--likely to do more harm than good\n         -- until/unless we can parse out color escape sequences\n         elseif token.event ~= \"repr_line\" then\n            token = composer:splitToken()\n         end\n      end\n      stage = composer:checkPopStage()\n   until composer:isReadyToEmit()\n\n   return composer:emit()\nend\n\nComposer.__call = Composer.composeLine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal window_cfg = {}\n\nwindow_cfg.field = { width = true, color = true }\nwindow_cfg.value = { depth = true, cycle = true }\nwindow_cfg.fn    = { remains = Composer.remains, case = Composer.case }\n\n\nfunction Composer.window(composer)\n   return Window(composer, window_cfg)\nend\n\n\n\n\n\n\n\n\nlocal function new(iter_gen, cfg)\n   cfg = cfg or {}\n   local function generator(val, disp_width, color)\n      assert(color, \"Must provide a color table to Composer\")\n      local width = disp_width or 80\n      local composer = setmetatable({\n         color = color,\n         width = width,\n         more = true,\n         pos = 0,\n         stages = {[0] = { long = true }},\n         level = 0,\n         long = false\n      }, Composer)\n      for k,v in pairs(cfg) do\n        composer[k] = v\n      end\n      composer.token_source = iter_gen(val, composer:window(), color)\n      return composer\n   end\n   return generator\nend\n\nComposer.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/compositor",
branch = "viewer",
},
  { 
hash = "3f75fcdf3e2d6032edfda6021360d54bfb470234e46ac21e74c31ed9ed37ba45",
binary = "\n\n\n\n\n\n\nlocal Token = require \"repr:token\"\nlocal string = require \"core:string\"\n\n\n\n\n\nlocal names = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anti_G = setmetatable({ _G = \"_G\" }, {__mode = \"k\"})\nnames.all_symbols = { _G = true }\nnames.anti_G = anti_G\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function tie_break(old, new)\n   return #old > #new\nend\n\nlocal isidentifier = assert(string.isidentifier)\n\nlocal addName, loadNames\n\naddName = function(value, name, aG)\n   local existing = aG[value]\n   if not existing or tie_break(existing, name) then\n      aG[value] = name\n      if type(value) == \"table\" then\n         loadNames(value, name, aG)\n      end\n   end\nend\n\nloadNames = function(tab, prefix, aG)\n   if prefix ~= \"\" then\n      prefix = prefix .. \".\"\n   end\n   aG = aG or anti_G\n   for k, v in pairs(tab) do\n      if type(k) == \"string\" then\n         -- Only add legal identifiers to all_symbols, since this is\n         -- used for autocomplete\n         if isidentifier(k) then\n            names.all_symbols[k] = true\n         end\n      else\n         -- #todo should we put <> around non-identifier strings? I guess\n         -- it seems fine not to, since this is just for display...\n         k = \"<\" .. tostring(k) .. \">\"\n      end\n      local name = prefix .. k\n      local typica = type(v)\n      if typica == \"table\"  or typica == \"function\"\n      or typica == \"thread\" or typica == \"userdata\" then\n         addName(v, name, aG)\n      end\n      local _M = getmetatable(v)\n      if typica == \"table\" and _M then\n         addName(_M, \"⟨\" .. name .. \"⟩\", aG)\n      end\n   end\nend\n\nfunction names.addName(value, name, aG)\n   aG = aG or anti_G\n   addName(value, name, aG)\nend\n\nfunction names.loadNames(tab, prefix, aG)\n   tab = tab or _G\n   prefix = prefix or \"\"\n   aG = aG or anti_G\n   loadNames(tab, prefix, aG)\nend\n\nfunction names.clearNames()\n   anti_G = {_G = \"_G\"}\n   names.all_symbols = {}\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _rawtostring(val)\n   local ts\n   if type(val) == \"table\" then\n      -- get metatable and check for __tostring\n      local M = getmetatable(val)\n      if M and M.__tostring then\n         -- cache the tostring method and put it back\n         local __tostring = M.__tostring\n         M.__tostring = nil\n         ts = tostring(val)\n         M.__tostring = __tostring\n      end\n   end\n   if not ts then\n      ts = tostring(val)\n   end\n   return ts\nend\n\nfunction names.nameFor(value, c, aG, hint)\n   local str\n   -- Hint provides a means to override the \"type\" of the value,\n   -- to account for cases more specific than mere type\n   local typica = hint or type(value)\n   -- Start with the color corresponding to the type--may be overridden below\n   local cfg = { color = typica }\n\n   -- Value types are generally represented by their tostring()\n   if typica == \"string\"\n      or typica == \"number\"\n      or typica == \"boolean\"\n      or typica == \"nil\" then\n      str = tostring(value)\n      if typica == \"string\" then\n         cfg.wrappable = true\n      elseif typica == \"boolean\" then\n         cfg.color = str -- i.e. \"true\" or \"false\"\n      end\n      return Token(str, cfg)\n   end\n\n   -- For other types, start by looking for a name in anti_G:\n   aG = aG or anti_G\n   if aG[value] then\n      str = aG[value]\n      if typica == \"thread\" then\n         -- Prepend coro: even to names from anti_G to more clearly\n         -- distinguish from functions\n         str = \"coro:\" .. str\n      end\n      return Token(str, cfg)\n   end\n\n   -- If not found, construct one starting with the tostring()\n   str = _rawtostring(value)\n   if typica == \"metatable\" then\n      str = \"⟨\" .. \"mt:\" .. str:sub(-6) .. \"⟩\"\n   elseif typica == \"table\" then\n      str = \"t:\" .. str:sub(-6)\n   elseif typica == \"function\" then\n      local f_label = str:sub(11)\n      str = f_label:sub(1,5) == \"built\"\n                and f_label\n                or \"f:\" .. str:sub(-6)\n   elseif typica == \"thread\" then\n      str = \"coro:\" .. str:sub(-6)\n   elseif typica == \"userdata\" then\n      local name_end = str:find(\":\")\n      if name_end then\n         str = str:sub(1, name_end - 1)\n      end\n   end\n\n   return Token(str, cfg)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function c_data(value, str, phrase)\n   --local meta = reflect.getmetatable(value)\n   coroutine.yield(str, #str)\n   --[[\n   if meta then\n      yield(c.base \" = \", 3)\n      yield_name(meta)\n   end\n   --]]\nend\n\n\n\nreturn names\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/names",
branch = "viewer",
},
  { 
hash = "\n\n\n\n\n\n\n\n\nreturn require \"repr:repr/tablib\" . tabulate\n\n",
binary = "\n\n\n\n\n\n\n\n\nreturn require \"repr:repr/tablib\" . tabulate\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/tabulate",
branch = "viewer",
},
  { 
hash = "990b6ef77266624d0141b587d475761245bf5c86d02216a9356e1e23c8c497f2",
binary = "\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table, string = core.table, core.string\n\nlocal core = require \"qor:core\"\nlocal Token = require \"repr:token\"\n\nlocal cluster = require \"cluster:cluster\"\nlocal sortedpairs = assert(core.table.sortedpairs)\nlocal assertfmt = assert(core.string.assertfmt)\nlocal hasmetamethod = assert(core.meta.hasmetamethod)\nlocal names = require \"repr:names\"\nlocal nameFor =  assert(names.nameFor)\nlocal C = require \"singletons:color\"\nlocal nest = assert(core.thread.nest) \'repr\'\nlocal Wrap, Yield = assert(nest.wrap), assert(nest.yield)\n\n\n\n\n\n\n\n\nlocal hasmetamethod = assert(require \"core/meta\" . hasmetamethod)\nlocal lines = assert(string.lines)\n\nlocal function _istoken(repr)\n   if type(repr) == \'table\' and repr.idEst == Token then\n      return true\n   else\n      return false\n   end\nend\n\nlocal function _yieldReprs(_repr, tab, window, c, aG)\n   assert(c, \"must have a value for c\")\n   local repr = _repr(tab, window, c, aG)\n   -- __repr may choose to use yield() directly rather than returning a value\n   if repr == nil then return end\n   if _istoken(repr) then\n      Yield(repr)\n      return nil\n   end\n   if type(repr) == \"string\" then\n      repr = lines(repr)\n   end\n   -- here the repr must be a function\n   assertfmt(type(repr) == \"function\",\n      \"Unexpected return type from __repr: \\\n       Expected string, Token, iterator-of-string, \\\n       or iterator-of-Token, got %s\",\n      type(repr))\n   for line_or_token, len in repr do\n      local token;\n      if type(line_or_token) == \"string\" then\n         -- Note that len may be nil, in which case the\n         -- Token will figure things out for itself\n         token = Token(line_or_token, { color = \"no_color\",\n                                        event = \"repr_line\",\n                                        total_disp = len })\n      else\n         token = line_or_token\n      end\n      Yield(token)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function yield_name(...) Yield(nameFor(...)) end\n\nlocal isarray, table_keys, keysort, sort = assert(table.isarray),\n                                           assert(table.keys),\n                                           assert(table.keysort),\n                                           assert(table.sort)\n\nlocal SORT_LIMIT = 500\n\nlocal function yieldToken(str, color, event)\n   Yield(Token(str, { color = color, event = event }))\nend\n\nlocal function _tabulate(tab, window, c, aG)\n   if type(tab) ~= \"table\"\n      or window.depth > C.depth\n      or window.cycle[tab] then\n      yield_name(tab, c, aG)\n      return nil\n   end\n   -- Check for an __repr metamethod. If present, it replaces the rest of the\n   -- tabulation process for this table\n   local _repr = hasmetamethod(\"__repr\", tab)\n   if _repr and (not rawget(tab, \"__repr\")) then\n      window.depth = window.depth + 1\n      _yieldReprs(_repr, tab, window, c, aG)\n      window.depth = window.depth - 1\n      return nil\n   end\n   -- add non-__repr\'ed tables to cycle\n   window.cycle[tab] = true\n\n   -- Okay, we\'re repring the body of a table of some kind\n   -- Check to see if this is an array\n   local is_array = isarray(tab) and \"array\" or \"map\"\n   -- And print an open brace, noting increased depth\n   Yield(Token(\"{ \", { color = \"base\", event = is_array }))\n   window.depth = window.depth + 1\n\n   -- if we have a metatable, get it first\n   local _M = getmetatable(tab)\n   if _M then\n      local mt_name_token = nameFor(_M, c, aG, \"metatable\")\n      mt_name_token.event = \"metatable\"\n      if window.cycle[_M] then\n         mt_name_token:insert(1, \"⟨\")\n         mt_name_token:insert(\"⟩\")\n         mt_name_token:insert(\" \")\n      end\n      Yield(mt_name_token)\n      -- Skip printing the metatable altogether if it\'s going to end up\n      -- represented by its name, since we just printed that.\n         if window.depth < C.depth and not window.cycle[_M] then\n            yieldToken(\" → \", \"base\",  \"sep\")\n            yieldToken(\"⟨\", \"metatable\",\"metatable\")\n            _tabulate(_M, window, c, aG)\n            yieldToken(\"⟩ \", \"metatable\", \"sep\")\n         else\n            yieldToken(\" \", \"no_color\", \"sep\")\n         end\n      end\n\n      if is_array == \'array\' then\n         for i, val in ipairs(tab) do\n            if i ~= 1 then yieldToken(\", \", \"base\", \"sep\") end\n            _tabulate(val, window, c, aG)\n         end\n      else\n         local keys = table_keys(tab)\n         if #keys <= SORT_LIMIT then\n            sort(keys, keysort)\n         end\n         for i, key in ipairs(keys) do\n            if i ~= 1 then yieldToken(\", \", \"base\",\"sep\") end\n            local val = tab[key]\n            if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then\n               -- legal identifier, display it as a bareword\n               yield_name(key, c, aG, \"field\")\n            else\n               -- arbitrary string or other type, wrap with braces and repr it\n               yieldToken(\"[\", \"base\")\n               -- We want names or hashes for any lvalue table\n               yield_name(key, c, aG)\n               yieldToken(\"]\",\"base\")\n            end\n            yieldToken(\" = \", \"base\")\n            _tabulate(val, window, c, aG)\n         end\n      end\n      yieldToken(\" }\", \"base\", \"end\")\n      window.depth = window.depth - 1\nend\n\nlocal function tabulate(tab, window, c, aG)\n   aG = aG or assert(names.anti_G)\n   return Wrap(function()\n      -- Don\'t overwrite these if they already exist, in case we\'re\n      -- re-entering from an __repr function\n      window.depth = window.depth or 0\n      window.cycle = window.cycle or {}\n      -- _tabulate returns nothing, so the return value here\n      -- can only be an error message\n      local success, err = xpcall(\n         function() return _tabulate(tab, window, c, aG) end,\n         debug.traceback)\n      if not success then\n         for line in lines(\"error in __repr: \" .. err) do\n            Yield(Token(line, { color = \"alert\", event = \"repr_line\" }))\n         end\n      end\n   end)\nend\n\n\n\nreturn {\n   tabulate = tabulate,\n   _tabulate = _tabulate, -- we can improve\n   yieldName = yield_name,\n   yieldReprs = _yieldReprs,\n   yieldToken = yieldToken,\n   isToken  = _istoken,\n}\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/tablib",
branch = "viewer",
},
  { 
hash = "7fe2045e7afffb6f3ca243436e407d20ab91dd27fa2042b3cc87de69079ccc2b",
binary = "\n\n\n\n\n\n\nlocal tabulate = require \"repr:repr/tabulate\"\nlocal names = require \"repr:repr/names\"\nlocal core = require \"qor:core\"\n\nlocal string, table = core.string, core.table\n\nlocal assertfmt = assert(string.assertfmt)\n\n\n\nlocal persist_tabulate = {}\n\n\n\n\n\n\n\n\n\nlocal compression_map = {\n   event = {\n      array     = \"[\",\n      map       = \"{\",\n      metatable = \"<\",\n      [\"end\"]   = \"}\",\n      repr_line = \"#\",\n      [\"break\"] = \"~\",\n      sep       = \",\"\n   },\n   wrappable = { [true] = \"w\" },\n   color = {\n      -- Types and pseudo-types\n      [\"nil\"]      = \"z\",\n      [\"true\"]     = \"t\",\n      [\"false\"]    = \"f\",\n      number       = \"n\",\n      string       = \"s\",\n      table        = \"o\", -- For \"object\", t is taken\n      [\"function\"] = \"e\", -- For \"executable\", f is taken\n      userdata     = \"u\",\n      cdata        = \"c\",\n      thread       = \"r\", -- For \"routine\", c (for coro) and t are both taken\n      metatable    = \"m\",\n      -- Syntax elements\n      field        = \"p\", -- For \"property\", f is taken\n      operator     = \"i\", -- Okay, I pretty much give up, but, b*i*nary? eh?\n                          -- Also the only available letter in \"punctuation\"\n      keyword      = \"k\",\n      comment      = \"v\",\n      base         = \"b\",\n      -- Misc\n      alert        = \"a\",\n      search_hl    = \"h\",\n      [\"error\"]    = \"d\", -- Now I *really* give up\n      bold         = \"l\",\n      greyscale    = \"g\",\n      highlight    = \"j\",\n      no_color     = \"x\",\n   }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal decompression_map = {}\nfor prop, sub_map in pairs(compression_map) do\n   for val, char in pairs(sub_map) do\n      assertfmt(not decompression_map[char], \"Duplicate compression char %s\", char)\n      decompression_map[char] = { [prop] = val }\n   end\nend\n\n\n\n\n\nlocal function ninsert(tab, val)\n   tab.n = tab.n + 1\n   tab[tab.n] = val\nend\n\nlocal SOH, STX = \"\\x01\", \"\\x02\"\n\nlocal concat, insert, sort = assert(table.concat),\n                             assert(table.insert),\n                             assert(table.sort)\nlocal function dump_token(token, stream)\n   ninsert(stream, SOH)\n   local header_chars = {}\n   for prop, sub_map in pairs(compression_map) do\n      local val = token[prop]\n      if val then\n         local char = sub_map[val]\n         assertfmt(char, \"Missing compression char for property %s = %s\", prop, val)\n         insert(header_chars, char)\n      end\n   end\n   sort(header_chars)\n   ninsert(stream, concat(header_chars))\n   ninsert(stream, STX)\n   ninsert(stream, tostring(token))\n   return stream\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal no_color = assert(require \"singletons:color\" . no_color)\n\nlocal function tabulate_some(results, count, aG)\n   count = count or 100\n   aG = aG or assert(names.anti_G)\n   local results_tostring, results_tabs = {}, {}\n   for i = 1, results.n do\n      -- Make a dummy table to stand in for Composer:window(),\n      -- since we won\'t be making a Composer at all.\n      local dummy_window = { width = 80, remains = 80, color = no_color }\n      results_tabs[i] = tabulate(results[i], dummy_window, no_color, aG)\n      results_tostring[i] = { n = 0 }\n   end\n   local i = 1\n   return function()\n      if i > #results_tabs then\n         return true, results_tostring\n      end\n      local start_token_count = results_tostring[i].n\n      if start_token_count > 15000 then\n         -- bail early\n         results_tostring[i] = concat(results_tostring[i])\n         i  = i + 1\n         return false\n      end\n      while results_tostring[i].n - start_token_count <= count do\n         local success, token = pcall(results_tabs[i])\n         if success then\n            if token then\n               dump_token(token, results_tostring[i])\n            else\n               results_tostring[i] = concat(results_tostring[i])\n               i = i + 1\n               return false\n            end\n         else\n            error(token)\n         end\n      end\n      return false\n   end\nend\n\npersist_tabulate.tabulate_some = tabulate_some\n\n\n\n\n\n\n\n\nfunction persist_tabulate.tabulate(results, aG)\n   local persist_cb = tabulate_some(results, math.huge, aG)\n   local done, results_tostring\n   repeat\n      done, results_tostring = persist_cb()\n   until done\n   return results_tostring\nend\n\n\n\n\n\n\n\n\nlocal addall = assert(table.addall)\nlocal find, lines, match, sub = assert(string.find),\n                                assert(string.lines),\n                                assert(string.match),\n                                assert(string.sub)\nlocal unescape = assert(require \"core:string/escape\" . unescape)\nlocal Token = require \"repr:repr/token\"\n\nlocal function result_repr(live, result)\n   if sub(result[1], 1, 1) == SOH then\n      -- New format--tokens delimited by SOH/STX\n      local header_position = 1\n      local text_position = 0\n      return function()\n         text_position = find(result[1], STX, header_position + 1)\n         if not text_position then\n            return nil\n         end\n         local metadata = sub(result[1], header_position + 1, text_position - 1)\n         local cfg = {}\n         -- Handle old-format metadata, with space-separated\n         -- \"wrappable\" and \"event=\" tokens. `wrappable` and `event=end`\n         -- are both 9 characters, so that\'s a sensible cut-off\n         if #metadata >= 9 then\n            if find(metadata, \"wrappable\") then cfg.wrappable = true end\n            cfg.event = match(metadata, \"event=([%w_]+)\")\n         -- New compressed format, read one char at time using decompression map\n         else\n            for c in metadata:gmatch \".\" do\n               local extra_cfg = assertfmt(decompression_map[c], \"Unrecognized compressed character %s\", c)\n               addall(cfg, extra_cfg)\n            end\n         end\n         if not live then\n            cfg.color = \"greyscale\"\n         end\n         header_position = find(result[1], SOH, text_position + 1)\n         if not header_position then\n            header_position = #result[1] + 1\n         end\n         local text = sub(result[1], text_position + 1, header_position - 1)\n         if cfg.wrappable then\n            text = unescape(text)\n         end\n         return Token(text, cfg)\n      end\n   else\n      -- Old format--just a string, which we\'ll break up into lines\n      local line_iter = lines(result[1])\n      return function()\n         local line = line_iter()\n         if line then\n            -- Might as well return a Token in order to attach the color properly,\n            -- rather than just including the color escapes in the string\n            return Token(line, { color = \"greyscale\", event = \"repr_line\" })\n         else\n            return nil\n         end\n      end\n   end\nend\n\n\n\nlocal curry = core.fn.curry\npersist_tabulate.db_result_M = { __repr = curry(result_repr, false) }\npersist_tabulate.live_result_M = { __repr = curry(result_repr, true) }\n\n\n\n\n\n\nreturn persist_tabulate\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/persist-tabulate",
branch = "viewer",
},
  { 
hash = "e0c2979b76be2d56d6768f89c213104e8c84c55a62e1eae268084404554468bd",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal utf8 = require \"lua-utf8\"\nlocal utf8_len, utf8_sub = utf8.len, utf8.sub\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n--local meta = assert(require \"core:cluster\" . Meta)\n\n\n\n\n\n\nlocal Token = {}; Token.__index = Token\nlocal new\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.toString(token, c)\n   local color = c[token.color]\n   if not token.wrappable then\n      return color(utf8_sub(token.str, token.start))\n   end\n   local output = {}\n   for i = token.start, #token.codepoints do\n      local frag = token.codepoints[i]\n      if token.escapes[frag] then\n         frag = c.stresc .. frag .. color\n      elseif token.err and token.err[i] then\n         frag = c.alert .. frag .. color\n      end\n      insert(output, frag)\n   end\n   return color(concat(output))\nend\n\n\n\n\n\n\n\n\n\nfunction Token.__tostring(token)\n   if token.wrappable then\n      return concat(token.codepoints, \"\", token.start)\n   else\n      return utf8_sub(token.str, token.start)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.split(token, max_disp)\n   local first\n   local cfg = { color = token.color,\n                 event = token.event,\n                 wrappable = token.wrappable,\n                 wrapped = token.wrapped }\n   if token.wrappable then\n      cfg.escapes = token.escapes\n      first = new(nil, cfg)\n      for i = token.start, #token.codepoints do\n         if first.total_disp + token.disps[i] > max_disp then\n            token.start = i\n            token.total_disp = token.total_disp - first.total_disp\n            break\n         end\n         first:insert(token.codepoints[i], token.disps[i], token.err and token.err[i])\n      end\n   else\n      first = new(utf8_sub(token.str, token.start, token.start + max_disp - 1), cfg)\n      token.start = token.start + max_disp\n      token.total_disp = token.total_disp - max_disp\n   end\n   return first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.insert(token, pos, frag, disp, err)\n   assert(token.start == 1, \"Cannot insert into a token with a start offset\")\n   if type(pos) ~= \"number\" then\n      err = disp\n      disp = frag\n      frag = pos\n      -- If we have a codepoints array, our total_disp might exceed its length\n      -- because of escapes. If not, total_disp is assumed equal to the\n      -- number of codepoints in the string\n      pos = (token.codepoints and #token.codepoints or token.total_disp) + 1\n   end\n   -- Assume one cell if disp is not specified.\n   -- Cannot use #frag because of Unicode--might be two bytes but one cell.\n   disp = disp or 1\n   if token.wrappable then\n      insert(token.codepoints, pos, frag)\n      insert(token.disps, pos, disp)\n      -- Create the error array if needed, and/or shift it if it exists (even\n      -- if this fragment is not in error) to keep indices aligned\n      if token.err or err then\n         token.err = token.err or {}\n         insert(token.err, pos, err)\n      end\n   else\n      token.str = utf8_sub(token.str, 1, pos - 1) .. frag .. utf8_sub(token.str, pos)\n   end\n   token.total_disp = token.total_disp + disp\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.remove(token, pos)\n   assert(token.start == 1, \"Cannot remove from a token with a start offset\")\n   local removed, rem_disp, err\n   if token.wrappable then\n      removed = remove(token.codepoints, pos)\n      rem_disp = remove(token.disps, pos)\n      err = token.err and remove(token.err, pos)\n   else\n      pos = pos or token.total_disp\n      removed = utf8_sub(token.str, pos, pos)\n      rem_disp = 1\n      token.str = utf8_sub(token.str, 1, pos - 1) .. utf8_sub(token.str, pos + 1)\n   end\n   token.total_disp = token.total_disp - rem_disp\n   return removed, rem_disp, err\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal string_sub = assert(string.sub)\n\nfunction Token.removeTrailingSpaces(token)\n   assert(not token.wrappable, \"removeTrailingSpaces not implemented \\\n      for wrappable tokens\")\n   assert(token.start == 1, \"removeTrailingSpaces not implemented \\\n      for tokens with a start offset\")\n   -- Note that we can ignore Unicode here, as we only care about spaces\n   local last_non_space = -1\n   while string_sub(token.str, last_non_space, last_non_space) == \" \" do\n      last_non_space = last_non_space - 1\n   end\n   token.str = string_sub(token.str, 1, last_non_space)\n   token.total_disp = token.total_disp + last_non_space + 1\nend\n\n\n\n\n\n\nfunction Token.isForceBreak(token)\n   return token.event == \"break\" or token.event == \"repr_line\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_char = assert(require \"core:string/escape\" . escape_char)\n\nnew = function(str, cfg)\n   local token = setmetatable({}, Token)\n   token.str = str\n   token.start = 1\n   cfg = cfg or {}\n   if cfg.wrappable then\n      token.codepoints = Codepoints(str or \"\")\n      token.err = token.codepoints.err\n      token.disps = {}\n      token.escapes = {}\n      token.total_disp = 0\n      for i, frag in ipairs(token.codepoints) do\n         -- For now, start by assuming that all codepoints occupy one cell.\n         -- This is wrong, but *usually* does the right thing, and\n         -- handling Unicode properly is hard.\n         local disp = 1\n         local escaped = escape_char(frag)\n         if escaped ~= frag then\n            token.codepoints[i] = escaped\n            -- In the case of an escape, we know all of the characters involved\n            -- are one-byte, and each occupy one cell\n            disp = #escaped\n            token.escapes[escaped] = true\n         end\n         token.disps[i] = disp\n         token.total_disp = token.total_disp + disp\n      end\n      -- Note that we don\'t quote if str was nil, only if it was an actual\n      -- empty string. nil is used to create a blank token into which chars\n      -- will later be inserted (see :split()).\n      if str and str:find(\'^ *$\') then\n         -- Need to assign this over now so :insert() behaves properly\n         token.wrappable = true\n         token:insert(1, \'\"\')\n         token:insert(\'\"\')\n      end\n   else -- not cfg.wrappable\n      token.total_disp = utf8_len(str)\n   end\n   for k, v in pairs(cfg) do\n      token[k] = v\n   end\n   return token\nend\n\nToken.idEst = new\n\nreturn new\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr/token",
branch = "viewer",
},
  { 
hash = "2153ecb8a6b00ef4e59d784471b4b2e1faa2f2352a144a9c4ca29d1a8ec1b3cb",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal ts = require \"tablestats\"\n\n\n\n\n\n\n\n\n\n\nlocal function datafacts(subject)\n   -- welcome to datafacts! your humble provider of facts, about data\n   -- The facts go here!\n   local facts = {} -- you\'re going to need to say local a lot. like a lot. more.\n   -- This is a key-value map. What goes in it?\n   -- number of key?\n\t local keycount = 0\n\t for k, v in ipairs (subject) do \n\t\t-- >print (k, v)\n\t\tkeycount = keycount + 1\t\n\t end\n   facts.nkeys = keycount\n\t if type(subject[1]) ~= \"nil\" then\n\t\tfacts.isarray = true\n\telse\n\t\tfacts.isarray = false\n\tend\n   facts.len = #subject --> for now \n   -- what else? facts!\n   return facts\nend\n\n\n\n\n\n\n\n\nreturn setmetatable({ all = datafacts },\n                    { __call = function(_, topic)\n                                  return datafacts(topic)\n                               end })\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "datafacts",
branch = "viewer",
},
  { 
hash = "fcc4a73faaffa5332e7d133c0843ac092bd668ed1e66fced9dfc5c37edd30ec8",
binary = "\n\nlocal datafacts = require \"repr:datafacts\"\nlocal ts = require \"repr:repr\" .ts_color\nlocal Deque = require \"deque:deque\"\nlocal d = Deque()\nd:push(\"a\")\nd:push(\"b\")\nd:push(\"c\")\nd:push(\"de\")\nprint (ts(datafacts.all(d)))\nreturn ts(datafacts.all(d))\n-- return d\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "factrig",
branch = "viewer",
},
  { 
hash = "dbb84daf1d77af26938b24090c54d7591bf19c351a82a2b4c414ca9d780dbe74",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table = core.table\nlocal nest = assert(core.thread.nest) \'repr\'\nlocal Token = require \"repr:token\"\nlocal Set = core.set\n\nlocal cluster = require \"cluster:cluster\"\nlocal sortedpairs = assert(core.table.sortedpairs)\nlocal tablib = require \"repr:tablib\"\nlocal yieldName = assert(tablib.yieldName)\nlocal yieldReprs = assert(tablib.yieldReprs)\nlocal yieldToken = assert(tablib.yieldToken)\nlocal assertfmt = assert(core.string.assertfmt)\nlocal hasmetamethod = assert(core.meta.hasmetamethod)\nlocal names = require \"repr:names\"\nlocal nameFor =  assert(names.nameFor)\nlocal C = require \"singletons:color\"\n\n\n\n\n\n\n\n\n\n\nlocal Wrap, Yield = assert(nest.wrap), assert(nest.yield)\nlocal tabulate, _tabulate = tablib.tabulate, tablib._tabulate\nlocal no = assert(cluster.ur.no)\nlocal isarray, isempty = assert(table.isarray), table.isempty\nlocal allkeys = assert(table.allkeys)\n\nlocal function repr_gen(cfg)\n   cfg = cfg or {}\n\n   local hide_key;\n   if cfg.hide_key then\n      if isarray(cfg.hide_key) then\n         hide_key = Set(cfg.hide_key)\n      else\n         hide_key = cfg.hide_key\n      end\n   else\n      hide_key = {}\n   end\n\n   local noPairs = cfg.noPairs or no\n   local showBoolean = cfg.showBoolean\n   local depth = cfg.depth or C.depth\n   local value_type = cfg.value_type or {}\n   local key_field = cfg.key_field or {}\n   local function repr(_tab, _window, _c, _aG)\n      local function represent(tab, window, c, aG)\n         tab, window, c, aG = tab or _tab,\n                              window or _window,\n                              c or _c,\n                              aG or _aG\n         if type(tab) ~= \"table\"\n            or window.depth > depth\n            or window.cycle[tab] then\n            return yieldName(tab, c, aG)\n         end\n         window.cycle[tab] = true\n         Yield(Token(\"{ \", { color = \"base\", event = \"map\"}))\n         local first = true\n         window.depth = window.depth + 1\n\n         for key, val in sortedpairs(tab) do\n            if hide_key[key] or noPairs(key, val) then\n               goto continue\n            end\n            if first then\n               first = false\n            else\n               yieldToken(\", \",\"base\", \"sep\")\n            end\n            if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then\n               -- legal identifier, display it as a bareword\n               yieldName(key, c, aG, \"field\")\n            else\n               -- arbitrary string or other type, wrap with braces and repr it\n               yieldToken(\"[\", \"base\")\n               -- We want names or hashes for any lvalue table\n               yieldName(key, c, aG)\n               yieldToken(\"]\",\"base\")\n            end\n            yieldToken(\" = \", \"base\")\n            if value_type[key] then\n               yieldToken(type(val), \'no_color\')\n            elseif key_field[key] then\n               represent(val[key_field[key]], window, c, aG)\n            elseif not val then\n               -- nil or false, name it\n               yieldName(val, c, aG)\n            else\n               represent(val, window, c, aG)\n            end\n            ::continue::\n         end\n         window.depth = window.depth - 1\n         yieldToken(\" }\", \"base\", \"end\")\n      end\n      return Wrap(represent)\n   end\n\n   return repr\nend\n\n\n\nreturn repr_gen\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "lens",
branch = "viewer",
},
  { 
hash = "04e2b17977fbcf811506cb5d9e553c568165c71ffb4e8a747e0e923954692945",
binary = "\n\n\n\n\n\n\n\n\nlocal C = require \"singletons/color\"\nlocal Composer = require \"repr:repr/composer\"\nlocal tabulate = require \"repr:repr/tabulate\"\n\nlocal concat = assert(table.concat)\n\n\n\n\n\n\nlocal repr = {}\n\n\n\n\n\n\n\n\n\n\nfunction repr.lineGen(tab, disp_width, color)\n   color = color or C.color\n   local generator = Composer(tabulate)\n   return generator(tab, disp_width, color)\nend\n\nfunction repr.lineGenBW(tab, disp_width)\n   return repr.lineGen(tab, disp_width, C.no_color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction repr.ts(val, disp_width, color)\n   local phrase = {}\n   for line in repr.lineGen(val, disp_width, color or C.no_color) do\n      phrase[#phrase + 1] = line\n   end\n   return concat(phrase, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\nfunction repr.ts_color(val, disp_width, color)\n   return repr.ts(val, disp_width, color or C.color)\nend\n\n\n\nreturn repr\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "repr",
branch = "viewer",
},
  { 
hash = "dd9b0c5bc84687fbd232cf3a65e85d4831630b4a6c3a89e2ae08e7cb93f5ca3e",
binary = "\n\n\nlocal ts = assert(require \"repr:repr\" . ts_color)\nlocal core = require \"qor:core\"\nlocal table = core.table\n\n\n\n\n\nlocal nkeys, isarray = table.nkeys, table.isarray\nlocal isempty = table.isempty\n-- this is the canonical sorting function\nlocal keysort = table.keysort\n\n\n\n\nlocal function tablestats(tab)\n   local stats = {}\n   -- code \n\n   return stats\nend\n\nlocal function statprint(tab)\n   print(ts(tablestats(tab)))\nend\n\n\n\nreturn { stats = tablestats, print = statprint }\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "tablestats",
branch = "viewer",
},
  { 
hash = "1b202334ec603789c44783a36b63ab9ebb00e5dedca5d9a27b28299a48a75f9e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table, string = core.table, core.string\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\n\n\nlocal Token = require \"repr:token\"\n\nlocal sortedpairs = assert(core.table.sortedpairs)\nlocal assertfmt = assert(core.string.assertfmt)\nlocal hasmetamethod = assert(core.meta.hasmetamethod)\nlocal names = require \"repr:names\"\nlocal nameFor =  assert(names.nameFor)\nlocal C = require \"singletons:color\"\nlocal tablib = require \"repr:tablib\"\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal datafacts = require \"repr:datafacts\" . all\n\n\n\n\n\n\n\n\n\n\nlocal new, Viewer, View_M = cluster.order()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function builder(_new, view, topic, window, c, antiG)\n   assert(table(topic), \"the topic must be a table\")\n   view.topic = topic\n   view.window = window\n   view.c = c\n   view.aG = antiG\n   return view\nend\n\ncluster.construct(new, builder)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\nlocal lines = assert(string.lines)\n\nfunction View_M.__repr(view, window, c, antiG)\n   view.facts = view.facts or datafacts(assert(view.topic))\n   -- this is where you generate strings, here\'s how\n   local phrase = {}\n   -- use insert to put strings into phrase a la insert(phrase, str)\n   -- we\'ll mock that with good ol\' ts:\n   insert(phrase, ts(view.facts))\n   local repr = concat(phrase)\n   return lines(repr)\nend\n\n\n\n\n\n\n\n\n\nfunction Viewer.datafacts(view)\n   view.facts = datafacts(view.topic)\n   return view\nend\n\n\n\n\n\nreturn new\n\n",
vc_hash = "89bc1f939c1539515f79568de81ad98773b6dc1f\n",
name = "viewer",
branch = "viewer",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "rig",
    repo = "",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "ede8d6f8a4586de258b3a85f914604fc90a88d0c8c32510021ac32c57f8a4963",
binary = "\n\n\n\n\n\n\na =  3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\n\n\n\n_ = -(2^-3)^4\n\n\n\n\nif 2 + 3 * 4 .. \"itis\" then\n   -- ...\nend\n\n\n\nfor i = 1, 23 * bingo(), 2 * (3 - 4) do\n   -- ...\nend\n\n\n\nfoo = - - 3 * 4\n\n",
vc_hash = "3d2f230041cd2a09ab4d2329fa0d41f5e60e9117\n",
name = "lua-blocks",
branch = "trunk",
},
  { 
hash = "7927da071ef30bb40afa8ee93c8ffd93bb6592e373dd53792253c1e89ef7ec01",
binary = "\n\n\nlocal Arcivist = require \"sqlun:arcivist\"\nlocal migration = Arcivist.migration\n\n\n\n\nlocal scheme = Arcivist.schema()\n\n\nlocal unique_string_table = [[\nCREATE TABLE IF NOT EXISTS uniq(\n   uniq_id INTEGER PRIMARY KEY,\n   str TEXT UNIQUE ON CONFLICT IGNORE\n)\n]]\n\n\n\nlocal migration_2 = migration(\n   unique_string_table\n)\n\nscheme:addMigration(migration_2)\n\n\n\n\n\n\n\n\n\nlocal insert_str = [[\nINSERT INTO uniq (str) VALUES (:str) RETURNING uniq_id;\n]]\n\n\n\nscheme.test = {insert_str = insert_str}\n\n\n\nlocal function new()\n   local arc = Arcivist(\"\", \"test\")\n   arc:apply(scheme)\n\n   return arc\nend\n\nreturn new\n\n",
vc_hash = "3d2f230041cd2a09ab4d2329fa0d41f5e60e9117\n",
name = "scratch-db",
branch = "trunk",
},
  { 
hash = "202ebde1dd5c64e4a7a7d6a6d58d93501c7dad11c8caa9fb1d4a88ffc070eecc",
binary = "\n\nlocal distinct_modules = [[\nSELECT code.binary as binary,\n       name,\n       CAST(project AS REAL) FROM code\nINNER JOIN (\n   SELECT DISTINCT(name), code, project\n   FROM module\n   GROUP BY name\n   ORDER BY MAX(module.time) DESC)\nON code == code.code_id;\n]]\n\nlocal get_projects = [[\nSELECT name,CAST(project_id AS REAL) FROM project;\n]]\n\nlocal distinct_count = [[\nSELECT COUNT(DISTINCT(name)) FROM module;\n]]\n\n\n\nlocal conn = require \"bridge\" . modules_conn\nlocal core = require \"qor:core\"\n\nlocal ts = require \"repr:repr\" . ts_color\n\n-- grab the scry parser with a modest program\nlocal lua = require \"scry:scry\" \"a = b\" . lua\n\nlocal loadstring = assert(loadstring)\n\n\n\n\n\n\n\n\n\n\n-- map for project names\nlocal id_to_project = {}\n\nfor _, name, project_id in conn :prepare(get_projects) :cols() do\n   id_to_project[project_id] = name\nend\n\n-- TAP header\n\nlocal total = tonumber(conn:prepare(distinct_count):value())\nprint(\"1..\" .. total)\n\nlocal string = require \"core:core/string\"\nlocal lines, find, format  = assert(string.lines),\n                             assert(string.find),\n                             assert(string.format)\n\nlocal function parse_load(i, binary, name)\n   local pass, skip = true, false\n   local tap_line = \"\"\n   local parse = lua(binary)\n   local line, col = parse:errorAt()\n\n   if line then\n      pass = false\n      if loadstring(binary) then\n         -- might be bytecode?\n         if find(binary, \'\\x1bLJ\\x02\') then\n            skip = true\n            tap_line = format(\"not ok %3d # SKIP %s, bytecode\", i, name)\n         else\n            tap_line = format(\"not ok %3d - %s @%d:%d, we can\'t parse\",\n                                       i, name, line, col)\n         end\n      else\n         tap_line = (\"not ok %3d # SKIP %s, lua can\'t parse\")\n      end\n   else\n      tap_line = format(\"ok     %3d - %s\", i, name)\n   end\n   print(tap_line)\n   return pass, skip, (not pass) and (not skip) and tap_line\nend\n\n-- counters, this all gets wrapped in a function eventually\n\nlocal passed, skipped = 0, 0\nlocal losers = {}\n\nlocal function count_if_true(num, bool)\n   if bool then\n      return num + 1\n   else\n      return num\n   end\nend\n\nfor i, binary, name, project_id in conn:prepare(distinct_modules) :cols() do\n   if not project_id then\n      print \"nil project id\"\n   end\n   local project_name = id_to_project[project_id] or \"\"\n   name = project_name .. \":\" .. name\n   local pass, skip, loser = parse_load(i, binary, name)\n   passed = count_if_true(passed, pass)\n   skipped = count_if_true(skipped, skip)\n   if loser then\n      losers[#losers + 1] = {i, name, binary, loser, n = 4}\n   end\nend\n\nif #losers > 0 then\n   print \"Some tests didn\'t pass\"\n   for _, lost in ipairs(losers) do\n      local i, name, binary, loser = unpack(lost)\n      print(format(\"%s \",  loser))\n      if load(binary) then\n         print(\"Lua can parse this one:\")\n         --print(binary)\n         local line, col = lua(binary):errorAt()\n         print(core.string.lineat(binary, line))\n      else\n         print(\"Lua can\'t parse it either, don\'t worry\")\n      end\n   end\nend\n\nprint(format(\"%d fail, %d pass, %d skip, %d total\",\n             #losers,   passed,  skipped, total))\n\n",
vc_hash = "3d2f230041cd2a09ab4d2329fa0d41f5e60e9117\n",
name = "parse-lua-modules",
branch = "trunk",
},
  { 
hash = "18aaf495006e24ce31fb55201e17b9400074d7042854eecf4b2aed3c372b496c",
binary = "\n\n\n\n\nlocal Element = require \"modlang:element\"\nlocal Doctype = require \"modlang:doctype\"\nlocal SVG     = require \"modlang:doctype/SVG\"\n\n",
vc_hash = "3d2f230041cd2a09ab4d2329fa0d41f5e60e9117\n",
name = "drawSVG",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "sandy",
    repo = "git@gitlab.com:bridgetools/sandy.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "a48a71df4f17910489a5a955308b1cd14249ffb8e33bce93886df8ec275ec14c",
binary = "\n\n\nlocal Actor = require \"actor:next\"\nlocal Task  = require \"actor:task\"\nlocal Message = require \"actor:message\"\n\n\n\n\nreturn { Actor = Actor, Task = Task, Message = Message }\n\n",
vc_hash = "f627c9172b36f558db5e8bb52b4e2942ae3a0ebd\n",
name = "box",
branch = "trunk",
},
  { 
hash = "\n\n\n\n\n\n\nlocal Act = require \"actor:next\"\n\nreturn Act()\n\n",
binary = "\n\n\n\n\n\n\nlocal Act = require \"actor:next\"\n\nreturn Act()\n\n",
vc_hash = "f627c9172b36f558db5e8bb52b4e2942ae3a0ebd\n",
name = "leader",
branch = "trunk",
},
  { 
hash = "3a3bda3ff6d3b5ecdbdf552ea4b5b235af62d2eb582a37143c669c62f98120fc",
binary = "\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal uv   = require \"luv\"\nlocal a    = require \"anterm\"\n\n\n\n\n\nlocal bridge = require \"bridge\"\nbridge.opennesty = \'opennesty\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal protocol = core.thread.nest \'protocol\'\n\n\n\n\n\n\n\n\nlocal Create, Wrap, Yield, Resume = assert(protocol.create),\nassert(protocol.wrap),\nassert(protocol.yield),\nassert(protocol.resume)\n\n\n\n\n\nlocal status, running = assert(coroutine.status),\n                        assert(coroutine.running)\n\n\n\n\n\n\nlocal write = print\n\n\n\n\n\n\n\nlocal function color(name)\n   return function(...)\n      return write(a[name](...))\n   end\nend\n\n\n\nlocal redSay, blueSay, greenSay = color \"red\" , color \"blue\", color \"green\"\n\n\n\n\n\n\n\n\nlocal function send(...)\n   write \"here we Yield\"\n   return Yield(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function once(fn)\n   return function()\n      local run = uv.new_idle()\n      run:start(function()\n         fn()\n         run:stop()\n         run:close()\n      end)\n   end\nend\n\n\n\n\n\n\n\nlocal DEFER_BY = 1500 -- ms\n\nlocal function defer(fn)\n   local co, main = running()\n   if main then\n      error \"whap! that\'s the coroutine boundary, bucko!\"\n   end\n   local later = uv.new_timer()\n   later:start(DEFER_BY, 0, function()\n      later:stop()\n      later:close()\n      return coroutine.resume(co, fn())\n   end)\n   return coroutine.yield(co)\nend\n\n\n\n\n\n\n\n\nlocal function task(fn, respond, ...)\n   local co = Create(fn)\n   local ok, msg; -- we start with one return value\n   local ret_val = pack(...)\n   while true do\n      write \"Starting the coroutine\"\n      ok, msg = Resume(co, unpack(ret_val))\n      write \"at nested Resume\"\n      if ok and status(co) == \'dead\' then\n         return msg\n      elseif not ok then\n         error(msg)\n      end\n      ret_val = respond(msg) or {n = 0} -- more on that later\n   end\nend\n\n\n\n\n\nlocal File = require \"fs:file\"\n\nlocal function subtask(...)\n   redSay \"    Starting the Subtask\"\n   local response = send \"  Write this for me\"\n   redSay(response)\n   ---[[\n   assert(coroutine.isyieldable())\n   response = send(File \"scratch.lua\":read())\n   assert(coroutine.isyieldable())\n   redSay(response)\n   --]]\n   write(protocol.ours(coroutine.running()))\n   send(response)\n   return defer(function()\n      redSay \"    Returned from defer\"\n      return \"returning this\"\n   end)\nend\n\n\n\nlocal function the_task(...)\n   blueSay \"  Starting the Task\"\n   blueSay(subtask(...))\n   blueSay \"  Back from subtask\"\nend\n\n\n\n\n\nlocal function response(msg)\n   msg = msg or \"NOTHING?\"\n   greenSay(\"  responder sees    \" .. msg)\n   return pack(\"    responded\")\nend\n\n\n\n\n\nlocal co;\n\nlocal runner = once(function()\n   co = coroutine.create(task)\n   local ok, msg = true\n   write \"normal resume\"\n   ok, msg = coroutine.resume(co, the_task, response)\n---[[\n   write \"restarting\"\n   print(ok, status(co), msg)\n   ok, msg = coroutine.resume(co)\n   print(ok, status(co), msg)\n--]]\nend)\n\n\n\nrunner()\n\n\n\n\n\n\nlocal restart = uv.new_timer()\n\n\n\n\n\n\n\n\n\nrestart:start(DEFER_BY, 0, function()\n   --[[\n   write \"deferred restart\"\n   restart:stop()\n   local ok, msg = true\n   while ok do\n      write \"normal resume\"\n      ok, msg = coroutine.resume(co)\n      print(ok, status(co), msg)\n   end\n   --]]\nend)\n\n",
vc_hash = "f627c9172b36f558db5e8bb52b4e2942ae3a0ebd\n",
name = "opennesty",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/scroll.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "scroll",
    repo = "git@gitlab.com:special-circumstance/scroll.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "98a18b0396969b095d87637d43f83d0968735c74715c5c87e620bd3cf4d3d313",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal string = require \"core:core/string\"\nlocal table = require \"core:core/table\"\nlocal Node = require \"espalier:node\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\n\n\n\nlocal Scroll = {}\nScroll.__index = Scroll\n\n\n\nlocal function new(seed)\n   local scroll = setmetatable({}, Scroll)\n   -- not using this, probably won\'t\n   scroll.source_map = {}\n   scroll.errors = {}\n   if seed then\n      scroll:add(seed)\n   end\n   return scroll\nend\nScroll.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert),\n                       assert(table.concat)\n\nlocal lines = string.lines\n\nlocal function _insert(scroll, frag, index)\n   index = index or #scroll + 1\n   local sc_end = scroll[#scroll]\n   if sc_end and sc_end.partial then\n      insert(sc_end, frag)\n   else\n      scroll[index] = {frag}\n   end\nend\n\nlocal function _add(scroll, frag, index)\n   local idx_start = index or #scroll + 1\n   local str\n   if type(frag) == \'string\' then\n      str = frag\n   elseif type(frag) == \'table\' and frag.isNode then\n      str = frag:span()\n      -- we need to handle source mapping as well\n   elseif type(frag) == \'table\' then -- we\'ll pretend it\'s a Phrase\n      str = tostring(frag)\n   else\n      error(\"cannot add fragment to scroll of type \" .. type(frag))\n   end\n\n   local ln = lines(str)\n   local this_ln = ln()\n   while true do\n      -- todo: this won\'t always go on its own line\n      -- right now we\'re just recapitulating add, but handling newlines\n      -- for everything, not just Nodes.\n      local next_ln = ln()\n      if not next_ln then\n         -- don\'t insert a final newline as a blank line\n         if this_ln ~= \"\" then\n            _insert(scroll, this_ln, index)\n            scroll[#scroll].partial = true\n         else\n            -- close the line\n            scroll[#scroll].partial = nil\n         end\n         break\n      else\n         _insert(scroll, this_ln)\n         index = index + 1\n         scroll[#scroll].partial = nil\n         this_ln = next_ln\n      end\n   end\n   return index - idx_start\nend\n\nfunction Scroll.add(scroll, frag)\n   return _add(scroll, frag, #scroll + 1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal replace = assert(table.replace)\n\nfunction Scroll.replace(scroll, frag, start, finish)\n   local sc_frag = new(frag)\n   sc_frag[#sc_frag].partial = nil\n   local span = finish - start + 1\n   replace(scroll, start, sc_frag, span)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- holds arrays of completed deferments, keyed by scroll\nlocal _defers = setmetatable({}, { __mode = \'k\' })\n\n-- holds deferments which are open but not closed,\n-- keyed by the close mark\nlocal _open_defers = setmetatable({}, { __mode = \'k\' })\n\nfunction Scroll.deferStart(scroll, deferment)\n   -- if we\'re on a partial, we start there. Otherwise, we need a new partial\n   -- line, with no contents.\n   local start_line;\n   if scroll[#scroll].partial then\n      start_line = scroll[#scroll]\n   else\n      start_line = { \"\", partial = true }\n      scroll[#scroll + 1] = start_line\n   end\n   -- make a new deferment table\n   local this_defer = { fn = deferment,\n                        start_index = #scroll,\n                        start_line  = scroll[#scroll] }\n   local close_mark = {}\n   _open_defers[close_mark] = this_defer\n   return close_mark, this_defer -- only returning the deferment for REPling.\nend\n\n\n\n\n\n\nfunction Scroll.deferFinish(scroll, close_mark, deferment)\n   local this_defer = _open_defers[close_mark]\n   if not this_defer then\n      error \"no deferment corresponding to the given close mark\"\n   end\n   -- remove from the collection\n   _open_defers[close_mark] = nil\n   if deferment then\n      this_defer.fn = deferment\n   end\n   -- always choose the last line for deferFinish\n   this_defer.finish_index = #scroll\n   this_defer.finish_line  = scroll[#scroll]\n   -- add to deferments, creating container if necessary.\n   local defers;\n   if _defers[scroll] then\n      defers = _defers[scroll]\n   else\n      defers = {}\n      _defers[scroll] = defers\n   end\n   defers[#defers + 1] = this_defer\n   -- return the deferment for REPLing\n   return this_defer\nend\n\n\n\n\n\n\nlocal function _findIndex(scroll, index, line)\n   -- for now we\'re just going to pretend that the\n   -- index is the line, as indeed it is,\n   -- if the scroll doesn\'t grow or shrink.\n   if scroll[index] == line then\n      return index\n   else\n      local offset =  1\n      while not (index - offset < 1 or index + offset > #scroll) do\n         if scroll[index + offset] == line then\n            return index + offset\n         end\n         if scroll[index - offset] == line then\n            return index - offset\n         end\n         offset = offset + 1\n      end\n      s:warn(\"failed to find the line at \" .. tostring(index))\n   end\nend\n\nfunction Scroll.deferResolve(scroll)\n   local resolved = true\n   local defers = _defers[scroll]\n   if not defers then\n      return resolved\n   end\n   for _, df in ipairs(defers) do\n      local start  = _findIndex(scroll, df.start_index, df.start_line)\n      local finish = _findIndex(scroll, df.finish_index, df.finish_line)\n      if not (start and finish) then\n         resolved = false\n      else\n         local section = scroll:section(start, finish)\n         local new_section = df.fn(section)\n         scroll:replace(new_section, start, finish)\n      end\n   end\n   -- remove the deferments\n   _defers[scroll] = nil\n\n   return resolved\nend\n\n\n\n\n\n\n\n\n\nlocal function section(scroll, start, finish)\n   assert(type(start) == \'number\', \"start must be a number\")\n   assert(type(finish) == \'number\', \"finish must be a number\")\n   local final = true\n   if scroll[finish].partial then\n      final = false\n   end\n   local collect = {}\n   for i = start, finish do\n      local line = scroll[i]\n      if type(line) == \'table\' and not line.has_closure then\n         collect[#collect + 1] = concat(line)\n      else\n         -- handle the case of a fragment or line closure\n         -- probably throw a warning and insert a placeholder?\n      end\n   end\n   if final then\n      collect[#collect + 1] = \"\"\n   end\n   return concat(collect, \"\\n\")\nend\n\nScroll.section = section\n\n\n\n\n\n\n\n\nfunction Scroll.__tostring(scroll)\n   return section(scroll, 1, #scroll)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Scroll.addError(scroll, errstring)\n   insert(scroll.errors, errstring)\nend\n\n\n\n\n\n\n\n\nfunction Scroll.repr(scroll)\n   return Phrase(tostring(scroll))\nend\n\n\n\nreturn new\n\n",
vc_hash = "44770540242003486ae252b0317e86a3d90bc78c\n",
name = "scroll",
branch = "palimpsest",
},
  { 
hash = "1f9a500bca49c732a7f147dd130fd9e96e15978da22d7c0d42b23c152c6253c5",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\nlocal Scroll = require \"scroll:scroll\"\n\n\n\n\n\n\nlocal new, Case = cluster.order()\n\n\n\n\n\n\n\n\nlocal function case_builder(_new, case)\n   case[1] = Scroll()\n   case.errors = {}\n   return case\nend\n\n\n\ncluster.construct(new, case_builder)\n\n\n\n\n\n\n\n\n\n\n\nfunction Case.add(case, frag)\n   return case[#case]:add(frag)\nend\n\n\n\n\n\n\n\n\nfunction Case.new(case)\n   case[#case + 1] = Scroll()\nend\n\n\n\n\n\nreturn new\n\n",
vc_hash = "44770540242003486ae252b0317e86a3d90bc78c\n",
name = "case",
branch = "palimpsest",
},
  { 
hash = "8f044d2802eea50cd93f5b9418d9ff8c9f1f96c593ea6c8681527af9bf69a476",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal meta = assert(core.cluster.meta)\nlocal table = assert(core.table)\n\n\n\n\n\n\nlocal Palimpsest = meta {}\n\n\n\n\n\n\n\n\nlocal function build(pal, str, first, last)\n   assert(type(str) == \'string\', \"#1 to Palimpsest must be a string\")\n   first = first or 1\n   last = last or #str\n\n   pal.str = str\n   pal.first, pal.last = first, last\n   pal.first_offs = {}\n   pal.last_offs = {}\n   pal.deltas = {}\n   pal.cursor = first\n   return pal\nend\n\nlocal function new(str, first, last)\n   local pal = {}\n   return setmetatable(build(pal, str, first, last), Palimpsest)\nend\n\nPalimpsest.idEst = new\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal assertfmt = assert(core.string.assertfmt)\n\nlocal function _sameLen(pal)\n   local len, first, last, delta = rawlen(pal),\n                                   #pal.first_offs,\n                                   #pal.last_offs,\n                                   #pal.deltas\n   assertfmt(len == first and len == last and len == delta,\n             \"uneven lengths! palimpsest: \\\n              %d, first_offs: %d, last_offs: %d, Δ: %d\",\n             len, first, last, delta)\nend\n\nfunction Palimpsest.swap(pal, frag, first, last)\n   assertfmt(pal.cursor <= first,\n             \"attempted backtrack in swap, cursor is %d, first is %d\",\n             pal.cursor, first)\n   assertfmt(last <= pal.last,\n             \"can\'t swap out of slice range, which ends at %d, asked for %d\",\n             pal.last, last)\n   if pal.cursor < first then\n      insert(pal, true)\n      insert(pal.first_offs, pal.cursor)\n      insert(pal.last_offs, first - 1)\n      insert(pal.deltas, 0)\n   end\n   local frag_len = #frag\n   local Δ = frag_len - (last - first + 1)\n   insert(pal, frag)\n   insert(pal.first_offs, first)\n   insert(pal.last_offs, last + Δ)\n   insert(pal.deltas, Δ)\n   -- cursor is into string, so it tracks last\n   pal.cursor = last + 1\n   _sameLen(pal)\n   return pal\nend\n\n\n\n\n\n\n\n\nlocal clamp = assert(core.math.clamp)\nfunction Palimpsest.sub(pal, first, last)\n   first = clamp(first, -pal.last, pal.last)\n   last = clamp(last, -pal.last, pal.last)\n   -- I think this is just #str - value? but get this working first\n   assert(first > 0, last > 0, \"can\'t handle negative subs, yet\")\n   -- easy case is an unscratched palimpsest, or a cursor behind the full\n   -- value\n   if rawlen(pal) == 0 or pal.cursor < first then\n      return pal.str:sub(first, last)\n   end\n   -- otherwise we\'re building\n   local phrase, cursor = {}, 1\n   for i, frag in ipairs(pal) do\n      local first_off, last_off, Δ = pal.first_offs[i],\n                                     pal.last_offs[i],\n                                     pal.deltas[i]\n      if frag == true then\n         -- if it\'s in the fragment, we\'re done:\n         if first >= first_off and last <= last_off then\n            return pal.str:sub(first, last)\n         end\n\n      elseif type(frag) == \'string\' then\n\n      end\n   end\n\nend\n\n\n\n\n\n\n\n\nfunction Palimpsest.previous(pal)\n   return pal.prior -- this can be nil\nend\n\n\n\n\n\n\n\n\nfunction Palimpsest.next(pal)\n   return pal.right -- we can add a left branch for multiple undo/redo\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat, cloneinstance = assert(table.concat),\n                              assert(table.cloneinstance)\nlocal clear = require \"table.clear\"\n\nfunction Palimpsest.__tostring(pal)\n   local str, phrase = pal.str, {}\n   for i, v in ipairs(pal) do\n      if v == true then\n         local first, last = pal.first_offs[i], pal.last_offs[i]\n         phrase[i] = str:sub(first, last)\n      else\n         phrase[i] = tostring(v) -- this is, permissive\n      end\n   end\n   -- account for remainder of string if any\n   if pal.cursor < pal.last then\n      insert(phrase, str:sub(pal.cursor, pal.last))\n      insert(pal, true)\n      insert(pal.first_offs, pal.cursor)\n      insert(pal.last_offs, pal.last)\n      pal.cursor = pal.last -- this closes the palimpsest\n   end\n   local new_str = concat(phrase)\n   -- wipe palimpsest and provide undo\n   local prior_pal = cloneinstance(pal)\n   prior_pal.right = pal\n   clear(pal)\n   build(pal, new_str)\n   pal.prior = prior_pal\n   return new_str\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
vc_hash = "44770540242003486ae252b0317e86a3d90bc78c\n",
name = "palimpsest",
branch = "palimpsest",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "scry",
    repo = "git@gitlab.com:bridgetools/scry.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "edf60c49f9a967d10e53d8f21ae2406c32f3764732b4bc77e771e248ee39a156",
binary = "\n\n\n\n\n\n\n\nlocal color = require \"singletons:color\" . color\nlocal Palette = require \"anterm:palette\"\nlocal a = require \"anterm:anterm\"\nlocal hex = require \"text:xterm/hexcolor\"\nlocal fg, bg = hex.fg, hex.bg\nlocal format = assert(string.format)\n\nlocal function fmt_color(fmt_str, color)\n   return function(v)\n      return color(format(fmt_str, v))\n   end\nend\n\n\n\n\n\nlocal num_c = fg \"#756fa8\"\nreturn Palette {\n   -- atomics\n   number = num_c,\n   string = color.string,\n   table = color.table,\n   [\'nil\'] = color[\'nil\'],\n   [\'true\'] = color[\'true\'],\n   [\'false\'] = color[\'false\'],\n   reference = fg \"#ff8c21\",\n   identifier = fg \"#d3fc03\",\n   variable = a.blue,\n   notfound = a.red,\n   arity = a.cyan,\n   em = a.bold,\n   alert = fg \"#ff2200\",\n   field = fg \"#fcf38b\",\n   literal = fg \"#ff33be\",\n   depth = function(num) return (\" \"):rep(num) end,\n   line  = fmt_color(\"%3d\", num_c),\n}\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "color",
branch = "orb-db",
},
  { 
hash = "260fd635af6484f7326c428e8caf34ee11b2135825af4fb0c950777b2c9040ad",
binary = "\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "host",
branch = "orb-db",
},
  { 
hash = "8b2dec95877982535bef0b747b9a2722085500846265789a3c658bca178e8446",
binary = "\n\n\n\n\n\n\n\n\nlocal symbolic = [[\n`symbolic`  ←  keyword / symbol\n\n    symbol  ←  any-sym\n\n   keyword  ←  ( \"and\" / \"break\" / \"do\" / \"elseif\" / \"else\"\n               / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n               / \"in\"  / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n               / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n               t ; t is the most PEG thing about PEGs\n\n`t`  ←  &(glyph / { \\t\\n\\r})\n\n`glyph` ← {!@#$%^&*()-+={[]\\\\|:;\\\"\'<,>.?/~`} / \"}\"\n\n\n`any-sym`  ←   ;; first character not this:\n               (!(glyph / { \\t\\n\\r} / [0-9])\n               ;; but anything(?) else is ok:\n               utf8\n               ;; after which digits are also legal\n               (!(glyph / { \\t\\n\\r}) utf8)*)\n\n\n`utf8`  ←  [\\x00-\\x7f]\n        /  [\\xc2-\\xdf] [\\x80-\\xbf]\n        /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n        /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\n\n\n\n\nlocal lua_string = [[\nstring  ←  single-string / double-string / long-string\n\n`single-string`  ←  \"\'\" (\"\\\\\" \"\'\" / \"\\\\\" 1 / (!\"\'\" !\"\\n\" 1))* \"\'\"\n\n`double-string`  ←  \'\"\' (\'\\\\\' \'\"\' / \"\\\\\" 1 / (!\'\"\' !\"\\n\" 1))* \'\"\'\n\n`long-string`  ←  ls_open (!ls_close 1)* ls_close\n\n\n`ls_open`  ←  \"[\" \"=\"*@eq \"[\"\n\n`ls_close`  ←  \"]\" \"=\"*@(eq) \"]\"\n]]\n\n\n\n\nlocal lua_number = [[\nnumber  ←  imaginary / real / long / hex / integer\n\n`imaginary`  ←  real {Ii}\n\n`real`  ←  integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n\n`integer`  ←  [0-9]+\n\n`long`  ←  (integer / hex) {Uu}? {Ll}%2\n\n`hex`  ←  \"0\" {Xx} higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n\n`higit`  ←  [0-9] / [a-f] / [A-F]\n]]\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "lua-primal",
branch = "orb-db",
},
  { 
hash = "b3d2c7e52bfb4a693b8a4d17b794d878960cd57fcb48e5d1e466a646559cd0b7",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mold = require \"scry:molds\"\n\nlocal NoRefs, NoDef = assert(mold.noReferences),\n                      assert(mold.noDefinition)\nlocal Identifier    = assert(mold.Identifier)\n\n\n\nlocal insert = table.insert\n\nlocal function noReferences(synth)\n   local noRefs = {}\n   for var in synth :filter \'variable\' do\n      if NoRefs(var) then\n         insert(noRefs, var)\n      end\n   end\n   return noRefs\nend\n\n\n\nlocal function noDefinition(synth)\n   local noDef = {}\n   for ref in synth:filter \'reference\' do\n      if NoDef(ref) then\n         insert(noDef, ref)\n      end\n   end\n   return noDef\nend\n\n\n\nlocal function identityMismatch(synth)\n   local noDef, noRefs = {}, {}\n   for identifier in synth:filter(Identifier) do\n      if identifier.class == \'reference\' and NoDef(identifier) then\n         insert(noDef, identifier)\n      elseif identifier.class == \'variable\' and NoRefs(identifier) then\n         insert(noRefs, identifier)\n      end\n   end\n   return noDef, noRefs\nend\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function noDefFact(no_def)\n   local fact = { ID = no_def.ID,\n                  linum = no_def.line,\n                  global = no_def.globalVar,\n                    }\n   fact.line, fact.offset = no_def:lineOn()\n\n   if no_def.ego.able then\n      -- note! this only works because the .able field has only one\n      -- entry for references\n      assert(#no_def.ego.able <= 1, \"abilities in excess of one detected\")\n      for ability in pairs(no_def.ego.able) do\n         fact.action = ability\n      end\n   else\n      fact.action = \"reference\"\n   end\n\n   if no_def.late_var then\n      local late_var = no_def.late_var\n      local lateVar = { linum = late_var.line,\n                          ID = late_var.ID }\n      fact.lateVar = lateVar\n      -- remove\n      fact.lateDef = lateVar\n      lateVar.line, lateVar.offset = late_var:lineOn()\n   else\n      fact.no_ref_for_var = true\n   end\n   return fact\nend\n\n\n\n\n\n\nlocal function noRefFact(no_ref)\n   local digest = no_ref:digest()\n   local fact = { ID = digest.ID,\n                  linum = digest.line, -- should make this regular\n                  parent = digest.parent_class }\n   fact.line, fact.offset = no_ref:lineOn()\n   fact.lead_underscore = sub(fact.ID, 1, 1) == \'_\'\n\n   return fact\nend\n\n\n\n\n\n\nreturn { noDef = noDefFact, noRef = noRefFact }\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "fact",
branch = "orb-db",
},
  { 
hash = "a0062e396d0b3d8edc89e3174ea749339a0ffa7511494590ff91c3a7cadf16a5",
binary = "\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal mold  = assert(cluster.mold)\n\n\n\nlocal Mold = {}\n\n\n\n\n\n\n\n\nMold.noReferences = mold { referred = false }\nMold.noDefinition = mold { not_found = true }\n\nMold.Identifier = mold { identifier = true }\n\n\n\nreturn Mold\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "molds",
branch = "orb-db",
},
  { 
hash = "a1c4d389f1b9017a1a616f8533247eae82ba9fdbdabc7ef89cccba77d4cc9496",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal Deque = require \"deque:deque\"\nlocal Stache = require \"text:stache\"\nlocal c = require \"scry:color\"\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\nlocal table, string = core.table, core.string\nlocal clonei = assert(table.cloneinstance)\n\n\n\n\n\n\n\nlocal bind = clonei(c)\n\n\n\n\n\n\nlocal masque = {}\nlocal onbind = {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal True, False, Nil = c[\'true\'] \"true\", c[\'false\'] \"false\", c[\'nil\'] \"nil\"\n\n\n\n\n\n\n\n\n\nlocal function paintAtomic(atom)\n   if atom.class == \'nil\' then\n      return Nil\n   elseif atom.class == \'boolean\' then\n      return atom.ego.just and True or False\n   else\n      return c[atom.class](atom.token)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal scope_templ =[[\n{{line}}: Scope {{name}}:\n   variables:\n      {{vars[#], }}\n   references:\n      {{refs[#], }}\n]]\n\nlocal var_templ = [[{{line}}: {{ID}}]]\n\nlocal mov_templ = [[{{lvalue.name}} ← {{rvalue?}} {{arity?}}]]\n\nlocal var_stache = Stache(var_templ, bind)\n\nlocal ref_stache = Stache(var_templ, bind)\n\nlocal scope_stache = Stache(scope_templ, bind)\nlocal mov_stache = Stache(mov_templ, bind)\n\n\n\nlocal function paintMov(mov)\n   return mov_stache(mov)\nend\n\n\n\nlocal function paintReference(ref)\n   if ref.not_found then\n      return c.notfound(ref.ID)\n   else\n      return c.reference(ref.ID)\n   end\nend\n\n\n\nlocal function paintScopeName(scope)\n   local name, class = scope.name, assert(scope.class)\n   if name ~= class then\n      name = c.variable(name) .. \" \" .. class\n   else\n      name = c.em(name)\n   end\n   return name\nend\n\n\n\nlocal function paintScope(scope)\n   local parts = { name = paintScopeName(scope), line = scope.line}\n   local p_vars, p_refs = {}, {}\n   parts.vars, parts.refs = p_vars, p_refs\n   local vars = scope.vars or {}\n   for _, var in ipairs(vars) do\n      insert(p_vars, var_stache(var))\n   end\n   for _, ref in ipairs(scope.refs) do\n      insert(p_refs, paintReference(ref))\n   end\n   return scope_stache(parts)\nend\n\n\n\nlocal concat = assert(table.concat)\nlocal function paintScopeTree(scope, depth, phrase)\n   local top = not depth\n   depth = depth or 0\n   phrase = phrase or {}\n   local dent = (\"  \"):rep(depth)\n   insert(phrase, dent)\n   insert(phrase, paintScopeName(scope))\n   insert(phrase, \"\\n\")\n   for i, _scope in ipairs(scope.inner or {}) do\n      paintScopeTree(_scope, depth + 1, phrase)\n   end\n   if top then\n      return concat(phrase)\n   else\n      return phrase\n   end\nend\n\n\n\n\n\n\nmasque.variable = [[{{line}} {{ID}}  {{ego?}}]]\nonbind.variable = clonei(c)\nonbind.variable.ID = assert(c.variable)\nonbind.reference = clonei(c)\nonbind.reference.ID = assert(c.reference)\nmasque.reference = masque.variable -- .. etc\n\n\n\n\n\n\nfor k, v in pairs(masque) do\n   local binder = onbind[k] or bind\n   masque[k] = Stache(v, binder)\nend\n\n\n\nlocal function paintMe(syn)\n   if masque[syn.class] then\n      return masque[syn.class](syn)\n   else\n      return ts(syn)\n   end\nend\n\n\n\n\nreturn { paintAtomic = paintAtomic,\n         paintMe = paintMe,\n         paintScope = paintScope,\n         paintMov = paintMov,\n         paintScopeTree = paintScopeTree, }\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "masque",
branch = "orb-db",
},
  { 
hash = "75af073fd310d71e7dc69ac526baf4ff9b592ba98100de37c32a5787a52e7597",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_file_table = [[\nCREATE TABLE file (\n   ino INTEGER PRIMARY KEY NOT NULL,\n   -- device ID\n   dev INTEGER,\n   type TEXT NOT NULL,\n   size INTEGER NOT NULL,\n   mode INTEGER,\n   -- creation time,\n   birthsec INTEGER NOT NULL,\n   birthnsec INTEGER NOT NULL,\n   -- modification time\n   msec INTEGER NOT NULL,\n   mnsec INTEGER NOT NULL\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_path_table = [[\nCREATE TABLE path (\n   path_id INTEGER PRIMARY KEY,\n   string TEXT NOT NULL UNIQUE ON CONFLICT ABORT,\n   ino INTEGER,\n   -- parent INTEGER, -- maybe later\n   -- link INTEGER REFERENCES path (path_id),\n   FOREIGN KEY (ino)\n      REFERENCES file (ino)\n   -- FOREIGN KEY (parent)\n    --  REFERENCES directory (directory_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_directory_table = [[\nCREATE TABLE directory(\n   directory_id INTEGER PRIMARY KEY,\n   path INTEGER,\n   ino INTEGER,\n   FOREIGN KEY (path)\n      REFERENCES path (path_id)\n   FOREIGN KEY (ino)\n      REFERENCES file (ino)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_project_table = [[\nCREATE TABLE project (\n   project_id INTEGER PRIMARY KEY,\n   directory INTEGER,\n   name TEXT NOT NULL,\n   repo_unique TEXT, -- the first commit to the repo\n   module_db_fk INTEGER, -- a foreign, foreign key, from bridge.modules\n   FOREIGN KEY (directory)\n      REFERENCES directory (directory_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_deck_table = [[\nCREATE TABLE deck (\n   deck_id INTEGER PRIMARY KEY,\n   project INTEGER NOT NULL,\n\n   cache_state TEXT NOT NULL DEFAULT \'none\', -- add check constraint\n      -- CHECK \'none\', \'loaded\', \'cached\', \'committed\'\n   cache LUATEXT,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_source_table = [[\nCREATE TABLE source (\n   source_id INTEGER PRIMARY KEY,\n   path INTEGER NOT NULL UNIQUE,\n   project INTEGER,\n   relpath TEXT,\n   FOREIGN KEY (path)\n      REFERENCES path (path_id)\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\nlocal create_revision_table = [[\nCREATE TABLE revision (\n   revision_id INTEGER PRIMARY KEY,\n   snapshot INTEGER NOT NULL,\n   previous TEXT NOT NULL DEFAULT \'\', -- the hash,\n   source INTEGER NUT NULL,\n   FOREIGN KEY (source)\n      REFERENCES source (source_id)\n   FOREIGN KEY (snapshot)\n      REFERENCES snapshot (snapshot_id)\n);\n]]\n\n\n\n\n\n\n\nlocal create_snapshot_table = [[\nCREATE TABLE snapshot (\n   snapshot_id INTEGER PRIMARY KEY,\n   hash TEXT NOT NULL UNIQUE ON CONFLICT IGNORE\n)\n]]\n\n\n\n\n\n\n\n\nlocal create_block_hash_table = [[\nCREATE TABLE block_hash (\n   hash TEXT NOT NULL UNIQUE ON CONFLICT IGNORE,\n   PRIMARY KEY(hash)\n);\n]]\n\n\n\n\n\n\n\nlocal create_block_table = [[\nCREATE TABLE block (\n   block_id INTEGER PRIMARY KEY,\n   revision INTEGER NOT NULL,\n   class TEXT NOT NULL,\n   hash NOT NULL,\n   first INTEGER NOT NULL CHECK (first > 0),\n   last INTEGER NOT NULL CHECK (last > 0),\n   FOREIGN KEY (revision)\n      REFERENCES revision (revision_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (hash)\n      REFERENCES block_hash (hash)\n);\n]]\n\n\n\n\n\n\n\n\n\n\nlocal create_scry_table = [[\nCREATE TABLE scry (\n   scry_id INTEGER PRIMARY KEY,\n   synth TEXT,\n   revision INTEGER NOT NULL,\n   FOREIGN KEY (revision)\n      REFERENCES revision (revision_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\n\nlocal ins_degen_path = [[\nINSERT INTO path (string) VALUES (\"\");\n]]\n\nlocal ins_degen_source = [[\nINSERT INTO source (path) VALUES (:path);\n]]\n\n\n\n\nlocal function insert_degenerates(conn)\n   conn:exec(ins_degen_path)\n   local path_id = sql.lastRowId(conn)\n   conn :prepare(ins_degen_source) :bind(path_id) :value()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal scan = {}\n\n\n\n\n\n\n\nscan.insert_file = [[\nINSERT INTO file (\n   ino,\n   dev,\n   type,\n   size,\n   mode,\n   birthsec,\n   birthnsec,\n   msec,\n   mnsec\n) VALUES (\n   :ino,\n   :dev,\n   :type,\n   :size,\n   :mode,\n   :birthsec,\n   :birthnsec,\n   :msec,\n   :mnsec\n);\n]]\n\n\n\n\n\nscan.insert_path = [[\nINSERT INTO path (\n   ino,\n   string\n) VALUES (\n   :ino,\n   :string\n);\n]]\n\nscan.insert_directory = [[\nINSERT INTO directory (\n   ino, path\n) VALUES (\n   :ino, :path\n);\n]]\n\nscan.insert_project = [[\nINSERT INTO project(\n   directory, name, repo_unique, module_db_fk\n) VALUES (\n   :directory, :name, :repo, :module_db_fk\n);\n]]\n\nscan.insert_source = [[\nINSERT INTO source (\n   path, project, relpath\n) VALUES (\n  :path, :project, :relpath\n);\n]]\n\n\n\n\n\n\n\n\n\n\nscan.get_all_ino_type = [[\nSELECT CAST (ino AS REAL), type FROM file;\n]]\n\nscan.get_all_paths = [[\nSELECT CAST (ino AS REAL), path_id AS path, string FROM path;\n]]\n\nscan.get_path_from_ino = [[\nSELECT path_id AS path, string AS path_str\nFROM path\nWHERE path.ino = :ino\n;\n]]\n\nscan.get_directory_id_from_path = [[\nSELECT directory_id\nFROM directory\nWHERE path = :path_id\n;\n]]\n\n\n\n\n\n\n\nscan.path_from_ino = [[\nSELECT string AS path FROM path WHERE path.ino = :ino;\n]]\n\nscan.dir_from_path = [[\nSELECT directory_id as id, ino, path\nFROM directory\nWHERE path = :path\n;\n]]\n\nscan.project_from_path = [[\nSELECT project.project_id AS id,\n       project.name,\n       path.string AS path\nFROM path\nINNER JOIN directory ON directory.path = path.path_id\nINNER JOIN project ON project.directory = directory.directory_id\nWHERE path.string = :str;\n]]\n\n\n\n\n\n\n\n\nlocal Arcivist = require \"arcivist:arcivist\"\nlocal schema, migration = Arcivist.schema, Arcivist.migration\n\n\n\nlocal orb_schema = Arcivist.schema()\n\n\n\norb_schema:addMigration(migration (\n   create_project_table,\n   create_file_table,\n   create_path_table,\n   create_directory_table,\n   create_deck_table,\n   create_source_table,\n   create_revision_table,\n   create_snapshot_table,\n   create_block_hash_table,\n   create_block_table,\n   create_scry_table,\n   -- add null path and source\n   insert_degenerates\n   ))\n\n\n\norb_schema:addStatements(\'scan\', scan)\n\n\n\n\n\n\n\n\nlocal function new(name)\n   name = name or \"\"\n   local arc = Arcivist(\"\", \"orb\")\n   arc:apply(orb_schema)\n   return arc\nend\n\nreturn new\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "orb-db",
branch = "orb-db",
},
  { 
hash = "ace193481f0cb289ff84b1a0b4319de9533033203f88bae938da7ea7da266041",
binary = "\n\n\n\n\nlocal Scry = require \"scry:scry\"\nlocal report = require \"scry:report\"\n\nlocal Voltron;\n\n\n\n--local args = require \"bridge\" . args\n\nlocal function orbScry(skein)\n   local ok, scry = pcall(Scry, skein)\n   -- local scry = Scry(skein)\n   if not ok then\n      print(scry)\n      return\n   end\n   --[[\n   if args.voltron then\n      Voltron = Voltron or require \"voltron:voltron\"\n      Voltron(scry)\n   end --]]\n   -- configure this with Manifest data!\n   report.fatal(scry)\n   report.unused(scry)\n   report.methodDef(scry)\nend\n\n\n\nreturn orbScry\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "orb-scry",
branch = "orb-db",
},
  { 
hash = "4979090fed64bca640696a63c6b663dcf7c5f31285d72a2f7bcfc3900265fbb9",
binary = "\n\n\n\n\nlocal lua_str = [[\n      lua  ←  BOM? shebang* _ body _ Error*\n\n    `BOM`  ←  \"\\xef\\xbb\\xbf\"\n  shebang  ←  \"#\" (!\"\\n\" 1)* \"\\n\"\n     body  ←  block\n    Error  ←  1+\n\n  `block`  ←   _ (statement _ semi?)* (_ last-statement _ semi?)?\n  `semi`   ←   \";\" _\n\n`statement`  ←  do\n             /  while\n             /  repeat\n             /  if\n             /  for\n             /  defn\n             /  assign\n             /  goto\n             /  comefrom\n             /  action\n\n        do  ←  \"do\" t chunk \"end\" t\n     while  ←  \"while\" t condition \"do\" t when-true \"end\" t\n    repeat  ←  \"repeat\" t chunk \"until\" t condition\n        if  ←  \"if\" t condition \"then\" t when-true elseif* else? \"end\" t\n       for  ←  \"for\" t _ counter _ \"=\" range _ \"do\" t chunk \"end\" t\n            /  \"for\" t _ lvalue _ \"in\" t iterator \"do\" t chunk \"end\" t\n      defn  ←  fn-head _ closure\n    assign  ←  local-assign / mutable-assign\n      goto  ←  \"goto\" t _ label\n`comefrom`  ←  \"::\" _ label _ \"::\"\n    action  ←  (chain / call) _ !(index)\n\n`last-statement`  ←  return / break\n          return  ←  \"return\" t _ (exp-list)?\n           break  ←  \"break\" t\n\n           chunk  ←  block\n       condition  ←  _ expr _\n\n       elseif  ←  \"elseif\" t condition \"then\" t when-true\n         else  ←  \"else\" t when-false\n    when-true  ←  block\n   when-false  ←  block\n      counter  ←  variable\n\n        range  ←  expression \",\" expression (\",\" expression)?\n     iterator  ←  expression (\",\" expression)? (\",\" expression)?\n\n   expression  ←  _ expr _\n\n       `expr`  ←  unop / value _ (binop  _ expr)* / group\n\n      `group`  ←  \"(\" _ expression _ \")\"\n\n          `fn-head`  ←  \"function\" t _ function-name\n                     /  local _ \"function\" t _ local-function-name\n      function-name  ←  reference _ (\".\" _ field)+ _ method?\n                     /  reference _ method\n                     /  variable\n              local  ←  \"local\" t\n; called function_name on the .id\nlocal-function-name  ←  variable\n            method   ←  \":\" _ field\n\n  `local-assign`  ←  local _ lvalue _ (\"=\" _ rvalue)?\n`mutable-assign`  ←  var-list _ \"=\" _ rvalue\n          lvalue  ←  variable-list\n          rvalue  ←  exp-list\n ;; synonym for lvalue\n var-list  ←  var (_ \",\" _ var)*\n\n    label  ←  symbol\n\n`unop`  ←  (unm / len / not) _ expr\n   unm  ←  \"-\"\n   len  ←  \"#\"\n   not  ←  \"not\" t\n\n\n`binop`  ←  and / or / add / sub / mul / div / mod / pow / concat / compare\n    and  ←  \"and\" t\n     or  ←  \"or\" t\n    add  ←  \"+\"\n    sub  ←  \"-\"\n    mul  ←  \"*\"\n    mod  ←  \"%\"\n    div  ←  \"/\"\n    pow  ←  \"^\"\n concat  ←  \"..\"\n\n`compare`  ←  lte / gte / neq / eq / lt / gt\n      lte  ←  \"<=\"\n      gte  ←  \">=\"\n      neq  ←  \"~=\"\n       eq  ←  \"==\"\n       lt  ←  \"<\"\n       gt  ←  \">\"\n\n`value`  ←  nil / boolean / vararg / number / string\n         /  table / function\n         /  action / var\n         /  group\n\n      nil  ←  \"nil\" t\n  boolean  ←  \"true\" t / \"false\" t\n   vararg  ←  \"...\"\n\n       chain  ←  fn-lead (_ fn-segment)+\n   `fn-lead`  ←  call / reference\n`fn-segment`  ←  field-call\n              /  index  &(_ seg-next)\n              /  method-call\n              /  arguments\n\n       call  ←  caller (_ arguments)+ /  expr-method\n\n     caller  ←  group / reference\n   `index`   ←  \"[\" expression \"]\" / \".\" _ field\n      field  ←  symbol\n field-call  ←  index (_ arguments)+\nmethod-call  ←  \":\" _ message (_ arguments)+\nexpr-method  ←  group _ method-call\n ; this is ad-hoc and may be causing problems on that basis\n `seg-next`  ←  _ ({:.{[(} / \"\'\" / \'\"\')\n   message   ←  symbol\n\n      `var`  ←  var-chain / reference / index-expr\n\n    var-chain  ←  var-lead _ (var-segment _)+\n   `var-lead`  ←  call / reference / index-expr\n`var-segment`  ←  ( field-call / method-call )\n               /  index / index-expr\n   reference  ←  symbol\n\n`index-expr`  ←  group _ &index\n\n     table  ←  \"{\" _ form-list* _ \"}\"\n\n  function  ←  \"function\" t _ closure\n\n`form-list`  ←  form (_ (\",\" / \";\") _ form)* (\",\" / \";\")?\n     `form`  ←  pair\n             /  expression\n       pair  ←   key _ \"=\" _ val\n      `key`  ←  \"[\" expression \"]\" / field\n      `val`  ←  expression\n\n arguments  ←  \"(\" _ (exp-list _)? \")\"\n            /  string\n            /  table\n`exp-list`  ←  expression (\",\" expression)*\n\n      closure  ←  parameters _ body _ \"end\" t\n   parameters  ←  \"(\" _ (variable-list (_ \",\" _ vararg)*)* _ \")\"\n               /  \"(\" _ vararg _ \")\"\n`variable-list`  ←  (variable _ (\",\" _ variable _)*)\n     variable  ←  symbol\n\n\n         string  ←  single-string / double-string / long-string\n`single-string`  ←  \"\'\" (escaped / !\"\'\" utf8)* \"\'\"\n`double-string`  ←  \'\"\' (escaped / !\'\"\' utf8)* \'\"\'\n      `escaped`  ←  \"\\\\\" ( ({abfnrtv} / \"\'\" / \'\"\' / \"\\\\\")\n                           / digit digit? digit?\n                           / \"x\" higit higit\n                           / \"\\n\" )\n\n    long-string  ←  ls_open (!ls_close 1)* ls_close\n\n `ls_open`  ←  \"[\" \"=\"*@eq \"[\" \"\\n\"?\n`ls_close`  ←  \"]\" \"=\"*@(eq) \"]\"\n\n`glyph` ← {!@#$%^&*()-+={[]\\\\|:;\\\"\'<,>.?/~`} / \"}\"\n\n`utf8`  ←  [\\x00-\\x7f]\n        /  [\\xc2-\\xdf] [\\x80-\\xbf]\n        /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n        /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n\n     `symbol`  ←  !keyword any-sym\n    `any-sym`  ←  first-char follow-char*\n\n                  ;; first character not this:  but anything(?) else is ok:\n `first-char`  ←  !(glyph / { \\t\\n\\r} / digit) utf8\n                  ;; after which digits are also legal\n`follow-char`  ←  !(glyph / { \\t\\n\\r}) utf8\n\n     number  ←  hex / real / imaginary / long /  integer\n`imaginary`  ←  (real / integer) {Ii}\n     `real`  ←  ( ( integer (\".\" integer)*)\n                  / (\".\" integer))\n                ((\"e\" / \"E\") \"-\"? integer)?\n     `long`  ←  (hex / integer) {Uu}? {Ll}%2\n  `integer`  ←  digit+\n    `digit`  ←  [0-9]\n      `hex`  ←  \"0\" {Xx} higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n    `higit`  ←  digit / [a-f] / [A-F]\n\n           `_`  ←  comment+ / whitespace\n     `comment`  ←  whitespace long-comment whitespace\n                /  whitespace \"--\" (!\"\\n\" 1)* whitespace\n`long-comment`  ←  \"--\" long-string\n  `whitespace`  ←  { \\t\\n\\r}*\n\nkeyword  ←  ( \"and\" / \"break\" / \"do\" / \"elseif\" / \"else\"\n            / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n            / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n            / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n            t ; t is the most PEG thing about PEGs\n\n           `t`  ←  !follow-char\n]]\n\n\nreturn lua_str\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "lua-peg",
branch = "orb-db",
},
  { 
hash = "f40a68114476783115fb982c2d1f4367d33e292bca750bb259ddb880bc2c87e2",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = require \"qor:core\", require \"cluster:cluster\"\nlocal table = core.table\n\n\n\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\nlocal masque = require \"scry:masque\"\nlocal molds  = require \"scry:molds\"\nlocal color  = require \"scry:color\"\nlocal fact   = require \"scry:fact\"\n\n\n\n\n\n\nlocal Stache = require \"text:stache\"\n\n\n\n\n\n\n\n\nlocal NoRefs, NoDef = assert(molds.noReferences),\n                      assert(molds.noDefinition)\nlocal Identifier    = assert(molds.Identifier)\n\n\n\nlocal insert = table.insert\n\nlocal function noReferences(synth)\n   local noRefs = {}\n   for var in synth :filter \'variable\' do\n      if NoRefs(var) then\n         insert(noRefs, var)\n      end\n   end\n   return noRefs\nend\n\n\n\nlocal function noDefinition(synth)\n   local noDef = {}\n   for ref in synth:filter \'reference\' do\n      if NoDef(ref) then\n         insert(noDef, ref)\n      end\n   end\n   return noDef\nend\n\n\n\nlocal function identityMismatch(synth)\n   local noDef, noRefs = {}, {}\n   for identifier in synth:filter(Identifier) do\n      if identifier.class == \'reference\' and NoDef(identifier) then\n         insert(noDef, identifier)\n      elseif identifier.class == \'variable\' and NoRefs(identifier) then\n         insert(noRefs, identifier)\n      end\n   end\n   return noDef, noRefs\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function apropos(write, synth, symbol)\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = color -- meh\n\n\n\nlocal undef_lead = \"[{{linum}}]: {{line}} The {{action}} will fail\"\n\nlocal undef_t = undef_lead .. \" since {{ID}} isn\'t defined.\"\n\nlocal latevar_t = undef_lead .. \", {{ID}} isn\'t in scope until:\\n\"\n                    .. \"[{{lateVar.linum}}]: {{lateVar.line}}\"\n\nlocal global_t = \"[{{linum}}]: {{line}} Warning: global assignment of {{ID}}.\"\n\nlocal fatalBind = { linum = c.number,\n                    ID = c.reference }\n\nlocal undef_stache = Stache(undef_t, fatalBind)\nlocal latevar_stache = Stache(latevar_t, fatalBind)\n\nlocal sub = assert(string.sub)\nlocal noDef = assert(fact.noDef)\n\nlocal function noDefReport(no_def)\n   local fact = noDef(no_def)\n   local ID, line, offset = fact.ID, fact.line, fact.offset\n   local comp_line = sub(fact.line, 1, 0 + fact.offset)\n                     .. c.notfound(fact.ID)\n                     .. sub(line, 1 + offset + #ID)\n   fact.line = comp_line\n\n   if fact.lateVar then\n      local ID, line, offset = fact.lateVar.ID,\n                               fact.lateVar.line,\n                               fact.lateVar.offset\n      local comp_line = sub(line,1, 0 + offset)\n                        .. c.variable(late_var.ID)\n                        .. sub(line, 1 + offset + #ID)\n      fact.def_line = comp_line\n   end\n\n   return fact\nend\n\n\n\n\nlocal function buildFatal(scry, _onbind)\n   local synth = scry.synth\n   local no_defs = noDefinition(synth)\n   local the_facts = {}\n   if #no_defs > 0 then -- this is an actual problem\n      -- template for fatal flaw\n      for _, no_def in ipairs(no_defs) do\n         local fact = noDef(no_def)\n         if fact.global then\n            -- use a global warning\n            fact.template = global_t\n         else\n            fact.template = fact.lateVar and latevar_t or undef_t\n         end\n\n         fact.stache = Stache(fact.template, _onbind or fatalBind)\n         insert(the_facts, fact)\n      end\n   end\n\n   return the_facts\nend\n\nlocal function reportFatal(scry)\n   local facts = buildFatal(scry)\n   if #facts > 0 then\n      print(\"In \" .. scry.path .. \":\")\n      print \"fatal! Identifiers are used without defining them.\"\n      for _, fact in ipairs(facts) do\n         print(fact:stache())\n      end\n   end\nend\n\n\n\n\n\n\nlocal noRef = fact.noRef\n\nlocal no_ref_template = \"   {{ID}} is defined but not used:\\n\"\n                         .. \"[{{linum}}]: {{line}}\"\nlocal function buildUnused(scry, _onbind)\n   local synth = scry.synth\n   local no_refs = noReferences(synth)\n   local the_facts = {}\n   if #no_refs > 0 then\n      for _, no_ref in ipairs(no_refs) do\n         local fact = noRef(no_ref)\n         if not fact.lead_underscore then\n            fact.template = no_ref_template\n            fact.stache = Stache(fact.template, _onbind or fatalBind)\n            insert(the_facts, fact)\n         end\n      end\n   end\n   return the_facts\nend\n\nlocal function reportUnused(scry)\n   local facts = buildUnused(scry)\n   if #facts > 0 then\n      print (\"Unused references in \" .. scry.path)\n      for _, no_ref in ipairs(facts) do\n         print(no_ref:stache())\n      end\n   end\nend\n\n\n\nlocal function reportMethod(scry)\n   local synth = scry.synth\n   for defn in synth :filter \'defn\' do\n      if defn :take \'function_name\' :take \'method\' then\n         local report = color.alert(\"Warning\") .. \": method definition: \\n[\"\n                        .. color.number(defn.line) .. \"]    \"\n                        .. defn:lineOn()\n                        .. \"Is probably a mistake!\"\n         print(report)\n      end\n   end\nend\n\n\n\nlocal B = {}\nfunction B:real(son)\n   error \"gotcha\"\nend\n\n\n\n\n\n\n\n\nlocal bones = assert(require \"cluster:scratch\" .bones)\nlocal function chunkFacts(scry)\n   print(ts(bones(scry.synth, 1)))\nend\n\n\n\nreturn { -- all = reportAll,\n         fatal = reportFatal,\n         unused = reportUnused,\n         methodDef = reportMethod,\n         chunk = chunkFacts,\n         buildFatal = buildFatal, }\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "report",
branch = "orb-db",
},
  { 
hash = "c0e83160d2c3a20223392e6d644878cfe6469a0a3029b9121599ce6b0c2ffb45",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal deque = require \"deque:deque\"\n\n\n\n\n\n\n\n\nno_such_function()\n\n\n\n\n\n\nearly_on()\n\nfunction early_on()\n   print \"we\'re early!\"\nend\n\n\n\n\nerror \"no run! just look!\"\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "sandbox",
branch = "orb-db",
},
  { 
hash = "e6cba294068ad57e11aae8522567777bbf3baa4a9572a9b363dd9a7f5eea5d96",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"qor:core\" .set\nlocal Q = {}\n\n\n\n\n\n\n\n\nQ.scoped = Set {\'lua\', \'do\', \'while\', \'repeat\', \'if\', \'closure\',\n                \'elseif\', \'else\', \'for\', \'function\'}\n\n\n\n\n\n\n\n\nQ.var_parent = Set {\'function_name\', \'local_function_name\', \'for_locals\',\n                    \'parameters\', \'lvalue\', \'counter\'}\n\n\n\n\n\n\n\n\nQ.assignment = Set {\'assign\', \'defn\', \'for\'}\n\n\n\n\n\n\n\n\nQ.functional = Set {\'closure\', \'lua\'}\n\n\n\n\n\n\n\n\n\nQ.statement = Set {\'do\', \'while\', \'repeat\', \'if\', \'elseif\', \'else\', \'for\',\n                   \'defn\', \'assign\', \'goto\', \'label\', \'action\', \'break\',\n                   \'return\'}\n\n\n\n\n\n\n\n\nQ.condition = Set {\'and\', \'or\', \'not\'}\nQ.arithmetic = Set {\'concat\', \'add\', \'sub\', \'mul\', \'div\',\n                    \'mod\', \'len\', \'unm\', \'pow\',}\nQ.comparison = Set {\'gte\', \'lte\', \'neq\', \'eq\', \'gt\', \'lt\'}\nQ.unary = Set {\'not\', \'unm\', \'len\'}\nQ.binop = (Q.arithmetic + Q.comparison + Q.condition) - Q.unary\nQ.r_assoc = Set {\'pow\', \'concat\'}\nQ.op = Q.unary + Q.binop\nQ.l_assoc = Q.binop - Q.r_assoc\n-- Any op other than conditions can throw a type error:\nQ.fail_op = Q.op - Q.condition\n\n\n\n\n\n\n\n\nQ.ref_parent = Set {\'function_name\', \'var_chain\', \'caller\', \'lvalue\',\n                    \'condition\', \'chain\', \'expression\'} + Q.op\n\n\n\n\n\n\n\n\nQ.field_parent = Set { \'function_name\', \'pair\', \'var_chain\', \'method\',\n                           \'field_call\', \'chain\'}\n\n\n\n\n\n\n\n\n\nQ.literal = Set {\'number\', \'string\', \'table\', \'nil\', \'boolean\'}\n\n\n\n\n\n\n\n\nQ.atomic = Q.literal - {\'table\'}\n\n\n\n\n\n\nQ.symbol = Set {\'reference\', \'variable\', \'field\'}\n\n\n\n\n\n\nQ.value = Set { \"nil\", \"boolean\", \"vararg\", \"number\",\n                \"string\", \"table\", \"function\", \"action\",\n                \"var_chain\", \"reference\", \"index_expr\",}\n\n\n\n\n\n\nQ.identifier = Q.symbol - {\'field\'}\n\n\n\n\n\n\n\n\nQ.call = Set {\"chain\", \"call\"}\n\n\n\n\n\n\n\n\nQ.variadic = Q.call + {\"vararg\", \"iterator\"}\n\n\n\n\nreturn Q\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "qualia",
branch = "orb-db",
},
  { 
hash = "202c81b2b4394c66341fb4d3bf14012082d1ab7302ed123d1716af1da3617e96",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal Path, File, Dir = require \"fs:fs2/path\",\n                        require \"fs:fs2/file\",\n                        require \"fs:fs2/directory\"\n\nlocal idest = assert(use \"cluster:cluster\" . idest)\n\nlocal orb_db = require \"scry:orb-db\"\n\n\n\n\n\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\nlocal cluster = require \"cluster:cluster\"\nlocal idest = assert(cluster.idest)\n\nlocal new, Scan = cluster.order()\n\n\n\n\n\n\n\n\n\n\n\n\nlocal probe;\n\ncluster.construct(new, function(_new, scan, path, arc)\n   arc = arc or orb_db()\n   assert(path, \"path missing\")\n   assert(arc.new_database) -- we want this to fail over, easily ungated\n   scan.arc = arc\n   scan.stmt = arc:proxy \'scan\'\n   scan.path, scan.what = probe(path)\n\n   return scan\nend)\n\n\n\n\n\n\n\n\nprobe = function(p_str)\n   local path = Path(p_str)\n   local stat = path:stat()\n   if not stat then\n      return nil, { not_found = path }\n   end\n\n   local what = { type = stat.type }\n   if what.type == \'directory\' then\n      for sub in Dir(path):alldirs() do\n         if sub:basename() == \'orb\' then\n            what.codex = true\n         elseif sub:basename() == \'.git\' then\n            what.git_repo = true\n         end\n      end\n   elseif what.type == \'file\' then\n      -- is it Orb? Lua?\n      local f = File(path)\n      local ext = f:ext()\n      if ext == \'orb\' then\n         what.source = true\n      end\n      what.ext = ext\n   end\n   return path, what\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal buildDatabase;\n\nfunction Scan.doScan(scan)\n   if scan.arc.new_database then\n      buildDatabase(scan)\n   end\n\n   return scan\nend\n\n\n\n\n\n\n\n\n\n local function dbStat(stat)\n    stat.birthsec = stat.birthtime.sec\n    stat.birthnsec = stat.birthtime.nsec\n    stat.msec = stat.mtime.sec\n    stat.mnsec = stat.mtime.nsec\n    return stat\n end\n\n\n\nlocal function statDir(dir)\n   local stat = dir:stat()\n\n   if not stat then\n      error (\"bad Directory \" .. ts(dir))\n   end\n   return stat.ino, tostring(dir.path), dbStat(stat)\nend\n\nlocal function statFile(file)\n   local stat = file:stat()\n   if not stat then\n      error (\"bad File\" .. ts(file))\n   end\n\n   return stat.ino, tostring(file.path), dbStat(stat)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function buildNewProjectDB(scan)\n   local new_db = scan.arc.new_database\n   -- we need the following:\n   --    ino_stat: every ino, statted\n   local ino_stat = {}\n   --    ino_path, ino_file, ino_dir: to fs subjects from ino\n   local ino_path, ino_file, ino_dir = {}, {}, {}\n\n   --  We\'ll apply parentage later\n   local project_dir = Dir(scan.path)\n\n   --- collect all directory stats up to the root /\n   if new_db then\n      local parent = project_dir:parentDir()\n      while parent do\n         local ino, path, stat = statDir(parent)\n         ino_stat[ino] = stat\n         ino_path[ino] = path\n         ino_dir[ino] = parent\n         parent = parent:parentDir()\n      end\n   end -- else is a check for if the parent exists first\n\n\n   -- recursive walk to stat and map everything\n   local function railRoad(dir)\n      local ino, path, stat = statDir(dir)\n      ino_stat[ino], ino_path[ino], ino_dir[ino] = stat, path, dir\n\n      for sub in dir:all() do\n         if sub:exists() and (not sub:isPrivate()) then\n            if idest(File, sub) then\n               ino, path, stat = statFile(sub)\n               ino_stat[ino], ino_path[ino], ino_file[ino] = stat, path, sub\n            elseif idest(Dir, sub) then\n               railRoad(sub)\n            else\n               -- error?\n               error \"unreachable\"\n            end\n         end\n      end\n   end\n\n   -- railroad the project\n   railRoad(project_dir)\n\n   -- next!\n   local stmt = scan.stmt\n   local ins_file, ins_path, ins_dir = stmt.insert_file, stmt.insert_path,\n                                       stmt.insert_directory\n\n   -- insert files\n   for _, stat in pairs(ino_stat) do\n      ins_file :bindkv(stat) :value()\n   end\n   -- insert paths, get path_id\n   local ino_path_id, path_id = {}, {}\n\n   for ino, path in pairs(ino_path) do\n      ins_path :bind(ino, path) :value()\n      local id = stmt.lastRowId()\n      ino_path_id[ino] = id\n      path_id[path] = id\n   end\n   -- add directories, map ids\n   local dir_id = {}\n   for ino, dir in pairs(ino_dir) do\n      local path = tostring(dir.path)\n      ins_dir :bind(ino, path_id[path]) :value()\n      dir_id[path] = stmt.lastRowId()\n   end\n\n   -- add project\n   local project_path = tostring(scan.path)\n   local proj_dir_id = dir_id[project_path]\n   local name = scan.path:basename()\n   -- get repo-unique and module_db_fk at some point+\n   stmt.insert_project :bind(proj_dir_id, name) :value()\n   local project_id = stmt.lastRowId()\n\n   --- add source references\n   local ins_source = stmt.insert_source\n\n   for ino, path_id in pairs(ino_path_id) do\n      local file = ino_file[ino]\n      if file and file:ext() == \'orb\' then\n         ins_source :bind(path_id, project_id) :value()\n      end\n   end\n   --\nend\n\n\n\nlocal insert = assert(table.insert)\n\nfunction buildDatabase(scan)\n   assert(scan.what.codex,\n          \"new database: must be built from a project codex root!\")\n   local project_map = buildNewProjectDB(scan)\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _withProject(scan)\n   local stmt = scan.stmt\n   local dir_from_path = scan.dir_from_path\n   --local project =\n\nend\n\n\n\nfunction Scan.onCodex(scan)\n   -- new project? It will be for awhile...\n   _withProject(scan)\n\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "scan",
branch = "orb-db",
},
  { 
hash = "4ea01139158cb6d9fd89dc8c03d798ca249001f99a96a14d1fa6102cde96e57d",
binary = "\n\n\n\n\n\nlocal core, cluster = use (\"qor:core\", \"cluster:cluster\")\nlocal basis = assert(cluster.contract.basis)\nlocal define, Manifest = use (\"manifest:define\", \"manifest:manifest\")\n\n\n\n\n\n\n\n\n\nlocal flag = assert(basis.isboolean)\n\nlocal scry_define = { \'scry\',\n   always_scry = false,\n   interactive = false,\n   globals = {\n      allow_any = false,\n      allow_these = {},\n   },\n   unused_variables = {\n      allow_any = false,\n      allow_these = {},\n   },\n   ignore_cache = {\n      all = false,\n   },\n\n}\n\n\n\nreturn Manifest(scry_define)\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "scry-manifest",
branch = "orb-db",
},
  { 
hash = "7ea408d7d07eef0e4849435f682e08fe658903ba9a2c38e034861569a93906bf",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table = core.table\nlocal Set = core.set\nlocal cluster = require \"cluster:cluster\"\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\n\n\nlocal new, Scope = cluster.order()\n\n\n\n\n\n\nlocal function builder(_new, scope, synth)\n   scope.refs, scope.vars = {}, {}\n   scope.scopeOf = synth\n   scope.line = synth.line\n   scope.class = synth.class\n   scope.functional = synth.functional\n   _new.nameFor(scope)\n   if synth.class == \'lua\' then\n      scope.notFound = Set {}\n      scope.globals = Set(scope.scopeOf.env.keys)\n      scope.globalAssign = {}\n   end\n   return scope\nend\ncluster.construct(new, builder)\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = assert(core.set)\nlocal keys = assert(table.keys)\nlocal insert = assert(table.insert)\n\n-- come back with a map function and do this neater...\nfunction Scope.resolve(scope)\n   local outer, enclosed = scope.outer, true\n   -- not doing anything with this logic?\n   if not outer then\n      outer = {} -- globals?\n      enclosed = false\n   end\n   local varIDs = {}\n   for _, varsyn in ipairs(scope.vars or {}) do\n      insert(varIDs, varsyn.ID)\n   end\n   scope.makes = Set(varIDs)\nend\n\n\n\n\n\n\n\n\nfunction Scope.nameFor(scope)\n   local class = scope.class\n   if class == \'closure\' then\n      scope.name = scope.scopeOf:nameOf()\n      return scope.name\n   end\n   return scope.name\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal NO_GLOBAL = \'no global reference\'\nlocal LATER_DEF = \'defined later\'\n\n\n\nfunction Scope.lookup(scope, reference)\n   local ID = reference.ID\n   local later_def = nil\n   local case, found, out_later_def = nil, nil, nil\n\n   -- if in-scope, might be above or below.\n   -- if below, but defined in outer scope, not an error\n   if scope.makes[ID] then\n      local vars = assert(scope.vars)\n      for j = #vars, 1, -1 do\n         if vars[j].ID == ID then\n            if vars[j].o < reference.o then\n               case, found = \'my\', vars[j]\n            elseif vars[j].o > reference.o then\n               later_def = vars[j]\n            else\n               error(\"equal offsets, something weird: \"\n                      .. \"var: \" .. ts(vars[j])\n                      .. \"ref: \" ..ts(reference))\n            end\n         end\n      end\n   end\n   if case then\n      return case, found\n   end\n\n   -- either found or found later, let\'s look in the outer:\n   if scope.outer then\n      case, found, out_later_def = scope.outer:lookup(reference)\n   else\n      case, found, out_later_def = scope:lookupGlobal(reference)\n   end\n\n   if case then\n      return case, found\n   end\n\n   -- we might have found (unreachable) definitions in two places, here:\n   if later_def then\n      -- not completely valid, hmm\n      return nil, LATER_DEF, later_def\n   end\n\n   -- and outside:\n   if out_later_def then\n      return case, found, out_later_def\n   end\nend\n\n\n\nlocal function globalAssigned(reference)\n   local p_class, gp_class = reference.parent.class,\n                             reference.parent.parent.class\n\n   if p_class == \'lvalue\' and gp_class == \'assign\'\n      and (not reference.parent.parent.my) then\n\n      return true\n   else\n      return nil\n   end\nend\n\nlocal function globalMutated(scope, reference)\n   for _, assign in ipairs(scope.globalAssign) do\n      if reference.ID == assign.ID then\n         return true\n      end\n   end\n   return false\nend\n\nfunction Scope.lookupGlobal(scope, reference)\n   assert(scope.globals, \"not the outer scope\")\n   if scope.globals[reference.ID] then\n      return \'G\', { global = reference.ID } -- we synthesize globals later.\n   elseif globalMutated(scope, reference) then\n      -- just, slapping labels on things...\n      reference.global_mutated = true\n      return \'G\', { global = reference.ID}\n   else\n      scope.notFound[reference] = true\n      if globalAssigned(reference) then\n         reference.globalVar = true\n         insert(scope.globalAssign, reference)\n      end\n      return nil, NO_GLOBAL\n   end\nend\n\n\n\n\n\n\n\n\nlocal getset = assert(table.getset)\n\nfunction Scope.agree(scope)\n   local refs = assert(scope.refs, \".refs should exist even if empty\")\n   for _, ref in ipairs(refs) do\n      local which, var, late_var = scope:lookup(ref)\n      if which then\n         ref.declared = var\n         local referred = getset(var, \'referred\')\n         insert(referred, ref)\n      else\n         ref.not_found = true\n         ref.late_var = late_var\n      end\n   end\nend\n\n\n\nlocal masque = require \"scry:masque\"\nScope.paint = assert(masque.paintScope)\nScope.paintTree = assert(masque.paintScopeTree)\n\n\n\n\nreturn new\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "scope",
branch = "orb-db",
},
  { 
hash = "cb3ee5e236500abdab1d20a56fbeb7cc2353239aef8d8dd300369c49e498e0ad",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal table, string = core.table, core.string\nlocal Lua = require \"scry:lua-peg\"\nlocal Set = require \"qor:core/set\"\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg = require \"espalier:espalier/peg\"\n\n\n\n\n\nlocal File = require \"fs:fs/file\"\nlocal Skein = require \"orb:skein/skein\"\n\n\n\nlocal color = require \"singletons:color\" . color\nlocal s = require \"status:status\" ()\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\nlocal Synthesis = require \"scry:synthesis\"\nlocal Scope = require \"scry:scope\"\n\n\n\n\nlocal Q = require \"scry:qualia\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = Node : inherit ()\n\nfunction Twig.errorAt(twig)\n   local maybe_err = twig:lastLeaf()\n   if maybe_err.id == \'Error\' then\n      local line, col = maybe_err:linePos()\n      return line, col\n   end\n   return nil, nil\nend\n\n\n\n\n\n\n\n\nfunction Twig.details(twig, c)\n   local facts = {}\n   local line, col = twig:linePos()\n   facts.line, facts.col = c.number(line), c.number(col)\n   facts.id = c.field(twig.id)\n   facts.extra = twig:strExtra(c)\n   return facts\nend\n\n\n\n\n\n\n\n\nlocal insert, concat, remove = assert(table.insert),\n                               assert(table.concat),\n                               assert(table.remove)\n\nfunction Twig.strExtra(twig, c)\n   local traits = {}\n   for k, v in pairs(getmetatable(twig)) do\n     if v == true then\n         insert(traits, k)\n         insert(traits, \":\")\n      end\n   end\n   if #traits > 0 then\n      return concat(traits)\n   end\n   return \"\"\nend\n\n\n\n\n\n\n\n\nlocal MAX_ITER = 2048\n\nfunction Twig.parentScope(twig)\n   local up = twig\n   local count = 1\n   repeat\n      if count > MAX_ITER then break end\n      if up.scoped then\n         return up\n      else\n      end\n      up = up.parent\n      count = count + 1\n   until false -- ok because top scope\n   -- but we bust out anyway because /something/ will go wrong eventually.\n\n   error \"spun out without finding a scope :/\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nlocal function _scry(lua, c)\n   c = c or color\n   local scope = Scope(lua)\n   lua.scope = scope\n   local body = assert(lua :take \'body\')\n   for node, depth, index in body:walkBreadth() do\n      if node.scoped then\n         scope:new(node, depth, index)\n      end\n      if node.statement then\n         scope:frame(node, depth, index, node.scoped)\n      end\n   end\n   return scope\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __index(metabuild, key)\n   metabuild[key] = Twig :inherit(key)\n   return metabuild[key]\nend\n\n\n\nlocal Metas = setmetatable({}, {__index = __index})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal precedence = { [\'or\']  = 1,\n                     [\'and\'] = 2,\n                     -- comparisons added --*\n                     concat  = 4,\n                     add     = 5,\n                     sub     = 5,\n                     mul     = 6,\n                     div     = 6,\n                     mod     = 6,\n                     [\'not\'] = 7,\n                     len     = 7,\n                     unm     = 7,\n                     pow     = 8, }\n--* here\nfor q in pairs(Q.comparison) do\n   precedence[q] = 3\nend\n\nlocal right_assoc = {\'pow\', \'concat\'}\n\nlocal unary =  {\'not\', \'unm\', \'len\'}\n\n\n\nlocal Shunter = require \"espalier:espalier/shunter\"\n\n\n\nlocal ShuntProperties = { Twig, \'expression\',\n                          precedence = precedence,\n                          unary = unary,\n                          right_assoc = right_assoc }\n\nlocal expression, Expr_Metas, Expr = Shunter(ShuntProperties)\n\n\n\n\nMetas.expression = expression\nMetas.condition  = expression\nMetas.Expression = Expr -- the actual metatable\n\nfor id, meta in pairs(Expr_Metas) do\n   Metas[id] = meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(Metas.lvalue)\nMetas.var_list = Metas.lvalue\n\n\n\n\n\n\n\n\nassert(Metas.function_name)\nMetas.local_function_name = Metas.function_name\n\n\n\n\n\n\n\n\n\n\n\nfor quality, classes in pairs(Q) do\n   for class in pairs(classes) do\n      -- workaround for expression and condition\n      if type(Metas[class]) == \'table\' then\n         Metas[class][quality] = true\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Metas.assign.split(assign)\n   local is_local = assign :take \'local\' and true or false\n   local lval, rval = assign :take \'lvalue\', assign :take \'rvalue\'\n   -- the lvalue is always present, no rvalue for a pure declaration\n   return is_local, assert(lval, \'no lvalue\'), rval\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Scry = {}; Scry.__index = Scry\n\n\n\n\nlocal idest = assert(cluster.idest)\nlocal Lua = Peg(Lua, Metas)\n\nlocal function new(source)\n   local scry = {}\n   -- let\'s start multiple dispatch with a File\n   local str;\n   if idest(File, source) then\n      str = source:read()\n      scry.path = source.path\n      scry.name = source:basename()\n   elseif idest(Skein, source) then\n      str = assert(tostring(source.knitted.lua),\n                   \"can\'t scry Skein without Lua knit\")\n      scry.path = source.source.file.path:relPath()\n      scry.name = source.source.file:basename()\n   elseif idest(\'string\', source) then\n      str = source\n      scry.path = \"\"\n      scry.name = \"\"\n   else\n      error \"bad source\"\n   end\n   scry.lua = Lua\n   scry.mod = Lua(str)\n   scry.synth = Synthesis(scry.mod)\n   return setmetatable(scry, Scry)\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "scry",
branch = "orb-db",
},
  { 
hash = "96506115248c1b1257b67ee78884b2aaad5bdf634cf815c81278f0b79e1370b8",
binary = "\n\n\n\n\nlocal core = require \"qor:core\"\n\nlocal Scry = require \"scry:scry\"\nlocal masque = require \"scry:masque\"\nlocal Mold = require \"scry:molds\"\nlocal report = require \"scry:report\"\n\nlocal slurp = core.string.slurp\nlocal keys  = core.table.keys\n\nlocal ts = require \"repr:repr\" . ts_color\n\nlocal File = require \"fs:file\"\n\nlocal ni = true\nlocal path;\n\nif ni then -- synthesis when nil\n   path = \'src/sandbox.lua\'\nelse\n   path = \'src/synthesis.lua\'\nend\n\n\nlocal spy = Scry(slurp(path))\n\n--spy:frame()\n\nlocal mod, synth = assert(spy.mod), assert(spy.synth)\nlocal lua = spy.lua\nlocal hasfield = core.table.hasfield\nlocal scope = assert(synth :take \'lua\' .scope)\n\nreturn spy\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "smolrig",
branch = "orb-db",
},
  { 
hash = "f65bf6d15ec08770dcb356866db2e4c2ecdde154e6a2bddc84a8114599375a16",
binary = "\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal table, string = core.table, core.string\nlocal cluster = require \"cluster:cluster\"\nlocal ts = require \"repr:repr\" . ts_color\nlocal Set = core.set\n\n\n\nlocal paint = require \"scry:masque\" . paintMe\nlocal Scope = require \"scry:scope\"\n\n\n\nlocal suppress =  Set {\'not_analyzed\',\n                       \'not_synthesized\',\n                       \'parent\',\n                       --\'line\',\n                       \'o\',\n                       \'col\',\n                       \'env\',\n                       \'stache\',\n                       \'up\',\n                       \'value\',\n                       \'node\'\n                       }\n\n\n\n\n\n\n\n\nlocal sendScopeToScope, newSynth;\n\n\n\nlocal compact = table.compact\n\nlocal function frame(twig, synth, parent_synth)\n   -- synthesis\n   parent_synth = parent_synth or synth\n   synth.parent = parent_synth\n   synth:synthesize()\n\n   -- scopes\n   if synth.scoped then\n      synth.scope = Scope(synth)\n      if not (parent_synth == synth) then\n         sendScopeToScope(synth.scope, parent_synth)\n      end\n   end\n\n   -- sub-synthesis\n   for i, ast in ipairs(twig) do\n      synth[i] =  newSynth(ast, i)\n      frame(ast, synth[i], synth)\n   end\n\n   -- garbage collection (right now makes sure none such is needed/happens)\n   compact(synth, #twig)\n   if #synth < #twig then\n      error \"compaction throws off up indexes, account for this\"\n   end\n\n   -- analysis\n   synth:analyze()\n\n   return synth\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Q = require \"scry:qualia\"\n\n\n\n\nlocal function noNode(_, val)\n   if type(val) == \'table\' and val.isNode then\n      return true\n   end\nend\n\nlocal _lens = { hide_key = suppress,\n                noPairs  = noNode,\n                depth = 6 }\n\n\n\n\n\n\nlocal new, Syndex, SynM = cluster.order()\n\nlocal function builder(_new, synth, node, i)\n   synth.up = i\n   synth.o = node.first\n   synth.node = node\n   synth.line, synth.col = node:linePos()\n   -- this is just for reading purposes, remove\n   -- when we have a subject view\n   synth.class = _new.class\n   return synth\nend\n\ncluster.construct(new, builder)\n\nlocal Syn_repr = require \"repr:lens\" (_lens)\n\nSynM.__repr = Syn_repr\n\n\n\nSyndex.paint = paint\n\n\n\n\n\n\n\n\n\n\nlocal newSes, metaSes =  {}, {}\n\nlocal function makeGenus(class)\n   local _new, Class, Class_M = cluster.genus(new)\n   cluster.extendbuilder(_new, true)\n   newSes[class] = _new\n   metaSes[class] = Class\n   Class.class = class\n   for quality, set in pairs(Q) do\n      if set[class] then\n         Class[quality] = true\n      end\n   end\n   return _new, Class, Class_M -- we ignore the metatable. until we don\'t.\nend\n\nnewSynth = function (node, i)\n   local class = node.id\n   local _new, Class = newSes[class]\n   if not _new then\n      _new, Class = makeGenus(class)\n   end\n   return _new(node, i)\nend\n\n\n\n\n\n\n\nlocal function Syn_index(Syn, class)\n   local meta, _ = metaSes[class]\n   if not meta then\n      _, meta = makeGenus(class)\n      Syn[class] = meta\n   end\n   return meta\nend\n\nlocal Syn = setmetatable({Syndex}, {__index = Syn_index })\n\n\n\n\n\n\n\n\n\nlocal walk = require \"gadget:walk\"\nlocal filter, reduce = assert(walk.filter), assert(walk.reduce)\nlocal classfilter = {}\n\nlocal function filterer(class)\n   local F = classfilter[class]\n   if not F then\n      classfilter[class] = function(node)\n                        return node.class == class\n                     end\n      F = classfilter[class]\n   end\n   return F\nend\n\nfunction _filter(synth, pred)\n   if type(pred) == \'string\' then\n      return filter(synth, filterer(pred))\n   else\n      return filter(synth, pred)\n   end\nend\nSyndex.filter = _filter\n\n\n\nfunction Syndex.take(synth, pred)\n   for syn in _filter(synth, pred) do\n      return syn\n   end\nend\n\n\n\nfunction Syndex.reduce(synth, pred)\n   if type(pred) == \'string\' then\n      return reduce(synth, filterer(pred))\n   else\n      return reduce(synth, pred)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Syndex.left(syn)\n   return syn.parent[syn.up + 1]\nend\n\nfunction Syndex.right(syn)\n   return syn.parent[syn.up - 1]\nend\n\n\n\n\n\n\n\n\nfunction Syndex.span(synth)\n   return synth.node:span()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal allkeys = assert(table.allkeys)\n\nlocal skip = Set {\'node\', \'parent\'}\n\nfunction Syndex.digest(syn)\n   local fact = {}\n   local all_keys = allkeys(syn)\n   fact.parent_class = syn.parent.class\n   for _, key in ipairs(all_keys) do\n      if type(key) == \'string\' then\n         local value, val_t = syn[key], type(syn[key])\n         if val_t == \'string\'\n            or val_t == \'number\'\n            or val_t == \'boolean\' then\n            fact[key] = value\n         elseif val_t == \'table\' then\n            if not skip[key] then\n               fact[key] = {}\n            end\n         end\n      end\n   end\n   return fact\nend\n\nfunction Syndex.digestAll(syn)\n   local fact = syn:digest()\n   for _, sub in ipairs(syn) do\n      insert(fact, sub:digestAll())\n   end\n   return fact\nend\n\n\n\n\n\n\n\n\n\nlocal lineat = assert(string.lineat)\nfunction Syndex.lineOn(synth)\n   local line, first = lineat(synth.node.str, synth.line)\n   return line, synth.o - first\nend\n\n\n\n\nfunction Syndex.nameOf(synth)\n   return synth.name or synth.class\nend\n\n\n\nfunction Syndex.shed(syn)\n   if #syn > 1 then\n      error \"can\'t shed a node with several children\"\n   elseif #syn == 0 then\n      error \"can\'t shed a leaf node\"\n   end\n   assert(syn.parent[syn.up] == syn, \"parent missing child\")\n   syn.parent[syn.up] = syn[1]\n   syn[1].parent = syn.parent\n   syn[1].up = syn.up\nend\n\n\n\n\n\n\n\n\n\n\n\nSyndex.synthesize = cluster.ur.pass\nSyndex.analyze = cluster.ur.pass\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal scoped = Q.scoped\n\nlocal function _scope(syn)\n   local up, up_id = syn.parent, syn.parent.class\n   while true do -- everything should be in a scope.\n      if scoped[up_id] then\n         return up.scope\n      else\n         up, up_id = up.parent, up.parent.class\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal getset = assert(table.getset)\nsendScopeToScope = function(scope, parent)\n   local upscope = _scope(parent)\n   local inner = getset(upscope, \'inner\')\n   insert(inner, scope)\n   scope.outer = upscope\nend\n\n\n\n\n\n\nlocal function sendRefToScope(ref)\n   local scope = _scope(ref)\n   local refs = scope.refs\n   insert(refs, ref)\nend\n\n\n\n\n\n\nlocal function sendVarToScope(var, is_fn)\n   local _scoped = is_fn and var.parent.parent or var\n   local scope = _scope(_scoped)\n   local vars = getset(scope, \'vars\')\n   insert(vars, var)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function sendExitToScopes(Return, exit)\n   local scope = _scope(Return)\n   insert(getset(scope, \'out\'), exit)\n   if scope.functional then return end\n   while not scope.functional do\n      scope = _scope(scope.scopeOf.parent)\n   end\n   insert(getset(scope, \'out\'), exit)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal allkeys = assert(table.allkeys)\n\nfunction Syn.lua.synthesize(lua)\n   -- we do a lot more with globals than just spot them, after we can do\n   -- subtyping and function synthesis\n   local _env = lua.ENV or getfenv(0) -- 0 is rude but comprehensive\n   lua.env = { keys = table.keys(_env) }\n   lua.parent = lua\n   --  We eventually load context about every single builtin, and so on and\n   --  So forth, but this is a start.\nend\n\n\n\n\n\n\n\nfunction Syn.lua.analyze(lua)\n   --[[ this will more than likely have content\n        at some point, the old code was just validation\n        and lives in :validate below\n   --]]\n\nend\n\n\n\n\n\n\nfunction Syn.lua.validate(lua)\n   -- any other invariants we want to test should go in here\n   for syn in lua:filter(cluster.ur.yes) do\n      if (not syn.up) and syn.class ~= \'lua\' then\n         return nil, \"missing up on \" .. syn.class\n      elseif syn.up and syn.up > 0 then\n         if not (syn.parent[syn.up] == syn) then\n            return nil, \"parent of \" .. syn.class .. \" at line \" .. syn.line\n                        .. \" does not have syn as child at \" .. syn.up\n         end\n      end\n   end\n\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function linkMov(mov)\n   mov.lvalue.rvalue = mov.rvalue\n   if mov.rvalue then\n      insert(getset(mov.rvalue, \'lvalue\'), mov.lvalue)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Syn.assign.synthesize(assign)\n   assign.my = not not assign :take \'local\'\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function nameForLvalue(lvalue)\n\n      if lvalue.class == \'variable\'\n         or lvalue.class == \'reference\'\n         or lvalue.class == \'function_name\' then\n         lvalue.ID = lvalue:span()\n      elseif lvalue.class == \'var_chain\' then\n         if lvalue[1].class == \'reference\' then\n            lvalue.ID = lvalue[1]:span()\n         else\n            lvalue.name = lvalue:span()\n         end\n      else\n         error(\"keep going: \" .. lvalue.class)\n      end\n      lvalue.name = lvalue.name or lvalue.ID or error \"need lvalue.ID or lvalue.name\"\nend\n\n\n\n\n\n\n\n\n\nlocal function balanceAssignments(my, lvals, rvals)\n   local mov = {}\n   local last_rval;\n   local arity = 1\n   for i, lval in ipairs(lvals) do\n      local _mov = {\n         lvalue = lval,\n         my = my,\n      }\n      mov[i] = _mov\n      nameForLvalue(lval)\n\n      local rval = rvals[i]\n      if rval then\n         assert(rval.class == \'expression\', \"rvalues should all be expressions\")\n         _mov.rvalue = rval\n         _mov.arity = arity\n         last_rval = rval\n      else\n         arity = arity + 1\n         if last_rval and last_rval[1].variadic then\n            _mov.rvalue = last_rval\n            _mov.arity = arity\n         else\n            _mov.rvalue = false\n         end\n      end\n      linkMov(_mov)\n   end\n   return mov\nend\n\n\n\n\n\nfunction Syn.assign.analyze(assign)\n   local my, lvals, rvals = assign.my,\n                            assign :take \'lvalue\',\n                            assign :take \'rvalue\' or {}\n   assign.mov = balanceAssignments(my, lvals, rvals)\nend\n\n\n\n\n\n\n\n\n\n\nSyn.defn.synthesize = Syn.assign.synthesize\n\nfunction Syn.defn.analyze(defn)\n   local my, name, closure  = defn.my,\n                              defn :take \'function_name\',\n                              defn :take \'closure\'\n   local _mov = { my = my,\n                  lvalue = name, -- perhaps name[1]?\n                  arity = 1,\n                  rvalue = closure }\n   nameForLvalue(_mov.lvalue)\n   linkMov(_mov)\n   defn.mov = {_mov}\nend\n\n\n\n\n\n\n\n\n\n\n\nSyn[\'for\'].analyze = function(For)\n   local counter = For :take \'counter\'\n   if counter then\n      local mov = linkMov { numeric = true,\n                            lvalue = counter,\n                            my = true,\n                            arity = 1,\n                            rvalue = assert(For :take \'range\'), }\n      For.mov = {mov}\n   else\n      local lvalue, iterator = For :take \'lvalue\', For :take \'iterator\'\n      -- Note that this is completely wrong. It\'s better, because it links\n      -- all the lvalues with /something/ and does distinguish between them,\n      -- however they all come from the iterator image, which is defined in\n      -- up to three variables\n      --\n      -- In e.g. for a, b in next, tab, nil this will assign a to next and\n      -- b to nil, neither of which is correct.\n      --\n      -- It *should* accidentally do the right things with ipairs and pairs.\n      For.mov = balanceAssignments(true, lvalue, iterator)\n   end\n\nend\n\n\n\n\n\n\n\n\nSyn[\"return\"].analyze = function (Return)\n   local exit = {}\n   for expr in Return :filter \'expression\' do\n      insert(exit, expr)\n   end\n   sendExitToScopes(Return, exit)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function evalAtom(span)\n   return load(\"return \" .. span)()\nend\n\nlocal function synthAtomic(synth)\n   synth.token = synth.node:span()\n   do\n      local ego = getset(synth, \'ego\')\n      ego.primal = synth.class\n      ego.just = evalAtom(synth.token)\n      ego.falsy = not ego.just\n   end\nend\n\nfor class in pairs(Q.atomic) do\n   Syn[class].synthesize = synthAtomic\nend\n\n\n\n\n\n\nfunction Syn.table.synthesize(tab)\n   local ego = getset(tab, \'ego\')\n   ego.primal = \'table\'\n   ego.falsy = false\n   -- we account for the map/array itself in analysis\nend\n\n\n\n\n\n\nfunction Syn.closure.analyze(closure)\n\nend\n\n\n\n\n\n\n\nfunction Syn.reference.synthesize(reference)\n   reference.ID = reference:span()\n   reference.ego = {}\n   sendRefToScope(reference)\n   assert(reference.parent.ref_parent, \"unrecognized ref parent \"\n                                       .. reference.parent.class .. \", \"\n                                       .. \" GP:\" .. reference.parent.parent.class )\n   -- here we deduce what we can from how the reference is used\n   local parent, context = reference.parent, reference.parent.class\n   local able;\n   if context == \'caller\' then\n      able = { call = true }\n   elseif context == \'var_chain\' or context == \'function_name\' then\n      able = { index = true }\n   elseif context == \'lvalue\' then\n      reference.ego.mutation = true\n   elseif parent.fail_op then\n      able = { [context] = true }\n   end\n   reference.ego.able = able\nend\n\n\n\n\n\n\nfunction Syn.variable.synthesize(variable)\n   variable.ID = variable:span()\n   local parent_class = variable.parent.class\n   local is_fn = parent_class == \'function_name\' or parent_class == \'local_function_name\'\n   if is_fn then\n      local ego = getset(variable, \'ego\')\n      ego.primal = \'function\'\n      ego.ins = {}\n      ego.outs = {}\n   else\n      assert(Q.var_parent[parent_class], parent_class)\n      -- pass for now\n   end\n   sendVarToScope(variable, is_fn)\nend\n\n\n\n\n\n\nfunction Syn.field.synthesize(field)\n   if not field.parent.field_parent then\n      error(\"unexpected field parent \" .. field.parent.class\n            .. \" on line \" .. field.line .. \" \\n\"\n            .. ts (field.parent.parent.node))\n   end\n   field.primal = \'string\'\n   field.symbol = true\n   field.token = field:span()\n   field.value = field.token\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasfield = assert(table.hasfield)\nlocal function Synthesize(lua)\n   local synth = frame(lua, newSynth(lua, nil))\n   for has in synth :filter(hasfield.scope) do\n      has.scope:resolve()\n      has.scope:agree()\n   end\n\n   return synth\nend\n\n\n\n\nreturn Synthesize\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "synthesis",
branch = "orb-db",
},
  { 
hash = "5e8d10a08e2a10c63a3eb47020b16094cbb9d72069a197a91276832169dbcf9f",
binary = "\n\n\n\n\n\nlocal T = {}\n\n\n\n\n\n\nlocal Is = {}\n\n\n\n\n\n\nfunction Is.Boolean(ego)\n   return ego.primal == \'boolean\'\nend\n\nfunction Is.Number(ego)\n   return ego.primal == \'number\'\nend\n\nfunction Is.String(ego)\n   return ego.primal == \'string\'\nend\n\nfunction Is.Nil(ego)\n   return ego.primal == \'nil\'\nend\n\nfunction Is.Function(ego)\n   return ego.primal == \'function\'\nend\n\nfunction Is.Table(ego)\n   return ego.primal == \'table\'\nend\n\n\n\n\n\n\nT.Is = Is\n\n\n\nreturn T\n\n",
vc_hash = "fbb7a44a45363aa5de34cf0c7d602e883a8e171d\n",
name = "typing",
branch = "orb-db",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/set.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "set",
    repo = "git@gitlab.com:special-circumstance/set.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "ca8c1bc500e2c5da4e3f90f9368c10c5eea98ba48f8136830fb2c99a27b88835",
binary = "\n\n\n\n\n\nlocal Set = {}\nSet.__index = Set\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _s = setmetatable({}, { __mode = \'k\' })\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(items)\n   -- set /object/\n   local set = {}\n   -- set /collection/\n   local ∈ = {}\n   -- cached in the attribute table as per usual\n   _s[set] = ∈\n   setmetatable(set, Set)\n\n   assert(type(items) == \"table\" or items == nil,\n          \"argument to set constructor must be a table\")\n   if items then\n      if items.idEst == new then\n         for k, _ in pairs(_s[items]) do\n            ∈[k] = true\n         end\n      else\n         for _, value in ipairs(items) do\n            ∈[value] = true\n         end\n      end\n   end\n   return set\nend\nSet.idEst = new\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.insert(set, ...)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   local items = pack(...)\n   for i = 1, items.n do\n      if items[i] then\n         ∈[items[i]] = true\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.remove(set, ...)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   local removed = true\n   local items = pack(...)\n   for i = 1, items.n do\n      removed = ∈[items[i]] and removed\n      ∈[items[i]] = nil\n   end\n   return removed and removed or nil\nend\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\n\nfunction Set.clear(set)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   clear(∈)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.∈(set, item)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   return ∈[item] or false\nend\n\nSet.E = Set.∈\n\n\n\n\n\n\n\n\nfunction Set.__call(set, item)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   return ∈[item] or false\nend\n\n\n\n\n\n\nlocal function hasSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\", \"bad argument #2 to hasSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = true\n   local maybe_∈ = assert(_s[maybe_subset], \"set elements lost at C\")\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   for k, _ in pairs(maybe_∈) do\n     is_subset = is_subset and ∈[k]\n   end\n\n   return is_subset == true\nend\n\nSet.hasSubset = hasSubset\n\nfunction Set.__lte(head, tail)\n   return hasSubset(tail, head)\nend\n\n\n\n\n\n\nlocal function hasProperSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\",\n          \"bad argument #2 to hasProperSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = hasSubset(set, maybe_subset)\n   local is_superset = false\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   local maybe_∈ = assert(_s[maybe_subset], \"set elements lost at C\")\n   for k, _ in pairs(∈) do\n      if not maybe_∈[k] then\n         is_superset = true\n      end\n   end\n   -- coerce a nil result to boolean for return value\n   return (is_subset and is_superset) == true\nend\n\nSet.hasProperSubset = hasProperSubset\n\nfunction Set.__lt(head, tail)\n   return hasProperSubset(tail, head)\nend\n\n\n\n\n\n\n\n\nfunction Set.__len(set)\n   local count = 0\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   for _, __ in pairs(∈) do\n      count = count + 1\n   end\n   return count\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.__eq(left, right)\n   local same = true\n   local l_∈ = assert(_s[left], \"set elements lost at C\")\n   local r_∈ = assert(_s[right], \"set elements lost at C\")\n   for k, _ in pairs(l_∈) do\n      same = same and r_∈[k] ~= nil\n   end\n   for k, _ in pairs(r_∈) do\n      same = same and l_∈[k] ~= nil\n   end\n   return same == true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function union(head, tail)\n   local union = new(head)\n   local u_∈ = assert(_s[union], \"set elements lost at C\")\n   assert(type(tail) == \"table\", \"bad argument #2 to union: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   local h_∈ = assert(_s[head], \"set elements lost at C\")\n   local t_∈ = assert(_s[tail], \"set elements lost at C\")\n   for k, _ in pairs(t_∈) do\n      u_∈[k] = true\n   end\n   return union\nend\n\nSet.union = union\n\nfunction Set.__add(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot make union of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return union(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function difference(head, tail)\n   local diff = new(head)\n   local d_∈ = assert(_s[diff], \"set elements lost at C\")\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to difference: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   local t_∈ = assert(_s[tail], \"set elements lost at C\")\n   for k,_ in pairs(t_∈) do\n      d_∈[k] = nil\n   end\n   return diff\nend\n\nSet.difference = difference\n\nfunction Set.__sub(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot take difference of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return difference(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.intersection(head, tail)\n   local h_∈ = assert(_s[head], \"set elements lost at C\")\n   local section = new()\n   local s_∈ = assert(_s[section], \"set elements lost at C\")\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to intersection: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   local t_∈ = assert(_s[tail], \"set elements lost at C\")\n   for k,_ in pairs(t_∈) do\n      if h_∈[k] then\n         s_∈[k] = true\n      end\n   end\n   return section\nend\n\n\n\n\n\n\n\n\n\nfunction Set.__newindex(set, key, value)\n   assert(type(value) == \'boolean\' or value == nil,\n      \"Bad assignment to Set: must be boolean or nil\")\n   if value == false then\n      value = nil\n   end\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   rawset(∈, key, value)\nend\n\n\n\n\n\n\n\n\nfunction Set.__pairs(set)\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   return pairs(∈)\nend\n\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate, Token\n\nfunction Set.__repr(set, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n\n   local ∈ = assert(_s[set], \"set elements lost at C\")\n   return wrap(function()\n      yield(Token(\"#{ \", { color = \"base\", event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for v, _ in pairs(∈) do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n         end\n         for t in tabulate(v, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "7445ac07daee8954cd02e54e566cbe9079f05cc5\n",
name = "set",
branch = "2022-02-28_RELEASE_BRANCH",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/singletons.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "singletons",
    repo = "git@gitlab.com:special-circumstance/singletons.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "fec80c7dbde72dbeed76d87afef5b205492a497575250dd821d26f688aeafc3f",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal S = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.color = require \"singletons/color\"\n\n\n\n\n\n\n\n\nS.codepoints = require \"singletons/codepoints\"\nS.Codepoints = S.codepoints\n\n\n\n\n\nS.phrase = require \"singletons/phrase\"\nS.Phrase = S.phrase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.check = require \"singletons/check\"\nS.It = S.check\n\n\n\n\n\n\n\n\n\n\n\nreturn S\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons",
branch = "trunk",
},
  { 
hash = "\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"singletons\"\n\n",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"singletons\"\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "ss",
branch = "trunk",
},
  { 
hash = "\n\n\n\n\n\nreturn require \"singletons\"\n\n",
binary = "\n\n\n\n\n\nreturn require \"singletons\"\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "init",
branch = "trunk",
},
  { 
hash = "0ffd0f68228d27dae4a962f367981b6fc07829a9b319af29472e42ce8c4b8e62",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable)\n\n\n\nlocal Stator = meta {}\n\n\n\n\n\n\n\n\n-- local _weakstate = setmeta({}, {__mode = \'v\'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(stator, _weakstate)\n   local _weakstate = _weakstate or setmeta({}, {__mode = \'v\'})\n   local _M = setmeta({}, {__index = stator, __call = call })\n   _M._weakstate =  _weakstate\n   return _M\nend\n\n\n\n\n\n\n\n\n\nlocal function new(Stator, _weakstate)\n   local stator = call(Stator, _weakstate)\n   stator.g, stator.G, stator._G = stator, stator, stator\n   return stator\nend\n\n\n\n\nreturn setmetatable(Stator, {__call = new})\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons/stator",
branch = "trunk",
},
  { 
hash = "dcfd442389f768062046498979c1740debd3d0cd6b699118455e8290bbf9d41e",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal utf8 = assert(require \"core:string\" . utf8)\n\n\n\n\n\nlocal Codepoints = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal sub = assert(string.sub)\n\nfunction Codepoints.__call(codepoints, str, start, finish)\n   start = start or 1\n   finish = (finish and finish <= #str) and finish or #str\n   -- propagate nil\n   if not str then return nil end\n   -- break on bad type\n   assert(type(str) == \"string\", \"codepoints must be given a string\")\n   local codes = setmetatable({}, Codepoints)\n   local index = start\n   while index <= finish do\n      local width, err = utf8(str, index)\n      if width then\n         local point = sub(str, index, index + width - 1)\n         insert(codes, point)\n         index = index + width\n      else\n         -- take off a byte and store it\n         local err_packet = { char = sub(str, index, index),\n                              err  = err }\n         codes.err = codes.err or {}\n         insert(codes, \"�\")\n         -- place the error at the same offset in the err table\n         codes.err[#codes] = err_packet\n         index = index + 1\n      end\n   end\n   return codes\nend\n\n\n\n\n\n\n\n\n\nlocal clone = assert(require \"core:core/table\" . clone)\n\nlocal function _adjustErrors(codepoints, pos, offset)\n   if pos and codepoints.err then\n      -- cache the error table so we can copy the\n      -- removed points without worrying about blasting them\n      -- before we reach them while iterating\n      local err_cache = clone(codepoints.err)\n      -- remove all errors above pos at once\n      for i, _ in pairs(codepoints.err) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i] = nil\n         end\n      end\n      -- now add them back, shifted by offset\n      for i, v in pairs(err_cache) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i + offset] = v\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Codepoints.insert(codepoints, pos, value)\n   if value then\n      -- Insert the fragment\n      insert(codepoints, pos, value)\n      -- Only need to adjust errors if inserting other than at the end\n      _adjustErrors(codepoints, pos, 1)\n   else\n      -- Work around arguable bug in table.insert where calling\n      -- insert({}, \"a\", nil) throws an error--the third parameter\n      -- must be actually omitted rather than merely nil\n      insert(codepoints, pos)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\n\nfunction Codepoints.remove(codepoints, pos)\n   local rem = remove(codepoints, pos)\n   -- Remove any corresponding error from the error table\n   if codepoints.err then\n      codepoints.err[pos or #codepoints + 1] = nil\n      -- And remove it altogether if it is now empty\n      if next(codepoints.err) then\n         _adjustErrors(codepoints, pos, -1)\n      else\n         codepoints.err = nil\n      end\n   end\n   return rem\nend\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nfunction Codepoints.__tostring(codepoints)\n   local output = codepoints\n   if codepoints.err then\n      output = {}\n      for i, v in ipairs(codepoints) do\n         local err_here = codepoints.err[i]\n         output[i] = err_here and err_here.char or v\n      end\n   end\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, byte = assert(string.format),\n                           assert(string.find),\n                           assert(string.byte)\n\nlocal escapes_map = {\n   [\'\"\'] = \'\\\\\"\',\n   [\"\'\"] = \"\\\\\'\",\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nfunction Codepoints.toLuaString(codepoints, preface, afterward)\n   if type(codepoints) == \"string\" then\n      codepoints = Codepoints.__call(nil, codepoints)\n   end\n   local phrase = {}\n   if preface then\n      insert(phrase, preface)\n   end\n   insert(phrase, \'\"\')\n   local err = codepoints.err or {}\n   for i,frag in ipairs(codepoints) do\n      -- escape map non-printing chars\n      -- replace errors with an \\x?? token\n      -- otherwise, insert the frag\n      if escapes_map[frag] or find(frag, \"%c\") then\n         frag = escapes_map[frag] or format(\"\\\\x%02x\", byte(frag))\n      end\n      if err[i] then\n         frag = format(\"\\\\x%02x\", byte(err[i].char))\n      end\n      insert(phrase, frag)\n   end\n   insert(phrase, \'\"\')\n   if afterward then\n      insert(phrase, afterward)\n   end\n   return concat(phrase)\nend\n\n\n\nlocal CP_constructor = setmetatable({}, Codepoints)\nCodepoints.idEst = CP_constructor\n\n\n\nreturn CP_constructor\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons/codepoints",
branch = "trunk",
},
  { 
hash = "cde0afd9842408b294af7fec2768d5419688f0e67ed18560a4bcfe37ec630a9c",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\n\nlocal Palette = require \"anterm:anterm/palette\"\n\nlocal WIDE_TABLE = 200 -- should be tty-specific\n\nlocal C = {}\n\nlocal thread_shade = a.fg24(240, 50, 100)\n\n-- #Todo make this into a proper color and use it again\n\nlocal function thread_color(str)\n   return a.italic .. thread_shade .. str .. a.clear\nend\n\nC.color = Palette {\n   -- Types and pseudo-types\n   [\"nil\"]      = a.fg(93),\n   [\"true\"]     = a.fg(231),\n   [\"false\"]    = a.fg(94),\n   number       = a.fg(42),\n   string       = a.fg(222),\n   stresc       = a.fg(225), -- Escaped characters within strings\n   table        = a.fg(64),\n   [\"function\"] = a.fg24(210,12,120),\n   userdata     = a.fg24(230, 145, 23),\n   cdata        = a.fg24(200, 115, 0),\n   thread       = a.fg24(240, 50, 100),\n   metatable    = a.fg24(242, 0, 234),\n   -- Syntax elements\n   field        = a.fg(111),\n   operator     = a.fg24(220, 40, 150),\n   keyword      = a.fg24(100, 210, 100),\n   comment      = a.fg24(128,128,128),\n   base         = a.fg24(200, 200, 200),\n   -- Misc\n   alert        = a.fg24(250, 0, 40),\n   search_hl    = a.fg24(30, 230, 100),\n   [\"error\"]    = a.bg24(50,0,0),\n   bold         = a.bold,\n   greyscale    = a.fg24(128,128,128),\n   highlight    = a.bg24(70, 70, 70)\n}\n\nC.depth = 4 -- table print depth\n\n\n\n\n\n\n\n\n\nlocal no_color = { name = \"no_color\" }\n-- if field accessed, pass through\nlocal function _no_c_index(nc, _)\n   return nc\nend\n\nlocal function _no_c_call(_, str)\n   return str or \"\"\nend\n\nlocal function _no_c_concat(head, tail)\n   head = head == no_color and \"\" or head\n   tail = tail == no_color and \"\" or tail\n   return head .. tail\nend\n\nsetmetatable(no_color, { __index  = _no_c_index,\n                                __call   = _no_c_call,\n                                __concat = _no_c_concat, })\n\nC.no_color = no_color\n\n-- Also attach a no_color option to the regular color table\nC.color.no_color = no_color\n\n\n\n\n\nreturn C\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons/color",
branch = "trunk",
},
  { 
hash = "bfbaaaace8ccf657afa714c701e177c3aac4fe5bbf3658b84b06b0562eac41fe",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ts = tostring\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ItIndex(itself, verb)\n   if verb == \"won\" or verb == \"did\" then\n      return nil\n   end\n   verb = verb and verb or \"\"\n   local it = itself.current\n   local result = {success = false}\n   result.why = \"`check` does not understand the verb \" .. ts(verb)\n               .. \" at least, not yet\" -- ¯\\_(ツ)_/¯\n   io.write(result.why .. \"\\n\")\n   it.did.also(result)\n   return function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(it)\n   if it.won == nil then\n      it = it:collate()\n   end\n   if it.won then\n      return it.subject, it\n   else\n      return nil, it\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function __repr(it)\n   return it.digest\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n   if Object.isIt and Object.isIt == It then\n      return Object\n   end\n\n   local itself = setmetatable({}, {__index = It,\n                                    __call = call,\n                                    __repr = __repr})\n   It.current  = setmetatable({} , {__index = itself,\n                                    __call = call,\n                                    __repr = __repr} )\n   itself.isIt = It\n   itself.name = name and name or \"it\"\n   itself.subject = Object\n   itself = must(itself)\n   itself.did = {}\n   itself.did.also = function(result)\n                        result.modal = itself.modal\n                        itself.did[#itself.did + 1] = result\n                        return itself\n                     end\n   itself.did.last = function() return itself.did[#itself.did] end\n\n   return itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\n\n\nlocal ts = tostring -- stub, #todo replace with real deal\nlocal function verdict(it, subject, verb, object)\n   local subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n   return it.name .. \": \" .. subj .. it.modal.inThatIt\n          .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local must = setmetatable({}, Modal)\n   must.beTrue = true\n   must.because = because\n   must.inThatIt = \"must\"\n   it.modal = must\n   return it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local mustnt = setmetatable({}, Modal)\n   mustnt.because = because or \"\"\n   mustnt.beTrue = false\n   mustnt.inThatIt = \"mustn\'t\"\n   it.modal = mustnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n   local should = setmetatable({}, Modal)\n   should.because = because or \"\"\n   should.beTrue = true\n   should.inThatIt = \"should\"\n   it.modal = should\n   return it\nend\n\nfunction It.shouldnt(it, because)\n   local shouldnt = setmetatable({}, Modal)\n   shouldnt.because = because or \"\"\n   shouldnt.beTrue = false\n   shouldnt.inThatIt = \"shouldn\'t\"\n   it.modal = shouldnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.can(it, because)\n   local can = setmetatable({}, Modal)\n   can.because = because or \"\"\n   can.beTrue = nil\n   can.inThatIt = \"could\"\n   it.modal = can\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.could(it, because)\n   local could = setmetatable({}, Modal)\n   could.because = because or \"\"\n   could.beTrue = nil\n   could.inThatIt = \"could\"\n   it.modal = could\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n   local result = {}\n   local success = it.subject == rValue and true or false\n   if not it.modal.beTrue then\n      success = not success\n   end\n   if success then\n      result.why =  verdict(it, it.subject, \"equal\", rValue)\n   else\n      result.why = verdict(it, it.subject, \"not equal\", rValue)\n   end\n   result.success = success\n\n   return it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n   local result = {}\n   local success = false\n   local having = it.subject[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having\n\n   if having == nil then\n      -- todo better message if \'has\' failed,\n      -- the more common case.\n      result.why = \"equalTo must follow have/has\"\n   else\n      success = having == rValue and true or false\n      local subj, obj\n      if not it.modal.beTrue then\n         success = not success\n         subj, obj = having, rValue\n      else\n         subj, obj = rValue, having\n      end\n      if success then\n         result.why = because or verdict(it, subj, \"==\", obj)\n       else\n         result.why = because or verdict(it, subj, \"~=\", obj)\n       end\n       result.having = having -- to chain field checks\n   end\n\n   result.success = success\n   return it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n   local result = {}\n   local success = false\n   local last = it.did[#it.did]\n   local having = last.having\n   if type(len) ~= \"number\" then\n      result.why = \"ofLen param must be a number\"\n   elseif not having then\n      result.why = \"ofLen must have a value on it.did\"\n   else\n      success = #having == len and true or false\n      if not it.modal.beTrue then\n         success = not success\n      end\n      if success then\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"==\", len)\n       else\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"~=\", len)\n       end\n   end\n\n   result.success = success\n   result.inThatIt = it.modal.inThatIt\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n   local result = { success = false,\n                    why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n   return {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   local method = last.having\n   if not method then\n      result.why = \"calling must be performed on a value\"\n   elseif not type(method) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name .. \" field must be function: \" .. last.field)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = method(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.field  = last.field\n      local callee = ts(last.field, \"field\") .. \"(\"\n      if result.arg and result.arg.n >= 1 then\n         for i = 1, result.arg.n do\n            callee = callee .. ts(result.arg[i]) .. \", \"\n         end\n         callee = string.sub(callee, 1, -3)\n      end\n      callee = callee .. \")\"\n      result.why    = verdict(it, \"\", \"be callable with\", callee)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name\n                   .. \" passedTo needs a function: \" .. fn)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = fn(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.fn     = fn\n      result.why    = verdict(it, \"\", \"be passed to\", fn)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n   local success = false\n   local result = {}\n   local last = it.did.last()\n   local answer = last.answer\n   if answer == nil then\n      result.why = \"prior clause must provide an answer\"\n   else\n      -- build strings for verdict\n      local callee = \":anon:\"\n      if last.field then\n         callee = it.name .. ts(\":\" ..last.field, \"field\")\n      elseif last.fn then\n         callee = ts(last.fn)\n      end\n      local param = \"(\"\n      if last.fn then\n         param = param .. it.name\n      end\n      if last.arg and last.arg.n >= 1 then\n         if last.fn then param = param .. \", \" end\n         for i = 1, last.arg.n do\n            param = param .. ts(last.arg[i]) .. \", \"\n         end\n         param = string.sub(param, 1, -3)\n      end\n      param = param .. \")\"\n\n      local isSame = answer == rValue and true or false\n      if isSame then\n         if not last.b then\n            success = true\n            result.why = verdict(it, callee .. param, \"give\", ts(answer))\n         elseif b then\n            local gives = {ts(answer)}\n            local is_b_same  = last.b == b and true or false\n            gives[2] = ts(last.b)\n            success = true and is_b_same\n            result.why = vertict(it, callee .. param, \"give\", gives[1]\n                         .. \" \" .. gives[2])\n         end\n      else\n         result.why = it.name .. \":\" .. callee .. param .. \" \"\n                      .. it.modal.inThatIt .. \" give \" .. ts(rValue)\n                      .. \" not \" .. ts(answer)\n      end\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n\n   result.success = success\n\n\n   return it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n   return it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n   local phrase = \"\"\n   local Yes, No\n   if mood == \"must\" or mood == \"mustn\'t\" then\n      Yes, No = \"✅   \",  \"❌   \"\n   elseif mood == \"should\" or mood == \"shouldn\'t\" then\n      Yes, No = \"🌟   \",  \"😡   \"\n   elseif mood == \"can\" or mood == \"could\" then\n      Yes, No = \"👍   \",  \"👎   \"\n   end\n   if did.success then\n      phrase = phrase .. \"   \" .. Yes .. did.why\n   else\n      phrase = phrase .. \"   \" .. No .. did.why\n   end\n   phrase = phrase .. \"\\n\"\n   did.digest = phrase\n   return phrase\nend\n\n\n\n\nfunction It.collate(it)\n   local winning = true\n   local wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n   local musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n   local phrase = it.name .. \":\\n\"\n   for _, did in ipairs(it.did) do\n      winning = winning and did.success\n      local mood = did.modal.inThatIt\n      local digest = digestLine(did, mood)\n      phrase = phrase .. digest\n\n      if mood == \"must\" or mood == \"mustn\'t\" then\n         musts = musts + 1\n         if did.success then\n            wins.must = wins.must + 1\n         end\n      elseif mood == \"should\" or mood == \"shouldn\'t\" then\n         shoulds = shoulds + 1\n         if did.success then\n            wins.should = wins.should + 1\n         end\n      end\n   -- etc\n   end\n   if musts > 0 then\n      phrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n   end\n   if shoulds > 0 then\n      phrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n   end\n   it.won = winning\n   if it.won then\n      phrase = \"All clear!\\n\" .. phrase\n   else\n      phrase = \"Needs work:\\n\" .. phrase\n   end\n   phrase = phrase .. \"\\n\"\n   it.digest = phrase\n\n   return it\nend\n\n\n\nfunction It.report(it)\n   it = it:collate()\n   io.write(it.digest)\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n   It[#It + 1] = it\n   return it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n   local winning = true\n   if not rawget(_G, \"_Bridge\") then\n      for _, that in ipairs(It) do\n         that:report()\n         winning = winning and that.won\n      end\n      return it, winning\n   else\n      local digests = {}\n      for _, that in ipairs(It) do\n         that:collate()\n         table.insert(digests, that)\n      end\n      return digests\n   end\nend\n\nfunction It.allFailure(it)\n   for _, that in ipairs(It) do\n      that:check()\n      for _, did in ipairs(that.did) do\n         if not did.success then\n            io.write(did.digest)\n         end\n      end\n   end\n   return it\nend\n\n\n\nreturn check\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons/check",
branch = "trunk",
},
  { 
hash = "c6f263a32fbe4c84b3837235bd7ca659a38f507ba4786455ad1487a11bf37e47",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.angry = false\n\n\n\n\n\n\nlocal Phrase = {}\nPhrase.__index = Phrase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal function spill(phrase)\n   local new_phrase = setmetatable({}, getmetatable(phrase))\n   for k, v in pairs(phrase) do\n      new_phrase[k] = v\n   end\n   new_phrase.interned = nil\n\n   return new_phrase\nend\n\n\nfunction Phrase.__concat(head_phrase, tail_phrase)\n   if type(head_phrase) == \'string\' then\n      -- bump the tail phrase accordingly\n      if tail_phrase.interned then\n         tail_phrase = spill(tail_phrase)\n      end\n\n      insert(tail_phrase, 1, head_phrase)\n      tail_phrase.len = tail_phrase.len + #head_phrase\n      return tail_phrase\n   end\n   local typica = type(tail_phrase)\n   if typica == \"string\" then\n      if head_phrase.interned then\n         head_phrase = spill(head_phrase)\n      end\n      insert(head_phrase, tail_phrase)\n      head_phrase.len = head_phrase.len + #tail_phrase\n      return head_phrase\n   elseif typica == \"table\" and tail_phrase.idEst == Phrase then\n      local new_phrase = setmetatable({}, getmetatable(head_phrase))\n      head_phrase.interned = true -- head_phrase is now in the middle of a string\n      tail_phrase.interned = true -- tail_phrase shouldn\'t be bump-catted\n      new_phrase[1] = head_phrase\n      new_phrase[2] = tail_phrase\n      new_phrase.len = head_phrase.len + tail_phrase.len\n      return new_phrase\n   end\n\n   return nil, \"tail phrase was unsuitable for concatenation\"\nend\n\n\n\n\n\n\n\n\nlocal function _gather_pieces(phrase, pieces)\n   pieces = pieces or {}\n   for _, v in ipairs(phrase) do\n      if type(v) == \"string\" then\n         insert(pieces, v)\n      else\n         _gather_pieces(v, pieces)\n      end\n   end\n   return pieces\nend\n\nfunction Phrase.__tostring(phrase)\n   return table.concat(_gather_pieces(phrase))\nend\n\n\n\n\n\n\n\nPhrase.toString = Phrase.__tostring\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__len(phrase)\n   return phrase.len\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__eq(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head == tail\nend\n\n\n\nfunction Phrase.__lt(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head < tail\nend\n\n\n\nfunction Phrase.__lte(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head <= tail\nend\n\n\n\n\n\n\n\n\n\nfunction Phrase.__repr(phrase)\n   return tostring(phrase)\nend\n\n\n\n\n\nfunction Phrase.__call(phrase, phrase_seed)\n   phrase_seed = phrase_seed or \"\"\n   local _PhraseM = getmetatable(phrase)\n   local new_phrase = {}\n   if type(phrase_seed) == \"string\" then\n      new_phrase[1] = phrase_seed\n      new_phrase.len = #phrase_seed\n   else\n      error \"bad argument #2 to Phrase, expected string\"\n   end\n   return setmetatable(new_phrase, _PhraseM)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.intern(phrase)\n   phrase.interned = true\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction Phrase.inherit(phrase, cfg)\n   local Phrase_M = getmetatable(phrase)\n   local phrase_child = setmetatable({}, Phrase_M)\n   ---[[\n   for k,v in pairs(Phrase_M) do\n      if sub(k, 1, 2) == \"__\" then\n         phrase_child[k] = v\n      end\n   end\n   phrase_child.__index = phrase_child\n   if cfg then\n      -- this can override the above metamethod assignment\n      for k,v in pairs(cfg) do\n         phrase_child[k] = v\n      end\n   end\n   return setmetatable({}, phrase_child)\n   --]]\nend\n\n\n\n\n\nPhrase.idEst = Phrase\n\n\n\nreturn setmetatable({}, Phrase)\n\n",
vc_hash = "d79aa3192617730597d5578800eb8a4efa427524\n",
name = "singletons/phrase",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "skry",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "62764eea8be890e2cb6ca96184355486e694cf7233b7e73c9c6ffd2c0942a157",
binary = "\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal Lua = require \"lun:lua-peg\"\nlocal Set = require \"qor:core/set\"\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg = require \"espalier:espalier/peg\"\n\n\n\nlocal color = require \"singletons:color\" . color\n\n\n\nlocal Scope = require \"scry:scope\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal scoped = Set { \'lua\', \'do\', \'while\', \'repeat\', \'if\',\n                     \'elseif\', \'else\', \'for\', \'defn\', \'function\'}\n\n\n\n\n\n\n\n\nlocal variable = Set { \'lvalue\', \'counter\', \"for_locals\",\n                       \'parameters\', \'function-name\' }\n\n\n\n\n\n\n\n\nlocal value = Set {\'rvalue\', \'expression\', \'condition\'}\n\n\n\n\n\n\n\n\n\nlocal statement = Set {\'do\', \'while\', \'repeat\', \'if\', \'elseif\', \'else\', \'for\',\n                       \'defn\', \'assign\', \'goto\', \'label\', \'action\'}\n\n\n\n\n\n\n\n\n\nlocal literal = Set {\'number\', \'string\', \'table\', \'nil\', \'boolean\'}\n\n\n\n\n\n\n\n\nlocal Twig = Node : inherit ()\n\nfunction Twig.errorAt(twig)\n   local maybe_err = twig:lastLeaf()\n   if maybe_err.id == \'Error\' then\n      local line, col = maybe_err:linePos()\n      return line, col\n   end\n   return nil, nil\nend\n\n\n\n\n\n\n\n\nfunction Twig.details(twig, c)\n   local facts = {}\n   local line, col = twig:linePos()\n   facts.line, facts.col = c.number(line), c.number(col)\n   facts.id = c.field(twig.id)\n   facts.extra = twig:strExtra(c)\n   return facts\nend\n\n\n\n\n\n\n\n\n\n\nlocal paintAssign, paintScope;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, concat, remove = assert(table.insert),\n                               assert(table.concat),\n                               assert(table.remove)\n\nlocal format = assert(string.format)\n\nlocal function scry(lua, color)\n   color = color or color\n   local state, frame = { }\n   local phrase = {}\n   -- skip shebangs and get to the point\n   local body = assert(lua :next \'body\')\n   for node, depth, index in body:walkBreadth() do\n      local id = node.id\n      if scoped[id] then\n         insert(phrase, paintScope(node, color, depth))\n      elseif id == \'assign\' then\n         insert(phrase, paintAssign(node, color, depth))\n      end\n   end\n   return concat(phrase, \"\\n\")\nend\n\n\n\nlocal lines = assert(core.string.lines)\n\nlocal function _scopes(twig, phrase, c, dent)\n   local line = twig:scopeLine(c, dent)\n   if line ~= \"\" then\n      insert(phrase, line)\n   end\n   for _, node in ipairs(twig) do\n      _scopes(node, phrase, c, dent + 1)\n   end\nend\n\nfunction Twig.scopes(twig, c)\n   c = c or color\n   local phrase = {}\n   _scopes(twig, phrase, c, 0)\n   return concat(phrase, \"\\n\")\nend\n\n\n\nlocal function reprFor(twig)\n   return function(_, window, c)\n      local report = scry(twig, c)\n      return lines(report)\n   end\nend\n\nfunction Twig.repr(twig, window, c)\n   return setmetatable({}, {__repr = reprFor(twig)})\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub, lower = assert(string.sub), assert(string.upper)\n\nlocal function __index(metabuild, key)\n   metabuild[key] = Twig :inherit(key)\n   return metabuild[key]\nend\n\n\n\nlocal Metas = setmetatable({}, {__index = __index})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal precedence = { [\'or\']  = 1,\n                     [\'and\'] = 2,\n                     compare = 3,\n                     concat  = 4,\n                     add     = 5,\n                     sub     = 5,\n                     mul     = 6,\n                     div     = 6,\n                     mod     = 6,\n                     [\'not\'] = 7,\n                     len     = 7,\n                     unm     = 7,\n                     pow     = 8, }\n\nlocal right_assoc = {\'pow\', \'concat\'}\n\nlocal unary =  {\'not\', \'unm\', \'len\'}\n\n\n\nlocal Shunter = require \"espalier:espalier/shunter\"\n\n\n\nlocal expression, Expr_Metas = Shunter { Twig, \'expression\',\n                                         precedence = precedence,\n                                         unary = unary,\n                                         right_assoc = right_assoc }\n\n\n\n\nMetas.expression = expression\nMetas.condition  = expression\n\nfor id, meta in pairs(Expr_Metas) do\n   Metas[id] = meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(Metas.lvalue)\nMetas.var_list = Metas.lvalue\n\n\n\n\n\n\n\n\nassert(Metas.function_name)\nMetas.local_function_name = Metas.function_name\n\n\n\n\n\n\nfor class in pairs(scoped) do\n   Metas[class].scope = true\nend\n\n\n\n\n\n\nfunction Metas.assign.split(assign)\n   is_local = assign :next \'local\' or false\n   local lval, rval = assign :next \'lvalue\', assign :next \'rvalue\'\n   return is_local, assert(lval, \'no lvalue\'), assert(rval, \'no rvalue\')\nend\n\n\n\n\n\n\nlocal rep = assert(string.rep)\nlocal function _indent(depth)\n   return rep(\" \", depth)\nend\n\n\n\npaintScope = function(twig, c, depth)\n   depth = depth or 0\n   local dent = _indent(depth)\n   local id = twig.id\n   if scoped[id] then\n      local f = twig:details(c)\n      local fmt = \"%s:%s %s%s %s\"\n      if id == \'defn\' then\n         local is_local = twig[1].id == \'local\'\n         local name = (is_local and twig[2] or twig[1]) :span()\n         if is_local then\n            name = c.keyword \"my \" .. name\n         end\n         return format(fmt, f.line, f.col, dent, f.id,  name)\n      else\n         return format(fmt, f.line, f.col, dent, f.id,  \"\")\n      end\n   end\n\n   return \"\"\nend\n\npaintAssign = function(twig, c, depth)\n   local dent = _indent(depth)\n   local f = twig:details(c)\n   local is_local, lval, rval = twig:split()\n   local my = is_local and c.keyword \"my \" or \"\"\n           -- \"line:col dent|id my lval = rval \"\n   local fmt = \"%s:%s %s%s %s%s \" .. c.operator \"=\" .. \" %s\"\n   local l_span, r_span = lval:span():gsub(\"\\n\", \"◼︎\"),\n                          rval:span():gsub(\"\\n\", \"◼︎\")\n\n   return format(fmt, f.line, f.col, dent, f.id, my, l_span, r_span)\nend\n\n\n\nreturn Peg(Lua, Metas)\n\n",
vc_hash = "ca2affd0360b6778cca8f8cd7eafe95f118c41dd\n",
name = "skry",
branch = "trunk",
},
  { 
hash = "162fe59758fbe2fef1e56a8c1f1f42032ab82b9682fa24a7fca2c7a612608f3c",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal Scope = {}\nScope.__index = Scope\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Scope.new(scope, scoped, depth, index)\n   local subscope = setmetatable({}, Scope)\n   scope[scoped] = subscope\n   insert(scope, subscope)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Scope.frame(scope, statement, depth, index)\n   insert(scope, false)\nend\n\n\n\n\n\n\n\n\nlocal function new(lua)\n   assert(lua.id == \'lua\', \"A new scope takes a Lua node\")\n\nend\n\n\n\nreturn new\n\n",
vc_hash = "ca2affd0360b6778cca8f8cd7eafe95f118c41dd\n",
name = "scope",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "sqlun",
    repo = "git@gitlab.com:special-circumstance/SQLun.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "4fd3ce6521ee9a5fdea23ce64d5faeb3b5a31d53f2c63eb342bc86977c1f06f4",
binary = "\n\n\n\n\n\n\n\n\nlocal arcivist = require \"SQLun:arcivist\"\n\nlocal schema, migration = arcivist.schema, arcivist.migration\n\n\n\nlocal spec = {}\n\n\n\n\n\n\n\n\n\n\n\nlocal widgets = {}\nspec.widgets = widgets\nwidgets.schema = schema()\n\n\n\n\n\n\nlocal create_widget_table = [[\nCREATE TABLE IF NOT EXISTS widget (\n   widget_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   widget TEXT NOT NULL,\n   inventory INTEGER,\n   FOREIGN KEY (inventory)\n      REFERENCES inventory (inventory_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\nlocal create_inventory_table = [[\nCREATE TABLE IF NOT EXISTS inventory (\n  inventory_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  SKU INTEGER UNIQUE NOT NULL,\n  stock INTEGER NOT NULL\n);\n]]\n\n\nwidgets.schema\n   :addMigration(migration(create_widget_table, create_inventory_table))\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert_widget = [[\nINSERT INTO widget (widget, inventory) VALUES (:widget, :inventory);\n]]\n\nlocal insert_inventory = [[\nINSERT INTO inventory (SKU, stock) VALUES (:SKU, :stock);\n]]\n\n\n\n\n\nlocal _widg_pop = {\n   dongle = {2, 15},\n   variolater = {3, 8},\n   rat_trap = {5, 255},\n   acme_transmogrifier = {7, 1022},\n}\n\n\n\n\n\nlocal lastRowId = assert(sql.lastRowId)\n\nlocal function _populate(conn, s)\n   local ins_widget = conn:prepare(insert_widget)\n   local ins_inventory = conn:prepare(insert_inventory)\n   for name, nums in pairs(_widg_pop) do\n      ins_inventory :bind(nums[1], nums[2]) :step()\n      local inv_id = lastRowId(conn)\n      ins_widget :bind(name, inv_id) :step()\n      ins_inventory :clearbind() :reset()\n      ins_widget :clearbind() :reset()\n   end\n\n   return true\nend\n\n\n\nlocal migration_2 = migration(_populate)\nwidgets.schema:addMigration(migration_2)\n\n\n\n\n\n\n\n\nlocal widg_search = {}\n\n\nwidg_search.find_stock_by_widget = [[\nSELECT CAST(inventory.stock AS REAL) AS stock FROM widget\nINNER JOIN inventory ON inventory.inventory_id == widget.inventory\nWHERE widget.widget = :widget\n;\n]]\n\n\n\nwidgets.schema.search  = widg_search\n\n\n\n\n\n\n\n\n\n\nwidgets.arc = arcivist(\"\", \"widgets\")\n\n\n\nreturn spec\n\n",
vc_hash = "75c26e7c69d702dbfc229de07a9252f556cc3666\n",
name = "spec/arcivist",
branch = "trunk",
},
  { 
hash = "3e99caa077c6d708a0f6aa55a4fb0f5ccf0332994a22c87d2041ec8b89062a41",
binary = "\n\n\nlocal Arcivist = require \"sqlun:arcivist\"\n\nlocal schema = Arcivist.new_schema() -- do schema-ish things incl migration\n\nlocal arc = Arcivist :home \"\" :open() :apply(schema)\n\nlocal proxy = arc:new_proxy(proxy_name)\n\n",
vc_hash = "75c26e7c69d702dbfc229de07a9252f556cc3666\n",
name = "notes/arcivist-api",
branch = "trunk",
},
  { 
hash = "0bfe21acab4639a00b7ab36e6b7707c7c5303f1a041037d8c9dd2720cb01db14",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\nlocal open = sql.open\nlocal bridge = assert(require \"bridge\", \"_Bridge is deprecated, update pylon\")\n\nlocal cluster  = require \"core:core/cluster\"\nlocal meta, constructor = assert(cluster.Meta), assert(cluster.constructor)\n\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal arc_lib = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Schema = meta {}\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Schema.addMigration(schema, migr)\n   assert(migr and migr.idEst == _migration, \"must pass a migration to schema\")\n   insert(schema[1], migr)\n   return schema\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Schema.addStatements(schema, name, stmts)\n   assert(type(name) == \'string\', \"#1 must be a string\")\n   assert(type(stmts) == \'table\', \"#2 must be a table\")\n   -- clone statements for uh. hygiene?\n   local _stmts = {}\n   schema[name] =  _stmts\n   for symbol, sql in pairs(stmts) do\n      _stmts[symbol] = sql\n   end\n\n   return schema\nend\n\n\n\n\n\n\n\n\nlocal function _migration_1()\n   return true\nend\n\nlocal function schema()\n   local _schema = setmetatable({{_migration_1}}, Schema)\n   _schema.stmts = {}\n   return _schema\nend\n\nSchema.idEst = schema\n\narc_lib.schema = schema\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Migration = meta {}\n\n\n\n\n\n\n\n\n\n\n\nfunction _migration(...)\n   local migr = setmetatable({}, Migration)\n   for i = 1, select(\'#\', ...) do\n      migr[i] = select(i, ...)\n   end\n\n   return migr\nend\n\nMigration.idEst = _migration\n\narc_lib.migration = _migration\n\n\n\n\n\n\n\n\n\n\nlocal Proxy = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _prepareStatements(conn, stmts)\n   return function(_, key)\n      if stmts[key] then\n         return conn:prepare(stmts[key])\n      elseif Proxy[key] then\n         return Proxy[key]\n      else\n         error(\"Don\'t have a statement \" .. key .. \" to prepare.\")\n      end\n   end\nend\n\nlocal function _readOnly(_, key, value)\n   error (\"can\'t assign to prepared statements table, key: \" .. key\n          .. \" value: \" .. value)\nend\n\nlocal lastRowId = assert(sql.lastRowId)\n\nfunction _makeProxy(conn, stmts)\n   if not stmts then\n      error \"no statements\"\n   end\n   local _stmts = {}\n   for name, stmt in pairs(stmts) do\n         _stmts[name] = stmt\n   end\n   return setmetatable({ lastRowId = function() return lastRowId(conn) end },\n                       { __index = _prepareStatements(conn, _stmts),\n                         __newindex = _readOnly })\nend\n\n\n\n\n\n\n\n\nlocal Arcivist = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal _arcivists = setmetatable({}, { __mode = \'v\' })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(Arc, home, name, OS_ENV, schema)\n   assert(type(home) == \'string\', \"missing database home string\")\n\n   local arc = setmetatable({}, Arcivist)\n   arc.rel_path = home\n   -- optional parameters included if present\n   arc.name, arc.schema = name, schema\n\n   arc:home(home, OS_ENV)\n   -- check if we have one of these /resolved/ paths before opening the\n   -- database\n   if home ~= \"\" and _arcivists[arc.db_home] then\n      error(format(\"Arcivists must be unique, %s already exists\", arc.db_home))\n   else\n      arc:open()\n   end\n\n   if schema then\n      arc:apply(schema)\n   end\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\nlocal function proxy(arc, proxy_name)\n   local conn = arc and arc.conn or error \"No Arcivist or missing conn\"\n   assert(arc.schema, \"Arcivist must have a schema to derive proxies form\")\n   assert(type(proxy_name) == \'string\', \"Proxy name must be a string\")\n   if not arc.schema[proxy_name] then\n      error (\"No statements associated with \" .. proxy_name)\n   end\n\n   local stmts =  _makeProxy(conn, arc.schema[proxy_name])\n   rawset(stmts, \"beginTransaction\",\n          function()\n             return conn:exec \"BEGIN TRANSACTION;\"\n          end)\n   rawset(stmts, \"commit\",\n          function()\n             return conn:exec \"COMMIT;\"\n          end)\n   return stmts\nend\n\nArcivist.proxy = proxy\n\n\n\n\n\nProxy.idEst = proxy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _migrate(conn, migration, s)\n   if type(migration) == \'function\' then\n      migration(conn, s)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n  --          s:verb(step)\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, s)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nfunction _boot(conn, migrations)\n   -- bail early with no migrations\n   if not migrations then return conn end\n   local version = #migrations\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      -- #Todo handle io redirect with status flags\n      --  chicken and egg thing...\n --     local s = require \"status:status\" (io.stdout, io.stderr)\n--      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         local s = true -- shim\n         --s:chat(\"Performing migration %d\", i)\n         _migrate(conn, migrations[i], s)\n      end\n      conn:exec \"COMMIT;\"\n      --s:chat \"Cleaning up...\"\n      conn:exec \"VACUUM;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n      --s:chat(\"Migrations completed, your version is %d\", version)\n   elseif user_version > version then\n      error(format(\"Error: database version is %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\nfunction Arcivist.apply(arc, schema)\n   if schema and arc.schema then\n      error (\"schema has already been applied to arcivist \"\n            .. (arc.name or \"\") .. \".\")\n   end\n   schema = schema or arc.schema or error \"no schema to apply\"\n   _boot(arc.conn, schema[1])\n   arc.schema = schema\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal getenv = assert(os.getenv)\n\nfunction Arcivist.home(arc, rel_path, OS_ENV)\n   assert(type(rel_path) == \'string\', \"rel_path must be a string.\")\n   assert((not OS_ENV) or type(OS_ENV) == \'string\',\n          \"OS_ENV must be nil or string\")\n   if rel_path == \"\" then\n      arc.db_home = \"\"\n      return arc\n   end\n   local abs_path = (OS_ENV and getenv(OS_ENV)) or bridge.bridge_home\n   local path =  abs_path .. rel_path\n   arc.db_home = path\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _openConn(conn_handle)\n   assert(conn_handle, \"conn handle must be present\")\n   local ok, conn = pcall(open, conn_handle, \'rwc\')\n\n   if not ok then\n      --| we can try and fix this by making the directory, but we also don\'t\n      --| want to create random junk either.\n      --|\n      --| As a compromise, we will create the directory if, and only if, the\n      --| parent directory exists, otherwise we will complain.\n      --\n      local db_file, why = require \"fs:file\" (conn_handle)\n      if not db_file then\n         -- so, it once happened that a user created one of our databases\n         -- as a directory, rather than creating the directory and letting\n         -- bridge create the DB.  This can be challenging to diagnose, so\n         -- why not be helpful if we can?\n            error (\"can\'t create \" .. conn_handle .. \":\\n\"\n                   .. why .. \"\\n\" .. conn)\n      end\n\n      local db_dir  = db_file :directory()\n      if db_dir and (not db_dir:exists()) then\n         if db_dir:parentDir():exists() then\n            db_dir:create()\n            ok, conn = pcall(open, conn_handle, \'rwc\')\n         end\n         -- we catch two \"not ok\" conditions here:\n         if not ok then\n            if db_file.path:isDir() then\n               error(tostring(db_file.path) .. \" is a directory:\\n\" ..conn)\n            end\n         end\n      end\n   end\n\n   return conn\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\n\nfunction Arcivist.open(arc)\n   assert(arc.db_home, \"Arcivist must have a database home to open\")\n   local conn =   _openConn(arc.db_home)\n                  or error (\"can\'t open conn at: \" .. arc.db_home)\n   arc.conn = conn\n\n   return arc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Arcivist.close(arc, is_uv)\n   local conn = arc and arc.conn\n   if not arc.conn then return end\n\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   if not is_uv then\n      -- try once and leave\n      local ok = pcall(conn.close, conn)\n      if ok then\n         _arcivists[arc] = nil\n      end\n   else\n      -- otherwise set up an idler to close the conn, so that e.g. busy\n      -- exceptions don\'t blow up the hook\n      local close_idler = uv.new_idle()\n      close_idler:start(function()\n         local ok = pcall(conn.close, conn)\n         if not success then\n            return nil\n         else\n            close_idler:stop()\n            _arcivists[arc] = nil\n         end\n      end)\n   end\n   return arc\nend\n\n\n\n\nreturn constructor({}, new, arc_lib)\n\n",
vc_hash = "75c26e7c69d702dbfc229de07a9252f556cc3666\n",
name = "arcivist",
branch = "trunk",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/status.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "status",
    repo = "git@gitlab.com:special-circumstance/status.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "bcf39a3fc710cc06e1211db52c7cd45d2042f6050d24694e83d8e6cdb3700ee7",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal printer = require \"core:core/string/print\"\nlocal string  = require \"core:core/string\"\n\n\n\n\n\n\nlocal Annotate = {}\nAnnotate.__index = Annotate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Note = {}\nNote.__index = Note\n\nlocal breakascii = assert(printer.breakascii)\nlocal lines, sub = assert(string.lines), assert(string.sub)\n\nfunction Note.__repr(note, window, c)\n   local win_width = window.remains\n   -- put together pieces of the line header\n   local line = tostring(note.line)\n   local name = note.name or \"\"\n   local samesource = note.prior and (note.prior.source == note.source)\n   local source = (not samesource) and note.source or \'\"\'\n\n   local sep = note.name and \"/\"  or \"\"\n   -- a hack follows, which lets us get color and still break the message\n   -- accurately: first compose the header with no color:\n   local bw_head = source .. sep .. name .. \":\" .. line .. \": \"\n   -- then with color\n   local head = c.field(source .. sep .. name)\n                .. \":\" .. c.number(line) .. \": \"\n   -- make an all-ascii version of the message\n   local message_bw = bw_head .. note[1]\n   if win_width <= #message_bw then\n      message_bw = breakascii(message_bw, win_width)\n   end\n   -- now cut the preface off and replace it with a colored equivalent\n   return lines(head .. sub(message_bw, #bw_head + 1))\nend\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\nlocal getinfo = assert(debug.getinfo)\n\nfunction Annotate.__call(notary, note, ...)\n   assert(type(note) == \'string\',\n          \"#1 argument to annotate() must be a string\")\n   -- format any additional arguments\n   if select(\'#\', ...) > 0 then\n      note = format(note, ...)\n   end\n   local info = getinfo(2, \'nlS\') -- \'nlS\' leaves out some irrelvancies\n   -- get the prior note, if any, for printing later\n   local prior = notary[#notary]\n   notary[#notary + 1] = setmetatable({ note,\n                                        line = info.currentline,\n                                        name = info.name,\n                                        prior = prior,\n                                        source = info.short_src }, Note)\nend\n\n\n\n\n\n\n\n\n\nfunction Annotate.__repr(notary, window, c)\n   local firstline, done, cursor = true, false, 1\n   local iter;\n   return function()\n      -- first line special-case so we don\'t print the first line in the\n      -- value position\n      if firstline then\n         firstline = false\n         -- just return one line if there are no notes\n         if #notary == 0 then\n            done = true\n            return c.alert \"[[  ]]\"\n         end\n         return c.alert \"[[\"\n      end\n      -- use up our iterator, if any\n      if iter then\n         local nextline = iter()\n         if nextline then return nextline end\n         cursor = cursor + 1\n         iter = nil\n      end\n      -- check if we\'ve printed everything\n      if cursor > #notary then\n         if not done then\n            done = true\n            return c.alert \"]]\"\n         else\n            return nil end\n         end\n      iter = notary[cursor]:__repr(window, c)\n      return iter()\n   end\nend\n\n\n\n\n\nlocal function new(params)\n   return setmetatable({}, Annotate)\nend\n\nAnnotate.idEst = new\n\n\n\nreturn new\n\n",
vc_hash = "02180863b610c02fdfc5451542c7f625d7ca8037\n",
name = "annotate",
branch = "core-sets",
},
  { 
hash = "3e0ccaf089a8d6ecb91258b32c89f68f92c386a7ff9437a360bd52acd36d8aca",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\nbridge.status_on = true\n\n\n\n\n\n\nlocal core = require \"qor:core\"\n\nlocal Set = assert(core.set)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Status = {}\nStatus.__index = Status\n\n\n\n\n\n\nStatus.idEst = Status\n\n\n\n\n\n\nlocal status_arclib = require \"status:status-db\"\n\n\n\n\n\n\n\n\n\nStatus[1] = io.stdout\nStatus[2] = io.stderr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.chatty  = true\nStatus.verbose = false\nStatus.boring  = false\nStatus.grumpy  = true\nStatus.angry   = false\n\n\n\n\n\n\n\n\n\nlocal _moods =\n{ [1] = \'chatty\',\n  [2] = \'verbose\',\n  [3] = \'boring\',\n  [4] = \'grumpy\',\n  [5] = \'angry\', }\n\nfor primary_key, mood in next, _moods, nil do\n   _moods[mood] = primary_key\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal helm_mode = bridge.args.helm or bridge.helm\nStatus.print = not helm_mode\nStatus.log   = true\nStatus.helm = not not helm_mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal arc_file, arc_mem;\n\nif Status.log then\n   arc_file = status_arclib()\nend\nif Status.helm then\n   arc_mem = status_arclib \"\"\n   bridge.status = arc_mem -- this is a shim for scaffolding #todo remove\n   local cwd = require \"luv\" . cwd()\n   -- brute the project name out of it\n   local project = cwd:sub(-(cwd:reverse():find(\"/\")) +1)\n   -- We might not need these:\n   Status.cwd, Status.project = cwd, project\n   -- to get this:\n   local helm_home = os.getenv \'HELM_HOME\' or (bridge.bridge_home .. \"/helm\")\n   local helm_log = helm_home .. \"/\" .. project .. \".log\"\n   -- do this with uv once it\'s demonstrated to work:\n   local helm_write = io.open(helm_log, \"a+\")\n   Status.helm_write = helm_write\n   helm_write:write(\"Starting helm run in project \" .. project .. \"\\n\")\nend\n\n\n\n\n\n\n\n\nlocal function _silent()\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _instance_logger(statusQuo, i)\n   return rawget(statusQuo, i) and (statusQuo ~= Status)\nend\n\n\n\n\n\n\n\n\nlocal getinfo = assert(debug.getinfo)\n\nlocal function logger(arc)\n   -- cache source to source_id map\n   local _source_id = {}\n   -- collect prepared statements\n   local stmts = arc:proxy \"status\"\n   local insert_status = stmts.insert_status\n   local insert_source = stmts.insert_source\n   local get_source_id  = stmts.get_source_id\n   -- return logger\n   return function(message, mood)\n      local info = getinfo(4, \'nlS\') -- \'nlS\' leaves out some irrelvancies\n      -- log to database\n      if _source_id[info.short_src] then\n         info.source_id = _source_id[info.short_src]\n      else\n         -- get source_id or add if not present\n         info.source_id = get_source_id :bind(info.short_src) :value()\n         if not info.source_id then\n            insert_source :bind(info.short_src) :value()\n            info.source_id = get_source_id :bind(info.short_src) :value()\n         end\n         _source_id[info.short_src] =  info.source_id\n      end\n      local details = { note = message,\n                        mood = _moods[mood],\n                        line = info.currentline,\n                        name = info.name,\n                        source = info.source_id }\n      insert_status :bindkv(details) :step()\n      insert_status :clearbind() :reset()\n      -- replace IDs in detail table with data equivalents\n      details.mood = mood\n      details.source = info.short_src\n\n      return details\n   end\nend\n\nlocal log_file, log_mem;\n\nif Status.log then\n   log_file = logger(arc_file)\nend\n\nif Status.helm then\n   log_mem = logger(arc_mem)\nend\n\n\nlocal function _log(statusQuo, message, mood)\n   if statusQuo.print or _instance_logger(statusQuo, 1) then\n      statusQuo[1]:write(message .. \"\\n\")\n   end\n   if statusQuo.log then\n      log_file(message, mood)\n   end\n   if statusQuo.tail then\n      -- append to file\n   end\n   if statusQuo.helm then\n      -- add to in-memory status \"file\"\n      local details = log_mem(message, mood)\n      local log_str = format(\"%s  %s:%s:%d:  %s\\n\",\n                             details.mood:upper(),\n                             details.source,\n                             details.name ~= \"\"\n                               and details.name or \"[λ]\",\n                             details.line,\n                             details.note)\n      statusQuo.helm_write:write(log_str)\n      statusQuo.helm_write:flush()\n   end\nend\n\n\n\nlocal function _errlog(statusQuo, message, should_print, mood)\n   if (statusQuo.print or _instance_logger(statusQuo, 2))\n      and should_print then\n      statusQuo[2]:write(message .. \"\\n\")\n   end\n   if statusQuo.log then\n      log_file(message, mood)\n   end\n   if statusQuo.tail then\n      -- append to file\n   end\n   if statusQuo.helm then\n      -- add to in-memory status \"file\"\n      local details = log_mem(message, mood)\n      local log_str = format(\"%s  %s:%s:%d:  %s\\n\",\n                       details.mood:upper(),\n                       details.source,\n                       details.name ~= \"\"\n                         and details.name or \"[λ]\",\n                       details.line,\n                       details.note)\n      statusQuo.helm_write:write(log_str)\n      statusQuo.helm_write:flush()\n   end\nend\n\n\n\n\n\n\n\n\nlocal function _massage(message, ...)\n   local msg = tostring(message)\n   if select(\"#\", ...) == 0 then\n      return msg\n   end\n   local ok, fmt = pcall(format, msg, ...)\n   if not ok then\n      -- append the error\n      return msg .. \" \" .. fmt\n   else\n      return fmt\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Status.halt(statusQuo, message, ...)\n   local msg = _massage(message, ...)\n   _errlog(statusQuo, msg, false, \'angry\')\n   error(msg, 2)\nend\n\n\n\n\n\n\nfunction Status.complain(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   local msg = _massage(message, ...)\n   _errlog(statusQuo, msg, (not statusQuo.angry),\n           statusQuo.angry and \'angry\' or \'grumpy\')\n   if statusQuo.angry then\n      error(msg, 2)\n   end\nend\n\n\n\n\n\n\nfunction Status.warn(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   local msg = _massage(message, ...)\n   _errlog(statusQuo, msg, true, \'grumpy\')\nend\n\n\n\n\n\n\nfunction Status.chat(statusQuo, message, ...)\n   if not statusQuo.chatty then return end\n   local msg = _massage(message, ...)\n   _log(statusQuo, msg, \'chatty\')\nend\n\n\n\n\n\n\nfunction Status.verb(statusQuo, message, ...)\n   if not statusQuo.verbose then return end\n   local msg = _massage(message, ...)\n   _log(statusQuo, msg, \'verbose\')\nend\n\n\n\n\n\n\nfunction Status.bore(statusQuo, message, ...)\n   if not statusQuo.boring then return end\n   local msg = _massage(message, ...)\n   _log(statusQuo, msg, \'boring\')\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Moods = Set {\'Angry\', \'Grumpy\', \'Chatty\', \'Verbose\', \'Boring\'}\nlocal moods = Set {\'angry\', \'grumpy\', \'chatty\', \'verbose\', \'boring\'}\n\n\n\n\n\n\nlocal verbs = Set {\'halt\', \'complain\', \'chat\', \'verb\', \'bore\', \'warn\'}\n\n\n\n\n\n\n\n\nlocal upper, sub = assert(string.upper), assert(string.sub)\n\nlocal function status__newindex(statusQuo, key, value)\n   if Moods[key] then\n      error(\"Cannot assign capital Mood \" .. key .. \" to instance of status\")\n   end\n   local Mood = upper(sub(key, 1, 1)) .. sub(key, 2)\n   if Status[Mood] ~= nil then return end\n   assert(type(value) == \'boolean\',\n          \"fields on status instance must be true or false\")\n   if moods[key] then\n      rawset(statusQuo, key, value)\n      if key == \'boring\' and value == true then\n         rawset(statusQuo, \'verbose\', true)\n      end\n      return\n   end\n   error (key .. \" is an invalid field to access on a status instance\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal status_M = { __index = Status,\n                   __newindex = status__newindex }\n\nlocal function Status__call(statusQuo, stdout, stderr)\n   return setmetatable({stdout, stderr}, status_M)\nend\n\n\n\n\n\n\n-- \'tail\' and \'silent\' are handled with custom code\nlocal modes = Set {\'print\', \'log\', \'helm\'}\n\n\n\nlocal moodOrder = {\'Chatty\', \'Verbose\', \'Boring\'}\nfor k, v in pairs(moodOrder) do\n   moodOrder[v] = k\nend\n\n\n\nlocal lower = assert(string.lower)\n\nlocal function Status__newindex(statusQuo, key, value)\n   if key == \'silent\' then\n      -- stub out all functions\n      for key in pairs(verbs) do\n         Status[key] = _silent\n      end\n   elseif key == \'tail\' then\n      -- use higher FIDs, canonically [3] and [4]\n   elseif modes[key] then\n      assert(type(value) == \'boolean\', \"Modes must be set true or false\")\n      rawset(Status, key, value)\n   elseif Moods[key] then\n      assert(type(value) == \'boolean\', \"Moods must be set true or false\")\n      local idx = moodOrder[key]\n      if not idx then\n         rawset(Status, key, value)\n         rawset(State, lower(key), value)\n      else\n         -- turn everything higher/lower on/off, depending\n         if value == true then\n            for i = idx, 1, -1 do\n               local S = moodOrder[i]\n               rawset(Status, S, true)\n               rawset(Status, lower(S), true)\n            end\n         else\n            for i = idx, #moodOrder do\n               local S = moodOrder[i]\n               rawset(Status, S, false)\n               rawset(Status, lower(S), false)\n            end\n         end\n      end\n   else\n      error(\"Cannot assign key \" .. key\n            .. \" to Status, with value \" .. tostring(value))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Status.close(status)\n   if status.helm_write then\n      status.helm_write:close()\n   end\n\n   return\nend\n\n\n\nreturn setmetatable(Status, { __newindex = Status__newindex,\n                              __call     = Status__call })\n\n",
vc_hash = "02180863b610c02fdfc5451542c7f625d7ca8037\n",
name = "status",
branch = "core-sets",
},
  { 
hash = "e98f20091a6fbdb1707da8c76cc34a7469fc28f4c73d5bd492bd056e57a402c3",
binary = "\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\n\nlocal Arcivist = require \"arcivist:arcivist\"\nlocal schema, migration = assert(Arcivist.schema), assert(Arcivist.migration)\n\n\n\n\n\n\nlocal status_schema = schema()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_status_table = [[\nCREATE TABLE IF NOT EXISTS status (\n   status_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   note TEXT NOT NULL,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   line INTEGER,\n   name TEXT,   -- name of current function scope on call\n   project TEXT, -- Foreign key but bridge.modules or helm is TBD\n   mood INTEGER,\n   source INTEGER,\n   FOREIGN KEY (mood)\n      REFERENCES mood (mood_id)\n   FOREIGN KEY (source)\n      REFERENCES source (source_id)\n --  short_source TEXT,\n);\n]]\n\n\n\n\n\n\nlocal create_mood_table = [[\nCREATE TABLE IF NOT EXISTS mood (\n   mood_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   mood TEXT NOT NULL\n);\n]]\n\n\n\n\n\n\nlocal create_source_table = [[\nCREATE TABLE IF NOT EXISTS source (\n   source_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   source TEXT UNIQUE ON CONFLICT IGNORE\n);\n]]\n\n\n\n\n\n\n\nlocal _moods =\n{ [1] = \'chatty\',\n  [2] = \'verbose\',\n  [3] = \'boring\',\n  [4] = \'grumpy\',\n  [5] = \'angry\', }\n\nfor primary_key, mood in next, _moods, nil do\n   _moods[mood] = primary_key\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_2 = migration(\n   create_status_table,\n   create_mood_table,\n   create_source_table,\n   function (conn, s)\n      local insert_mood = conn :prepare [[\n         INSERT INTO mood (mood) VALUES (:mood) ;\n      ]]\n      for _, mood in ipairs(_moods) do\n         --    s :verb(\"inserting %s mood into database\", mood)\n         insert_mood :bind(mood) :step()\n         insert_mood :clearbind() :reset()\n      end\n   end  )\n\nstatus_schema:addMigration(migration_2)\n\n\n\n\n\n\n\n\n\nlocal status_sql = {}\n\nstatus_schema.status = status_sql\n\n\n\n\n\nstatus_sql.insert_note_mood = [[\nINSERT INTO status (note, mood) VALUES (:note, :mood);\n]]\n\nstatus_sql.insert_status = [[\nINSERT INTO status (\n  note, mood, line, name, source\n  ) VALUES (\n  :note, :mood, :line, :name, :source\n);\n]]\n\nstatus_sql.insert_source = [[\nINSERT INTO source (source) VALUES (:source);\n]]\n\n\n\n\nstatus_sql.get_source_id = [[\nSELECT source_id FROM source WHERE source.source = :source;\n]]\n\n\n\nlocal function new(home)\n   home = home or \"/status/status.sqlite\"\n   local arc = Arcivist(home, \"status\", \'STATUS_HOME\')\n   arc: apply(status_schema)\n   return arc\nend\n\n\n\n\n\nreturn new\n\n",
vc_hash = "02180863b610c02fdfc5451542c7f625d7ca8037\n",
name = "status-db",
branch = "core-sets",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "text",
    repo = "git@gitlab.com:bridgetools/text.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "d37b256426956e25bea9ba2ecf972855fe9d14ca3d8ac6d155439aa210fe52ac",
binary = "\n\n\nlocal a = require \"anterm:anterm\"\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal match, P, R, C, Cg  = L.match, L.P, L.R, L.C, L.Cg\n\n\n\nlocal higit = R\"09\" + R\"AF\" + R\"af\"\nlocal shade = higit * higit\nlocal prefix = P\"0X\" + P\"0x\" + P\"#\"\nlocal color = prefix * (Cg(C(shade) * C(shade) * C(shade))\n                       + Cg(C(higit) * C(higit) * C(higit)))\n\n\n\nlocal a24, b24 = a.fg24, a.bg24\n\nlocal mk_colorizer = function(_color)\n   return function(str)\n      local r, g, b = match(color, str)\n      if not r then\n         return nil, \"no match for string \" .. str\n      end\n      if #r == 1 then\n         r, g, b = r .. r, g .. g, b .. b\n      end\n      local R, G, B = tonumber(r, 16), tonumber(g, 16), tonumber(b, 16)\n      return _color(R, G, B)\n   end\nend\n\n\n\nreturn { fg = mk_colorizer(a24), bg = mk_colorizer(b24) }\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "xterm/hexcolor",
branch = "form-feed",
},
  { 
hash = "3186cb0655f865b4a0d427afac00871bc05d78af2ad5ea9b3ec1ab4d19434d0f",
binary = "\n\n\n\n\n\nlocal utf8 = require \"lua-utf8\"\nlocal codes = assert(utf8.codes)\n\nlocal function to_points(a)\n   if type(a) == \'string\' then\n      local points = {}\n      for i, point in codes(a) do\n         points[i] = point\n      end\n      return points\n   else\n      return assert((type(a) == \'table\') and a, \"not a table\")\n   end\nend\n\nlocal function transposeable(a, b, i, j)\n   if i > 1 and j > 1\n      and a[i] == b[j - 1]\n      and a[i - 1] == b[j] then\n         return true\n   else\n      return false\n   end\nend\n\nlocal abs = assert(math.abs)\nlocal newtable = assert(table.new)\n\nlocal function distance(a, b, limit)\n   -- this respects any plausible __eq relation this algorithm will see.\n   if a == b then\n     return 0\n   end\n\n   local left = to_points(a)\n   local right = to_points(b)\n\n   local l_len, r_len = #left, #right\n   if limit and abs(l_len, r_len) >= limit then\n      return huge\n   end\n   local stride = r_len + 1\n   -- big ol-row normal matrix array, like Dad used to write\n   local d = newtable(l_len * stride, 0)\n\n   -- Cost of deletion\n   for i = 0, l_len do\n      d[i * stride] = i\n   end\n   -- Cost of substitution\n   for j = 0, r_len do\n      d[j] = j\n   end\n\n   local min = assert(math.min)\n   for i = 1, l_len do\n      local si = stride * i\n      local best = limit\n      for j = 1, r_len do\n         local weight = (left[i] == right[j]) and 0 or 1\n         local D, I, S = d[si - stride + j] + 1, -- deletion\n                         d[si + j - 1] + 1,      -- insertion\n                         d[si - stride + j - 1] + weight -- substitution\n         local cost = min(D, I, S)\n         d[si + j] = cost\n\n         if transposeable(left, right, i, j) then\n            d[si + j] = min(cost, d[si - 2 * stride + j - 2] + weight)\n         end\n         if limit and cost < best then\n            best = cost\n         end\n      end\n\n      if limit and best > limit then\n         return limit\n      end\n   end\n   return d[#d]\nend\n\n\n\nreturn distance\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "distance",
branch = "form-feed",
},
  { 
hash = "c8b73a6c4755916e2b2cca449ae9b8b4fb0ec276f666f891f94061c1ab15cd03",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = use(\"qor:core\", \"cluster:cluster\")\n---[[DBG]] local Deque = use \"deque:deque\"\n\n\n\nlocal new, Feed, Feed_M = cluster.order()\n\ncluster.construct(new,\n   function(_new, feed, cfg)\n      cfg = cfg or {}\n      feed.WID = cfg.width or 78\n      feed.lex = cfg.lex\n      feed.stop = {0}\n      ---[[DBG]] feed.allStops = Deque()\n      feed.wide = 0\n      return feed\n   end)\n\n\n\n\n\n\n\n\n\nlocal addToken;\n\nfunction Feed.push(feed, ...)\n   local one = ...\n   if one == nil then return feed end\n\n   addToken(feed, one)\n   return feed:push(select(2, ...))\nend\n\n\n\nlocal width = assert(utf8.width)\nlocal insert, remove = table.insert, table.remove\n\nfunction addToken(feed, one)\n   local wid = width(one)\n   local span = feed.wide + wid\n   if span > feed.WID then\n      -- special case if what we\'re trying to add won\'t fit on the\n      -- next line either\n      local overshot = feed.stop[#feed.stop] + wid - feed.WID\n      if overshot > 0 then\n         feed :indent(feed.stop[#feed.stop] - overshot) :newLine() :dedent()\n      else\n         feed :newLine()\n      end\n   end\n   if one == \"\" then\n      -- check the preceding for a non-space token\n      if not feed:trailingWhite() then\n         insert(feed, \" \")\n         feed.wide = feed.wide + 1\n      end\n   else\n      insert(feed, one)\n   end\n   feed.wide = feed.wide + wid\nend\n\n\n\n\n\n\n\n\nfunction Feed.cling(feed, tok)\n   if feed[#feed] == \" \" then\n      remove(feed)\n      feed.wide = feed.wide - 1\n   end\n   feed:push(tok)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Feed.indent(feed, where)\n   if not where then\n      where = feed.wide - 1\n   end\n   ---[[DBG]] feed.allStops:push(where)\n   insert(feed.stop, where)\n\n   return feed\nend\n\n\n\n\n\n\n\nfunction Feed.dedent(feed)\n   if #feed.stop > 1 then\n      local dropped = remove(feed.stop)\n      ---[[DBG]] feed.allStops:push(-dropped)\n   else\n      feed.overdedent = feed.overdedent and feed.overdedent + 1 or 1\n   end\n\n   return feed\nend\n\n\n\n\n\n\n\n\n\nFeed.pushStop, Feed.popStop = Feed.indent, Feed.dedent\n\n\n\n\n\n\nfunction Feed.nudge(feed, delta)\n   feed.stop[#feed.stop] = feed.stop[#feed.stop] + delta\n   return feed\nend\n\n\n\n\n\n\n\n\n\n\nlocal rep = string.rep\n\nfunction Feed.newLine(feed, number)\n   while feed:trailingWhite() do\n      remove(feed)\n   end\n   -- add and pad one newline\n   local stop = feed.stop[#feed.stop]\n   insert(feed, \"\\n\")\n   if stop > 0 then\n      insert(feed, rep(\" \", stop))\n   end\n   feed.wide = stop\n\n   if number and number > 1 then\n      return feed:newLine(number - 1)\n   end\n\n   return feed\nend\n\n--  The synonym is probably worth it here, given that newline is the /name/\n--  of \"\\n\".  What we\'re doing is making a new line, so the camelCase is to\n--  be preferred, but this is a half-conceptual typo.  I\'ll allow it.\n\nFeed.newline = Feed.newLine\n\n\n\n\n\n\n\n\nlocal match = string.match\n\nfunction Feed.trailingWhite(feed)\n   --  \'%S\' matches any non-space in the string\n   if #feed == 0 then return nil end\n\n   if match(feed[#feed], \'%S\') then\n      return false\n   elseif match(feed[#feed], \'[\\n]+\') then\n      -- a bare newline is not trailing\n      return false\n   else\n      return true\n   end\n\n   return feed\nend\n\n\n\n\n\n\nFeed.string = table.concat -- love that this works\n\n\n\n\n\n\n\nlocal function __repr(tab)\n   return tab[2] or tab[1]\nend\n\nlocal function __tostring(tab)\n   return tab[1]\nend\n\nlocal rtab = { __repr =  __repr,\n               __tostring = __tostring }\n\nfunction Feed.view(feed)\n   local view = {feed:string()}\n   -- lexer?\n   if feed.lex then\n      view[2] = feed.lex(view[1])\n   end\n   return setmetatable(view, rtab)\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "formfeed",
branch = "form-feed",
},
  { 
hash = "38e16ddac9120f790cde8d1f197f24875ce05969ccd5382b553ff7a37d7e8bbc",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal meta = assert(core.cluster.meta)\nlocal table = assert(core.table)\n\n\n\n\n\n\nlocal Palimpsest = meta {}\n\n\n\n\n\n\n\n\nlocal function build(pal, str, first, last)\n   assert(type(str) == \'string\', \"#1 to Palimpsest must be a string\")\n   first = first or 1\n   last = last or #str\n\n   pal.str = str\n   pal.first, pal.last = first, last\n   pal.first_offs = {}\n   pal.last_offs = {}\n   pal.deltas = {}\n   pal.cursor = first\n   return pal\nend\n\nlocal function new(str, first, last)\n   local pal = {}\n   return setmetatable(build(pal, str, first, last), Palimpsest)\nend\n\nPalimpsest.idEst = new\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal assertfmt = assert(core.string.assertfmt)\n\nlocal function _sameLen(pal)\n   local len, first, last, delta = rawlen(pal),\n                                   #pal.first_offs,\n                                   #pal.last_offs,\n                                   #pal.deltas\n   assertfmt(len == first and len == last and len == delta,\n             \"uneven lengths! palimpsest: \\\n              %d, first_offs: %d, last_offs: %d, Δ: %d\",\n             len, first, last, delta)\nend\n\nfunction Palimpsest.swap(pal, frag, first, last)\n   assertfmt(pal.cursor <= first,\n             \"attempted backtrack in swap, cursor is %d, first is %d\",\n             pal.cursor, first)\n   assertfmt(last <= pal.last,\n             \"can\'t swap out of slice range, which ends at %d, asked for %d\",\n             pal.last, last)\n   if pal.cursor < first then\n      insert(pal, true)\n      insert(pal.first_offs, pal.cursor)\n      insert(pal.last_offs, first - 1)\n      insert(pal.deltas, 0)\n   end\n   local frag_len = #frag\n   local Δ = frag_len - (last - first + 1)\n   insert(pal, frag)\n   insert(pal.first_offs, first)\n   insert(pal.last_offs, last + Δ)\n   insert(pal.deltas, Δ)\n   -- cursor is into string, so it tracks last\n   pal.cursor = last + 1\n   _sameLen(pal)\n   return pal\nend\n\n\n\n\n\n\n\n\nlocal clamp = assert(core.math.clamp)\nfunction Palimpsest.sub(pal, first, last)\n   first = clamp(first, -pal.last, pal.last)\n   last = clamp(last, -pal.last, pal.last)\n   -- I think this is just #str - value? but get this working first\n   assert(first > 0, last > 0, \"can\'t handle negative subs, yet\")\n   -- easy case is an unscratched palimpsest, or a cursor behind the full\n   -- value\n   if rawlen(pal) == 0 or pal.cursor < first then\n      return pal.str:sub(first, last)\n   end\n   -- otherwise we\'re building\n   local phrase, cursor = {}, 1\n   for i, frag in ipairs(pal) do\n      local first_off, last_off, Δ = pal.first_offs[i],\n                                     pal.last_offs[i],\n                                     pal.deltas[i]\n      if frag == true then\n         -- if it\'s in the fragment, we\'re done:\n         if first >= first_off and last <= last_off then\n            return pal.str:sub(first, last)\n         end\n\n      elseif type(frag) == \'string\' then\n\n      end\n   end\n\nend\n\n\n\n\n\n\n\n\nlocal concat, cloneinstance = assert(table.concat),\n                              assert(table.cloneinstance)\nlocal clear = require \"table.clear\"\n\nfunction Palimpsest.__tostring(pal)\n   local str, phrase = pal.str, {}\n   for i, v in ipairs(pal) do\n      if v == true then\n         local first, last = pal.first_offs[i], pal.last_offs[i]\n         phrase[i] = str:sub(first, last)\n      else\n         phrase[i] = tostring(v) -- this is, permissive\n      end\n   end\n   -- account for remainder of string if any\n   if pal.cursor <= pal.last then\n      insert(phrase, str:sub(pal.cursor, pal.last))\n      insert(pal, true)\n      insert(pal.first_offs, pal.cursor)\n      insert(pal.last_offs, pal.last)\n   end\n   local new_str = concat(phrase)\n   clear(pal)\n   build(pal, new_str)\n   return new_str\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "palimpsest",
branch = "form-feed",
},
  { 
hash = "73ffd7f4abc6e230006e026189b47b71e6e1c769b42e1db91b7d11b489a820f2",
binary = "\n\n\n\n\n\n\nlocal Stats_M = {}\nlocal stats = setmetatable({}, Stats_M)\n\n\n\n\n\n\n\n\n\nfunction stats.printstats(str)\n\nend\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "printstats",
branch = "form-feed",
},
  { 
hash = "0df3543021970e60d368d297265919826bafdbcbf964f92c88883a1afc97c614",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal Palimpsest = require \"text:palimpsest\"\nlocal distance = require \"text:distance\"\n\n\n\nlocal s = require \"status:status\" ()\n\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\n\n\nlocal mustache = [[\n  moustache  ←  ((template / normal)+ / bad-stache)+\n             /  garbage\n   template  ←  in _ (chain / field) _ option? _ out\n      field  ←  sym\n      chain  ←  field _ (index)+ special?\n             /  field _ special\n     option  ←  \"?\"\n\n      index  ←  \".\" _ field _ /  \"[\" _ int _ \"]\" _\n        int  ←  [0-9]+\n\n  `special`  ←   \"[\" _ array _ \"]\" interpolate\ninterpolate  ←   (!out utf8)*\n      array  ←  \"#\"\n\n   `normal`  ←  (!in utf8)+\n       `in`  ←  !\"{{{\" \"{{\"\n      `out`  ←  \"}}\"\n        `_`  ←  { \\t}*\n\n   bad-stache  ←  in (!out utf8)+ out\n      garbage  ←  utf8+\n\n\n; this is copypasta from scry peg, because we can\'t do\n; grammar arithmetic yet >.>\n\n   `sym`  ←          !keyword (\n                 ;; first character not this:\n                 (!(glyph / { \\t\\n\\r} / [0-9])\n                 ;; but anything(?) else is ok:\n                 utf8\n                 ;; after which digits are also legal\n                 (!(glyph / { \\t\\n\\r}) utf8)*\n                 / [A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )* )\n\n\n\n\n   keyword  ←  ( \"and\" / \"break\" / \"do\" / \"elseif\" / \"else\"\n               / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n               / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n               / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n               t ; t is the most PEG thing about PEGs\n\n   `t`  ←  !([A-Z] / [a-z] / [0-9] / \"_\")\n\n   `glyph` ← {!@#$%^&*()-+={[]\\\\|:;\\\"\'<,>.?/~`} / \"}\"\n\n\n   `utf8`  ←  [\\x00-\\x7f]\n           /  [\\xc2-\\xdf] [\\x80-\\xbf]\n           /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n           /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\n\n\nlocal pegstache = Peg(mustache)\nlocal parse = pegstache.parse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Stache, Stache_M = cluster.order()\n\n\n\nlocal lens = require \"repr:lens\"\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal function _patches(templates)\n   local patches = {}\n   for _, temp in ipairs(templates) do\n      if temp.id == \'bad_stache\' or temp.id == \'garbage\' then\n         error(\"that\'s a funny-lookin mustache pardner: \" .. temp:span())\n      end\n      local patch = {}\n      local first = temp[1]\n      local id = first.id\n      local is_array = false\n      if id == \'field\' then\n         patch[1] = first:span()\n         patch[2] = { first = temp.first,\n                      last =  temp.last }\n      elseif id == \'chain\' then\n         local field = first[1]\n         local subs = {}\n         assert(field.id == \'field\', \"missing lead field on template\")\n         for i = 2, #first do\n            local next = first[i]\n            if next.id == \'index\' then\n               local sub = next[1]\n               assert(sub.id == \'field\'\n                   or sub.id == \'int\', \"unexpected subfield\")\n               if sub.id == \'int\' then\n                  insert(subs, tonumber(sub:span()))\n               elseif sub.id == \'field\' then\n                  insert(subs, sub:span())\n               end\n            elseif next.id == \'interpolate\' then\n               -- smuggle our interpolate out\n               is_array = next:span():gsub(\"\\\\n\", \"\\n\")\n            end -- array doesn\'t need looking at\n         end\n         patch[1] = field:span()\n         patch[2] = { first = temp.first,\n                       last = temp.last,\n                        sub = subs,\n                       span = first:span() }\n         if is_array then\n            patch[2].interpolate = is_array\n         end\n      end\n      local option = temp[2]\n      if option then\n         assert(option.id == \'option\', \"new class, expected option\")\n         patch[2].optional = true\n      end\n      insert(patches, patch)\n   end\n   return patches\nend\n\n\n\n\n\n\n\nlocal function builder(_new, stache, template, onbind)\n   assert(type(template) == \'string\')\n   stache.str = template\n   local temp = parse(template)\n   local patch = _patches(temp)\n   if #temp == 0 then\n      error(\"no templates visible in \" .. template:sub(1, 32))\n   end\n   stache.patch = patch\n   stache.template = temp\n   stache.peg = pegstache -- for repl\'ing\n   if onbind then\n      onbind[1] = onbind[1] or cluster.ur.pass\n   else\n      onbind  = {cluster.ur.pass}\n   end\n   stache.onbind = onbind\n   return stache\nend\n\n\n\n\n\n\n\n\nlocal function nearest(str, tab)\n   if type(tab) ~= \'table\' then return \"\" end\n   local cost, best = math.huge, \"\"\n   for key in pairs(tab) do\n      if type(key) == \'string\' then\n         local dist = distance(str, key)\n         if dist < cost then\n            best = key\n            cost = dist\n         end\n      end\n   end\n   return best, cost\nend\n\n\n\ncluster.construct(new, builder)\n\n\n\n\n\n\n\n\nlocal format  = assert(string.format)\nlocal clone1 = assert(core.table.clone1)\n\nlocal function _resolvePatch(patch, tab)\n   local var, slice = patch[1], patch[2]\n   local fields = {var}\n   local val = tab[var]\n   if val == nil then\n      return nil, fields\n   end\n   local last = tab\n   if slice.sub then\n      for _, var in ipairs(slice.sub) do\n         if not (type(val) == \'table\') then\n            return nil,  \" expected \" .. var.. \" to be a table, not a \"\n                       .. type(val)\n         else\n            insert(fields, var)\n            last = val\n            val = val[var]\n         end\n      end\n   end\n   if val == nil then\n      return val, fields, last\n   else\n      return val, fields\n   end\nend\n\nlocal function resolveBind(val, fields, slice, onbind)\n   local bind = onbind\n   local no_match = false\n   for _, field in ipairs(fields) do\n     bind = bind[field]\n     if not bind then\n        no_match = true\n        break\n     end\n   end\n   if no_match then\n      -- try the last field\n      bind = onbind[fields[#fields]]\n   end\n   bind = bind or onbind[1]\n   if slice.interpolate then\n      if not (type(val) == \'table\') then\n         err = (err or \"\") .. \" can\'t interpolate \"\n               .. fields[#fields] .. \" of type \" .. type(val)\n         val = nil\n      else\n         local phrase = {}\n         local top = #val\n         for i, v in ipairs(val) do\n            insert(phrase, bind(v))\n            if i < top then\n               insert(phrase, slice.interpolate)\n            end\n         end\n         val = concat(phrase)\n      end\n   else\n      val = bind(val)\n   end\n   return val\nend\n\nfunction Stache_M.__call(stache, tab)\n   local pal = assert(Palimpsest(stache.str))\n   local patch = stache.patch\n   local swaps = {}\n   local err = false\n   for i, p in ipairs(patch) do\n      local slice = p[2]\n      local val, fields = _resolvePatch(p, tab)\n      if val ~= nil then\n         val = resolveBind(val, fields, slice, stache.onbind)\n      end\n      if val ~= nil then\n         swaps[i] = {tostring(val), slice.first, slice.last}\n      else\n         swaps[i] = false\n      end\n   end\n   -- apply swaps\n   for i, swap in ipairs(swaps) do\n      if swap then\n         pal:swap(unpack(swap))\n      else\n         local var, slice = patch[i][1], patch[i][2]\n         if slice.optional then\n            pal:swap(\"\", slice.first, slice.last)\n         else\n            -- #todo a good error message needs to find out what\n            -- is actually missing, this is only truly informative with\n            -- one field.\n            local ok, fields, _tab = _resolvePatch(patch[i], tab)\n            assert(not ok, \"oh NOW we have a value ¯\\\\_(ツ)_/¯\")\n            local name = \"table\"\n            if _tab  then\n               tab = _tab\n               name = fields[#fields]\n            end\n            if type(fields) == \'string\' then\n               err = (err or \" \") .. fields\n            end\n            err = (err or \" \") .. \"%s wasn\'t patched, %s has %s\\n\"\n            local best = nearest(var, tab)\n            if best == \"\" then\n               best = \"nothing useful\"\n            else\n               best = \"\'\" .. best .. \"\'\"\n            end\n\n            local mustache =  pal.str:sub(slice.first, slice.last)\n            err = format(err, mustache, name, best)\n         end\n      end\n   end\n   if err then\n      error(err)\n   end\n   return tostring(pal)\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "stache",
branch = "form-feed",
},
  { 
hash = "ccca19dcc6e2f9d2227389b4be6d53d7e0ab55a6bf3eb1ebf67316d70a724f3b",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:cluster\" . Meta)\nlocal utf8 = assert(require \"core:string\" . utf8)\n\n\n\n\n\nlocal Codepoints = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal sub = assert(string.sub)\n\nfunction Codepoints.__call(codepoints, str, start, finish)\n   start = start or 1\n   finish = (finish and finish <= #str) and finish or #str\n   -- propagate nil\n   if not str then return nil end\n   -- break on bad type\n   assert(type(str) == \"string\", \"codepoints must be given a string\")\n   local codes = setmetatable({}, Codepoints)\n   local index = start\n   while index <= finish do\n      local width, err = utf8(str, index)\n      if width then\n         local point = sub(str, index, index + width - 1)\n         insert(codes, point)\n         index = index + width\n      else\n         -- take off a byte and store it\n         local err_packet = { char = sub(str, index, index),\n                              err  = err }\n         codes.err = codes.err or {}\n         insert(codes, \"�\")\n         -- place the error at the same offset in the err table\n         codes.err[#codes] = err_packet\n         index = index + 1\n      end\n   end\n   return codes\nend\n\n\n\n\n\n\n\n\n\n\nlocal clone = assert(require \"core:core/table\" . clone)\n\nlocal function _adjustErrors(codepoints, pos, offset)\n   if pos and codepoints.err then\n      -- cache the error table so we can copy the\n      -- removed points without worrying about blasting them\n      -- before we reach them while iterating\n      local err_cache = clone(codepoints.err)\n      -- remove all errors above pos at once\n      for i, _ in pairs(codepoints.err) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i] = nil\n         end\n      end\n      -- now add them back, shifted by offset\n      for i, v in pairs(err_cache) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i + offset] = v\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Codepoints.insert(codepoints, pos, value)\n   if value then\n      -- Insert the fragment\n      insert(codepoints, pos, value)\n      -- Only need to adjust errors if inserting other than at the end\n      _adjustErrors(codepoints, pos, 1)\n   else\n      -- Work around arguable bug in table.insert where calling\n      -- insert({}, \"a\", nil) throws an error--the third parameter\n      -- must be actually omitted rather than merely nil\n      insert(codepoints, pos)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\n\nfunction Codepoints.remove(codepoints, pos)\n   local rem = remove(codepoints, pos)\n   -- Remove any corresponding error from the error table\n   if codepoints.err then\n      codepoints.err[pos or #codepoints + 1] = nil\n      -- And remove it altogether if it is now empty\n      if next(codepoints.err) then\n         _adjustErrors(codepoints, pos, -1)\n      else\n         codepoints.err = nil\n      end\n   end\n   return rem\nend\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nfunction Codepoints.__tostring(codepoints)\n   local output = codepoints\n   if codepoints.err then\n      output = {}\n      for i, v in ipairs(codepoints) do\n         local err_here = codepoints.err[i]\n         output[i] = err_here and err_here.char or v\n      end\n   end\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, byte = assert(string.format),\n                           assert(string.find),\n                           assert(string.byte)\n\nlocal escapes_map = {\n   [\'\"\'] = \'\\\\\"\',\n   [\"\'\"] = \"\\\\\'\",\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nfunction Codepoints.toLuaString(codepoints, preface, afterward)\n   if type(codepoints) == \"string\" then\n      codepoints = Codepoints.__call(nil, codepoints)\n   end\n   local phrase = {}\n   if preface then\n      insert(phrase, preface)\n   end\n   insert(phrase, \'\"\')\n   local err = codepoints.err or {}\n   for i,frag in ipairs(codepoints) do\n      -- escape map non-printing chars\n      -- replace errors with an \\x?? token\n      -- otherwise, insert the frag\n      if escapes_map[frag] or find(frag, \"%c\") then\n         frag = escapes_map[frag] or format(\"\\\\x%02x\", byte(frag))\n      end\n      if err[i] then\n         frag = format(\"\\\\x%02x\", byte(err[i].char))\n      end\n      insert(phrase, frag)\n   end\n   insert(phrase, \'\"\')\n   if afterward then\n      insert(phrase, afterward)\n   end\n   return concat(phrase)\nend\n\n\n\nlocal CP_constructor = setmetatable({}, Codepoints)\nCodepoints.idEst = CP_constructor\n\n\n\nreturn CP_constructor\n\n",
vc_hash = "3e4f48d9512eae2cdf1f054ff6ed3b25d6dcd240\n",
name = "codepoints",
branch = "form-feed",
},
} },
{
  project = {
    repo_alternates = "",
    website = "",
    repo_type = "git",
    home = "",
    name = "typetrain",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "3849e9e70136a2ec28037e4dd293150cbee5260d6c274e26168d42c64d3e427d",
binary = "\nlocal core = require \"qor:core\"\n\n\n\n\nlocal nums = {\n   [0] = [[\n┏━┓\n┃·┃\n┗━┛]],\n[[\n ┓\n ┃\n ┻]],\n[[\n╺━┓\n┏━┛\n┗━╸]],\n[[\n╺━┓\n╺━┫\n╺━┛]],\n[[\n╻ ╻\n┗━┫\n  ╹]],\n[[\n┏━╸\n┗━┓\n╺━┛]],\n[[\n┏━╸\n┠━┓\n┗━┛]],\n[[\n╺━┓\n  ╋\n  ╹]],\n[[\n┏━┓\n┠━┫\n┗━┛]],\n[[\n┏━┓\n┗━┫\n╺━┛]], -- but wait! there\'s more!\n\"   \\n━╸\\n   \",\n\"   \\n ｡ \\n   \",\n}\n\n\n\n\n\nlocal sub = string.sub\n\nlocal lines = core.string.lines\n\nlocal hi, mid, low = {}, {}, {}\n\nfor i = 0, 11 do\n   local is_one = i == 1\n   local _num = nums[i]\n   local st = \'hi\'\n   for stripe in lines(_num) do\n      if is_one then\n         stripe = stripe .. \" \"\n      end\n      if st == \'hi\' then\n         hi[i] = stripe\n         st = \'mid\'\n      elseif st == \'mid\' then\n         mid[i] = stripe\n         st = \'low\'\n      elseif st == \'low\' then\n         low[i] = stripe\n      end\n   end\nend\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nreturn function(num)\n   local numstr = tostring(num)\n   if #numstr == 1 then\n      return nums[num]\n   end\n\n   local _hi, _mid, _low = {}, {}, {}\n   for digit in numstr:gmatch \'.\' do\n      local n = tonumber(digit)\n      insert(_hi, hi[n])\n      insert(_mid, mid[n])\n      insert(_low, low[n])\n   end\n   return concat(_hi)\n          .. \"\\n\" .. concat(_mid)\n          .. \"\\n\" .. concat(_low)\nend\n\n",
vc_hash = "a46b8587522ea53809ff0d05ebd69dab1da4816a\n",
name = "scorecard",
branch = "scorecard",
},
  { 
hash = "996b125f811a3872a8a74c4f694a2e8e4dc41f4eba8a6cfbdc3ff5c60fd94d35",
binary = "\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal Codepoints = require \"text:codepoints\"\n\n\n\n\n\n\n\n\n\nlocal new, Modline, Mod_M = cluster.order()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal line_peg = [[\n   line  ←  (word / glyphs / ws)+\n   word  ←  char (char / punct)*\n glyphs  ←  glyph+\n     ws  ←  w+\n `char`  ←  (!glyph !w utf8)\n`glyph`  ←  [!-/] / [:-@] / [[-`] / [{-~]\n`punct`  ←  {,.:;\\\'\\\"}\n    `w`  ←  { \\n}\n\n`utf8`  ←  [\\x00-\\x7f]\n        /  [\\xc2-\\xdf] [\\x80-\\xbf]\n        /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n        /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\n\n\n\n\nlocal parse = assert(require \"espalier:peg\"(line_peg).parse)\n\n\n\n\nlocal function toCodepoints(line)\n   local tokens = {}\n   for i, tok in ipairs(line) do\n      tokens[i] = {first = tok.first, last = tok.last, id = tok.id}\n      for j, point in ipairs(Codepoints(tok.str, tok.first, tok.last)) do\n         tokens[i][j] = point\n      end\n   end\n   return tokens\nend\n\n\n\n\nlocal function builder(_new, modline, line)\n   modline.points = Codepoints(line)\n   modline.line = line\n   modline.cursor = 1\n   modline.target = modline.points[1]\n   modline.winning = true\n   modline.tokens = toCodepoints(parse(line))\n   return modline\nend\n\ncluster.construct(new, builder)\n\n\n\n\n\n\n\n\nlocal function isWhite(glyph)\n   if glyph == \" \" or glyph == \"\\n\" then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Modline.letter(modline, glyph)\n   local target =  modline.target\n   if glyph == target then\n      -- stay winning!\n      modline.winning = true\n      modline.cursor = modline.cursor + 1\n      modline.target = modline.points[modline.cursor]\n      -- we probably want to include the return key on the line, this\n      -- logic will just load the next so that\'s fine as well\n      if modline.cursor > #modline.points then\n         modline.completed =  true\n      end\n      return true\n   end\n\n   modline.winning = false\n   return false\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Modline.chunk(modline, chunk)\n   local pt = Codepoints(chunk)\n   for _, point in ipairs(pt) do\n      local ok = modline:letter(point)\n      if not ok then\n         return false, modline.cursor\n      end\n   end\n   return true, modline.cursor\nend\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\n\n\n\n\n\nlocal clear, bold = tostring(a.clear), tostring(a.bold)\nlocal clear_bold = tostring(a.clear_bold)\nlocal green, red, yellow = tostring(a.green),\n                           tostring(a.red),\n                           tostring(a.yellow)\n\n\n\nlocal clear_fg, clear_bg = tostring(a.clear_fg), tostring(a.clear_bg)\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\n\n\n\n\n\n\n\n\n\nlocal hi_cursor = a.yellow(\"▂\")\n\nfunction Modline.paint(modline)\n   if modline.completed then\n      return a.green(modline.line) .. a.yellow(\"⏎\")\n   end\n\n   local painted = {}\n   local tokens, cursor = modline.tokens, modline.cursor\n   for i, token in ipairs(tokens) do\n      if token.last < cursor then\n         insert(painted, concat(token))\n      elseif (token.first <= cursor) and (token.last >= cursor) then\n         local win = modline.winning and green or red\n         insert(painted, win)\n         for j, point in ipairs(token) do\n            local offset = j - 1 + token.first\n            if offset == cursor then\n               local ws = isWhite(point)\n               local at_cursor = ws and hi_cursor or yellow .. point\n               insert(painted, at_cursor)\n               insert(painted, win)\n            else\n               insert(painted, point)\n            end\n         end\n         insert(painted, clear_fg)\n      else\n         insert(painted, concat(token))\n      end\n   end\n\n   return concat(painted), painted\nend\n\n\n\n\n\n\n\n\n\nlocal salad = {a.red, a.blue, a.green, a.yellow, a.cyan, a.magenta}\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\n\nfunction Modline.winSource(modline)\n   local c = a.green\n   local line = modline.line\n   local i = 0\n   local function source()\n      i = i + 1\n      if i > #line then\n         return nil\n      else\n         return c(line:sub(i) .. \" \")\n      end\n   end\n\n   return source\nend\n\n\n\n\n\n\n\n\nlocal lines = assert(core.string.lines)\n\nfunction Modline.view(modline)\n   local paint = modline:paint()\n   return setmetatable({}, {__repr = function() return lines(paint) end})\nend\n\n\n\n\n\nreturn new\n\n",
vc_hash = "a46b8587522ea53809ff0d05ebd69dab1da4816a\n",
name = "model-line",
branch = "scorecard",
},
  { 
hash = "a842853a3b4e4352b561b7c9f8a33a5b3cc7966276f7e2018df698b781549456",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Ozymandias = [[wwwww\nI met a traveller from an antique land,\nWho said-\"Two vast and trunkless legs of stone\nStand in the desert... Near them, on the sand,\nHalf sunk a shattered visage lies, whose frown,\nAnd wrinkled lip, and sneer of cold command,\nTell that its sculptor well those passions read\nWhich yet survive, stamped on these lifeless things,\nThe hand that mocked them, and the heart that fed;\nAnd on the pedestal, these words appear:\nMy name is Ozymandias, King of Kings;\nLook on my Works, ye Mighty, and despair!\nNothing beside remains. Round the decay\nOf that colossal Wreck, boundless and bare\nThe lone and level sands stretch far away.\"]]\n\n\n\nlocal lines = require \"qor:core\" . string . lines\n\nreturn function()\n   return lines(Ozymandias)\nend\n\n",
vc_hash = "a46b8587522ea53809ff0d05ebd69dab1da4816a\n",
name = "library",
branch = "scorecard",
},
  { 
hash = "09a3482fa808ec33893fd4520faec17b3b29c8da8dcaa983eccfd01bd82c3f5b",
binary = "\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal drain = require \"gadget:drain\"\nlocal ts = require \"repr:repr\" . ts_color\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal cursor = require \"anterm:cursor\"\n\n\n\n\n\nlocal onread = require \"cursory:onread\"\nlocal Point = require \"cursory:shape/point\"\nlocal Rectangle = require \"cursory:shape/rectangle\"\nlocal Keeper = require \"cursory:keeper\"\nlocal Panel  = require \"cursory:panel\"\n\n\n\nlocal Modline = require \"typetrain:model-line\"\nlocal Timekeeper = require \"typetrain:timekeeper\"\nlocal Library = require \"typetrain:library\"\nlocal scorecard = require \"typetrain:scorecard\"\n\n\n\n\nlocal new, Runner = cluster.order()\n\n\n\ncluster.construct(new, function(new, runner)\n   runner.keeper = Keeper()\n   runner.lib = Library()\n   runner.line = Modline(runner.lib())\n   runner.painter = uv.new_idle()\n   -- these are just for now:\n   runner.event = {}\n   runner.seq = \"\"\n\n   return runner\nend)\n\n\n\nlocal utf8len = assert(require \"utf8\" . len)\n\nlocal function extractLetter(event)\n   if event.modifiers > 0\n      or utf8len(event.key) > 1\n      or event.type ~= \'keypress\' then\n      return nil\n   end\n   return event.key\nend\n\n\n\n\n\n\n\n\nfunction Runner.run(runner, seconds)\n   seconds = seconds or 60\n   runner.keeper :setup() :start()\n   runner.write, runner.shutdown = runner.keeper:closures()\n   runner.write(a.cursor.hide())\n   local stdin = assert(runner.keeper.stdin)\n\n   runner.statPanel = Panel { origin = Point {10, 20}, -- just to try out the\n                              depth  = 12,             -- packed form\n                              width  = 30,\n                              write = runner.write, }\n                              -- add back in BG color to debug new cursory\n                              -- colors: we need a way to override default\n                              -- foregrounds and backgrounds in palettes.\n   runner.wpmPanel = Panel { 5, 80, 7, 90, write = runner.write }\n   runner.linePanel = Panel { 5, 10, 6, 70,\n                              justify = \'center\',\n                              --border = \'light\',\n                              write = runner.write, }\n\n   runner.linePanel:replace(runner.line:paint())\n\n   -- we need a bit of state to feed the timekeeper:\n   local presses = 0\n   local function strokes()\n      return presses\n   end\n\n   local time = Timekeeper(strokes, seconds)\n   runner.time = time\n   time:kickoff()\n\n   -- Add pause handling here\n   local function onseq(event)\n      if not event then\n         error \"parser failed to return event, unrecoverable\"\n      end\n      local completed = runner.line.completed\n\n      runner.statPanel:replace(ts(completed))\n      local key = extractLetter(event)\n\n      if key then  -- but not when paused!\n         presses = presses + 1\n         runner.wpmPanel:replace(scorecard(time:wpm()))\n         runner:play(key)\n         runner.linePanel:replace(runner.line:paint())\n      end\n\n      if completed and event.key == \'RETURN\' then\n         runner.statPanel:replace(ts(event))\n         runner:next()\n      end\n\n      if event.key == \'ESC\' then\n         runner:quit()\n      end\n\n      runner:paint()\n   end\n\n   onread(stdin, onseq)\n   runner:paint()\n\n   return runner\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\n\nfunction Runner.next(runner)\n   -- we get a fancy source from the line like so\n   local source = runner.line:winSource()\n   -- which we sink thus\n   local linePanel = runner.linePanel\n   --linePanel.justify = \'left\'\n   local function sink(dressed_line)\n      -- replace, yield, paint: gets us to the next event before painting\n      linePanel:replace(dressed_line)\n      dressed_line = yield(true)\n      repeat\n         linePanel:overlay()\n         linePanel:replace(dressed_line)\n         dressed_line = yield(true)\n      until not dressed_line\n      -- set up the next line, now that we\'ve had our fun\n      local next_str = runner.lib()\n      if next_str then\n         runner.line = Modline(next_str)\n         linePanel:replace(runner.line:paint())\n         --linePanel.justify = \'center\'\n      end\n\n      runner:paint()\n      return false\n   end\n   --- annnnd... drain\n   drain(source, 15, wrap(sink))\nend\n\n\n\n\n\n\nfunction Runner.paint(runner)\n\n   local function paint_cb()\n      runner.linePanel:paint()\n      runner.statPanel:paint()\n      runner.wpmPanel:paint()\n      runner.painter:stop()\n   end\n\n   runner.painter:start(paint_cb)\n\n   return runner\nend\n\n\n\n\nfunction Runner.play(runner, key)\n   runner.line:letter(key)\nend\n\n\n\n\nfunction Runner.quit(runner)\n   runner.time:finish()\n   runner.write(a.cursor.show())\n   runner.shutdown()\nend\n\n\n\n\n\n\nreturn new\n\n",
vc_hash = "a46b8587522ea53809ff0d05ebd69dab1da4816a\n",
name = "runner",
branch = "scorecard",
},
  { 
hash = "e55c873cc5ac1a65eb99359aef9f8b1366526d36aa9698225074ca5c656cb8b9",
binary = "\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\nlocal Deque = require \"deque:deque\"\nlocal uv = require \"luv\"\n\n\n\n\n\n\n\n\nlocal HZ = 30\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new, Time = cluster.order()\n\ncluster.construct(new, function(new, time, strokes, limit)\n   time.strokes = strokes\n   time.limit   = limit and limit * 1000  or math.huge -- milliseconds\n   time.keeper = uv.new_timer()\n   return time\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Time.tracker(time)\n   time.madetracker = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function wpm(ring)\n   -- this saturates to 1 after 12 seconds\n   local scale = 12 / #ring\n   local count = 0\n   for i = 1, #ring do\n      for presses in ring[i]:peekAll() do\n         count = count + presses\n      end\n   end\n\n   return math.floor(count * scale)\nend\n\n\n\n\n\n\n\n\nfunction Time.wpm(timer)\n   return wpm(timer.ring or {}) -- always better to have a base case\nend\n\n\n\n\n\n\n\n\nlocal now = assert(uv.now)\n\nlocal clear, insert = assert(table.clear), assert(table.insert)\n\nlocal INTERVAL = math.floor(1000 / HZ)\n\nfunction Time.kickoff(time)\n   -- for convenience we can toss the tracker closure if we\'re not using it\n   -- but typetrain always makes one so no sense in optional logic.\n   if not time.madetracker then\n      time:tracker()\n   end\n   -- set up the timer itself\n   local instant = now()\n   time.first = instant\n   time.thus  = instant\n   time.goal  = instant + time.limit\n   time.letters = 0\n   -- rolling average data structure\n   local ring = {Deque()}\n   time.ring = ring\n\n   local second = 1\n   local last_second;\n   local saturated = false\n   time.keeper:start(0, INTERVAL, function()\n      local this = now()\n      last_second = last_second or this\n      local duration = time.thus - this\n      local millis = this - last_second\n\n      ---[[ DIAGNOSTIC\n      time.state = { second = second,\n                     last_second = last_second,\n                     saturated = saturated,\n                     millis = this - last_second,\n                     this = this,\n                     ringlen = #ring,\n                     duration = duration }\n      --]]\n\n      time.thus = this\n      if time.paused then\n         -- bump goal by duration and bail out\n         time.goal = time.goal + duration\n         return\n      end\n\n      -- first question: has it been a full second?\n      if millis > 1000 then\n         -- millis isn\'t stateful, so we needn\'t reset itb\n         if second == 12 then\n            saturated = true\n            second = 1\n         else\n            second = second + 1\n         end\n         last_second = this\n      end\n\n      -- where are we at with keystrokes?\n      local keycount = time.strokes()\n      local keys_pressed = keycount - time.letters\n      time.letters = keycount\n\n      -- we need to load up queues in the ring buffer at the beginning\n      if second > #ring then\n         ring[second] = Deque()\n      end\n\n      local queue = ring[second]\n      if not queue then\n         error (\"nil queue at second \" .. second .. \"seq \" .. prn)\n      end\n\n      queue:push(keys_pressed)\n      -- saturated is true once the ring starts rolling\n      if saturated then\n         queue:pop()\n      end\n\n      -- we add up the ring on demand, elsewhere\n      if this > time.goal then\n         return time:finish()\n      end\n   end)\nend\n\n\n\n\n\n\n\n\n\nfunction Time.pause(time)\n   time.paused = true\nend\n\n\n\n\n\n\n\n\n\nfunction Time.start(timer, limit)\n   if not time.complete then\n      timer.paused = false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Time.finish(time)\n   time:pause()\n\n   time.keeper:stop()\n   time.complete = true\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "a46b8587522ea53809ff0d05ebd69dab1da4816a\n",
name = "timekeeper",
branch = "scorecard",
},
} },
{
  project = {
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/util.git\n\n",
    website = "",
    repo_type = "git",
    home = "",
    name = "util",
    repo = "git@gitlab.com:special-circumstance/util.git\n",
},
  version = {    stage = "SNAPSHOT",
    edition = "",
    special = "no",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "7e80a0634ca526b0cc96a5e0ec47830ee7de1bee2f5b0081e456a38a039ee6ca",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal always_use_lpeg = true\n--[==[\n\nDavid Kolf\'s JSON module for Lua 5.1 - 5.4\n\nVersion 2.6\n\n--]==]\n\n-- global dependencies:\nlocal pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n      pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\nlocal error, require, pcall, select = error, require, pcall, select\nlocal floor, huge = math.floor, math.huge\nlocal strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n      string.rep, string.gsub, string.sub, string.byte, string.char,\n      string.find, string.len, string.format\nlocal strmatch = string.match\nlocal concat = table.concat\n\nlocal json = { version = \"dkjson 2.6\" }\n\nlocal jsonlpeg = {}\n\n\nlocal _ENV = nil -- blocking globals in Lua 5.2 and later\n\npcall (function()\n  -- Enable access to blocked metatables.\n  -- Don\'t worry, this module doesn\'t change anything in them.\n  local debmeta = require \"debug\".getmetatable\n  if debmeta then getmetatable = debmeta end\nend)\n\njson.null = setmetatable ({}, {\n  __tojson = function () return \"null\" end\n})\n\nlocal function isarray (tbl)\n  local max, n, arraylen = 0, 0, 0\n  for k,v in pairs (tbl) do\n    if k == \'n\' and type(v) == \'number\' then\n      arraylen = v\n      if v > max then\n        max = v\n      end\n    else\n      if type(k) ~= \'number\' or k < 1 or floor(k) ~= k then\n        return false\n      end\n      if k > max then\n        max = k\n      end\n      n = n + 1\n    end\n  end\n  if max > 10 and max > arraylen and max > n * 2 then\n    return false -- don\'t create an array with too many holes\n  end\n  return true, max\nend\n\nlocal escapecodes = {\n  [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n  [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n}\n\nlocal function escapeutf8 (uchar)\n  local value = escapecodes[uchar]\n  if value then\n    return value\n  end\n  local a, b, c, d = strbyte (uchar, 1, 4)\n  a, b, c, d = a or 0, b or 0, c or 0, d or 0\n  if a <= 0x7f then\n    value = a\n  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n    value = (a - 0xc0) * 0x40 + b - 0x80\n  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n  else\n    return \"\"\n  end\n  if value <= 0xffff then\n    return strformat (\"\\\\u%.4x\", value)\n  elseif value <= 0x10ffff then\n    -- encode as UTF-16 surrogate pair\n    value = value - 0x10000\n    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n    return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n  else\n    return \"\"\n  end\nend\n\nlocal function fsub (str, pattern, repl)\n  -- gsub always builds a new string in a buffer, even when no match\n  -- exists. First using find should be more efficient when most strings\n  -- don\'t contain the pattern.\n  if strfind (str, pattern) then\n    return gsub (str, pattern, repl)\n  else\n    return str\n  end\nend\n\nlocal function quotestring (value)\n  -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n  value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n  if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n    value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n    value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n    value = fsub (value, \"\\220\\143\", escapeutf8)\n    value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n    value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n    value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n    value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n    value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n  end\n  return \"\\\"\" .. value .. \"\\\"\"\nend\njson.quotestring = quotestring\n\nlocal function replace(str, o, n)\n  local i, j = strfind (str, o, 1, true)\n  if i then\n    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n  else\n    return str\n  end\nend\n\n-- locale independent num2str and str2num functions\nlocal decpoint, numfilter\n\nlocal function updatedecpoint ()\n  decpoint = strmatch(tostring(0.5), \"([^05+])\")\n  -- build a filter that can be used to remove group separators\n  numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\nend\n\nupdatedecpoint()\n\nlocal function num2str (num)\n  return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\nend\n\nlocal function str2num (str)\n  local num = tonumber(replace(str, \".\", decpoint))\n  if not num then\n    updatedecpoint()\n    num = tonumber(replace(str, \".\", decpoint))\n  end\n  return num\nend\n\nlocal function addnewline2 (level, buffer, buflen)\n  buffer[buflen+1] = \"\\n\"\n  buffer[buflen+2] = strrep (\"  \", level)\n  buflen = buflen + 2\n  return buflen\nend\n\nfunction json.addnewline (state)\n  if state.indent then\n    state.bufferlen = addnewline2 (state.level or 0,\n                           state.buffer, state.bufferlen or #(state.buffer))\n  end\nend\n\nlocal encode2 -- forward declaration\n\nlocal function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n  local kt = type (key)\n  if kt ~= \'string\' and kt ~= \'number\' then\n    return nil, \"type \'\" .. kt .. \"\' is not supported as a key by JSON.\"\n  end\n  if prev then\n    buflen = buflen + 1\n    buffer[buflen] = \",\"\n  end\n  if indent then\n    buflen = addnewline2 (level, buffer, buflen)\n  end\n  buffer[buflen+1] = quotestring (key)\n  buffer[buflen+2] = \":\"\n  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\nend\n\nlocal function appendcustom(res, buffer, state)\n  local buflen = state.bufferlen\n  if type (res) == \'string\' then\n    buflen = buflen + 1\n    buffer[buflen] = res\n  end\n  return buflen\nend\n\nlocal function exception(reason, value, state, buffer, buflen, defaultmessage)\n  defaultmessage = defaultmessage or reason\n  local handler = state.exception\n  if not handler then\n    return nil, defaultmessage\n  else\n    state.bufferlen = buflen\n    local ret, msg = handler (reason, value, state, defaultmessage)\n    if not ret then return nil, msg or defaultmessage end\n    return appendcustom(ret, buffer, state)\n  end\nend\n\nfunction json.encodeexception(reason, value, state, defaultmessage)\n  return quotestring(\"<\" .. defaultmessage .. \">\")\nend\n\nencode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n  local valtype = type (value)\n  local valmeta = getmetatable (value)\n  valmeta = type (valmeta) == \'table\' and valmeta -- only tables\n  local valtojson = valmeta and valmeta.__tojson\n  if valtojson then\n    if tables[value] then\n      return exception(\'reference cycle\', value, state, buffer, buflen)\n    end\n    tables[value] = true\n    state.bufferlen = buflen\n    local ret, msg = valtojson (value, state)\n    if not ret then return exception(\'custom encoder failed\', value, state, buffer, buflen, msg) end\n    tables[value] = nil\n    buflen = appendcustom(ret, buffer, state)\n  elseif value == nil then\n    buflen = buflen + 1\n    buffer[buflen] = \"null\"\n  elseif valtype == \'number\' then\n    local s\n    if value ~= value or value >= huge or -value >= huge then\n      -- This is the behaviour of the original JSON implementation.\n      s = \"null\"\n    else\n      s = num2str (value)\n    end\n    buflen = buflen + 1\n    buffer[buflen] = s\n  elseif valtype == \'boolean\' then\n    buflen = buflen + 1\n    buffer[buflen] = value and \"true\" or \"false\"\n  elseif valtype == \'string\' then\n    buflen = buflen + 1\n    buffer[buflen] = quotestring (value)\n  elseif valtype == \'table\' then\n    if tables[value] then\n      return exception(\'reference cycle\', value, state, buffer, buflen)\n    end\n    tables[value] = true\n    level = level + 1\n    local isa, n = isarray (value)\n    if n == 0 and valmeta and valmeta.__jsontype == \'object\' then\n      isa = false\n    end\n    local msg\n    if isa then -- JSON array\n      buflen = buflen + 1\n      buffer[buflen] = \"[\"\n      for i = 1, n do\n        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n        if not buflen then return nil, msg end\n        if i < n then\n          buflen = buflen + 1\n          buffer[buflen] = \",\"\n        end\n      end\n      buflen = buflen + 1\n      buffer[buflen] = \"]\"\n    else -- JSON object\n      local prev = false\n      buflen = buflen + 1\n      buffer[buflen] = \"{\"\n      local order = valmeta and valmeta.__jsonorder or globalorder\n      if order then\n        local used = {}\n        n = #order\n        for i = 1, n do\n          local k = order[i]\n          local v = value[k]\n          if v ~= nil then\n            used[k] = true\n            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n            prev = true -- add a seperator before the next element\n          end\n        end\n        for k,v in pairs (value) do\n          if not used[k] then\n            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n            if not buflen then return nil, msg end\n            prev = true -- add a seperator before the next element\n          end\n        end\n      else -- unordered\n        for k,v in pairs (value) do\n          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n          if not buflen then return nil, msg end\n          prev = true -- add a seperator before the next element\n        end\n      end\n      if indent then\n        buflen = addnewline2 (level - 1, buffer, buflen)\n      end\n      buflen = buflen + 1\n      buffer[buflen] = \"}\"\n    end\n    tables[value] = nil\n  else\n    return exception (\'unsupported type\', value, state, buffer, buflen,\n      \"type \'\" .. valtype .. \"\' is not supported by JSON.\")\n  end\n  return buflen\nend\n\nfunction json.encode (value, state)\n  -- this is a saner default esp since decode returns two values\n  state = type(state) == \'table\' and state or {}\n  local oldbuffer = state.buffer\n  local buffer = oldbuffer or {}\n  state.buffer = buffer\n  updatedecpoint()\n  local ret, msg = encode2 (value, state.indent, state.level or 0,\n                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n  if not ret then\n    error (msg, 2)\n  elseif oldbuffer == buffer then\n    state.bufferlen = ret\n    return true\n  else\n    state.bufferlen = nil\n    state.buffer = nil\n    return concat (buffer)\n  end\nend\n\nlocal function loc (str, where)\n  local line, pos, linepos = 1, 1, 0\n  while true do\n    pos = strfind (str, \"\\n\", pos, true)\n    if pos and pos < where then\n      line = line + 1\n      linepos = pos\n      pos = pos + 1\n    else\n      break\n    end\n  end\n  return \"line \" .. line .. \", column \" .. (where - linepos)\nend\n\nlocal escapechars = {\n  [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n  [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n}\n\n\n\nlocal function optionalmetatables(...)\n  if select(\"#\", ...) > 0 then\n    return ...\n  else\n    return {__jsontype = \'object\'}, {__jsontype = \'array\'}\n  end\nend\n\n\nfunction json.use_lpeg ()\n  local g = require (\"lpeg\")\n\n  if g.version() == \"0.11\" then\n    error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n  end\n\n  local pegmatch = g.match\n  local P, S, R = g.P, g.S, g.R\n\n  local function ErrorCall (str, pos, msg, state)\n    if not state.msg then\n      state.msg = msg .. \" at \" .. loc (str, pos)\n      state.pos = pos\n    end\n    return false\n  end\n\n  local function Err (msg)\n    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n  end\n\n  local function ErrorUnterminatedCall (str, pos, what, state)\n    return ErrorCall (str, pos - 1, \"unterminated \" .. what, state)\n  end\n\n  local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n  local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n  local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n\n  local function ErrUnterminated (what)\n    return g.Cmt (g.Cc (what) * g.Carg (2), ErrorUnterminatedCall)\n  end\n\n  local unichar = require \"utf8\" . char\n  local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n  local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n  local HexDigit = R(\"09\", \"af\", \"AF\")\n  local function UTF16Surrogate (match, pos, high, low)\n    high, low = tonumber (high, 16), tonumber (low, 16)\n    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n    else\n      return false\n    end\n  end\n  local function UTF16BMP (hex)\n    return unichar (tonumber (hex, 16))\n  end\n  local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n  local Char = UnicodeEscape + EscapeSequence + PlainChar\n  local String = P\"\\\"\" * (g.Cs (Char ^ 0) * P\"\\\"\" + ErrUnterminated \"string\")\n  local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n  local Fractal = P\".\" * R\"09\"^0\n  local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n  local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n  local SimpleValue = Number + String + Constant\n  local ArrayContent, ObjectContent\n\n  -- The functions parsearray and parseobject parse only a single value/pair\n  -- at a time and store them directly to avoid hitting the LPeg limits.\n  local function parsearray (str, pos, nullval, state)\n    local obj, cont\n    local start = pos\n    local npos\n    local t, nt = {}, 0\n    repeat\n      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n      if cont == \'end\' then\n        return ErrorUnterminatedCall (str, start, \"array\", state)\n      end\n      pos = npos\n      if cont == \'cont\' or cont == \'last\' then\n        nt = nt + 1\n        t[nt] = obj\n      end\n    until cont ~= \'cont\'\n    return pos, setmetatable (t, state.arraymeta)\n  end\n\n  local function parseobject (str, pos, nullval, state)\n    local obj, key, cont\n    local start = pos\n    local npos\n    local t = {}\n    repeat\n      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n      if cont == \'end\' then\n        return ErrorUnterminatedCall (str, start, \"object\", state)\n      end\n      pos = npos\n      if cont == \'cont\' or cont == \'last\' then\n        t[key] = obj\n      end\n    until cont ~= \'cont\'\n    return pos, setmetatable (t, state.objectmeta)\n  end\n\n  local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray)\n  local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject)\n  local Value = Space * (Array + Object + SimpleValue)\n  local ExpectedValue = Value + Space * Err \"value expected\"\n  local ExpectedKey = String + Err \"key expected\"\n  local End = P(-1) * g.Cc\'end\'\n  local ErrInvalid = Err \"invalid JSON\"\n  ArrayContent = (Value * Space * (P\",\" * g.Cc\'cont\' + P\"]\" * g.Cc\'last\'+ End + ErrInvalid)  + g.Cc(nil) * (P\"]\" * g.Cc\'empty\' + End  + ErrInvalid)) * g.Cp()\n  local Pair = g.Cg (Space * ExpectedKey * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n  ObjectContent = (g.Cc(nil) * g.Cc(nil) * P\"}\" * g.Cc\'empty\' + End + (Pair * Space * (P\",\" * g.Cc\'cont\' + P\"}\" * g.Cc\'last\' + End + ErrInvalid) + ErrInvalid)) * g.Cp()\n  local DecodeValue = ExpectedValue * g.Cp ()\n\n  jsonlpeg.version = json.version\n  jsonlpeg.encode = json.encode\n  jsonlpeg.null = json.null\n  jsonlpeg.quotestring = json.quotestring\n  jsonlpeg.addnewline = json.addnewline\n  jsonlpeg.encodeexception = json.encodeexception\n  jsonlpeg.using_lpeg = true\n\n  function jsonlpeg.decode (str, pos, nullval, ...)\n    local state = {}\n    state.objectmeta, state.arraymeta = optionalmetatables(...)\n    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n    if state.msg then\n      return nil, state.pos, state.msg\n    else\n      return obj, retpos\n    end\n  end\n  return jsonlpeg\nend\n\n\nreturn json.use_lpeg()\n\n",
vc_hash = "f2dc07a1a9e3ad301e3c0d938504452f3fb5df00\n",
name = "json",
branch = "trunk",
},
  { 
hash = "bce8a2084abbd67bb6a1c1f76dd58e4dc32b614301f049430f252f0da0004282",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal n, v = \"serpent\", \"0.302\" -- (C) 2012-18 Paul Kulchenko; MIT License\nlocal c, d = \"Paul Kulchenko\", \"Lua serializer and pretty printer\"\nlocal snum = {[tostring(1/0)]=\'1/0 --[[math.huge]]\',[tostring(-1/0)]=\'-1/0 --[[-math.huge]]\',[tostring(0/0)]=\'0/0\'}\nlocal badtype = {thread = true, userdata = true, cdata = true}\nlocal getmetatable = debug and debug.getmetatable or getmetatable\nlocal pairs = function(t) return next, t end -- avoid using __pairs in Lua 5.2+\nlocal keyword, globals, G = {}, {}, (_G or _ENV)\nfor _,k in ipairs({\'and\', \'break\', \'do\', \'else\', \'elseif\', \'end\', \'false\',\n  \'for\', \'function\', \'goto\', \'if\', \'in\', \'local\', \'nil\', \'not\', \'or\', \'repeat\',\n  \'return\', \'then\', \'true\', \'until\', \'while\'}) do keyword[k] = true end\nfor k,v in pairs(G) do globals[v] = k end -- build func to name mapping\nfor _,g in ipairs({\'coroutine\', \'debug\', \'io\', \'math\', \'string\', \'table\', \'os\'}) do\n  for k,v in pairs(type(G[g]) == \'table\' and G[g] or {}) do globals[v] = g..\'.\'..k end end\n\nlocal function s(t, opts)\n  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum\n  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge\n  local space, maxl = (opts.compact and \'\' or \' \'), (opts.maxlevel or math.huge)\n  local maxlen, metatostring = tonumber(opts.maxlength), opts.metatostring\n  local iname, comm = \'_\'..(name or \'\'), opts.comment and (tonumber(opts.comment) or math.huge)\n  local numformat = opts.numformat or \"%.17g\"\n  local seen, sref, syms, symn = {}, {\'local \'..iname..\'={}\'}, {}, 0\n  local function gensym(val) return \'_\'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\n    -- tostring(val) is needed because __tostring may return a non-string value\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end\n  local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end\n  local function comment(s,l) return comm and (l or 0) < comm and \' --[[\'..select(2, pcall(tostring, s))..\']]\' or \'\' end\n  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can\'t serialize \"..tostring(s)) end\n  local function safename(path, name) -- generates foo.bar, foo[3], or foo[\'b a r\']\n    local n = name == nil and \'\' or name\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\n    local safe = plain and n or \'[\'..safestr(n)..\']\'\n    return (path or \'\')..(plain and path and \'.\' or \'\')..safe, safe end\n  local alphanumsort = type(opts.sortkeys) == \'function\' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\n    local maxn, to = tonumber(n) or 12, {number = \'a\', string = \'b\'}\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\n    table.sort(k, function(a,b)\n      -- sort numeric keys first: k[key] is not nil for numerical keys\n      return (k[a] ~= nil and 0 or to[type(a)] or \'z\')..(tostring(a):gsub(\"%d+\",padnum))\n           < (k[b] ~= nil and 0 or to[type(b)] or \'z\')..(tostring(b):gsub(\"%d+\",padnum)) end) end\n  local function val2str(t, name, indent, insref, path, plainindex, level)\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\n    local spath, sname = safename(path, name)\n    local tag = plainindex and\n      ((type(name) == \"number\") and \'\' or name..space..\'=\'..space) or\n      (name ~= nil and sname..space..\'=\'..space or \'\')\n    if seen[t] then -- already seen this element\n      sref[#sref+1] = spath..space..\'=\'..space..seen[t]\n      return tag..\'nil\'..comment(\'ref\', level) end\n    -- protect from those cases where __tostring may fail\n    if type(mt) == \'table\' and metatostring ~= false then\n      local to, tr = pcall(function() return mt.__tostring(t) end)\n      local so, sr = pcall(function() return mt.__serialize(t) end)\n      if (to or so) then -- knows how to serialize itself\n        seen[t] = insref or spath\n        t = so and sr or tr\n        ttype = type(t)\n      end -- new value falls through to be serialized\n    end\n    if ttype == \"table\" then\n      if level >= maxl then return tag..\'{}\'..comment(\'maxlvl\', level) end\n      seen[t] = insref or spath\n      if next(t) == nil then return tag..\'{}\'..comment(t, level) end -- table empty\n      if maxlen and maxlen < 0 then return tag..\'{}\'..comment(\'maxlen\', level) end\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\n      for key = 1, maxn do o[key] = key end\n      if not maxnum or #o < maxnum then\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\n      for n, key in ipairs(o) do\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\n        or opts.keyallow and not opts.keyallow[key]\n        or opts.keyignore and opts.keyignore[key]\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\n        or sparse and value == nil then -- skipping nils; do nothing\n        elseif ktype == \'table\' or ktype == \'function\' or badtype[ktype] then\n          if not seen[key] and not globals[key] then\n            sref[#sref+1] = \'placeholder\'\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\n          sref[#sref+1] = \'placeholder\'\n          local path = seen[t]..\'[\'..tostring(seen[key] or globals[key] or gensym(key))..\']\'\n          sref[#sref] = path..space..\'=\'..space..tostring(seen[value] or val2str(value,nil,indent,path))\n        else\n          out[#out+1] = val2str(value,key,indent,nil,seen[t],plainindex,level+1)\n          if maxlen then\n            maxlen = maxlen - #out[#out]\n            if maxlen < 0 then break end\n          end\n        end\n      end\n      local prefix = string.rep(indent or \'\', level)\n      local head = indent and \'{\\n\'..prefix..indent or \'{\'\n      local body = table.concat(out, \',\'..(indent and \'\\n\'..prefix..indent or space))\n      local tail = indent and \"\\n\"..prefix..\'}\' or \'}\'\n      return (custom and custom(tag,head,body,tail,level) or tag..head..body..tail)..comment(t, level)\n    elseif badtype[ttype] then\n      seen[t] = insref or spath\n      return tag..globerr(t, level)\n    elseif ttype == \'function\' then\n      seen[t] = insref or spath\n      if opts.nocode then return tag..\"function() --[[..skipped..]] end\"..comment(t, level) end\n      local ok, res = pcall(string.dump, t)\n      local func = ok and \"((loadstring or load)(\"..safestr(res)..\",\'@serialized\'))\"..comment(t, level)\n      return tag..(func or globerr(t, level))\n    else return tag..safestr(t) end -- handle all other types\n  end\n  local sepr = indent and \"\\n\" or \";\"..space\n  local body = val2str(t, name, indent) -- this call also populates sref\n  local tail = #sref>1 and table.concat(sref, sepr)..sepr or \'\'\n  local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or \'\'\n  return not name and body..warn or \"do local \"..body..sepr..tail..\"return \"..name..sepr..\"end\"\nend\n\nlocal function deserialize(data, opts)\n  opts = opts or {}\n  local env = (opts and opts.safe == false) and G\n    or setmetatable({}, {\n        __index = function(t,k) return t end,\n        __call = function(t,...) error(\"cannot call functions\") end\n      })\n  local ret = opts.noreturn and \'\' or \'return \'\n  local f, res = (loadstring or load)(ret..data, nil, nil, env)\n  if not f then f, res = (loadstring or load)(data, nil, nil, env) end\n  if not f then return f, res end\n  if setfenv then setfenv(f, env) end\n  local ok, res = pcall(f)\n  if ok then return res end\n  return nil, res\nend\n\nlocal function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end\nreturn { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,\n  load = deserialize,\n  import = function(bundle)\n              return deserialize(bundle, {noreturn = true})\n           end,\n  bundle = function(a, opts)\n              return \"return \" .. s(a, merge({ indent = \'  \',\n                                               sortkeys = true,\n                                               metatostring = false,\n                                               comment = false, }, opts))\n           end,\n  dump = function(a, opts) return s(a, merge({name = \'_\', compact = true, sparse = true}, opts)) end,\n  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,\n  block = function(a, opts) return s(a, merge({indent = \'  \', sortkeys = true, comment = true}, opts)) end }\n\n",
vc_hash = "f2dc07a1a9e3ad301e3c0d938504452f3fb5df00\n",
name = "serpent",
branch = "trunk",
},
  { 
hash = "7f8cb2b48abb20c4e25891bcb8789d82b04ef346b15cc021d17b3f7c2afe43f4",
binary = "\n\n\n\n\n--[=====================================================================[\nv0.8 Copyright © 2013-2018 Gavin Kistner <!@phrogz.net>; MIT Licensed\nSee http://github.com/Phrogz/SLAXML for details.\n--]=====================================================================]\nlocal SLAXML = {\n   VERSION = \"0.8\",\n   _call = {\n      pi = function(target,content)\n         print(string.format(\"<?%s %s?>\",target,content))\n      end,\n      comment = function(content)\n         print(string.format(\"<!-- %s -->\",content))\n      end,\n      startElement = function(name,nsURI,nsPrefix)\n                          io.write(\"<\")\n         if nsPrefix then io.write(nsPrefix,\":\") end\n                          io.write(name)\n         if nsURI    then io.write(\" (ns=\'\",nsURI,\"\')\") end\n                          print(\">\")\n      end,\n      attribute = function(name,value,nsURI,nsPrefix)\n                          io.write(\'  \')\n         if nsPrefix then io.write(nsPrefix,\":\") end\n                          io.write(name,\'=\',string.format(\'%q\',value))\n         if nsURI    then io.write(\" (ns=\'\",nsURI,\"\')\") end\n                          io.write(\"\\n\")\n      end,\n      text = function(text,cdata)\n         print(string.format(\"  %s: %q\",cdata and \'cdata\' or \'text\',text))\n      end,\n      closeElement = function(name,nsURI,nsPrefix)\n                          io.write(\"</\")\n         if nsPrefix then io.write(nsPrefix,\":\") end\n                          print(name..\">\")\n      end,\n   }\n}\n\nfunction SLAXML:parser(callbacks)\n   return { _call=callbacks or self._call, parse=SLAXML.parse }\nend\n\nfunction SLAXML:parse(xml,options)\n   if not options then options = { stripWhitespace=false } end\n\n   -- Cache references for maximum speed\n   local find, sub, gsub, char, push, pop, concat = string.find, string.sub, string.gsub, string.char, table.insert, table.remove, table.concat\n   local first, last, match1, match2, match3, pos2, nsURI\n   local unpack = unpack or table.unpack\n   local pos = 1\n   local state = \"text\"\n   local textStart = 1\n   local currentElement={}\n   local currentAttributes={}\n   local currentAttributeCt -- manually track length since the table is re-used\n   local nsStack = {}\n   local anyElement = false\n\n   local utf8markers = { {0x7FF,192}, {0xFFFF,224}, {0x1FFFFF,240} }\n   local function utf8(decimal) -- convert unicode code point to utf-8 encoded character string\n      if decimal<128 then return char(decimal) end\n      local charbytes = {}\n      for bytes,vals in ipairs(utf8markers) do\n         if decimal<=vals[1] then\n            for b=bytes+1,2,-1 do\n               local mod = decimal%64\n               decimal = (decimal-mod)/64\n               charbytes[b] = char(128+mod)\n            end\n            charbytes[1] = char(vals[2]+decimal)\n            return concat(charbytes)\n         end\n      end\n   end\n\n   local entityMap  = { [\"lt\"]=\"<\", [\"gt\"]=\">\", [\"amp\"]=\"&\", [\"quot\"]=\'\"\', [\"apos\"]=\"\'\" }\n   local entitySwap = function(orig,n,s) return entityMap[s] or n==\"#\" and utf8(tonumber(\'0\'..s)) or orig end\n   local function unescape(str) return gsub( str, \'(&(#?)([%d%a]+);)\', entitySwap ) end\n\n   local _text = self._call.text\n   local function finishText()\n      if first>textStart and self._call.text then\n         local text = sub(xml,textStart,first-1)\n         if options.stripWhitespace then\n            text = gsub(text,\'^%s+\',\'\')\n            text = gsub(text,\'%s+$\',\'\')\n            if #text==0 then text=nil end\n         end\n         if text and _text then _text(unescape(text),false, pos) end\n      end\n   end\n\n   local _pi = self._call.pi\n   local function findPI()\n      first, last, match1, match2 = find( xml, \'^<%?([:%a_][:%w_.-]*) ?(.-)%?>\', pos )\n      if first then\n         finishText()\n         if _pi then _pi(match1, match2, pos) end\n         pos = last+1\n         textStart = pos\n         return true\n      end\n   end\n\n   local _comment = self._call.comment\n   local function findComment()\n      first, last, match1 = find( xml, \'^<!%-%-(.-)%-%->\', pos )\n      if first then\n         finishText()\n         if _comment then _comment(match1, pos) end\n         pos = last+1\n         textStart = pos\n         return true\n      end\n   end\n\n   local function nsForPrefix(prefix)\n      if prefix==\'xml\' then return \'http://www.w3.org/XML/1998/namespace\' end -- http://www.w3.org/TR/xml-names/#ns-decl\n      for i=#nsStack,1,-1 do\n         if nsStack[i][prefix] then\n            return nsStack[i][prefix]\n         end\n      end\n      error((\"Cannot find namespace for prefix %s\"):format(prefix))\n   end\n\n   local function startElement()\n      anyElement = true\n      first, last, match1 = find( xml, \'^<([%a_][%w_.-]*)\', pos )\n      if first then\n         currentElement[2] = nil -- reset the nsURI, since this table is re-used\n         currentElement[3] = nil -- reset the nsPrefix, since this table is re-used\n         finishText()\n         pos = last+1\n         first, last, match2 = find(xml, \'^:([%a_][%w_.-]*)\', pos )\n         if first then\n            currentElement[1] = match2\n            currentElement[3] = match1 -- Save the prefix for later resolution\n            match1 = match2\n            pos = last+1\n         else\n            currentElement[1] = match1\n            for i=#nsStack,1,-1 do if nsStack[i][\'!\'] then currentElement[2] = nsStack[i][\'!\']; break end end\n         end\n         currentAttributeCt = 0\n         push(nsStack,{})\n         return true\n      end\n   end\n\n   local function findAttribute()\n      first, last, match1 = find( xml, \'^%s+([:%a_][:%w_.-]*)%s*=%s*\', pos )\n      if first then\n         pos2 = last+1\n         first, last, match2 = find( xml, \'^\"([^<\"]*)\"\', pos2 ) -- FIXME: disallow non-entity ampersands\n         if first then\n            pos = last+1\n            match2 = unescape(match2)\n         else\n            first, last, match2 = find( xml, \"^\'([^<\']*)\'\", pos2 ) -- FIXME: disallow non-entity ampersands\n            if first then\n               pos = last+1\n               match2 = unescape(match2)\n            end\n         end\n      end\n      if match1 and match2 then\n         local currentAttribute = {match1,match2}\n         local prefix,name = string.match(match1,\'^([^:]+):([^:]+)$\')\n         if prefix then\n            if prefix==\'xmlns\' then\n               nsStack[#nsStack][name] = match2\n            else\n               currentAttribute[1] = name\n               currentAttribute[4] = prefix\n            end\n         else\n            if match1==\'xmlns\' then\n               nsStack[#nsStack][\'!\'] = match2\n               currentElement[2]      = match2\n            end\n         end\n         currentAttributeCt = currentAttributeCt + 1\n         currentAttributes[currentAttributeCt] = currentAttribute\n         return true\n      end\n   end\n\n   local function findCDATA()\n      first, last, match1 = find( xml, \'^<!%[CDATA%[(.-)%]%]>\', pos )\n      if first then\n         finishText()\n         if _text then _text(match1,true) end\n         pos = last+1\n         textStart = pos\n         return true\n      end\n   end\n\n   local _startElement, _attribute, _closeElement = self._call.startElement,\n                                                    self._call.attribute,\n                                                    self._call.closeElement\n\n   local function closeElement()\n      first, last, match1 = find( xml, \'^%s*(/?)>\', pos )\n      if first then\n         state = \"text\"\n         pos = last+1\n         textStart = pos\n\n         -- Resolve namespace prefixes AFTER all new/redefined prefixes have been parsed\n         if currentElement[3] then currentElement[2] = nsForPrefix(currentElement[3])    end\n         if _startElement then\n            push(currentElement, pos)\n            _startElement(unpack(currentElement))\n            pop(currentElement)\n         end\n         if _attribute then\n            for i=1, currentAttributeCt do\n               if currentAttributes[i][4] then currentAttributes[i][3] = nsForPrefix(currentAttributes[i][4]) end\n               push(currentAttributes[i], pos)\n               _attribute(unpack(currentAttributes[i]))\n               pop(currentAttributes[i])\n            end\n         end\n\n         if match1==\"/\" then\n            pop(nsStack)\n            if _closeElement then _closeElement(unpack(currentElement), pos) end\n         end\n         return true\n      end\n   end\n\n   local function findElementClose()\n      first, last, match1, match2 = find( xml, \'^</([%a_][%w_.-]*)%s*>\', pos )\n      if first then\n         nsURI = nil\n         for i=#nsStack,1,-1 do if nsStack[i][\'!\'] then nsURI = nsStack[i][\'!\']; break end end\n      else\n         first, last, match2, match1 = find( xml, \'^</([%a_][%w_.-]*):([%a_][%w_.-]*)%s*>\', pos )\n         if first then nsURI = nsForPrefix(match2) end\n      end\n      if first then\n         finishText()\n         if _closeElement then _closeElement(match1, nsURI, pos) end\n         pos = last+1\n         textStart = pos\n         pop(nsStack)\n         return true\n      end\n   end\n\n   while pos<#xml do\n      if state==\"text\" then\n         if not (findPI()\n            or findComment()\n            or findCDATA()\n            or findElementClose()) then\n\n            if startElement() then\n               state = \"attributes\"\n            else\n               first, last = find( xml, \'^[^<]+\', pos )\n               pos = (first and last or pos) + 1\n            end\n         end\n      elseif state == \"attributes\" then\n         if not findAttribute() then\n            if not closeElement() then\n               error(\"Was in an element and couldn\'t find attributes or the close.\")\n            end\n         end\n      end\n   end\n\n   if not anyElement then error(\"Parsing did not discover any elements\") end\n   if #nsStack > 0 then error(\"Parsing ended with unclosed elements\") end\nend\n\n\n\n\n\n\n\n\n\nfunction SLAXML:dom(xml,opts)\n   opts = opts or {}\n   local rich = not opts.simple\n   local push, pop = table.insert, table.remove\n   local doc = { type=\"document\", name=\"#doc\" }\n   local current, stack = doc, {doc}\n   local builder = SLAXML:parser{\n      startElement = function(name, nsURI, nsPrefix)\n         local el = { type = \"element\",\n                      name = name,\n                        el = rich and {} or nil,\n                      attr = {},\n                      --nsURI=nsURI,\n                      nsPrefix=nsPrefix,\n                      parent = rich and current or nil }\n         if current==doc then\n            if doc.root then error((\"Encountered element \'%s\' when the document already has a root \'%s\' element\"):format(name,doc.root.name)) end\n            doc.root = rich and el or nil\n         end\n         push(current,el)\n         if current.el then push(current.el,el) end\n         current = el\n         push(stack,el)\n      end,\n      attribute = function(name,value,nsURI,nsPrefix)\n         if not current or current.type~=\"element\" then error((\"Encountered an attribute %s=%s but I wasn\'t inside an element\"):format(name,value)) end\n         local attr = { type = \'attribute\',\n                        name = name,\n                        --nsURI=nsURI,\n                        nsPrefix=nsPrefix,\n                        value = value,\n                        parent = rich and current or nil }\n         current.attr[name] = value\n         --if rich then push(current.attr,attr) end\n      end,\n      closeElement = function(name)\n         if current.name~=name or current.type~=\"element\" then error((\"Received a close element notification for \'%s\' but was inside a \'%s\' %s\"):format(name,current.name,current.type)) end\n         pop(stack)\n         current = stack[#stack]\n      end,\n      text = function(value,cdata)\n         -- documents may only have text node children that are whitespace: https://www.w3.org/TR/xml/#NT-Misc\n         if value:find(\'^%s+$\') then return end\n         if current.type==\'document\' then error((\"Document has non-whitespace text at root: \'%s\'\"):format(value:gsub(\'[\\r\\n\\t]\',{[\'\\r\']=\'\\\\r\', [\'\\n\']=\'\\\\n\', [\'\\t\']=\'\\\\t\'}))) end\n         push(current,{ type = \'text\',\n                             name = \'#text\',\n                             cdata = cdata and true or nil,\n                             value = value,\n                             parent = rich and current or nil})\n      end,\n      comment = function(value)\n         push(current,{ type = \'comment\',\n                             name = \'#comment\',\n                             value = value,\n                             parent = rich and current or nil})\n      end,\n      pi = function(name,value)\n         push(current,{ type =\'pi\',\n                             name = name,\n                             value = value,\n                             parent = rich and current or nil})\n      end\n   }\n   builder:parse(xml,opts)\n   return doc\nend\n\n\n\n\n\n\n\n\n\nlocal DOUBLE_ROOT = \"Encountered element \'%s\' when the document \\\nalready has a root \'%s\' element\"\n\nlocal MAX_DEPTH = \"The %s maximum depth of %d has been exceeded.%s\"\n\nlocal CAN_CONFIG = \"\\nThis limit can be changed with opts.max_depth.\"\n\nlocal ATTR_OUTSIDE = \"Encountered an attribute %s=%s \\\nbut I wasn\'t inside an element\"\n\nlocal BAD_CLOSE = \"Received a close element notification for \'%s\' \\\nbut was inside a \'%s\' %s\"\n\nlocal NON_WS = \"Document has non-whitespace text at root: \'%s\'\"\n\n\nfunction SLAXML:tree(xml, opts)\n   opts = opts or {}\n   local push, pop = table.insert, table.remove\n   local doc = { type=\"document\", name=\"#doc\" }\n   local current, stack = doc, {doc}\n   local drop, dropping, drop_ct = opts.drop or {}, \"\", 0\n   local suspend = false\n   local max_depth = opts.max_depth or 1020\n   local builder = SLAXML:parser{\n      startElement = function(name, nsURI, pos)\n         if suspend then\n            if dropping == name then\n               drop_ct = drop_ct + 1\n               return\n            end\n         end\n         if drop[name] then\n            dropping = name\n            drop_ct = 1\n            suspend = true\n            return\n         end\n         local el = { type = \"element\",\n                      name = name,\n                         o = pos,\n                      attr = {},\n                      parent = current.name }\n         if current==doc then\n            if doc.root then\n               error(DOUBLE_ROOT:format(name,doc.root.name))\n            end\n            doc.root = el\n         end\n         push(current,el)\n         current = el\n         push(stack,el)\n         if #stack > max_depth then\n            -- as a future refinement we can \'clip\': count elements up, then\n            -- down, then check tags and continue.\n            -- truth is, highly-nested documents are DOS attacks, for some\n            -- value of high-nested, so this would be more cool than useful.\n            --\n            local which, post = opts.max_depth and \"configured\" or \"default\",\n                                opts.max_depth and \"\" or CAN_CONFIG\n            error(MAX_DEPTH:format(which, max_depth, post))\n         end\n      end,\n      attribute = function(name, value, nsURI, pos)\n         if suspend then return end\n         if not current or current.type~=\"element\"\n            then error(ATTR_OUTSIDE:format(name,value))\n         end\n         local attr = { type = \'attribute\',\n                        name = name,\n                           o = pos,\n                        value = value,\n                        parent = current.name }\n         current.attr[name] = value\n      end,\n      closeElement = function(name)\n         if suspend then\n            if dropping == name then\n               drop_ct = drop_ct - 1\n               if drop_ct <= 1 then -- saturating checks are more robust\n                  drop_ct = 0\n                  dropping = \"\"\n                  suspend = false\n               end\n            end\n            return\n         end\n\n         if current.name~=name or current.type~=\"element\" then\n            error(BAD_CLOSE:format(name,current.name,current.type))\n         end\n         pop(stack)\n         current = stack[#stack]\n      end,\n      text = function(value, cdata, pos)\n         if suspend then return end\n         -- documents may only have text node children that are whitespace:\n         -- https://www.w3.org/TR/xml/#NT-Misc\n         if value:find(\'^%s+$\') then return end\n         if current.type==\'document\' then\n            error(NON_WS :format(value :gsub(\'[\\r\\n\\t]\',\n                                             {[\'\\r\']=\'\\\\r\',\n                                              [\'\\n\']=\'\\\\n\',\n                                              [\'\\t\']=\'\\\\t\'})))\n            end\n         push(current,{ type = \'text\',\n                             name = \'#text\',\n                             cdata = cdata and true or nil,\n                                 o = pos,\n                             value = value,\n                             parent = current.name})\n      end,\n      comment = function(value, pos)\n         if suspend or opts.no_comment then return end\n         push(current,{ type = \'comment\',\n                             name = \'#comment\',\n                             value = value,\n                             parent = current.name})\n      end,\n      pi = function(name, value, pos)\n         if suspend then return end\n         push(current,{ type =\'pi\',\n                             name = name,\n                             value = value,\n                                 o = pos,\n                             parent = current.name})\n      end\n   }\n   builder:parse(xml, {})\n   return doc\nend\n\n\n\n\n\n\n\n\n\n\nlocal escmap = {[\"<\"]=\"&lt;\", [\">\"]=\"&gt;\", [\"&\"]=\"&amp;\", [\'\"\']=\"&quot;\", [\"\'\"]=\"&apos;\"}\nlocal function esc(s) return s:gsub(\'[<>&\"]\', escmap) end\n\n-- opts.indent: number of spaces, or string\nfunction SLAXML:xml(n,opts)\n   opts = opts or {}\n   local out = {}\n   local tab = opts.indent and (type(opts.indent)==\"number\" and string.rep(\" \",opts.indent) or opts.indent) or \"\"\n   local ser = {}\n   local omit = {}\n   if opts.omit then for _,s in ipairs(opts.omit) do omit[s]=true end end\n\n   function ser.document(n)\n      for _,kid in ipairs(n) do\n         if ser[kid.type] then ser[kid.type](kid,0) end\n      end\n   end\n\n   function ser.pi(n,depth)\n      depth = depth or 0\n      table.insert(out, tab:rep(depth)..\'<?\'..n.name..\' \'..n.value..\'?>\')\n   end\n\n   function ser.element(n,depth)\n      if n.nsURI and omit[n.nsURI] then return end\n      depth = depth or 0\n      local indent = tab:rep(depth)\n      local name = n.nsPrefix and n.nsPrefix..\':\'..n.name or n.name\n      local result = indent..\'<\'..name\n      if n.attr and n.attr[1] then\n         local sorted = n.attr\n         if opts.sort then\n            sorted = {}\n            for i,a in ipairs(n.attr) do sorted[i]=a end\n            table.sort(sorted,function(a,b)\n               if a.nsPrefix and b.nsPrefix then\n                  return a.nsPrefix==b.nsPrefix and a.name<b.name or a.nsPrefix<b.nsPrefix\n               elseif not (a.nsPrefix or b.nsPrefix) then\n                  return a.name<b.name\n               elseif b.nsPrefix then\n                  return true\n               else\n                  return false\n               end\n            end)\n         end\n\n         local attrs = {}\n         for _,a in ipairs(sorted) do\n            if (not a.nsURI or not omit[a.nsURI])\n                and not (omit[a.value]\n                and a.name:find(\'^xmlns:\')) then\n               attrs[#attrs+1] = \' \' .. (a.nsPrefix and (a.nsPrefix..\':\') or \'\')\n                                     .. a.name .. \'=\"\' .. esc(a.value) .. \'\"\'\n            end\n         end\n         result = result..table.concat(attrs,\'\')\n      end\n      result = result .. (n[1] and \'>\' or \'/>\')\n      table.insert(out, result)\n      if n[1] then\n         for _,kid in ipairs(n) do\n            if ser[kid.type] then ser[kid.type](kid,depth+1) end\n         end\n         table.insert(out, indent..\'</\'..name..\'>\')\n      end\n   end\n\n   function ser.text(n,depth)\n      if n.cdata then\n         table.insert(out, tab:rep(depth)..\'<![CDATA[\'..n.value..\']]>\')\n      else\n         table.insert(out, tab:rep(depth)..esc(n.value))\n      end\n   end\n\n   function ser.comment(n,depth)\n      table.insert(out, tab:rep(depth)..\'<!--\'..n.value..\'-->\')\n   end\n\n   ser[n.type](n,0)\n\n   return table.concat(out, opts.indent and \'\\n\' or \'\')\nend\n\nreturn SLAXML\n\n",
vc_hash = "f2dc07a1a9e3ad301e3c0d938504452f3fb5df00\n",
name = "xml",
branch = "trunk",
},
  { 
hash = "b7e484a46e39c1d62bcfb20892c4cc4c2ebff34c597020de6e68e57c2a4b1c3d",
binary = "\n\n\n\n\n\n\n\n\n\n\n--------------------------------------------------------------------------------------------------------------------------\n-- sha2.lua\n--------------------------------------------------------------------------------------------------------------------------\n-- VERSION: 8 (2019-09-03)\n-- AUTHOR:  Egor Skriptunoff\n-- LICENSE: MIT (the same license as Lua itself)\n--\n--\n-- DESCRIPTION:\n--    This module contains functions to calculate SHA digest:\n--       MD5, SHA-1,\n--       SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,\n--       SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,\n--       HMAC\n--    Written in pure Lua.\n--    Compatible with:\n--       Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).\n--    Main feature of this module: it was heavily optimized for speed.\n--    For every Lua version the module contains particular implementation branch to get benefits from version-specific features.\n--       - branch for Lua 5.1 (emulating bitwise operators using look-up table)\n--       - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"\n--       - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)\n--       - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT\n--       - branch for LuaJIT without FFI library (useful in a sandboxed environment)\n--       - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)\n--       - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)\n--       - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n--\n--\n-- USAGE:\n--    Input data should be provided as a binary string: either as a whole string or as a sequence of substrings (chunk-by-chunk loading, total length < 9*10^15 bytes).\n--    Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.\n--    Simplest usage example:\n--       local sha = require(\"sha2\")\n--       local your_hash = sha.sha256(\"your string\")\n--    See file \"sha2_test.lua\" for more examples.\n--\n--\n-- CHANGELOG:\n--  version     date      description\n--  -------  ----------   -----------\n--     8     2019-09-03   SHA3 functions added\n--     7     2019-03-17   Added functions to convert to/from base64\n--     6     2018-11-12   HMAC added\n--     5     2018-11-10   SHA-1 added\n--     4     2018-11-03   MD5 added\n--     3     2018-11-02   Bug fixed: incorrect hashing of long (2 GByte) data streams on Lua 5.3/5.4 built with \"int32\" integers\n--     2     2018-10-07   Decreased module loading time in Lua 5.1 implementation branch (thanks to Peter Melnichenko for giving a hint)\n--     1     2018-10-06   First release (only SHA-2 functions)\n-----------------------------------------------------------------------------\n\nlocal print_debug_messages = false  -- set to true to view some messages about your system\'s abilities and implementation branch chosen for your system\n\nlocal unpack, table_concat, byte, char, string_rep, sub, gsub, gmatch, string_format, floor, ceil, math_min, math_max, tonumber, type =\n   table.unpack or unpack, table.concat, string.byte, string.char, string.rep, string.sub, string.gsub, string.gmatch, string.format, math.floor, math.ceil, math.min, math.max, tonumber, type\n\n\n--------------------------------------------------------------------------------\n-- EXAMINING YOUR SYSTEM\n--------------------------------------------------------------------------------\n\nlocal function get_precision(one)\n   -- \"one\" must be either float 1.0 or integer 1\n   -- returns bits_precision, is_integer\n   -- This function works correctly with all floating point datatypes (including non-IEEE-754)\n   local k, n, m, prev_n = 0, one, one\n   while true do\n      k, prev_n, n, m = k + 1, n, n + n + 1, m + m + k % 2\n      if k > 256 or n - (n - 1) ~= 1 or m - (m - 1) ~= 1 or n == m then\n         return k, false   -- floating point datatype\n      elseif n == prev_n then\n         return k, true    -- integer datatype\n      end\n   end\nend\n\n-- Make sure Lua has \"double\" numbers\nlocal x = 2/3\nlocal Lua_has_double = x * 5 > 3 and x * 4 < 3 and get_precision(1.0) >= 53\nassert(Lua_has_double, \"at least 53-bit floating point numbers are required\")\n\n-- Q:\n--    SHA2 was designed for FPU-less machines.\n--    So, why floating point numbers are needed for this module?\n-- A:\n--    53-bit \"double\" numbers are useful to calculate \"magic numbers\" used in SHA.\n--    I prefer to write 50 LOC \"magic numbers calculator\" instead of storing more than 200 constants explicitly in this source file.\n\nlocal int_prec, Lua_has_integers = get_precision(1)\nlocal Lua_has_int64 = Lua_has_integers and int_prec == 64\nlocal Lua_has_int32 = Lua_has_integers and int_prec == 32\nassert(Lua_has_int64 or Lua_has_int32 or not Lua_has_integers, \"Lua integers must be either 32-bit or 64-bit\")\n\n-- Q:\n--    Does it mean that almost all non-standard configurations are not supported?\n-- A:\n--    Yes.  Sorry, too many problems to support all possible Lua numbers configurations.\n--       Lua 5.1/5.2    with \"int32\"               will not work.\n--       Lua 5.1/5.2    with \"int64\"               will not work.\n--       Lua 5.1/5.2    with \"int128\"              will not work.\n--       Lua 5.1/5.2    with \"float\"               will not work.\n--       Lua 5.1/5.2    with \"double\"              is OK.          (default config for Lua 5.1, Lua 5.2, LuaJIT)\n--       Lua 5.3/5.4    with \"int32\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int64\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int128\" + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int32\"  + \"double\"   is OK.          (config used by Fengari)\n--       Lua 5.3/5.4    with \"int64\"  + \"double\"   is OK.          (default config for Lua 5.3, Lua 5.4)\n--       Lua 5.3/5.4    with \"int128\" + \"double\"   will not work.\n--   Using floating point numbers better than \"double\" instead of \"double\" is OK (non-IEEE-754 floating point implementation are allowed).\n--   Using \"int128\" instead of \"int64\" is not OK: \"int128\" would require different branch of implementation for optimized SHA512.\n\n-- Check for LuaJIT and 32-bit bitwise libraries\nlocal is_LuaJIT = ({false, [1] = true})[1] and (type(jit) ~= \"table\" or jit.version_num >= 20000)  -- LuaJIT 1.x.x is treated as vanilla Lua 5.1\nlocal is_LuaJIT_21  -- LuaJIT 2.1+\nlocal LuaJIT_arch\nlocal ffi           -- LuaJIT FFI library (as a table)\nlocal b             -- 32-bit bitwise library (as a table)\nlocal library_name\n\nif is_LuaJIT then\n   -- Assuming \"bit\" library is always available on LuaJIT\n   b = require\"bit\"\n   library_name = \"bit\"\n   -- \"ffi\" is intentionally disabled on some systems for safety reason\n   local LuaJIT_has_FFI, result = pcall(require, \"ffi\")\n   if LuaJIT_has_FFI then\n      ffi = result\n   end\n   is_LuaJIT_21 = not not loadstring\"b=0b0\"\n   LuaJIT_arch = type(jit) == \"table\" and jit.arch or ffi and ffi.arch or nil\nelse\n   -- For vanilla Lua, \"bit\"/\"bit32\" libraries are searched in global namespace only.  No attempt is made to load a library if it\'s not loaded yet.\n   for _, libname in ipairs(_VERSION == \"Lua 5.2\" and {\"bit32\", \"bit\"} or {\"bit\", \"bit32\"}) do\n      if type(_G[libname]) == \"table\" and _G[libname].bxor then\n         b = _G[libname]\n         library_name = libname\n         break\n      end\n   end\nend\n\n--------------------------------------------------------------------------------\n-- You can disable here some of your system\'s abilities (for testing purposes)\n--------------------------------------------------------------------------------\n-- is_LuaJIT = nil\n-- is_LuaJIT_21 = nil\n-- ffi = nil\n-- Lua_has_int32 = nil\n-- Lua_has_int64 = nil\n-- b, library_name = nil\n--------------------------------------------------------------------------------\n\nif print_debug_messages then\n   -- Printing list of abilities of your system\n   print(\"Abilities:\")\n   print(\"   Lua version:               \"..(is_LuaJIT and \"LuaJIT \"..(is_LuaJIT_21 and \"2.1 \" or \"2.0 \")..(LuaJIT_arch or \"\")..(ffi and \" with FFI\" or \" without FFI\") or _VERSION))\n   print(\"   Integer bitwise operators: \"..(Lua_has_int64 and \"int64\" or Lua_has_int32 and \"int32\" or \"no\"))\n   print(\"   32-bit bitwise library:    \"..(library_name or \"not found\"))\nend\n\n-- Selecting the most suitable implementation for given set of abilities\nlocal method, branch\nif is_LuaJIT and ffi then\n   method = \"Using \'ffi\' library of LuaJIT\"\n   branch = \"FFI\"\nelseif is_LuaJIT then\n   method = \"Using special code for FFI-less LuaJIT\"\n   branch = \"LJ\"\nelseif Lua_has_int64 then\n   method = \"Using native int64 bitwise operators\"\n   branch = \"INT64\"\nelseif Lua_has_int32 then\n   method = \"Using native int32 bitwise operators\"\n   branch = \"INT32\"\nelseif library_name then   -- when bitwise library is available (Lua 5.2 with native library \"bit32\" or Lua 5.1 with external library \"bit\")\n   method = \"Using \'\"..library_name..\"\' library\"\n   branch = \"LIB32\"\nelse\n   method = \"Emulating bitwise operators using look-up table\"\n   branch = \"EMUL\"\nend\n\nif print_debug_messages then\n   -- Printing the implementation selected to be used on your system\n   print(\"Implementation selected:\")\n   print(\"   \"..method)\nend\n\n\n--------------------------------------------------------------------------------\n-- BASIC 32-BIT BITWISE FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal AND, OR, XOR, SHL, SHR, ROL, ROR, NOT, NORM, HEX, XOR_BYTE\n-- Only low 32 bits of function arguments matter, high bits are ignored\n-- The result of all functions (except HEX) is an integer inside \"correct range\":\n--    for \"bit\" library:    (-2^31)..(2^31-1)\n--    for \"bit32\" library:        0..(2^32-1)\n\nif branch == \"FFI\" or branch == \"LJ\" or branch == \"LIB32\" then\n\n   -- Your system has 32-bit bitwise library (either \"bit\" or \"bit32\")\n\n   AND  = b.band                -- 2 arguments\n   OR   = b.bor                 -- 2 arguments\n   XOR  = b.bxor                -- 2..5 arguments\n   SHL  = b.lshift              -- second argument is integer 0..31\n   SHR  = b.rshift              -- second argument is integer 0..31\n   ROL  = b.rol or b.lrotate    -- second argument is integer 0..31\n   ROR  = b.ror or b.rrotate    -- second argument is integer 0..31\n   NOT  = b.bnot                -- only for LuaJIT\n   NORM = b.tobit               -- only for LuaJIT\n   HEX  = b.tohex               -- returns string of 8 lowercase hexadecimal digits\n   assert(AND and OR and XOR and SHL and SHR and ROL and ROR and NOT, \"Library \'\"..library_name..\"\' is incomplete\")\n   XOR_BYTE = XOR               -- XOR of two bytes (0..255)\n\nelseif branch == \"EMUL\" then\n\n   -- Emulating 32-bit bitwise operations using 53-bit floating point arithmetic\n\n   function SHL(x, n)\n      return (x * 2^n) % 2^32\n   end\n\n   function SHR(x, n)\n      -- return (x % 2^32 - x % 2^n) / 2^n\n      x = x % 2^32 / 2^n\n      return x - x % 1\n   end\n\n   function ROL(x, n)\n      x = x % 2^32 * 2^n\n      local r = x % 2^32\n      return r + (x - r) / 2^32\n   end\n\n   function ROR(x, n)\n      x = x % 2^32 / 2^n\n      local r = x % 1\n      return r * 2^32 + (x - r)\n   end\n\n   local AND_of_two_bytes = {[0] = 0}  -- look-up table (256*256 entries)\n   local idx = 0\n   for y = 0, 127 * 256, 256 do\n      for x = y, y + 127 do\n         x = AND_of_two_bytes[x] * 2\n         AND_of_two_bytes[idx] = x\n         AND_of_two_bytes[idx + 1] = x\n         AND_of_two_bytes[idx + 256] = x\n         AND_of_two_bytes[idx + 257] = x + 1\n         idx = idx + 2\n      end\n      idx = idx + 256\n   end\n\n   local function and_or_xor(x, y, operation)\n      -- operation: nil = AND, 1 = OR, 2 = XOR\n      local x0 = x % 2^32\n      local y0 = y % 2^32\n      local rx = x0 % 256\n      local ry = y0 % 256\n      local res = AND_of_two_bytes[rx + ry * 256]\n      x = x0 - rx\n      y = (y0 - ry) / 256\n      rx = x % 65536\n      ry = y % 256\n      res = res + AND_of_two_bytes[rx + ry] * 256\n      x = (x - rx) / 256\n      y = (y - ry) / 256\n      rx = x % 65536 + y % 256\n      res = res + AND_of_two_bytes[rx] * 65536\n      res = res + AND_of_two_bytes[(x + y - rx) / 256] * 16777216\n      if operation then\n         res = x0 + y0 - operation * res\n      end\n      return res\n   end\n\n   function AND(x, y)\n      return and_or_xor(x, y)\n   end\n\n   function OR(x, y)\n      return and_or_xor(x, y, 1)\n   end\n\n   function XOR(x, y, z, t, u)          -- 2..5 arguments\n      if z then\n         if t then\n            if u then\n               t = and_or_xor(t, u, 2)\n            end\n            z = and_or_xor(z, t, 2)\n         end\n         y = and_or_xor(y, z, 2)\n      end\n      return and_or_xor(x, y, 2)\n   end\n\n   function XOR_BYTE(x, y)\n      return x + y - 2 * AND_of_two_bytes[x + y * 256]\n   end\n\nend\n\nHEX = HEX or\n   function (x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x % 4294967296)\n   end\n\nlocal function XOR32A5(x)\n   return XOR(x, 0xA5A5A5A5) % 4294967296\nend\n\nlocal function create_array_of_lanes()\n   return {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\n\n--------------------------------------------------------------------------------\n-- CREATING OPTIMIZED INNER LOOP\n--------------------------------------------------------------------------------\n\n-- Inner loop functions\nlocal sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n\n-- Arrays of SHA2 \"magic numbers\" (in \"INT64\" and \"FFI\" branches \"*_lo\" arrays contain 64-bit values)\nlocal sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}\nlocal sha2_H_ext256 = {[224] = {}, [256] = sha2_H_hi}\nlocal sha2_H_ext512_lo, sha2_H_ext512_hi = {[384] = {}, [512] = sha2_H_lo}, {[384] = {}, [512] = sha2_H_hi}\nlocal md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}\nlocal md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}\nlocal HEX64, XOR64A5, lanes_index_base  -- defined only for branches that internally use 64-bit integers: \"INT64\" and \"FFI\"\nlocal common_W = {}    -- temporary table shared between all calculations (to avoid creating new temporary table every time)\nlocal K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0\n\nlocal function build_keccak_format(elem)\n   local keccak_format = {}\n   for _, size in ipairs{1, 9, 13, 17, 18, 21} do\n      keccak_format[size] = \"<\"..string_rep(elem, size)\n   end\n   return keccak_format\nend\n\n\nif branch == \"FFI\" then\n\n\n   -- SHA256 implementation for \"LuaJIT with FFI\" branch\n\n   local common_W_FFI_int32 = ffi.new\"int32_t[80]\"   -- 64 is enough for SHA256, but 80 is needed for SHA-1\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 63 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16] )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 0, 63, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j] + K[j+1] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+1] + K[j+2] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+2] + K[j+3] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+3] + K[j+4] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+4] + K[j+5] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+5] + K[j+6] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+6] + K[j+7] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+7] + K[j+8] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local common_W_FFI_int64 = ffi.new\"int64_t[80]\"\n   local int64 = ffi.typeof\"int64_t\"\n   local int32 = ffi.typeof\"int32_t\"\n   local uint32 = ffi.typeof\"uint32_t\"\n\n   hi_factor = int64(2^32)\n\n   if is_LuaJIT_21 then   -- LuaJIT 2.1 supports bitwise 64-bit operations\n\n      local AND64, OR64, XOR64, NOT64, SHL64, SHR64, ROL64, ROR64  -- introducing synonyms for better code readability\n          = AND,   OR,   XOR,   NOT,   SHL,   SHR,   ROL,   ROR\n      HEX64 = HEX\n\n\n      -- SHA3 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local lanes_arr64 = ffi.typeof\"int64_t[30]\"  -- 25 + 5 for temporary usage\n      -- lanes array is indexed from 0\n      lanes_index_base = 0\n      hi_factor_keccak = int64(2^32)\n\n      function create_array_of_lanes()\n         return lanes_arr64()\n      end\n\n      function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = SHR(block_size_in_bytes, 3)\n         for pos = offs, offs + size - 1, block_size_in_bytes do\n            for j = 0, qwords_qty - 1 do\n               pos = pos + 8\n               local h, g, f, e, d, c, b, a = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               lanes[j] = XOR64(lanes[j], OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))))\n            end\n            for round_idx = 1, 24 do\n               for j = 0, 4 do\n                  lanes[25 + j] = XOR64(lanes[j], lanes[j+5], lanes[j+10], lanes[j+15], lanes[j+20])\n               end\n               local D = XOR64(lanes[25], ROL64(lanes[27], 1))\n               lanes[1], lanes[6], lanes[11], lanes[16] = ROL64(XOR64(D, lanes[6]), 44), ROL64(XOR64(D, lanes[16]), 45), ROL64(XOR64(D, lanes[1]), 1), ROL64(XOR64(D, lanes[11]), 10)\n               lanes[21] = ROL64(XOR64(D, lanes[21]), 2)\n               D = XOR64(lanes[26], ROL64(lanes[28], 1))\n               lanes[2], lanes[7], lanes[12], lanes[22] = ROL64(XOR64(D, lanes[12]), 43), ROL64(XOR64(D, lanes[22]), 61), ROL64(XOR64(D, lanes[7]), 6), ROL64(XOR64(D, lanes[2]), 62)\n               lanes[17] = ROL64(XOR64(D, lanes[17]), 15)\n               D = XOR64(lanes[27], ROL64(lanes[29], 1))\n               lanes[3], lanes[8], lanes[18], lanes[23] = ROL64(XOR64(D, lanes[18]), 21), ROL64(XOR64(D, lanes[3]), 28), ROL64(XOR64(D, lanes[23]), 56), ROL64(XOR64(D, lanes[8]), 55)\n               lanes[13] = ROL64(XOR64(D, lanes[13]), 25)\n               D = XOR64(lanes[28], ROL64(lanes[25], 1))\n               lanes[4], lanes[14], lanes[19], lanes[24] = ROL64(XOR64(D, lanes[24]), 14), ROL64(XOR64(D, lanes[19]), 8), ROL64(XOR64(D, lanes[4]), 27), ROL64(XOR64(D, lanes[14]), 39)\n               lanes[9] = ROL64(XOR64(D, lanes[9]), 20)\n               D = XOR64(lanes[29], ROL64(lanes[26], 1))\n               lanes[5], lanes[10], lanes[15], lanes[20] = ROL64(XOR64(D, lanes[10]), 3), ROL64(XOR64(D, lanes[20]), 18), ROL64(XOR64(D, lanes[5]), 36), ROL64(XOR64(D, lanes[15]), 41)\n               lanes[0] = XOR64(D, lanes[0])\n               lanes[0], lanes[1], lanes[2], lanes[3], lanes[4] = XOR64(lanes[0], AND64(NOT64(lanes[1]), lanes[2]), RC[round_idx]), XOR64(lanes[1], AND64(NOT64(lanes[2]), lanes[3])), XOR64(lanes[2], AND64(NOT64(lanes[3]), lanes[4])), XOR64(lanes[3], AND64(NOT64(lanes[4]), lanes[0])), XOR64(lanes[4], AND64(NOT64(lanes[0]), lanes[1]))\n               lanes[5], lanes[6], lanes[7], lanes[8], lanes[9] = XOR64(lanes[8], AND64(NOT64(lanes[9]), lanes[5])), XOR64(lanes[9], AND64(NOT64(lanes[5]), lanes[6])), XOR64(lanes[5], AND64(NOT64(lanes[6]), lanes[7])), XOR64(lanes[6], AND64(NOT64(lanes[7]), lanes[8])), XOR64(lanes[7], AND64(NOT64(lanes[8]), lanes[9]))\n               lanes[10], lanes[11], lanes[12], lanes[13], lanes[14] = XOR64(lanes[11], AND64(NOT64(lanes[12]), lanes[13])), XOR64(lanes[12], AND64(NOT64(lanes[13]), lanes[14])), XOR64(lanes[13], AND64(NOT64(lanes[14]), lanes[10])), XOR64(lanes[14], AND64(NOT64(lanes[10]), lanes[11])), XOR64(lanes[10], AND64(NOT64(lanes[11]), lanes[12]))\n               lanes[15], lanes[16], lanes[17], lanes[18], lanes[19] = XOR64(lanes[19], AND64(NOT64(lanes[15]), lanes[16])), XOR64(lanes[15], AND64(NOT64(lanes[16]), lanes[17])), XOR64(lanes[16], AND64(NOT64(lanes[17]), lanes[18])), XOR64(lanes[17], AND64(NOT64(lanes[18]), lanes[19])), XOR64(lanes[18], AND64(NOT64(lanes[19]), lanes[15]))\n               lanes[20], lanes[21], lanes[22], lanes[23], lanes[24] = XOR64(lanes[22], AND64(NOT64(lanes[23]), lanes[24])), XOR64(lanes[23], AND64(NOT64(lanes[24]), lanes[20])), XOR64(lanes[24], AND64(NOT64(lanes[20]), lanes[21])), XOR64(lanes[20], AND64(NOT64(lanes[21]), lanes[22])), XOR64(lanes[21], AND64(NOT64(lanes[22]), lanes[23]))\n            end\n         end\n      end\n\n\n      -- SHA512 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local A5_long = 0xA5A5A5A5 * int64(2^32 + 1)  -- It\'s impossible to use constant 0xA5A5A5A5A5A5A5A5LL because it will raise syntax error on other Lua versions\n\n      function XOR64A5(long)\n         return XOR64(long, A5_long)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h))))\n            end\n            for j = 16, 79 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7)) + XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6)) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   else  -- LuaJIT 2.0 doesn\'t support 64-bit bitwise operations\n\n\n      -- SHA512 implementation for \"LuaJIT 2.0 + FFI\" branch\n\n      local union64 = ffi.typeof\"union{int64_t i64; struct{int32_t lo, hi;} i32;}\"\n      do  -- make sure the struct is endianness-compatible\n         local u = union64(1)\n         if u.i32.lo < u.i32.hi then\n            union64 = ffi.typeof\"union{int64_t i64; struct{int32_t hi, lo;} i32;}\"\n         end\n      end\n      local unions64 = ffi.typeof(\"$[?]\", union64)\n      local U = unions64(3)   -- this array of unions is used for fast splitting int64 into int32_high and int32_low\n\n      -- \"xorrific\" 64-bit functions :-)\n      -- int64 input is splitted into two int32 parts, some bitwise 32-bit operations are performed, finally the result is converted to int64\n      -- these functions are needed because bit.* functions in LuaJIT 2.0 don\'t work with int64_t\n\n      local function XORROR64_1(a)\n         -- return XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7))\n         U[0].i64 = a\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n         local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n         return t_hi * int64(2^32) + uint32(int32(t_lo))\n      end\n\n      local function XORROR64_2(b)\n         -- return XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6))\n         U[0].i64 = b\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n         local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_3(e)\n         -- return XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23))\n         U[0].i64 = e\n         local e_lo, e_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n         local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_6(a)\n         -- return XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30))\n         U[0].i64 = a\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n         local u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_4(e, f, g)\n         -- return XOR64(g, AND64(e, XOR64(f, g)))\n         U[0].i64 = f\n         U[1].i64 = g\n         U[2].i64 = e\n         local f_lo, f_hi = U[0].i32.lo, U[0].i32.hi\n         local g_lo, g_hi = U[1].i32.lo, U[1].i32.hi\n         local e_lo, e_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n         local result_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      local function XORROR64_5(a, b, c)\n         -- return XOR64(AND64(XOR64(a, b), c), AND64(a, b))\n         U[0].i64 = a\n         U[1].i64 = b\n         U[2].i64 = c\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local b_lo, b_hi = U[1].i32.lo, U[1].i32.hi\n         local c_lo, c_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(AND(XOR(a_lo, b_lo), c_lo), AND(a_lo, b_lo))\n         local result_hi = XOR(AND(XOR(a_hi, b_hi), c_hi), AND(a_hi, b_hi))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      function XOR64A5(long)\n         -- return XOR64(long, 0xA5A5A5A5A5A5A5A5)\n         U[0].i64 = long\n         local lo32, hi32 = U[0].i32.lo, U[0].i32.hi\n         lo32 = XOR(lo32, 0xA5A5A5A5)\n         hi32 = XOR(hi32, 0xA5A5A5A5)\n         return hi32 * int64(2^32) + uint32(int32(lo32))\n      end\n\n      function HEX64(long)\n         U[0].i64 = long\n         return HEX(U[0].i32.hi)..HEX(U[0].i32.lo)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32) + uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))\n            end\n            for j = 16, 79 do\n               W[j] = XORROR64_1(W[j-15]) + XORROR64_2(W[j-2]) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT with FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 0, 15, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+4] + W[j+3] + a), 22) + b)\n         end\n         for j = 16, 31, 4 do\n            local g = 5*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g + 1, 15)] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 6, 15)] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g - 5, 15)] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+4] + W[AND(g    , 15)] + a), 20) + b)\n         end\n         for j = 32, 47, 4 do\n            local g = 3*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 5, 15)] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 8, 15)] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 5, 15)] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+4] + W[AND(g - 2, 15)] + a), 23) + b)\n         end\n         for j = 48, 63, 4 do\n            local g = 7*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15)] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15)] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15)] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+4] + W[AND(g + 5, 15)] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT with FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W_FFI_int32\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 79 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 0, 19, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 20, 39, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 40, 59, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 60, 79, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\n-- SHA3 implementation for \"LuaJIT 2.0 + FFI\" and \"LuaJIT without FFI\" branches\n\nif branch == \"FFI\" and not is_LuaJIT_21 or branch == \"LJ\" then\n\n   if branch == \"FFI\" then\n      local lanes_arr32 = ffi.typeof\"int32_t[31]\"  -- 25 + 5 + 1 (due to 1-based indexing)\n\n      function create_array_of_lanes()\n         return lanes_arr32()\n      end\n\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = SHR(block_size_in_bytes, 3)\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n         end\n         for round_idx = 1, 24 do\n            for j = 1, 5 do\n               lanes_lo[25 + j] = XOR(lanes_lo[j], lanes_lo[j + 5], lanes_lo[j + 10], lanes_lo[j + 15], lanes_lo[j + 20])\n            end\n            for j = 1, 5 do\n               lanes_hi[25 + j] = XOR(lanes_hi[j], lanes_hi[j + 5], lanes_hi[j + 10], lanes_hi[j + 15], lanes_hi[j + 20])\n            end\n            local D_lo = XOR(lanes_lo[26], SHL(lanes_lo[28], 1), SHR(lanes_hi[28], 31))\n            local D_hi = XOR(lanes_hi[26], SHL(lanes_hi[28], 1), SHR(lanes_lo[28], 31))\n            lanes_lo[2], lanes_hi[2], lanes_lo[7], lanes_hi[7], lanes_lo[12], lanes_hi[12], lanes_lo[17], lanes_hi[17] = XOR(SHR(XOR(D_lo, lanes_lo[7]), 20), SHL(XOR(D_hi, lanes_hi[7]), 12)), XOR(SHR(XOR(D_hi, lanes_hi[7]), 20), SHL(XOR(D_lo, lanes_lo[7]), 12)), XOR(SHR(XOR(D_lo, lanes_lo[17]), 19), SHL(XOR(D_hi, lanes_hi[17]), 13)), XOR(SHR(XOR(D_hi, lanes_hi[17]), 19), SHL(XOR(D_lo, lanes_lo[17]), 13)), XOR(SHL(XOR(D_lo, lanes_lo[2]), 1), SHR(XOR(D_hi, lanes_hi[2]), 31)), XOR(SHL(XOR(D_hi, lanes_hi[2]), 1), SHR(XOR(D_lo, lanes_lo[2]), 31)), XOR(SHL(XOR(D_lo, lanes_lo[12]), 10), SHR(XOR(D_hi, lanes_hi[12]), 22)), XOR(SHL(XOR(D_hi, lanes_hi[12]), 10), SHR(XOR(D_lo, lanes_lo[12]), 22))\n            local L, H = XOR(D_lo, lanes_lo[22]), XOR(D_hi, lanes_hi[22])\n            lanes_lo[22], lanes_hi[22] = XOR(SHL(L, 2), SHR(H, 30)), XOR(SHL(H, 2), SHR(L, 30))\n            D_lo = XOR(lanes_lo[27], SHL(lanes_lo[29], 1), SHR(lanes_hi[29], 31))\n            D_hi = XOR(lanes_hi[27], SHL(lanes_hi[29], 1), SHR(lanes_lo[29], 31))\n            lanes_lo[3], lanes_hi[3], lanes_lo[8], lanes_hi[8], lanes_lo[13], lanes_hi[13], lanes_lo[23], lanes_hi[23] = XOR(SHR(XOR(D_lo, lanes_lo[13]), 21), SHL(XOR(D_hi, lanes_hi[13]), 11)), XOR(SHR(XOR(D_hi, lanes_hi[13]), 21), SHL(XOR(D_lo, lanes_lo[13]), 11)), XOR(SHR(XOR(D_lo, lanes_lo[23]), 3), SHL(XOR(D_hi, lanes_hi[23]), 29)), XOR(SHR(XOR(D_hi, lanes_hi[23]), 3), SHL(XOR(D_lo, lanes_lo[23]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[8]), 6), SHR(XOR(D_hi, lanes_hi[8]), 26)), XOR(SHL(XOR(D_hi, lanes_hi[8]), 6), SHR(XOR(D_lo, lanes_lo[8]), 26)), XOR(SHR(XOR(D_lo, lanes_lo[3]), 2), SHL(XOR(D_hi, lanes_hi[3]), 30)), XOR(SHR(XOR(D_hi, lanes_hi[3]), 2), SHL(XOR(D_lo, lanes_lo[3]), 30))\n            L, H = XOR(D_lo, lanes_lo[18]), XOR(D_hi, lanes_hi[18])\n            lanes_lo[18], lanes_hi[18] = XOR(SHL(L, 15), SHR(H, 17)), XOR(SHL(H, 15), SHR(L, 17))\n            D_lo = XOR(lanes_lo[28], SHL(lanes_lo[30], 1), SHR(lanes_hi[30], 31))\n            D_hi = XOR(lanes_hi[28], SHL(lanes_hi[30], 1), SHR(lanes_lo[30], 31))\n            lanes_lo[4], lanes_hi[4], lanes_lo[9], lanes_hi[9], lanes_lo[19], lanes_hi[19], lanes_lo[24], lanes_hi[24] = XOR(SHL(XOR(D_lo, lanes_lo[19]), 21), SHR(XOR(D_hi, lanes_hi[19]), 11)), XOR(SHL(XOR(D_hi, lanes_hi[19]), 21), SHR(XOR(D_lo, lanes_lo[19]), 11)), XOR(SHL(XOR(D_lo, lanes_lo[4]), 28), SHR(XOR(D_hi, lanes_hi[4]), 4)), XOR(SHL(XOR(D_hi, lanes_hi[4]), 28), SHR(XOR(D_lo, lanes_lo[4]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[24]), 8), SHL(XOR(D_hi, lanes_hi[24]), 24)), XOR(SHR(XOR(D_hi, lanes_hi[24]), 8), SHL(XOR(D_lo, lanes_lo[24]), 24)), XOR(SHR(XOR(D_lo, lanes_lo[9]), 9), SHL(XOR(D_hi, lanes_hi[9]), 23)), XOR(SHR(XOR(D_hi, lanes_hi[9]), 9), SHL(XOR(D_lo, lanes_lo[9]), 23))\n            L, H = XOR(D_lo, lanes_lo[14]), XOR(D_hi, lanes_hi[14])\n            lanes_lo[14], lanes_hi[14] = XOR(SHL(L, 25), SHR(H, 7)), XOR(SHL(H, 25), SHR(L, 7))\n            D_lo = XOR(lanes_lo[29], SHL(lanes_lo[26], 1), SHR(lanes_hi[26], 31))\n            D_hi = XOR(lanes_hi[29], SHL(lanes_hi[26], 1), SHR(lanes_lo[26], 31))\n            lanes_lo[5], lanes_hi[5], lanes_lo[15], lanes_hi[15], lanes_lo[20], lanes_hi[20], lanes_lo[25], lanes_hi[25] = XOR(SHL(XOR(D_lo, lanes_lo[25]), 14), SHR(XOR(D_hi, lanes_hi[25]), 18)), XOR(SHL(XOR(D_hi, lanes_hi[25]), 14), SHR(XOR(D_lo, lanes_lo[25]), 18)), XOR(SHL(XOR(D_lo, lanes_lo[20]), 8), SHR(XOR(D_hi, lanes_hi[20]), 24)), XOR(SHL(XOR(D_hi, lanes_hi[20]), 8), SHR(XOR(D_lo, lanes_lo[20]), 24)), XOR(SHL(XOR(D_lo, lanes_lo[5]), 27), SHR(XOR(D_hi, lanes_hi[5]), 5)), XOR(SHL(XOR(D_hi, lanes_hi[5]), 27), SHR(XOR(D_lo, lanes_lo[5]), 5)), XOR(SHR(XOR(D_lo, lanes_lo[15]), 25), SHL(XOR(D_hi, lanes_hi[15]), 7)), XOR(SHR(XOR(D_hi, lanes_hi[15]), 25), SHL(XOR(D_lo, lanes_lo[15]), 7))\n            L, H = XOR(D_lo, lanes_lo[10]), XOR(D_hi, lanes_hi[10])\n            lanes_lo[10], lanes_hi[10] = XOR(SHL(L, 20), SHR(H, 12)), XOR(SHL(H, 20), SHR(L, 12))\n            D_lo = XOR(lanes_lo[30], SHL(lanes_lo[27], 1), SHR(lanes_hi[27], 31))\n            D_hi = XOR(lanes_hi[30], SHL(lanes_hi[27], 1), SHR(lanes_lo[27], 31))\n            lanes_lo[6], lanes_hi[6], lanes_lo[11], lanes_hi[11], lanes_lo[16], lanes_hi[16], lanes_lo[21], lanes_hi[21] = XOR(SHL(XOR(D_lo, lanes_lo[11]), 3), SHR(XOR(D_hi, lanes_hi[11]), 29)), XOR(SHL(XOR(D_hi, lanes_hi[11]), 3), SHR(XOR(D_lo, lanes_lo[11]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[21]), 18), SHR(XOR(D_hi, lanes_hi[21]), 14)), XOR(SHL(XOR(D_hi, lanes_hi[21]), 18), SHR(XOR(D_lo, lanes_lo[21]), 14)), XOR(SHR(XOR(D_lo, lanes_lo[6]), 28), SHL(XOR(D_hi, lanes_hi[6]), 4)), XOR(SHR(XOR(D_hi, lanes_hi[6]), 28), SHL(XOR(D_lo, lanes_lo[6]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[16]), 23), SHL(XOR(D_hi, lanes_hi[16]), 9)), XOR(SHR(XOR(D_hi, lanes_hi[16]), 23), SHL(XOR(D_lo, lanes_lo[16]), 9))\n            lanes_lo[1], lanes_hi[1] = XOR(D_lo, lanes_lo[1]), XOR(D_hi, lanes_hi[1])\n            lanes_lo[1], lanes_lo[2], lanes_lo[3], lanes_lo[4], lanes_lo[5] = XOR(lanes_lo[1], AND(NOT(lanes_lo[2]), lanes_lo[3]), RC_lo[round_idx]), XOR(lanes_lo[2], AND(NOT(lanes_lo[3]), lanes_lo[4])), XOR(lanes_lo[3], AND(NOT(lanes_lo[4]), lanes_lo[5])), XOR(lanes_lo[4], AND(NOT(lanes_lo[5]), lanes_lo[1])), XOR(lanes_lo[5], AND(NOT(lanes_lo[1]), lanes_lo[2]))\n            lanes_lo[6], lanes_lo[7], lanes_lo[8], lanes_lo[9], lanes_lo[10] = XOR(lanes_lo[9], AND(NOT(lanes_lo[10]), lanes_lo[6])), XOR(lanes_lo[10], AND(NOT(lanes_lo[6]), lanes_lo[7])), XOR(lanes_lo[6], AND(NOT(lanes_lo[7]), lanes_lo[8])), XOR(lanes_lo[7], AND(NOT(lanes_lo[8]), lanes_lo[9])), XOR(lanes_lo[8], AND(NOT(lanes_lo[9]), lanes_lo[10]))\n            lanes_lo[11], lanes_lo[12], lanes_lo[13], lanes_lo[14], lanes_lo[15] = XOR(lanes_lo[12], AND(NOT(lanes_lo[13]), lanes_lo[14])), XOR(lanes_lo[13], AND(NOT(lanes_lo[14]), lanes_lo[15])), XOR(lanes_lo[14], AND(NOT(lanes_lo[15]), lanes_lo[11])), XOR(lanes_lo[15], AND(NOT(lanes_lo[11]), lanes_lo[12])), XOR(lanes_lo[11], AND(NOT(lanes_lo[12]), lanes_lo[13]))\n            lanes_lo[16], lanes_lo[17], lanes_lo[18], lanes_lo[19], lanes_lo[20] = XOR(lanes_lo[20], AND(NOT(lanes_lo[16]), lanes_lo[17])), XOR(lanes_lo[16], AND(NOT(lanes_lo[17]), lanes_lo[18])), XOR(lanes_lo[17], AND(NOT(lanes_lo[18]), lanes_lo[19])), XOR(lanes_lo[18], AND(NOT(lanes_lo[19]), lanes_lo[20])), XOR(lanes_lo[19], AND(NOT(lanes_lo[20]), lanes_lo[16]))\n            lanes_lo[21], lanes_lo[22], lanes_lo[23], lanes_lo[24], lanes_lo[25] = XOR(lanes_lo[23], AND(NOT(lanes_lo[24]), lanes_lo[25])), XOR(lanes_lo[24], AND(NOT(lanes_lo[25]), lanes_lo[21])), XOR(lanes_lo[25], AND(NOT(lanes_lo[21]), lanes_lo[22])), XOR(lanes_lo[21], AND(NOT(lanes_lo[22]), lanes_lo[23])), XOR(lanes_lo[22], AND(NOT(lanes_lo[23]), lanes_lo[24]))\n            lanes_hi[1], lanes_hi[2], lanes_hi[3], lanes_hi[4], lanes_hi[5] = XOR(lanes_hi[1], AND(NOT(lanes_hi[2]), lanes_hi[3]), RC_hi[round_idx]), XOR(lanes_hi[2], AND(NOT(lanes_hi[3]), lanes_hi[4])), XOR(lanes_hi[3], AND(NOT(lanes_hi[4]), lanes_hi[5])), XOR(lanes_hi[4], AND(NOT(lanes_hi[5]), lanes_hi[1])), XOR(lanes_hi[5], AND(NOT(lanes_hi[1]), lanes_hi[2]))\n            lanes_hi[6], lanes_hi[7], lanes_hi[8], lanes_hi[9], lanes_hi[10] = XOR(lanes_hi[9], AND(NOT(lanes_hi[10]), lanes_hi[6])), XOR(lanes_hi[10], AND(NOT(lanes_hi[6]), lanes_hi[7])), XOR(lanes_hi[6], AND(NOT(lanes_hi[7]), lanes_hi[8])), XOR(lanes_hi[7], AND(NOT(lanes_hi[8]), lanes_hi[9])), XOR(lanes_hi[8], AND(NOT(lanes_hi[9]), lanes_hi[10]))\n            lanes_hi[11], lanes_hi[12], lanes_hi[13], lanes_hi[14], lanes_hi[15] = XOR(lanes_hi[12], AND(NOT(lanes_hi[13]), lanes_hi[14])), XOR(lanes_hi[13], AND(NOT(lanes_hi[14]), lanes_hi[15])), XOR(lanes_hi[14], AND(NOT(lanes_hi[15]), lanes_hi[11])), XOR(lanes_hi[15], AND(NOT(lanes_hi[11]), lanes_hi[12])), XOR(lanes_hi[11], AND(NOT(lanes_hi[12]), lanes_hi[13]))\n            lanes_hi[16], lanes_hi[17], lanes_hi[18], lanes_hi[19], lanes_hi[20] = XOR(lanes_hi[20], AND(NOT(lanes_hi[16]), lanes_hi[17])), XOR(lanes_hi[16], AND(NOT(lanes_hi[17]), lanes_hi[18])), XOR(lanes_hi[17], AND(NOT(lanes_hi[18]), lanes_hi[19])), XOR(lanes_hi[18], AND(NOT(lanes_hi[19]), lanes_hi[20])), XOR(lanes_hi[19], AND(NOT(lanes_hi[20]), lanes_hi[16]))\n            lanes_hi[21], lanes_hi[22], lanes_hi[23], lanes_hi[24], lanes_hi[25] = XOR(lanes_hi[23], AND(NOT(lanes_hi[24]), lanes_hi[25])), XOR(lanes_hi[24], AND(NOT(lanes_hi[25]), lanes_hi[21])), XOR(lanes_hi[25], AND(NOT(lanes_hi[21]), lanes_hi[22])), XOR(lanes_hi[21], AND(NOT(lanes_hi[22]), lanes_hi[23])), XOR(lanes_hi[22], AND(NOT(lanes_hi[23]), lanes_hi[24]))\n         end\n      end\n   end\n\nend\n\n\nif branch == \"LJ\" then\n\n\n   -- SHA256 implementation for \"LuaJIT without FFI\" branch\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) ) + NORM( W[j-7] + W[j-16] ) )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 1, 64, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j] + W[j] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+1] + W[j+1] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+2] + W[j+2] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+3] + W[j+3] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+4] + W[j+4] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+5] + W[j+5] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+6] + W[j+6] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+7] + W[j+7] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local function ADD64_4(a_lo, a_hi, b_lo, b_hi, c_lo, c_hi, d_lo, d_hi)\n      local sum_lo = a_lo % 2^32 + b_lo % 2^32 + c_lo % 2^32 + d_lo % 2^32\n      local sum_hi = a_hi + b_hi + c_hi + d_hi\n      local result_lo = NORM( sum_lo )\n      local result_hi = NORM( sum_hi + floor(sum_lo / 2^32) )\n      return result_lo, result_hi\n   end\n\n   if LuaJIT_arch == \"x86\" then  -- Special trick is required to avoid \"PHI shuffling too complex\" on x86 platform\n\n\n      -- SHA512 implementation for \"LuaJIT x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            local zero = 0\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               zero = zero + zero  -- this thick is needed to avoid \"PHI shuffling too complex\" due to PHIs overlap\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = OR(zero, g_lo), OR(zero, g_hi), OR(zero, f_lo), OR(zero, f_hi), OR(zero, e_lo), OR(zero, e_hi)\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = OR(zero, c_lo), OR(zero, c_hi), OR(zero, b_lo), OR(zero, b_hi), OR(zero, a_lo), OR(zero, a_hi)\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + t_lo % 2^32 + u_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + t_hi + u_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   else  -- all platforms except x86\n\n\n      -- SHA512 implementation for \"LuaJIT non-x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = g_lo, g_hi, f_lo, f_hi, e_lo, e_hi\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = c_lo, c_hi, b_lo, b_hi, a_lo, a_hi\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + u_lo % 2^32 + t_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + u_hi + t_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT without FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 1, 16, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j  ] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+3] + a), 22) + b)\n         end\n         for j = 17, 32, 4 do\n            local g = 5*j-4\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j  ] + W[AND(g     , 15) + 1] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g +  5, 15) + 1] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 10, 15) + 1] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g -  1, 15) + 1] + a), 20) + b)\n         end\n         for j = 33, 48, 4 do\n            local g = 3*j+2\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j  ] + W[AND(g    , 15) + 1] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 3, 15) + 1] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 6, 15) + 1] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 7, 15) + 1] + a), 23) + b)\n         end\n         for j = 49, 64, 4 do\n            local g = j*7\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j  ] + W[AND(g - 7, 15) + 1] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15) + 1] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15) + 1] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15) + 1] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT without FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 1, 20, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 21, 40, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 41, 60, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 61, 80, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\nif branch == \"INT64\" then\n\n\n   -- implementation for Lua 5.3/5.4\n\n   hi_factor = 4294967296\n   hi_factor_keccak = 4294967296\n   lanes_index_base = 1\n\n   HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo = ...\n      local string_format, string_unpack = string.format, string.unpack\n\n      local function HEX64(x)\n         return string_format(\"%016x\", x)\n      end\n\n      local function XOR64A5(x)\n         return x ~ 0xa5a5a5a5a5a5a5a5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 64 do\n               local a = W[j-15]\n               a = a<<32 | a\n               local b = W[j-2]\n               b = b<<32 | b\n               W[j] = (a>>7 ~ a>>18 ~ a>>35) + (b>>17 ~ b>>19 ~ b>>42) + W[j-7] + W[j-16] & (1<<32)-1\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               e = e<<32 | e & (1<<32)-1\n               local z = (e>>6 ~ e>>11 ~ e>>25) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = a<<32 | a & (1<<32)-1\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a>>13 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W, sha2_K_lo\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-15]\n               local b = W[j-2]\n               W[j] = (a >> 1 ~ a >> 7 ~ a >> 8 ~ a << 56 ~ a << 63) + (b >> 6 ~ b >> 19 ~ b >> 61 ~ b << 3 ~ b << 45) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 80 do\n               local z = (e >> 14 ~ e >> 18 ~ e >> 41 ~ e << 23 ~ e << 46 ~ e << 50) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a >> 28 ~ a >> 34 ~ a >> 39 ~ a << 25 ~ a << 30 ~ a << 36)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = (a<<32 | a) << 1 >> 32\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i8 = build_keccak_format(\"i8\")\n\n      local function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i8[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local qwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes[j] = lanes[j] ~ qwords_from_message[j]\n            end\n            local L01, L02, L03, L04, L05, L06, L07, L08, L09, L10, L11, L12, L13, L14, L15, L16, L17, L18, L19, L20, L21, L22, L23, L24, L25 =\n               lanes[1], lanes[2], lanes[3], lanes[4], lanes[5], lanes[6], lanes[7], lanes[8], lanes[9], lanes[10], lanes[11], lanes[12], lanes[13],\n               lanes[14], lanes[15], lanes[16], lanes[17], lanes[18], lanes[19], lanes[20], lanes[21], lanes[22], lanes[23], lanes[24], lanes[25]\n            for round_idx = 1, 24 do\n               local C1 = L01 ~ L06 ~ L11 ~ L16 ~ L21\n               local C2 = L02 ~ L07 ~ L12 ~ L17 ~ L22\n               local C3 = L03 ~ L08 ~ L13 ~ L18 ~ L23\n               local C4 = L04 ~ L09 ~ L14 ~ L19 ~ L24\n               local C5 = L05 ~ L10 ~ L15 ~ L20 ~ L25\n               local D = C1 ~ C3<<1 ~ C3>>63\n               local T0 = D ~ L02\n               local T1 = D ~ L07\n               local T2 = D ~ L12\n               local T3 = D ~ L17\n               local T4 = D ~ L22\n               L02 = T1<<44 ~ T1>>20\n               L07 = T3<<45 ~ T3>>19\n               L12 = T0<<1 ~ T0>>63\n               L17 = T2<<10 ~ T2>>54\n               L22 = T4<<2 ~ T4>>62\n               D = C2 ~ C4<<1 ~ C4>>63\n               T0 = D ~ L03\n               T1 = D ~ L08\n               T2 = D ~ L13\n               T3 = D ~ L18\n               T4 = D ~ L23\n               L03 = T2<<43 ~ T2>>21\n               L08 = T4<<61 ~ T4>>3\n               L13 = T1<<6 ~ T1>>58\n               L18 = T3<<15 ~ T3>>49\n               L23 = T0<<62 ~ T0>>2\n               D = C3 ~ C5<<1 ~ C5>>63\n               T0 = D ~ L04\n               T1 = D ~ L09\n               T2 = D ~ L14\n               T3 = D ~ L19\n               T4 = D ~ L24\n               L04 = T3<<21 ~ T3>>43\n               L09 = T0<<28 ~ T0>>36\n               L14 = T2<<25 ~ T2>>39\n               L19 = T4<<56 ~ T4>>8\n               L24 = T1<<55 ~ T1>>9\n               D = C4 ~ C1<<1 ~ C1>>63\n               T0 = D ~ L05\n               T1 = D ~ L10\n               T2 = D ~ L15\n               T3 = D ~ L20\n               T4 = D ~ L25\n               L05 = T4<<14 ~ T4>>50\n               L10 = T1<<20 ~ T1>>44\n               L15 = T3<<8 ~ T3>>56\n               L20 = T0<<27 ~ T0>>37\n               L25 = T2<<39 ~ T2>>25\n               D = C5 ~ C2<<1 ~ C2>>63\n               T1 = D ~ L06\n               T2 = D ~ L11\n               T3 = D ~ L16\n               T4 = D ~ L21\n               L06 = T2<<3 ~ T2>>61\n               L11 = T4<<18 ~ T4>>46\n               L16 = T1<<36 ~ T1>>28\n               L21 = T3<<41 ~ T3>>23\n               L01 = D ~ L01\n               L01, L02, L03, L04, L05 = L01 ~ ~L02 & L03, L02 ~ ~L03 & L04, L03 ~ ~L04 & L05, L04 ~ ~L05 & L01, L05 ~ ~L01 & L02\n               L06, L07, L08, L09, L10 = L09 ~ ~L10 & L06, L10 ~ ~L06 & L07, L06 ~ ~L07 & L08, L07 ~ ~L08 & L09, L08 ~ ~L09 & L10\n               L11, L12, L13, L14, L15 = L12 ~ ~L13 & L14, L13 ~ ~L14 & L15, L14 ~ ~L15 & L11, L15 ~ ~L11 & L12, L11 ~ ~L12 & L13\n               L16, L17, L18, L19, L20 = L20 ~ ~L16 & L17, L16 ~ ~L17 & L18, L17 ~ ~L18 & L19, L18 ~ ~L19 & L20, L19 ~ ~L20 & L16\n               L21, L22, L23, L24, L25 = L23 ~ ~L24 & L25, L24 ~ ~L25 & L21, L25 ~ ~L21 & L22, L21 ~ ~L22 & L23, L22 ~ ~L23 & L24\n               L01 = L01 ~ RC[round_idx]\n            end\n            lanes[1]  = L01\n            lanes[2]  = L02\n            lanes[3]  = L03\n            lanes[4]  = L04\n            lanes[5]  = L05\n            lanes[6]  = L06\n            lanes[7]  = L07\n            lanes[8]  = L08\n            lanes[9]  = L09\n            lanes[10] = L10\n            lanes[11] = L11\n            lanes[12] = L12\n            lanes[13] = L13\n            lanes[14] = L14\n            lanes[15] = L15\n            lanes[16] = L16\n            lanes[17] = L17\n            lanes[18] = L18\n            lanes[19] = L19\n            lanes[20] = L20\n            lanes[21] = L21\n            lanes[22] = L22\n            lanes[23] = L23\n            lanes[24] = L24\n            lanes[25] = L25\n         end\n      end\n\n      return HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo)\n\nend\n\n\nif branch == \"INT32\" then\n\n\n   -- implementation for Lua 5.3/5.4 having non-standard numbers config \"int32\"+\"double\" (built with LUA_INT_TYPE=LUA_INT_INT)\n\n   K_lo_modulo = 2^32\n\n   function HEX(x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x)\n   end\n\n   XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi = ...\n      local string_unpack, floor = string.unpack, math.floor\n\n      local function XOR32A5(x)\n         return x ~ 0xA5A5A5A5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 64 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = (a>>7 ~ a<<25 ~ a<<14 ~ a>>18 ~ a>>3) + (b<<15 ~ b>>17 ~ b<<13 ~ b>>19 ~ b>>10) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               local z = (e>>6 ~ e<<26 ~ e>>11 ~ e<<21 ~ e>>25 ~ e<<7) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a<<30 ~ a>>13 ~ a<<19 ~ a<<10 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local floor, W, K_lo, K_hi = floor, common_W, sha2_K_lo, sha2_K_hi\n         local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n         local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16],\n               W[17], W[18], W[19], W[20], W[21], W[22], W[23], W[24], W[25], W[26], W[27], W[28], W[29], W[30], W[31], W[32] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n               local tmp =\n                  (a_lo>>1 ~ a_hi<<31 ~ a_lo>>8 ~ a_hi<<24 ~ a_lo>>7 ~ a_hi<<25) % 2^32\n                  + (b_lo>>19 ~ b_hi<<13 ~ b_lo<<3 ~ b_hi>>29 ~ b_lo>>6 ~ b_hi<<26) % 2^32\n                  + W[jj-14] % 2^32 + W[jj-32] % 2^32\n               W[jj-1] =\n                  (a_hi>>1 ~ a_lo<<31 ~ a_hi>>8 ~ a_lo<<24 ~ a_hi>>7)\n                  + (b_hi>>19 ~ b_lo<<13 ~ b_hi<<3 ~ b_lo>>29 ~ b_hi>>6)\n                  + W[jj-15] + W[jj-33] + floor(tmp / 2^32)\n               W[jj] = 0|((tmp + 2^31) % 2^32 - 2^31)\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n            for j = 1, 80 do\n               local jj = 2*j\n               local z_lo = (e_lo>>14 ~ e_hi<<18 ~ e_lo>>18 ~ e_hi<<14 ~ e_lo<<23 ~ e_hi>>9) % 2^32 + (g_lo ~ e_lo & (f_lo ~ g_lo)) % 2^32 + h_lo % 2^32 + K_lo[j] + W[jj] % 2^32\n               local z_hi = (e_hi>>14 ~ e_lo<<18 ~ e_hi>>18 ~ e_lo<<14 ~ e_hi<<23 ~ e_lo>>9) + (g_hi ~ e_hi & (f_hi ~ g_hi)) + h_hi + K_hi[j] + W[jj-1] + floor(z_lo / 2^32)\n               z_lo = z_lo % 2^32\n               h_lo = g_lo\n               h_hi = g_hi\n               g_lo = f_lo\n               g_hi = f_hi\n               f_lo = e_lo\n               f_hi = e_hi\n               e_lo = z_lo + d_lo % 2^32\n               e_hi = z_hi + d_hi + floor(e_lo / 2^32)\n               e_lo = 0|((e_lo + 2^31) % 2^32 - 2^31)\n               d_lo = c_lo\n               d_hi = c_hi\n               c_lo = b_lo\n               c_hi = b_hi\n               b_lo = a_lo\n               b_hi = a_hi\n               z_lo = z_lo + (d_lo & c_lo ~ b_lo & (d_lo ~ c_lo)) % 2^32 + (b_lo>>28 ~ b_hi<<4 ~ b_lo<<30 ~ b_hi>>2 ~ b_lo<<25 ~ b_hi>>7) % 2^32\n               a_hi = z_hi + (d_hi & c_hi ~ b_hi & (d_hi ~ c_hi)) + (b_hi>>28 ~ b_lo<<4 ~ b_hi<<30 ~ b_lo>>2 ~ b_hi<<25 ~ b_lo>>7) + floor(z_lo / 2^32)\n               a_lo = 0|((z_lo + 2^31) % 2^32 - 2^31)\n            end\n            a_lo = h1_lo % 2^32 + a_lo % 2^32\n            h1_hi = h1_hi + a_hi + floor(a_lo / 2^32)\n            h1_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h2_lo % 2^32 + b_lo % 2^32\n            h2_hi = h2_hi + b_hi + floor(a_lo / 2^32)\n            h2_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h3_lo % 2^32 + c_lo % 2^32\n            h3_hi = h3_hi + c_hi + floor(a_lo / 2^32)\n            h3_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h4_lo % 2^32 + d_lo % 2^32\n            h4_hi = h4_hi + d_hi + floor(a_lo / 2^32)\n            h4_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h5_lo % 2^32 + e_lo % 2^32\n            h5_hi = h5_hi + e_hi + floor(a_lo / 2^32)\n            h5_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h6_lo % 2^32 + f_lo % 2^32\n            h6_hi = h6_hi + f_hi + floor(a_lo / 2^32)\n            h6_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h7_lo % 2^32 + g_lo % 2^32\n            h7_hi = h7_hi + g_hi + floor(a_lo / 2^32)\n            h7_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h8_lo % 2^32 + h_lo % 2^32\n            h8_hi = h8_hi + h_hi + floor(a_lo / 2^32)\n            h8_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n         end\n         H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = a << 1 ~ a >> 31\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = (a << 5 ~ a >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = (a << 5 ~ a >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i4i4 = build_keccak_format(\"i4i4\")\n\n      local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i4i4[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local dwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes_lo[j] = lanes_lo[j] ~ dwords_from_message[2*j-1]\n               lanes_hi[j] = lanes_hi[j] ~ dwords_from_message[2*j]\n            end\n            local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n               L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n               L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n               lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n               lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n               lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n               lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n               lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n            for round_idx = 1, 24 do\n               local C1_lo = L01_lo ~ L06_lo ~ L11_lo ~ L16_lo ~ L21_lo\n               local C1_hi = L01_hi ~ L06_hi ~ L11_hi ~ L16_hi ~ L21_hi\n               local C2_lo = L02_lo ~ L07_lo ~ L12_lo ~ L17_lo ~ L22_lo\n               local C2_hi = L02_hi ~ L07_hi ~ L12_hi ~ L17_hi ~ L22_hi\n               local C3_lo = L03_lo ~ L08_lo ~ L13_lo ~ L18_lo ~ L23_lo\n               local C3_hi = L03_hi ~ L08_hi ~ L13_hi ~ L18_hi ~ L23_hi\n               local C4_lo = L04_lo ~ L09_lo ~ L14_lo ~ L19_lo ~ L24_lo\n               local C4_hi = L04_hi ~ L09_hi ~ L14_hi ~ L19_hi ~ L24_hi\n               local C5_lo = L05_lo ~ L10_lo ~ L15_lo ~ L20_lo ~ L25_lo\n               local C5_hi = L05_hi ~ L10_hi ~ L15_hi ~ L20_hi ~ L25_hi\n               local D_lo = C1_lo ~ C3_lo<<1 ~ C3_hi>>31\n               local D_hi = C1_hi ~ C3_hi<<1 ~ C3_lo>>31\n               local T0_lo = D_lo ~ L02_lo\n               local T0_hi = D_hi ~ L02_hi\n               local T1_lo = D_lo ~ L07_lo\n               local T1_hi = D_hi ~ L07_hi\n               local T2_lo = D_lo ~ L12_lo\n               local T2_hi = D_hi ~ L12_hi\n               local T3_lo = D_lo ~ L17_lo\n               local T3_hi = D_hi ~ L17_hi\n               local T4_lo = D_lo ~ L22_lo\n               local T4_hi = D_hi ~ L22_hi\n               L02_lo = T1_lo>>20 ~ T1_hi<<12\n               L02_hi = T1_hi>>20 ~ T1_lo<<12\n               L07_lo = T3_lo>>19 ~ T3_hi<<13\n               L07_hi = T3_hi>>19 ~ T3_lo<<13\n               L12_lo = T0_lo<<1 ~ T0_hi>>31\n               L12_hi = T0_hi<<1 ~ T0_lo>>31\n               L17_lo = T2_lo<<10 ~ T2_hi>>22\n               L17_hi = T2_hi<<10 ~ T2_lo>>22\n               L22_lo = T4_lo<<2 ~ T4_hi>>30\n               L22_hi = T4_hi<<2 ~ T4_lo>>30\n               D_lo = C2_lo ~ C4_lo<<1 ~ C4_hi>>31\n               D_hi = C2_hi ~ C4_hi<<1 ~ C4_lo>>31\n               T0_lo = D_lo ~ L03_lo\n               T0_hi = D_hi ~ L03_hi\n               T1_lo = D_lo ~ L08_lo\n               T1_hi = D_hi ~ L08_hi\n               T2_lo = D_lo ~ L13_lo\n               T2_hi = D_hi ~ L13_hi\n               T3_lo = D_lo ~ L18_lo\n               T3_hi = D_hi ~ L18_hi\n               T4_lo = D_lo ~ L23_lo\n               T4_hi = D_hi ~ L23_hi\n               L03_lo = T2_lo>>21 ~ T2_hi<<11\n               L03_hi = T2_hi>>21 ~ T2_lo<<11\n               L08_lo = T4_lo>>3 ~ T4_hi<<29\n               L08_hi = T4_hi>>3 ~ T4_lo<<29\n               L13_lo = T1_lo<<6 ~ T1_hi>>26\n               L13_hi = T1_hi<<6 ~ T1_lo>>26\n               L18_lo = T3_lo<<15 ~ T3_hi>>17\n               L18_hi = T3_hi<<15 ~ T3_lo>>17\n               L23_lo = T0_lo>>2 ~ T0_hi<<30\n               L23_hi = T0_hi>>2 ~ T0_lo<<30\n               D_lo = C3_lo ~ C5_lo<<1 ~ C5_hi>>31\n               D_hi = C3_hi ~ C5_hi<<1 ~ C5_lo>>31\n               T0_lo = D_lo ~ L04_lo\n               T0_hi = D_hi ~ L04_hi\n               T1_lo = D_lo ~ L09_lo\n               T1_hi = D_hi ~ L09_hi\n               T2_lo = D_lo ~ L14_lo\n               T2_hi = D_hi ~ L14_hi\n               T3_lo = D_lo ~ L19_lo\n               T3_hi = D_hi ~ L19_hi\n               T4_lo = D_lo ~ L24_lo\n               T4_hi = D_hi ~ L24_hi\n               L04_lo = T3_lo<<21 ~ T3_hi>>11\n               L04_hi = T3_hi<<21 ~ T3_lo>>11\n               L09_lo = T0_lo<<28 ~ T0_hi>>4\n               L09_hi = T0_hi<<28 ~ T0_lo>>4\n               L14_lo = T2_lo<<25 ~ T2_hi>>7\n               L14_hi = T2_hi<<25 ~ T2_lo>>7\n               L19_lo = T4_lo>>8 ~ T4_hi<<24\n               L19_hi = T4_hi>>8 ~ T4_lo<<24\n               L24_lo = T1_lo>>9 ~ T1_hi<<23\n               L24_hi = T1_hi>>9 ~ T1_lo<<23\n               D_lo = C4_lo ~ C1_lo<<1 ~ C1_hi>>31\n               D_hi = C4_hi ~ C1_hi<<1 ~ C1_lo>>31\n               T0_lo = D_lo ~ L05_lo\n               T0_hi = D_hi ~ L05_hi\n               T1_lo = D_lo ~ L10_lo\n               T1_hi = D_hi ~ L10_hi\n               T2_lo = D_lo ~ L15_lo\n               T2_hi = D_hi ~ L15_hi\n               T3_lo = D_lo ~ L20_lo\n               T3_hi = D_hi ~ L20_hi\n               T4_lo = D_lo ~ L25_lo\n               T4_hi = D_hi ~ L25_hi\n               L05_lo = T4_lo<<14 ~ T4_hi>>18\n               L05_hi = T4_hi<<14 ~ T4_lo>>18\n               L10_lo = T1_lo<<20 ~ T1_hi>>12\n               L10_hi = T1_hi<<20 ~ T1_lo>>12\n               L15_lo = T3_lo<<8 ~ T3_hi>>24\n               L15_hi = T3_hi<<8 ~ T3_lo>>24\n               L20_lo = T0_lo<<27 ~ T0_hi>>5\n               L20_hi = T0_hi<<27 ~ T0_lo>>5\n               L25_lo = T2_lo>>25 ~ T2_hi<<7\n               L25_hi = T2_hi>>25 ~ T2_lo<<7\n               D_lo = C5_lo ~ C2_lo<<1 ~ C2_hi>>31\n               D_hi = C5_hi ~ C2_hi<<1 ~ C2_lo>>31\n               T1_lo = D_lo ~ L06_lo\n               T1_hi = D_hi ~ L06_hi\n               T2_lo = D_lo ~ L11_lo\n               T2_hi = D_hi ~ L11_hi\n               T3_lo = D_lo ~ L16_lo\n               T3_hi = D_hi ~ L16_hi\n               T4_lo = D_lo ~ L21_lo\n               T4_hi = D_hi ~ L21_hi\n               L06_lo = T2_lo<<3 ~ T2_hi>>29\n               L06_hi = T2_hi<<3 ~ T2_lo>>29\n               L11_lo = T4_lo<<18 ~ T4_hi>>14\n               L11_hi = T4_hi<<18 ~ T4_lo>>14\n               L16_lo = T1_lo>>28 ~ T1_hi<<4\n               L16_hi = T1_hi>>28 ~ T1_lo<<4\n               L21_lo = T3_lo>>23 ~ T3_hi<<9\n               L21_hi = T3_hi>>23 ~ T3_lo<<9\n               L01_lo = D_lo ~ L01_lo\n               L01_hi = D_hi ~ L01_hi\n               L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = L01_lo ~ ~L02_lo & L03_lo, L02_lo ~ ~L03_lo & L04_lo, L03_lo ~ ~L04_lo & L05_lo, L04_lo ~ ~L05_lo & L01_lo, L05_lo ~ ~L01_lo & L02_lo\n               L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = L01_hi ~ ~L02_hi & L03_hi, L02_hi ~ ~L03_hi & L04_hi, L03_hi ~ ~L04_hi & L05_hi, L04_hi ~ ~L05_hi & L01_hi, L05_hi ~ ~L01_hi & L02_hi\n               L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = L09_lo ~ ~L10_lo & L06_lo, L10_lo ~ ~L06_lo & L07_lo, L06_lo ~ ~L07_lo & L08_lo, L07_lo ~ ~L08_lo & L09_lo, L08_lo ~ ~L09_lo & L10_lo\n               L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = L09_hi ~ ~L10_hi & L06_hi, L10_hi ~ ~L06_hi & L07_hi, L06_hi ~ ~L07_hi & L08_hi, L07_hi ~ ~L08_hi & L09_hi, L08_hi ~ ~L09_hi & L10_hi\n               L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = L12_lo ~ ~L13_lo & L14_lo, L13_lo ~ ~L14_lo & L15_lo, L14_lo ~ ~L15_lo & L11_lo, L15_lo ~ ~L11_lo & L12_lo, L11_lo ~ ~L12_lo & L13_lo\n               L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = L12_hi ~ ~L13_hi & L14_hi, L13_hi ~ ~L14_hi & L15_hi, L14_hi ~ ~L15_hi & L11_hi, L15_hi ~ ~L11_hi & L12_hi, L11_hi ~ ~L12_hi & L13_hi\n               L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = L20_lo ~ ~L16_lo & L17_lo, L16_lo ~ ~L17_lo & L18_lo, L17_lo ~ ~L18_lo & L19_lo, L18_lo ~ ~L19_lo & L20_lo, L19_lo ~ ~L20_lo & L16_lo\n               L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = L20_hi ~ ~L16_hi & L17_hi, L16_hi ~ ~L17_hi & L18_hi, L17_hi ~ ~L18_hi & L19_hi, L18_hi ~ ~L19_hi & L20_hi, L19_hi ~ ~L20_hi & L16_hi\n               L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = L23_lo ~ ~L24_lo & L25_lo, L24_lo ~ ~L25_lo & L21_lo, L25_lo ~ ~L21_lo & L22_lo, L21_lo ~ ~L22_lo & L23_lo, L22_lo ~ ~L23_lo & L24_lo\n               L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = L23_hi ~ ~L24_hi & L25_hi, L24_hi ~ ~L25_hi & L21_hi, L25_hi ~ ~L21_hi & L22_hi, L21_hi ~ ~L22_hi & L23_hi, L22_hi ~ ~L23_hi & L24_hi\n               L01_lo = L01_lo ~ RC_lo[round_idx]\n               L01_hi = L01_hi ~ RC_hi[round_idx]\n            end\n            lanes_lo[1]  = L01_lo\n            lanes_hi[1]  = L01_hi\n            lanes_lo[2]  = L02_lo\n            lanes_hi[2]  = L02_hi\n            lanes_lo[3]  = L03_lo\n            lanes_hi[3]  = L03_hi\n            lanes_lo[4]  = L04_lo\n            lanes_hi[4]  = L04_hi\n            lanes_lo[5]  = L05_lo\n            lanes_hi[5]  = L05_hi\n            lanes_lo[6]  = L06_lo\n            lanes_hi[6]  = L06_hi\n            lanes_lo[7]  = L07_lo\n            lanes_hi[7]  = L07_hi\n            lanes_lo[8]  = L08_lo\n            lanes_hi[8]  = L08_hi\n            lanes_lo[9]  = L09_lo\n            lanes_hi[9]  = L09_hi\n            lanes_lo[10] = L10_lo\n            lanes_hi[10] = L10_hi\n            lanes_lo[11] = L11_lo\n            lanes_hi[11] = L11_hi\n            lanes_lo[12] = L12_lo\n            lanes_hi[12] = L12_hi\n            lanes_lo[13] = L13_lo\n            lanes_hi[13] = L13_hi\n            lanes_lo[14] = L14_lo\n            lanes_hi[14] = L14_hi\n            lanes_lo[15] = L15_lo\n            lanes_hi[15] = L15_hi\n            lanes_lo[16] = L16_lo\n            lanes_hi[16] = L16_hi\n            lanes_lo[17] = L17_lo\n            lanes_hi[17] = L17_hi\n            lanes_lo[18] = L18_lo\n            lanes_hi[18] = L18_hi\n            lanes_lo[19] = L19_lo\n            lanes_hi[19] = L19_hi\n            lanes_lo[20] = L20_lo\n            lanes_hi[20] = L20_hi\n            lanes_lo[21] = L21_lo\n            lanes_hi[21] = L21_hi\n            lanes_lo[22] = L22_lo\n            lanes_hi[22] = L22_hi\n            lanes_lo[23] = L23_lo\n            lanes_hi[23] = L23_hi\n            lanes_lo[24] = L24_lo\n            lanes_hi[24] = L24_hi\n            lanes_lo[25] = L25_lo\n            lanes_hi[25] = L25_hi\n         end\n      end\n\n      return XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi)\n\nend\n\n\nif branch == \"LIB32\" or branch == \"EMUL\" then\n\n\n   -- implementation for Lua 5.1/5.2 (with or without bitwise library available)\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16]\n         end\n         local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n         for j = 1, 64 do\n            local z = XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + AND(e, f) + AND(-1-e, g) + h + K[j] + W[j]\n            h = g\n            g = f\n            f = e\n            e = z + d\n            d = c\n            c = b\n            b = a\n            a = z + AND(d, c) + AND(a, XOR(d, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10))\n         end\n         h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296\n         h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n   end\n\n   function sha512_feed_128(H_lo, H_hi, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 128\n      -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n      local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n      local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n      local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n      for pos = offs, offs + size - 1, 128 do\n         for j = 1, 16*2 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for jj = 17*2, 80*2, 2 do\n            local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n            local tmp1 = XOR(SHR(a_lo, 1) + SHL(a_hi, 31), SHR(a_lo, 8) + SHL(a_hi, 24), SHR(a_lo, 7) + SHL(a_hi, 25)) % 4294967296 + XOR(SHR(b_lo, 19) + SHL(b_hi, 13), SHL(b_lo, 3) + SHR(b_hi, 29), SHR(b_lo, 6) + SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]\n            local tmp2 = tmp1 % 4294967296\n            W[jj-1] = XOR(SHR(a_hi, 1) + SHL(a_lo, 31), SHR(a_hi, 8) + SHL(a_lo, 24), SHR(a_hi, 7)) + XOR(SHR(b_hi, 19) + SHL(b_lo, 13), SHL(b_hi, 3) + SHR(b_lo, 29), SHR(b_hi, 6)) + W[jj-15] + W[jj-33] + (tmp1 - tmp2) / 4294967296\n            W[jj] = tmp2\n         end\n         local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n         for j = 1, 80 do\n            local jj = 2*j\n            local tmp1 = XOR(SHR(e_lo, 14) + SHL(e_hi, 18), SHR(e_lo, 18) + SHL(e_hi, 14), SHL(e_lo, 23) + SHR(e_hi, 9)) % 4294967296 + (AND(e_lo, f_lo) + AND(-1-e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]\n            local z_lo = tmp1 % 4294967296\n            local z_hi = XOR(SHR(e_hi, 14) + SHL(e_lo, 18), SHR(e_hi, 18) + SHL(e_lo, 14), SHL(e_hi, 23) + SHR(e_lo, 9)) + AND(e_hi, f_hi) + AND(-1-e_hi, g_hi) + h_hi + K_hi[j] + W[jj-1] + (tmp1 - z_lo) / 4294967296\n            h_lo = g_lo\n            h_hi = g_hi\n            g_lo = f_lo\n            g_hi = f_hi\n            f_lo = e_lo\n            f_hi = e_hi\n            tmp1 = z_lo + d_lo\n            e_lo = tmp1 % 4294967296\n            e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296\n            d_lo = c_lo\n            d_hi = c_hi\n            c_lo = b_lo\n            c_hi = b_hi\n            b_lo = a_lo\n            b_hi = a_hi\n            tmp1 = z_lo + (AND(d_lo, c_lo) + AND(b_lo, XOR(d_lo, c_lo))) % 4294967296 + XOR(SHR(b_lo, 28) + SHL(b_hi, 4), SHL(b_lo, 30) + SHR(b_hi, 2), SHL(b_lo, 25) + SHR(b_hi, 7)) % 4294967296\n            a_lo = tmp1 % 4294967296\n            a_hi = z_hi + (AND(d_hi, c_hi) + AND(b_hi, XOR(d_hi, c_hi))) + XOR(SHR(b_hi, 28) + SHL(b_lo, 4), SHL(b_hi, 30) + SHR(b_lo, 2), SHL(b_hi, 25) + SHR(b_lo, 7)) + (tmp1 - a_lo) / 4294967296\n         end\n         a_lo = h1_lo + a_lo\n         h1_lo = a_lo % 4294967296\n         h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296\n         a_lo = h2_lo + b_lo\n         h2_lo = a_lo % 4294967296\n         h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296\n         a_lo = h3_lo + c_lo\n         h3_lo = a_lo % 4294967296\n         h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296\n         a_lo = h4_lo + d_lo\n         h4_lo = a_lo % 4294967296\n         h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296\n         a_lo = h5_lo + e_lo\n         h5_lo = a_lo % 4294967296\n         h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296\n         a_lo = h6_lo + f_lo\n         h6_lo = a_lo % 4294967296\n         h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296\n         a_lo = h7_lo + g_lo\n         h7_lo = a_lo % 4294967296\n         h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296\n         a_lo = h8_lo + h_lo\n         h8_lo = a_lo % 4294967296\n         h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296\n      end\n      H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n      H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n   end\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n      local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((d * 256 + c) * 256 + b) * 256 + a\n         end\n         local a, b, c, d = h1, h2, h3, h4\n         local s = 32-7\n         for j = 1, 16 do\n            local F = ROR(AND(b, c) + AND(-1-b, d) + a + K[j] + W[j], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-5\n         for j = 17, 32 do\n            local F = ROR(AND(d, b) + AND(-1-d, c) + a + K[j] + W[(5*j-4) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-4\n         for j = 33, 48 do\n            local F = ROR(XOR(XOR(b, c), d) + a + K[j] + W[(3*j+2) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-6\n         for j = 49, 64 do\n            local F = ROR(XOR(c, OR(b, -1-d)) + a + K[j] + W[(j*7-7) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n      end\n      H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n   end\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = h1, h2, h3, h4, h5\n         for j = 1, 20 do\n            local z = ROL(a, 5) + AND(b, c) + AND(-1-b, d) + 0x5A827999 + W[j] + e        -- constant = floor(2^30 * sqrt(2))\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 21, 40 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0x6ED9EBA1 + W[j] + e                    -- 2^30 * sqrt(3)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 41, 60 do\n            local z = ROL(a, 5) + AND(d, c) + AND(b, XOR(d, c)) + 0x8F1BBCDC + W[j] + e   -- 2^30 * sqrt(5)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 61, 80 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0xCA62C1D6 + W[j] + e                    -- 2^30 * sqrt(10)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n         h5 = (e + h5) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- This is an example of a Lua function having 79 local variables :-)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = block_size_in_bytes / 8\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)\n         end\n         local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n            L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n            L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n            lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n            lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n            lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n            lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n            lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n         for round_idx = 1, 24 do\n            local C1_lo = XOR(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)\n            local C1_hi = XOR(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)\n            local C2_lo = XOR(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)\n            local C2_hi = XOR(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)\n            local C3_lo = XOR(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)\n            local C3_hi = XOR(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)\n            local C4_lo = XOR(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)\n            local C4_hi = XOR(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)\n            local C5_lo = XOR(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)\n            local C5_hi = XOR(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)\n            local D_lo = XOR(C1_lo, C3_lo * 2 + (C3_hi % 2^32 - C3_hi % 2^31) / 2^31)\n            local D_hi = XOR(C1_hi, C3_hi * 2 + (C3_lo % 2^32 - C3_lo % 2^31) / 2^31)\n            local T0_lo = XOR(D_lo, L02_lo)\n            local T0_hi = XOR(D_hi, L02_hi)\n            local T1_lo = XOR(D_lo, L07_lo)\n            local T1_hi = XOR(D_hi, L07_hi)\n            local T2_lo = XOR(D_lo, L12_lo)\n            local T2_hi = XOR(D_hi, L12_hi)\n            local T3_lo = XOR(D_lo, L17_lo)\n            local T3_hi = XOR(D_hi, L17_hi)\n            local T4_lo = XOR(D_lo, L22_lo)\n            local T4_hi = XOR(D_hi, L22_hi)\n            L02_lo = (T1_lo % 2^32 - T1_lo % 2^20) / 2^20 + T1_hi * 2^12\n            L02_hi = (T1_hi % 2^32 - T1_hi % 2^20) / 2^20 + T1_lo * 2^12\n            L07_lo = (T3_lo % 2^32 - T3_lo % 2^19) / 2^19 + T3_hi * 2^13\n            L07_hi = (T3_hi % 2^32 - T3_hi % 2^19) / 2^19 + T3_lo * 2^13\n            L12_lo = T0_lo * 2 + (T0_hi % 2^32 - T0_hi % 2^31) / 2^31\n            L12_hi = T0_hi * 2 + (T0_lo % 2^32 - T0_lo % 2^31) / 2^31\n            L17_lo = T2_lo * 2^10 + (T2_hi % 2^32 - T2_hi % 2^22) / 2^22\n            L17_hi = T2_hi * 2^10 + (T2_lo % 2^32 - T2_lo % 2^22) / 2^22\n            L22_lo = T4_lo * 2^2 + (T4_hi % 2^32 - T4_hi % 2^30) / 2^30\n            L22_hi = T4_hi * 2^2 + (T4_lo % 2^32 - T4_lo % 2^30) / 2^30\n            D_lo = XOR(C2_lo, C4_lo * 2 + (C4_hi % 2^32 - C4_hi % 2^31) / 2^31)\n            D_hi = XOR(C2_hi, C4_hi * 2 + (C4_lo % 2^32 - C4_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L03_lo)\n            T0_hi = XOR(D_hi, L03_hi)\n            T1_lo = XOR(D_lo, L08_lo)\n            T1_hi = XOR(D_hi, L08_hi)\n            T2_lo = XOR(D_lo, L13_lo)\n            T2_hi = XOR(D_hi, L13_hi)\n            T3_lo = XOR(D_lo, L18_lo)\n            T3_hi = XOR(D_hi, L18_hi)\n            T4_lo = XOR(D_lo, L23_lo)\n            T4_hi = XOR(D_hi, L23_hi)\n            L03_lo = (T2_lo % 2^32 - T2_lo % 2^21) / 2^21 + T2_hi * 2^11\n            L03_hi = (T2_hi % 2^32 - T2_hi % 2^21) / 2^21 + T2_lo * 2^11\n            L08_lo = (T4_lo % 2^32 - T4_lo % 2^3) / 2^3 + T4_hi * 2^29 % 2^32\n            L08_hi = (T4_hi % 2^32 - T4_hi % 2^3) / 2^3 + T4_lo * 2^29 % 2^32\n            L13_lo = T1_lo * 2^6 + (T1_hi % 2^32 - T1_hi % 2^26) / 2^26\n            L13_hi = T1_hi * 2^6 + (T1_lo % 2^32 - T1_lo % 2^26) / 2^26\n            L18_lo = T3_lo * 2^15 + (T3_hi % 2^32 - T3_hi % 2^17) / 2^17\n            L18_hi = T3_hi * 2^15 + (T3_lo % 2^32 - T3_lo % 2^17) / 2^17\n            L23_lo = (T0_lo % 2^32 - T0_lo % 2^2) / 2^2 + T0_hi * 2^30 % 2^32\n            L23_hi = (T0_hi % 2^32 - T0_hi % 2^2) / 2^2 + T0_lo * 2^30 % 2^32\n            D_lo = XOR(C3_lo, C5_lo * 2 + (C5_hi % 2^32 - C5_hi % 2^31) / 2^31)\n            D_hi = XOR(C3_hi, C5_hi * 2 + (C5_lo % 2^32 - C5_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L04_lo)\n            T0_hi = XOR(D_hi, L04_hi)\n            T1_lo = XOR(D_lo, L09_lo)\n            T1_hi = XOR(D_hi, L09_hi)\n            T2_lo = XOR(D_lo, L14_lo)\n            T2_hi = XOR(D_hi, L14_hi)\n            T3_lo = XOR(D_lo, L19_lo)\n            T3_hi = XOR(D_hi, L19_hi)\n            T4_lo = XOR(D_lo, L24_lo)\n            T4_hi = XOR(D_hi, L24_hi)\n            L04_lo = T3_lo * 2^21 % 2^32 + (T3_hi % 2^32 - T3_hi % 2^11) / 2^11\n            L04_hi = T3_hi * 2^21 % 2^32 + (T3_lo % 2^32 - T3_lo % 2^11) / 2^11\n            L09_lo = T0_lo * 2^28 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^4) / 2^4\n            L09_hi = T0_hi * 2^28 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^4) / 2^4\n            L14_lo = T2_lo * 2^25 % 2^32 + (T2_hi % 2^32 - T2_hi % 2^7) / 2^7\n            L14_hi = T2_hi * 2^25 % 2^32 + (T2_lo % 2^32 - T2_lo % 2^7) / 2^7\n            L19_lo = (T4_lo % 2^32 - T4_lo % 2^8) / 2^8 + T4_hi * 2^24 % 2^32\n            L19_hi = (T4_hi % 2^32 - T4_hi % 2^8) / 2^8 + T4_lo * 2^24 % 2^32\n            L24_lo = (T1_lo % 2^32 - T1_lo % 2^9) / 2^9 + T1_hi * 2^23 % 2^32\n            L24_hi = (T1_hi % 2^32 - T1_hi % 2^9) / 2^9 + T1_lo * 2^23 % 2^32\n            D_lo = XOR(C4_lo, C1_lo * 2 + (C1_hi % 2^32 - C1_hi % 2^31) / 2^31)\n            D_hi = XOR(C4_hi, C1_hi * 2 + (C1_lo % 2^32 - C1_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L05_lo)\n            T0_hi = XOR(D_hi, L05_hi)\n            T1_lo = XOR(D_lo, L10_lo)\n            T1_hi = XOR(D_hi, L10_hi)\n            T2_lo = XOR(D_lo, L15_lo)\n            T2_hi = XOR(D_hi, L15_hi)\n            T3_lo = XOR(D_lo, L20_lo)\n            T3_hi = XOR(D_hi, L20_hi)\n            T4_lo = XOR(D_lo, L25_lo)\n            T4_hi = XOR(D_hi, L25_hi)\n            L05_lo = T4_lo * 2^14 + (T4_hi % 2^32 - T4_hi % 2^18) / 2^18\n            L05_hi = T4_hi * 2^14 + (T4_lo % 2^32 - T4_lo % 2^18) / 2^18\n            L10_lo = T1_lo * 2^20 % 2^32 + (T1_hi % 2^32 - T1_hi % 2^12) / 2^12\n            L10_hi = T1_hi * 2^20 % 2^32 + (T1_lo % 2^32 - T1_lo % 2^12) / 2^12\n            L15_lo = T3_lo * 2^8 + (T3_hi % 2^32 - T3_hi % 2^24) / 2^24\n            L15_hi = T3_hi * 2^8 + (T3_lo % 2^32 - T3_lo % 2^24) / 2^24\n            L20_lo = T0_lo * 2^27 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^5) / 2^5\n            L20_hi = T0_hi * 2^27 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^5) / 2^5\n            L25_lo = (T2_lo % 2^32 - T2_lo % 2^25) / 2^25 + T2_hi * 2^7\n            L25_hi = (T2_hi % 2^32 - T2_hi % 2^25) / 2^25 + T2_lo * 2^7\n            D_lo = XOR(C5_lo, C2_lo * 2 + (C2_hi % 2^32 - C2_hi % 2^31) / 2^31)\n            D_hi = XOR(C5_hi, C2_hi * 2 + (C2_lo % 2^32 - C2_lo % 2^31) / 2^31)\n            T1_lo = XOR(D_lo, L06_lo)\n            T1_hi = XOR(D_hi, L06_hi)\n            T2_lo = XOR(D_lo, L11_lo)\n            T2_hi = XOR(D_hi, L11_hi)\n            T3_lo = XOR(D_lo, L16_lo)\n            T3_hi = XOR(D_hi, L16_hi)\n            T4_lo = XOR(D_lo, L21_lo)\n            T4_hi = XOR(D_hi, L21_hi)\n            L06_lo = T2_lo * 2^3 + (T2_hi % 2^32 - T2_hi % 2^29) / 2^29\n            L06_hi = T2_hi * 2^3 + (T2_lo % 2^32 - T2_lo % 2^29) / 2^29\n            L11_lo = T4_lo * 2^18 + (T4_hi % 2^32 - T4_hi % 2^14) / 2^14\n            L11_hi = T4_hi * 2^18 + (T4_lo % 2^32 - T4_lo % 2^14) / 2^14\n            L16_lo = (T1_lo % 2^32 - T1_lo % 2^28) / 2^28 + T1_hi * 2^4\n            L16_hi = (T1_hi % 2^32 - T1_hi % 2^28) / 2^28 + T1_lo * 2^4\n            L21_lo = (T3_lo % 2^32 - T3_lo % 2^23) / 2^23 + T3_hi * 2^9\n            L21_hi = (T3_hi % 2^32 - T3_hi % 2^23) / 2^23 + T3_lo * 2^9\n            L01_lo = XOR(D_lo, L01_lo)\n            L01_hi = XOR(D_hi, L01_hi)\n            L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = XOR(L01_lo, AND(-1-L02_lo, L03_lo)), XOR(L02_lo, AND(-1-L03_lo, L04_lo)), XOR(L03_lo, AND(-1-L04_lo, L05_lo)), XOR(L04_lo, AND(-1-L05_lo, L01_lo)), XOR(L05_lo, AND(-1-L01_lo, L02_lo))\n            L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = XOR(L01_hi, AND(-1-L02_hi, L03_hi)), XOR(L02_hi, AND(-1-L03_hi, L04_hi)), XOR(L03_hi, AND(-1-L04_hi, L05_hi)), XOR(L04_hi, AND(-1-L05_hi, L01_hi)), XOR(L05_hi, AND(-1-L01_hi, L02_hi))\n            L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = XOR(L09_lo, AND(-1-L10_lo, L06_lo)), XOR(L10_lo, AND(-1-L06_lo, L07_lo)), XOR(L06_lo, AND(-1-L07_lo, L08_lo)), XOR(L07_lo, AND(-1-L08_lo, L09_lo)), XOR(L08_lo, AND(-1-L09_lo, L10_lo))\n            L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = XOR(L09_hi, AND(-1-L10_hi, L06_hi)), XOR(L10_hi, AND(-1-L06_hi, L07_hi)), XOR(L06_hi, AND(-1-L07_hi, L08_hi)), XOR(L07_hi, AND(-1-L08_hi, L09_hi)), XOR(L08_hi, AND(-1-L09_hi, L10_hi))\n            L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = XOR(L12_lo, AND(-1-L13_lo, L14_lo)), XOR(L13_lo, AND(-1-L14_lo, L15_lo)), XOR(L14_lo, AND(-1-L15_lo, L11_lo)), XOR(L15_lo, AND(-1-L11_lo, L12_lo)), XOR(L11_lo, AND(-1-L12_lo, L13_lo))\n            L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = XOR(L12_hi, AND(-1-L13_hi, L14_hi)), XOR(L13_hi, AND(-1-L14_hi, L15_hi)), XOR(L14_hi, AND(-1-L15_hi, L11_hi)), XOR(L15_hi, AND(-1-L11_hi, L12_hi)), XOR(L11_hi, AND(-1-L12_hi, L13_hi))\n            L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = XOR(L20_lo, AND(-1-L16_lo, L17_lo)), XOR(L16_lo, AND(-1-L17_lo, L18_lo)), XOR(L17_lo, AND(-1-L18_lo, L19_lo)), XOR(L18_lo, AND(-1-L19_lo, L20_lo)), XOR(L19_lo, AND(-1-L20_lo, L16_lo))\n            L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = XOR(L20_hi, AND(-1-L16_hi, L17_hi)), XOR(L16_hi, AND(-1-L17_hi, L18_hi)), XOR(L17_hi, AND(-1-L18_hi, L19_hi)), XOR(L18_hi, AND(-1-L19_hi, L20_hi)), XOR(L19_hi, AND(-1-L20_hi, L16_hi))\n            L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = XOR(L23_lo, AND(-1-L24_lo, L25_lo)), XOR(L24_lo, AND(-1-L25_lo, L21_lo)), XOR(L25_lo, AND(-1-L21_lo, L22_lo)), XOR(L21_lo, AND(-1-L22_lo, L23_lo)), XOR(L22_lo, AND(-1-L23_lo, L24_lo))\n            L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = XOR(L23_hi, AND(-1-L24_hi, L25_hi)), XOR(L24_hi, AND(-1-L25_hi, L21_hi)), XOR(L25_hi, AND(-1-L21_hi, L22_hi)), XOR(L21_hi, AND(-1-L22_hi, L23_hi)), XOR(L22_hi, AND(-1-L23_hi, L24_hi))\n            L01_lo = XOR(L01_lo, RC_lo[round_idx])\n            L01_hi = L01_hi + RC_hi[round_idx]      -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR\n         end\n         lanes_lo[1]  = L01_lo\n         lanes_hi[1]  = L01_hi\n         lanes_lo[2]  = L02_lo\n         lanes_hi[2]  = L02_hi\n         lanes_lo[3]  = L03_lo\n         lanes_hi[3]  = L03_hi\n         lanes_lo[4]  = L04_lo\n         lanes_hi[4]  = L04_hi\n         lanes_lo[5]  = L05_lo\n         lanes_hi[5]  = L05_hi\n         lanes_lo[6]  = L06_lo\n         lanes_hi[6]  = L06_hi\n         lanes_lo[7]  = L07_lo\n         lanes_hi[7]  = L07_hi\n         lanes_lo[8]  = L08_lo\n         lanes_hi[8]  = L08_hi\n         lanes_lo[9]  = L09_lo\n         lanes_hi[9]  = L09_hi\n         lanes_lo[10] = L10_lo\n         lanes_hi[10] = L10_hi\n         lanes_lo[11] = L11_lo\n         lanes_hi[11] = L11_hi\n         lanes_lo[12] = L12_lo\n         lanes_hi[12] = L12_hi\n         lanes_lo[13] = L13_lo\n         lanes_hi[13] = L13_hi\n         lanes_lo[14] = L14_lo\n         lanes_hi[14] = L14_hi\n         lanes_lo[15] = L15_lo\n         lanes_hi[15] = L15_hi\n         lanes_lo[16] = L16_lo\n         lanes_hi[16] = L16_hi\n         lanes_lo[17] = L17_lo\n         lanes_hi[17] = L17_hi\n         lanes_lo[18] = L18_lo\n         lanes_hi[18] = L18_hi\n         lanes_lo[19] = L19_lo\n         lanes_hi[19] = L19_hi\n         lanes_lo[20] = L20_lo\n         lanes_hi[20] = L20_hi\n         lanes_lo[21] = L21_lo\n         lanes_hi[21] = L21_hi\n         lanes_lo[22] = L22_lo\n         lanes_hi[22] = L22_hi\n         lanes_lo[23] = L23_lo\n         lanes_hi[23] = L23_hi\n         lanes_lo[24] = L24_lo\n         lanes_hi[24] = L24_hi\n         lanes_lo[25] = L25_lo\n         lanes_hi[25] = L25_hi\n      end\n   end\n\nend\n\n\n--------------------------------------------------------------------------------\n-- MAGIC NUMBERS CALCULATOR\n--------------------------------------------------------------------------------\n-- Q:\n--    Is 53-bit \"double\" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?\n-- A:\n--    Yes, 53-bit \"double\" arithmetic is enough.\n--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton\'s method.\n\ndo\n   local function mul(src1, src2, factor, result_length)\n      -- src1, src2 - long integers (arrays of digits in base 2^24)\n      -- factor - small integer\n      -- returns long integer result (src1 * src2 * factor) and its floating point approximation\n      local result, carry, value, weight = {}, 0.0, 0.0, 1.0\n      for j = 1, result_length do\n         for k = math_max(1, j + 1 - #src2), math_min(j, #src1) do\n            carry = carry + factor * src1[k] * src2[j + 1 - k]  -- \"int32\" is not enough for multiplication result, that\'s why \"factor\" must be of type \"double\"\n         end\n         local digit = carry % 2^24\n         result[j] = floor(digit)\n         carry = (carry - digit) / 2^24\n         value = value + digit * weight\n         weight = weight * 2^24\n      end\n      return result, value\n   end\n\n   local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo\n   repeat\n      p = p + step[p % 6]\n      local d = 1\n      repeat\n         d = d + step[d % 6]\n         if d*d > p then -- next prime number is found\n            local root = p^(1/3)\n            local R = root * 2^40\n            R = mul({R - R % 1}, one, 1.0, 2)\n            local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)\n            local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n            local lo = R[1] % 256 * 16777216 + floor(delta * (2^-56 / 3) * root / p)\n            if idx < 16 then\n               root = p^(1/2)\n               R = root * 2^40\n               R = mul({R - R % 1}, one, 1.0, 2)\n               _, delta = mul(R, R, -1.0, 2)\n               local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n               local lo = R[1] % 256 * 16777216 + floor(delta * 2^-17 / root)\n               local idx = idx % 8 + 1\n               sha2_H_ext256[224][idx] = lo\n               sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor\n               if idx > 7 then\n                  sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]\n               end\n            end\n            idx = idx + 1\n            sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor\n            break\n         end\n      until p % d == 0\n   until idx > 79\nend\n\n-- Calculating IVs for SHA512/224 and SHA512/256\nfor width = 224, 256, 32 do\n   local H_lo, H_hi = {}\n   if XOR64A5 then\n      for j = 1, 8 do\n         H_lo[j] = XOR64A5(sha2_H_lo[j])\n      end\n   else\n      H_hi = {}\n      for j = 1, 8 do\n         H_lo[j] = XOR32A5(sha2_H_lo[j])\n         H_hi[j] = XOR32A5(sha2_H_hi[j])\n      end\n   end\n   sha512_feed_128(H_lo, H_hi, \"SHA-512/\"..tostring(width)..\"\\128\"..string_rep(\"\\0\", 115)..\"\\88\", 0, 128)\n   sha2_H_ext512_lo[width] = H_lo\n   sha2_H_ext512_hi[width] = H_hi\nend\n\n-- Constants for MD5\ndo\n   local sin, abs, modf = math.sin, math.abs, math.modf\n   for idx = 1, 64 do\n      -- we can\'t use formula floor(abs(sin(idx))*2^32) because its result may be beyond integer range on Lua built with 32-bit integers\n      local hi, lo = modf(abs(sin(idx)) * 2^16)\n      md5_K[idx] = hi * 65536 + floor(lo * 2^16)\n   end\nend\n\n-- Constants for SHA3\ndo\n   local sh_reg = 29\n   local function next_bit()\n      local r = sh_reg % 2\n      sh_reg = XOR_BYTE((sh_reg - r) / 2, 142 * r)\n      return r\n   end\n   for idx = 1, 24 do\n      local lo, m = 0\n      for _ = 1, 6 do\n         m = m and m * m * 2 or 1\n         lo = lo + next_bit() * m\n      end\n      local hi = next_bit() * m\n      sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak\n   end\nend\n\n\n--------------------------------------------------------------------------------\n-- MAIN FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal function sha256ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(sha2_H_ext256[width])}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha256_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha256_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process 2^53 bytes of data by using this Lua script :-)\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha256_feed_64(H, final_blocks, 0, #final_blocks)\n            local max_reg = width / 32\n            for j = 1, max_reg do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H, \"\", 1, max_reg)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA256 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha512ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local length, tail, H_lo, H_hi = 0.0, \"\", {unpack(sha2_H_ext512_lo[width])}, not HEX64 and {unpack(sha2_H_ext512_hi[width])}\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 128 then\n               offs = 128 - #tail\n               sha512_feed_128(H_lo, H_hi, tail..sub(message_part, 1, offs), 0, 128)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 128\n            sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-17-length) % 128 + 9)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-17 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move floating point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)\n            local max_reg = ceil(width / 64)\n            if HEX64 then\n               for j = 1, max_reg do\n                  H_lo[j] = HEX64(H_lo[j])\n               end\n            else\n               for j = 1, max_reg do\n                  H_lo[j] = HEX(H_hi[j])..HEX(H_lo[j])\n               end\n               H_hi = nil\n            end\n            H_lo = sub(table_concat(H_lo, \"\", 1, max_reg), 1, width / 4)\n         end\n         return H_lo\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA512 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function md5(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H, 1, 4)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               md5_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            md5_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64)}\n            tail = nil\n            length = length * 8  -- convert \"byte-counter\" to \"bit-counter\"\n            for j = 4, 11 do\n               local low_byte = length % 256\n               final_blocks[j] = char(low_byte)\n               length = (length - low_byte) / 256\n            end\n            final_blocks = table_concat(final_blocks)\n            md5_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 4 do\n               H[j] = HEX(H[j])\n            end\n            H = gsub(table_concat(H), \"(..)(..)(..)(..)\", \"%4%3%2%1\")\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the MD5 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha1(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha1_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha1_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha1_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 5 do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA-1 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)\n   -- \"block_size_in_bytes\" is multiple of 8\n   if type(digest_size_in_bytes) ~= \"number\" then\n      -- arguments in SHAKE are swapped:\n      --    NIST FIPS 202 defines SHAKE(message,num_bits)\n      --    this module   defines SHAKE(num_bytes,message)\n      -- it\'s easy to forget about this swap, hence the check\n      error(\"Argument \'digest_size_in_bytes\' must be a number\", 2)\n   end\n\n   -- Create an instance (private objects for current calculation)\n   local tail, lanes_lo, lanes_hi = \"\", create_array_of_lanes(), hi_factor_keccak == 0 and create_array_of_lanes()\n   local result\n\n--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),\n--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)\n--~     initialize the state S to a string of b 0 bits.\n--~     absorb the input into the state: For each block Pi,\n--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,\n--~         XOR that with S and\n--~         apply the block permutation f to the result, yielding a new state S\n--~     initialize Z to be the empty string\n--~     while the length of Z is less than d:\n--~         append the first r bits of S to Z\n--~         if Z is still less than d bits long, apply f to S, yielding a new state S.\n--~     truncate Z to d bits\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= block_size_in_bytes then\n               offs = block_size_in_bytes - #tail\n               keccak_feed(lanes_lo, lanes_hi, tail..sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % block_size_in_bytes\n            keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            -- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1\n            local gap_start = is_SHAKE and 31 or 6\n            tail = tail..(#tail + 1 == block_size_in_bytes and char(gap_start + 128) or char(gap_start)..string_rep(\"\\0\", (-2 - #tail) % block_size_in_bytes)..\"\\128\")\n            keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)\n            tail = nil\n\n            local lanes_used = 0\n            local total_lanes = floor(block_size_in_bytes / 8)\n            local qwords = {}\n\n            local function get_next_qwords_of_digest(qwords_qty)\n               -- returns not more than \'qwords_qty\' qwords (\'qwords_qty\' might be non-integer)\n               -- doesn\'t go across keccak-buffer boundary\n               -- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords\n               if lanes_used >= total_lanes then\n                  keccak_feed(lanes_lo, lanes_hi, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 0, 8, 8)\n                  lanes_used = 0\n               end\n               qwords_qty = floor(math_min(qwords_qty, total_lanes - lanes_used))\n               if hi_factor_keccak ~= 0 then\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])\n                  end\n               else\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX(lanes_hi[lanes_used + j])..HEX(lanes_lo[lanes_used + j])\n                  end\n               end\n               lanes_used = lanes_used + qwords_qty\n               return\n                  gsub(table_concat(qwords, \"\", 1, qwords_qty), \"(..)(..)(..)(..)(..)(..)(..)(..)\", \"%8%7%6%5%4%3%2%1\"),\n                  qwords_qty * 8\n            end\n\n            local parts = {}      -- digest parts\n            local last_part, last_part_size = \"\", 0\n\n            local function get_next_part_of_digest(bytes_needed)\n               -- returns \'bytes_needed\' bytes, for arbitrary integer \'bytes_needed\'\n               bytes_needed = bytes_needed or 1\n               if bytes_needed <= last_part_size then\n                  last_part_size = last_part_size - bytes_needed\n                  local part_size_in_nibbles = bytes_needed * 2\n                  local result = sub(last_part, 1, part_size_in_nibbles)\n                  last_part = sub(last_part, part_size_in_nibbles + 1)\n                  return result\n               end\n               local parts_qty = 0\n               if last_part_size > 0 then\n                  parts_qty = 1\n                  parts[parts_qty] = last_part\n                  bytes_needed = bytes_needed - last_part_size\n               end\n               -- repeats until the length is enough\n               while bytes_needed >= 8 do\n                  local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = next_part\n                  bytes_needed = bytes_needed - next_part_size\n               end\n               if bytes_needed > 0 then\n                  last_part, last_part_size = get_next_qwords_of_digest(1)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = get_next_part_of_digest(bytes_needed)\n               else\n                  last_part, last_part_size = \"\", 0\n               end\n               return table_concat(parts, \"\", 1, parts_qty)\n            end\n\n            if digest_size_in_bytes < 0 then\n               result = get_next_part_of_digest\n            else\n               result = get_next_part_of_digest(digest_size_in_bytes)\n            end\n\n         end\n         return result\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA3 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal hex2bin, bin2base64, base642bin\ndo\n\n   function hex2bin(hex_string)\n      return (gsub(hex_string, \"%x%x\",\n         function (hh)\n            return char(tonumber(hh, 16))\n         end\n      ))\n   end\n\n   local base64_symbols = {\n      [\'+\'] = 62, [\'-\'] = 62,  [62] = \'+\',\n      [\'/\'] = 63, [\'_\'] = 63,  [63] = \'/\',\n      [\'=\'] = -1, [\'.\'] = -1,  [-1] = \'=\'\n   }\n   local symbol_index = 0\n   for j, pair in ipairs{\'AZ\', \'az\', \'09\'} do\n      for ascii = byte(pair), byte(pair, 2) do\n         local ch = char(ascii)\n         base64_symbols[ch] = symbol_index\n         base64_symbols[symbol_index] = ch\n         symbol_index = symbol_index + 1\n      end\n   end\n\n   function bin2base64(binary_string)\n      local result = {}\n      for pos = 1, #binary_string, 3 do\n         local c1, c2, c3, c4 = byte(sub(binary_string, pos, pos + 2)..\'\\0\', 1, -1)\n         result[#result + 1] =\n            base64_symbols[floor(c1 / 4)]\n            ..base64_symbols[c1 % 4 * 16 + floor(c2 / 16)]\n            ..base64_symbols[c3 and c2 % 16 * 4 + floor(c3 / 64) or -1]\n            ..base64_symbols[c4 and c3 % 64 or -1]\n      end\n      return table_concat(result)\n   end\n\n   function base642bin(base64_string)\n      local result, chars_qty = {}, 3\n      for pos, ch in gmatch(gsub(base64_string, \'%s+\', \'\'), \'()(.)\') do\n         local code = base64_symbols[ch]\n         if code < 0 then\n            chars_qty = chars_qty - 1\n            code = 0\n         end\n         local idx = pos % 4\n         if idx > 0 then\n            result[-idx] = code\n         else\n            local c1 = result[-1] * 4 + floor(result[-2] / 16)\n            local c2 = (result[-2] % 16) * 16 + floor(result[-3] / 4)\n            local c3 = (result[-3] % 4) * 64 + code\n            result[#result + 1] = sub(char(c1, c2, c3), 1, chars_qty)\n         end\n      end\n      return table_concat(result)\n   end\n\nend\n\n\nlocal block_size_for_HMAC  -- this table will be initialized at the end of the module\n\nlocal function pad_and_xor(str, result_length, byte_for_xor)\n   return gsub(str, \".\",\n      function(c)\n         return char(XOR_BYTE(byte(c), byte_for_xor))\n      end\n   )..string_rep(char(byte_for_xor), result_length - #str)\nend\n\nlocal function hmac(hash_func, key, message)\n\n   -- Create an instance (private objects for current calculation)\n   local block_size = block_size_for_HMAC[hash_func]\n   if not block_size then\n      error(\"Unknown hash function\", 2)\n   end\n   if #key > block_size then\n      key = hex2bin(hash_func(key))\n   end\n   local append = hash_func()(pad_and_xor(key, block_size, 0x36))\n   local result\n\n   local function partial(message_part)\n      if not message_part then\n         result = result or hash_func(pad_and_xor(key, block_size, 0x5C)..hex2bin(append()))\n         return result\n      elseif result then\n         error(\"Adding more chunks is not allowed after receiving the result\", 2)\n      else\n         append(message_part)\n         return partial\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the HMAC of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading of a message\n      -- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal sha = {\n   md5        = md5,                                                                                                                   -- MD5\n   sha1       = sha1,                                                                                                                  -- SHA-1\n   -- SHA2 hash functions:\n   sha224     = function (message)                       return sha256ext(224, message)                                           end, -- SHA-224\n   sha256     = function (message)                       return sha256ext(256, message)                                           end, -- SHA-256\n   sha512_224 = function (message)                       return sha512ext(224, message)                                           end, -- SHA-512/224\n   sha512_256 = function (message)                       return sha512ext(256, message)                                           end, -- SHA-512/256\n   sha384     = function (message)                       return sha512ext(384, message)                                           end, -- SHA-384\n   sha512     = function (message)                       return sha512ext(512, message)                                           end, -- SHA-512\n   -- SHA3 hash functions:\n   sha3_224   = function (message)                       return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)             end, -- SHA3-224\n   sha3_256   = function (message)                       return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)             end, -- SHA3-256\n   sha3_384   = function (message)                       return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)             end, -- SHA3-384\n   sha3_512   = function (message)                       return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)             end, -- SHA3-512\n   shake128   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message) end, -- SHAKE128\n   shake256   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message) end, -- SHAKE256\n   -- misc utilities:\n   hmac       = hmac,       -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*\n   hex2bin    = hex2bin,    -- converts hexadecimal representation to binary string\n   base642bin = base642bin, -- converts base64 representation to binary string\n   bin2base64 = bin2base64, -- converts binary string to base64 representation\n}\n\n\nblock_size_for_HMAC = {\n   [sha.md5]        = 64,\n   [sha.sha1]       = 64,\n   [sha.sha224]     = 64,\n   [sha.sha256]     = 64,\n   [sha.sha512_224] = 128,\n   [sha.sha512_256] = 128,\n   [sha.sha384]     = 128,\n   [sha.sha512]     = 128,\n   [sha.sha3_224]   = (1600 - 2 * 224) / 8,\n   [sha.sha3_256]   = (1600 - 2 * 256) / 8,\n   [sha.sha3_384]   = (1600 - 2 * 384) / 8,\n   [sha.sha3_512]   = (1600 - 2 * 512) / 8,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\nlocal function shorthash(str)\n   if #str < 64 then return str end\n   return sub(sha512ext(512, str),1,64)\nend\n\nsha.shorthash = shorthash\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function weirdo_sha_3(str)\n   return sub(sha512ext(512, str),1,64)\nend\n\nsha.hash = weirdo_sha_3\n\n\n\n\nreturn sha\n\n",
vc_hash = "f2dc07a1a9e3ad301e3c0d938504452f3fb5df00\n",
name = "sha",
branch = "trunk",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/valiant.git\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/valiant\n\n",
    website = "",
    name = "valiant",
    home = "",
},
  version = {    special = "no",
    stage = "SNAPSHOT",
    edition = "",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "e0f3da7d20258557616bde52c7f99ccd415781b47be3b236265a0dcde1f81f01",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Bundle = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Bundle.create(stmts, project)\n   return { version = 1,\n            bundle_type = \'session\',\n            project = project }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Bundle.addSession(stmts, bundle, session)\n   local premise_stmt = stmts.get_premises_for_export :bindkv(session)\n   for premise in premise_stmt:rows() do\n       -- get results here\n       local results, n = stmts.get_results\n                             :bind(premise.line_id)\n                             :resultset()\n       if not results then\n          results = {n = 0}\n       else\n         results.n = n\n       end\n       premise.results = results\n       -- don\'t need the line_id any longer\n       premise.line_id = nil\n       session[#session + 1] = premise\n   end\n   -- remove parameters we don\'t want to export\n   session.session_id = nil\n   session.project = nil\n   bundle[#bundle + 1] = session\n   return bundle\nend\n\n\n\n\nreturn Bundle\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "bundle",
branch = "valiant-jr",
},
  { 
hash = "82572618748f92eedbd1fa0e7b5f316f0b8a64769e31e9ef4e45ae0843f874c6",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal uv = require \"luv\"\nlocal table = core.table\n\n\n\n\n\n\n\n\n\nlocal session = require \"helm:helm/helm-db\" . session()\n\n\n\n\nlocal function toDoc(session)\n\nend\n\n\n\nlocal document = {}\n\n\n\nlocal NN, NNN = \"\\n\\n\", \"\\n\\n\\n\"\n\nlocal H = {\n   \"* \",\n   \"** \",\n   \"*** \",\n   \"**** \",\n   -- might not need 5 and 6, or 4?\n}\n\nlocal CB_START = \"#!lua #Premise\\n\"\nlocal CB_DONE = \"#/lua \"\n\nlocal SESH_T = { [0] = \"  #Deprecated\", [1] = \"  #Accepted\" }\n\n\n\n\n\nlocal insert, append, concat = assert(table.insert),\n                               assert(table.append),\n                               assert(table.concat)\n\nlocal format = assert(string.format)\n\nlocal realpath = assert(uv.fs_realpath)\n\nlocal function addPremise(doc, row)\n   local title;\n   if row.title == \"\" then\n      title = \"«\" .. row.line .. \"»\"\n   else\n      title = row.title\n   end\n   append(doc, NNN, H[3], title, NN, CB_START, row.line, \"\\n\")\n   -- more to come here\n   append(doc, CB_DONE, \" #\", row.status, NN)\n   -- results\n   if row.status ~= \'ignore\' then\n      local hashes = {}\n      for hash in session.get_result_hash\n                                :bind(row.line_id)\n                                :rows() do\n         insert(hashes, format(\"%q\", hash.hash))\n      end\n      if #hashes > 0 then\n         insert(doc, \"#results #v 1\")\n         for _, hash in ipairs(hashes) do\n            append(doc, \" #sha3 \", hash)\n         end\n         insert(doc, NN)\n      end\n   end\nend\n\nfunction document.exportAll(dir)\n   dir = dir and realpath(dir) or require \"luv\" . cwd()\n   -- so obvs we put a better name here\n   local doc = {\"* Test Export\", \"\\n\"}\n   local the_sesh = \"\"\n   for row in session.all_session_by_directory :bind(dir) :rows() do\n      row.accepted = tonumber(row.accepted)\n      if row.session_title == the_sesh then\n         -- add another premise\n         addPremise(doc, row)\n      else\n         -- new session\n         append(doc, NNN, H[2], row.session_title, SESH_T[row.accepted])\n         addPremise(doc, row)\n         the_sesh = row.session_title\n      end\n   end\n\n   return concat(doc)\nend\n\n\n\nreturn document\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "document",
branch = "valiant-jr",
},
  { 
hash = "46cf3b04bff691ec410f923c8133688976e816171b9d27f43098d02d65774ef8",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal stmts = assert(require \"helm:helm/helm-db\" . session())\nlocal core  = require \"qor:core\"\nlocal Path = require \"fs:path\"\n\n\n\n\nlocal replkit = {}\n\n\n\n\n\n\n\n\n\n\nfunction replkit.project_path(project)\n   -- get all project directories\n   local project_info, n = stmts.get_project_info()\n   -- iterate until we find the directory matching the basename\n   for i = 1, n do\n       local project_path = Path(project_info.directory[i])\n       if project_path:basename() == project then\n          return project_path\n       end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal match, P = L.match, L.P\n\nlocal err_head = (-P \" \" * P(1))^1 * P(\" \")^1\n\nfunction replkit.errline(fn, ...)\n   local ok, err = xpcall(fn, debug.traceback, ...)\n   if ok then -- not ok!\n      return not ok\n   end\n   local last = match(err_head, err)\n   local rest = err:sub(last, err:find(\"\\n\") - 1)\n   return rest\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction replkit.POD(tab)\n   if type(tab) ~= tab then\n      return nil, tab, \"POD is for tables!\"\n   end\n   -- #RestOfTheOwl\nend\n\n\n\n\n\n\n\n\nlocal clone = assert(core.table.cloneinstance)\nfunction replkit.bare(val)\n   if type(val) == \'string\' then\n      return setmetatable({},{ __repr = function() return val end})\n   elseif type(val) == \'table\' then\n      return setmetatable(clone(val), nil)\n   else\n      return nil, val\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ITER_MAX = 50000\n\nfunction replkit.num_iters(iter, state, start)\n   local count, done, drain = 0, false, start\n   while (not done) and count < ITER_MAX do\n      drain = iter(state, drain)\n      if drain ~= nil then\n         count = count + 1\n      else\n         done = true\n      end\n   end\n   if count >= ITER_MAX then\n      error (\"num_iters cannot count past 50k!\"\n             .. \" very long iterator or infinite loop\")\n   end\n   return count\nend\n\n\n\n\n\n\nfunction replkit.is(a)\n   return not not a\nend\nfunction replkit.isnt(a)\n   return not a\nend\nfunction replkit.are(...)\n   local be = true\n   for i = 1, select(\'#\', ...) do\n      be = select(i, ...) and be\n   end\n   return be\nend\n\n\n\n\n\n\n\n\nfunction replkit.G(replkit)\n   local _G = getfenv(1)\n   for k,v in pairs(replkit) do\n      rawset(_G, k, v)\n   end\nend\n\n\n\nreturn replkit\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "replkit",
branch = "valiant-jr",
},
  { 
hash = "d0235af8de2cf8444c5f188b10a14451a36430043fc137b4c35b47ab6d2d4424",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal require = assert(require)\nlocal tostring = assert(tostring)\nlocal loadstring = assert(loadstring)\nlocal s = require \"status:status\" ()\ns.verbose = true\n\n\n\n\n\n\nlocal uv       = require \"luv\"\nlocal lua_read = require \"lun:lua-parser\"\nlocal names    = require \"repr:repr/names\"\n\nlocal core = require \"qor:core\" -- #Todo more qor to remove\nlocal string = assert(core.string)\n\nlocal meta = assert(core.cluster.Meta)\nlocal weak = assert(core.meta.weak)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Valeta = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal loadNames = assert(names.loadNames)\n\nlocal function make__newindex(anti_G)\n   return function (eval_ENV, key, value)\n      rawset(eval_ENV, key, value)\n      -- Use loadNames() to get the key added to all_symbols\n      loadNames({ [key] = value }, nil, anti_G)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal μreader = meta {}\n\nμreader.name = \'Lua\'\n\nμreader.label = \'Lua Reader\'\n\nlocal sub = assert(string.sub)\n\nfunction μreader.__call(reader, expr)\n   local return_expr, reddit;\n   local returned = false -- we haven\'t put \"return \" on the head\n\n   -- check for leading =, old-school style\n   local head = sub(expr, 1, 1)\n   if head == \"=\" then -- take pity on old-school Lua hackers\n       return_expr = \"return \" .. sub(expr, 2)\n       returned = true\n   end\n   -- add \"return\" and see if it parses\n   if not returned then\n      return_expr = \"return \" .. expr\n   end\n\n   local parsed_expr = lua_read(return_expr)\n   if parsed_expr then\n      -- check for errors and return vs. not return, if the parser fails,\n      -- we nil out parsed_expr and try it with =loadstring=\n      local err = parsed_expr:error()\n      if not err then\n         -- `\"return \" .. expr` parses correctly with our Lua parser\n         reddit = return_expr\n      else\n         parsed_expr = lua_read(expr)\n         err = parsed_expr:error()\n         if not err then\n            -- `expr` parses correctly with our Lua parser\n            reddit = expr\n         else\n            parsed_expr = nil\n         end\n      end\n   end\n\n   if not parsed_expr then\n      -- try the stock Lua parser, which is after all the final judge\n      -- note: we could just include the chunk if we make it? ehhhh...\n\n      local chunk = loadstring(return_expr)\n      if chunk then\n         reddit = return_expr\n      else\n         chunk = loadstring(expr)\n         if chunk then\n            reddit = expr\n         end\n      end\n   end\n\n   reader.reddit = reddit\n\n   return reader\nend\n\nfunction μreader.toLua(reader, valeta)\n   local reddit = reader.reddit\n   reader.reddit = nil\n   if not reddit then\n      return nil, \"reader didn\'t read\"\n   end\n\n   return tostring(reddit)\nend\n\nlocal μread = setmetatable({}, μreader)\n\n\n\n\n\n\nlocal μCompread = meta {}\n\nμCompread.name = \'Lua\'\n\nμCompread.label = \'Lua Comptime\'\n\nfunction μCompread.__call(Comptime, expr)\n   return expr\nend\n\nlocal μcompread = setmetatable({}, μCompread)\n\n\n\n\n\n\nlocal Error = meta {}\n\nfunction Error.__repr(err)\n   return string.lines(err[1])\nend\n\nlocal function toError(err)\n   return setmetatable({err}, Error)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _res = weak \'k\'\n\n\n\n\n\n\n\n\n\nlocal function gatherResults(success, ...)\n  -- check for a thrown result\n  if _res[select(2, ...)] then\n     -- \'true\' because any error is already packaged for us\n     return true, select(2, ...)\n  end\n  return success, pack(...)\nend\n\n\n\n\nlocal wrap, running = assert(coroutine.wrap), assert(coroutine.running)\n\nfunction Valeta.__call(valeta, expr)\n   local response = {\'pending\'}\n\n   local success, results;\n\n   wrap(function()\n      local label, compread, read = valeta.label,\n                                    valeta.compread,\n                                    valeta.read\n      local co = running()\n      local readable, msg = compread(tostring(expr))\n      -- this should also pick up in another event, but it\'s worth not doing\n      -- that for a trivial compread, and since that\'s all we have right this\n      -- instant, we\'ll skip that.\n      if not readable then\n         -- we have a comptime error\n         success, results = false, { toError(msg),\n                                     n = 1,\n                                     error = true,\n                                     comptime = true, }\n      else\n         local read_expr = tostring(read(tostring(readable)):toLua())\n         -- set up a checker to pick up success and results (or not) on the\n         -- next uv tick\n         local check_result = uv.new_check()\n         check_result:start(function(err)\n            assert(not err, err)\n            if success ~= nil then\n               response[1] = results\n               check_result:stop()\n            else\n               -- hand back the thread\n               response[1] = co\n               -- don\'t stop checking\n               -- note that this is a potential resource leak, but\n               -- we\'re going to need the caller to handle that sort of\n               -- thing\n            end\n         end)\n         local f, err = loadstring(read_expr, label)\n         if f then\n            setfenv(f, valeta.eval_env)\n            -- #todo patch our custom require for the duration of the call\n            success, results = gatherResults(xpcall(f, debug.traceback))\n            if not success then\n               -- error\n               results.error = true\n               results.runtime = true\n               results[1] = toError(results[1])\n            end\n         else\n            success = false\n            if err:match \"\'<eof>\'$\" then\n               -- Lua expects some more input\n               results = \'advance\'\n               -- this didn\'t block, so we can replace \'pending\' right now\n               response[1] = \'advance\'\n               -- the next tick will do this assignment again and\n               -- close the check\n            else\n               -- make the error into the result\n               results = { toError(err),\n                           n = 1,\n                           loadtime = true,\n                           error = true, }\n            end\n         end\n      end\n      _res[results] = true\n      --return success, results\n   end)()\n   return response\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(require \"core:fn\" . curry)\n\nlocal function new(env, _now, anti_G, reader, compread)\n   assert(env, \"must provide at least one environment\")\n   reader = reader or μread\n   compread = compread or μcompread\n   local valeta = meta(Valeta)\n   valeta.read = reader\n   valeta.label = reader and reader.label or μread.label\n   valeta.compread = compread\n   valeta.mods = {}\n   valeta.cleared = {}\n   anti_G = anti_G or assert(names.anti_G) -- #todo replace with Namer\n\n   local eval_M, _Mac_env = { __index = env,\n                              __newindex = make__newindex(anti_G) },\n                            _now and { __index = _now,\n                                       __newindex = make__newindex(anti_G) }\n                            or { __index = env,\n                                 __newindex = make__newindex(anti_G) }\n   valeta.eval_env = setmetatable({}, eval_M)\n   valeta.comptime_env = setmetatable({}, _Mac_env)\n\n   return valeta\nend\n\n\n\nreturn new\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "valeta",
branch = "valiant-jr",
},
  { 
hash = "6e79bd8e7b682005795b5a145721a7713ca35b143d5d9ea1333e653f30e20edf",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = use \"qor:core\"\nlocal Set = core.set\n\n\n\n\n\n\nlocal bytecode_by_module = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nWHERE module.name = :name\nORDER BY module.time desc limit 1\n;\n]]\n\nlocal bytecode_by_module_and_project = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nINNER JOIN project\nON project.project_id = module.project\nWHERE project.name = :project_name\nAND module.name = :module_name\nORDER BY module.time desc limit 1\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal function _open(conn_str)\n   if type(conn_str) == \'string\' then\n      return sql.open(conn)\n   elseif type(conn_str) == \'cdata\' then\n      -- guess it\'s a conn ¯\\_(ツ)_/¯\n      return conn_str\n   else\n      error (\"illegal \'conn string\' of type \" .. type(conn_str))\n   end\nend\n\nlocal modules_conn, modNames = assert(_Bridge.modules_conn),\n                               assert(_Bridge.modNames)\n\nlocal toRow = assert(sql.toRow)\n\nlocal function resultMap(result)\n   if result == nil then return nil end\n   return toRow(result)\nend\n\nlocal _luaMagic = Set {\'bit\', \'jit\', \'jit.zone\'}\n\nfunction getLua(mod_name, conn_str)\n   -- two reasons to ignore a string: preload, or magic Lua summonings\n   if package.preload[mod_name] or _luaMagic[mod_name] then\n      return nil\n   end\n\n\n   -- mostly cribbed from preamble.orb\n   local conn = conn_str and _open(conn_str) or modules_conn\n                or error \"No bridge.modules conn?\"\n   if conn._closed then return nil end\n   local module_stmt = conn:prepare(bytecode_by_module)\n   local project_stmt = conn:prepare(bytecode_by_module_and_project)\n   local project, mod, proj_double, mod_double = modNames(mod_name)\n   local bytecode = nil\n\n   if project then\n      -- retrieve bytecode by project and module\n      bytecode = resultMap(project_stmt :bind(project, mod) :resultset())\n      if not bytecode then\n         -- try mod_double\n         project_stmt:reset()\n         bytecode = resultMap(project_stmt :bind(project, mod_double)\n                                 :resultset())\n      end\n      if not bytecode then\n         -- try proj_double\n         project_stmt:reset()\n         bytecode = resultMap(project_stmt :bind(project, proj_double)\n                                 :resultset())\n      end\n      project_stmt:reset()\n   else\n      -- retrieve by bare module name\n      bytecode = resultMap(module_stmt :bind(mod) :resultset())\n      if not bytecode then\n         module_stmt:reset()\n         bytecode = resultMap(module_stmt :bind(mod_double) :resultset())\n      end\n      module_stmt:reset()\n   end\n\n   if bytecode then\n      return bytecode.binary, bytecode.hash\n   end\n   return nil\nend\n\n\n\n\n\n\nlocal bridge = use \"bridge\"\n\nlocal loaded, load_hashes = assert(bridge.loaded),\n                            assert(bridge.load_hashes)\nlocal package_loaded      = assert(package.loaded)\n\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\nlocal function transplant()\n   local hash_load = {}\n\n   for mod_name, hash in pairs(load_hashes) do\n      if package_loaded[mod_name] then\n         hash_load[hash] = package_loaded[mod_name]\n         package_loaded[mod_name] = nil\n         -- lua has special logic to enable iteration to continue\n         -- when we do this:\n         load_hashes[mod_name] = nil -- I think that\'s neat\n      end\n   end\n\n   local function loader(mod_name)\n      local lua, hash = getLua(mod_name)\n      if hash_load[hash] then\n         return function()\n            return hash_load[hash]\n         end\n      end\n      if not lua then return nil, mod_name end\n      local load = assert(load(lua, \"@\" .. mod_name))\n      loaded[hash] = mod_name\n      load_hashes[mod_name] = hash\n      return load\n   end\n\n   insert(package.loaders, 2, loader)\nend\n\n\n\n\n\nreturn transplant\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "transplant",
branch = "valiant-jr",
},
  { 
hash = "8d0c46499d9a9a70bf796f20b02a0cb0ecfb7de390ce9bcc80c579b0ebfb62cd",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge = require \"bridge\"\nlocal req = assert(require)\nlocal tostring = assert(tostring)\nlocal loadstring = assert(loadstring)\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\nlocal lua_read = req \"lun:lua-parser\"\nlocal names      = req \"repr:repr/names\"\nlocal string = req \"core:core/string\"\n\nlocal core = require \"qor:core\" -- #Todo more qor to remove\n\nlocal meta = assert(core.cluster.meta)\nlocal weak = assert(core.meta.weak)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Valiant = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _require(valiant, module)\n   if not valiant.restarting then\n      valiant.mods[module] = true\n      return req(module)\n   else\n      if valiant.cleared[module] then\n         return req(module)\n      end\n      local hash = bridge.load_hashes[module]\n      if not hash then\n         return req(module)\n      else\n         -- invalidate our various caches\n         package.loaded[module] = nil\n         bridge.loaded[hash] = nil\n         bridge.load_hashes[module] = nil\n         -- mark as cleared so we don\'t re-invalidate it\n         valiant.cleared[module] = true\n         return req(module)\n      end\n   end\nend\n\nlocal clear = assert(table.clear)\n\nfunction Valiant.restart(valiant)\n   clear(valiant.eval_env)\n   valiant.eval_env.require = valiant.require\n   valiant.restarting = true\nend\n\nfunction Valiant.reset(valiant)\n   valiant.cleared = {}\n   valiant.restarting = nil\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal pget = assert(require \"core:table\" . pget)\n\nlocal function make__index(env, env_2)\n\n   return function (eval_ENV, key)\n      local val = pget(env, key)\n      if val == nil and env_2 then\n         val = pget(env_2, key)\n      end\n      return val\n   end\nend\n\n\n\nlocal loadNames = assert(names.loadNames)\n\nlocal function make__newindex(anti_G)\n   return function (eval_ENV, key, value)\n      rawset(eval_ENV, key, value)\n      -- Use loadNames() to get the key added to all_symbols\n      loadNames({ [key] = value }, nil, anti_G)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal μreader = meta {}\n\nμreader.name = \'Lua\'\n\nμreader.label = \'Lua Reader\'\n\nlocal sub = assert(string.sub)\n\nfunction μreader.__call(reader, expr)\n   local return_expr, reddit;\n   local returned = false -- we haven\'t put \"return \" on the head\n\n   -- check for leading =, old-school style\n   local head = sub(expr, 1, 1)\n   if head == \"=\" then -- take pity on old-school Lua hackers\n       return_expr = \"return \" .. sub(expr, 2)\n       returned = true\n   end\n   -- add \"return\" and see if it parses\n   if not returned then\n      return_expr = \"return \" .. expr\n   end\n\n   local parsed_expr = lua_read(return_expr)\n   if parsed_expr then\n      -- check for errors and return vs. not return, if the parser fails,\n      -- we nil out parsed_expr and try it with =loadstring=\n      local err = parsed_expr:errorAt()\n      if not err then\n         -- `\"return \" .. expr` parses correctly with our Lua parser\n         reddit = return_expr\n      else\n         parsed_expr = lua_read(expr)\n         err = parsed_expr:errorAt()\n         if not err then\n            -- `expr` parses correctly with our Lua parser\n            reddit = expr\n         else\n            parsed_expr = nil\n         end\n      end\n   end\n\n   if not parsed_expr then\n      -- try the stock Lua parser, which is after all the final judge\n      -- note: we could just include the chunk if we make it? ehhhh...\n\n      local chunk = loadstring(return_expr)\n      if chunk then\n         reddit = return_expr\n      else\n         chunk = loadstring(expr)\n         if chunk then\n            reddit = expr\n         end\n      end\n   end\n\n   reader.reddit = reddit\n\n   return reader\nend\n\nfunction μreader.toLua(reader, valiant)\n   local reddit = reader.reddit\n   reader.reddit = nil\n   if not reddit then\n      return nil, \"reader didn\'t read\"\n   end\n\n   return tostring(reddit)\nend\n\nlocal μread = setmetatable({}, μreader)\n\n\n\n\n\n\nlocal μCompread = meta {}\n\nμCompread.name = \'Lua\'\n\nμCompread.label = \'Lua Comptime\'\n\nfunction μCompread.__call(Comptime, expr)\n   return expr\nend\n\nlocal μcompread = setmetatable({}, μCompread)\n\n\n\n\n\n\nlocal Error = meta {}\n\nfunction Error.__repr(err)\n   return string.lines(err[1])\nend\n\nfunction Error.__tostring(err)\n   return err[1]\nend\n\nlocal function toError(err)\n   return setmetatable({err}, Error)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _res = weak \'k\'\n\n\n\n\n\n\n\n\n\nlocal function gatherResults(success, ...)\n  -- check for a thrown result\n  if _res[select(2, ...)] then\n     -- \'true\' because any error is already packaged for us\n     return true, select(2, ...)\n  end\n  return success, pack(...)\nend\n\n\n\n\nfunction Valiant.__call(valiant, expr)\n   local label, compread, read = valiant.label, valiant.compread, valiant.read\n\n   local success, results;\n\n   local readable, msg = compread(tostring(expr))\n   if not readable then\n      -- we have a comptime error\n      success, results = false, { toError(msg),\n                                  n = 1,\n                                  error = true,\n                                  comptime = true, }\n   else\n\n      local read_expr = tostring(read(tostring(readable)):toLua())\n\n\n      local f, err = loadstring(read_expr, label)\n      if f then\n         setfenv(f, valiant.eval_env)\n         -- patch our custom require for the duration of the call\n         local global_env = getfenv(0)\n         local req = global_env.require\n         s:bore \"begins evaluation\"\n         rawset(global_env, \"require\", valiant.require)\n         success, results = gatherResults(xpcall(f, debug.traceback))\n         s:bore \"ends evaluation\"\n         rawset(global_env, \"require\", req)\n         if not success then\n            -- error\n            s:verb \"error in evaluation\"\n            results.error = true\n            results.runtime = true\n            results[1] = toError(results[1])\n         end\n      else\n         success = false\n         s:verb \"parse error\"\n         if err:match \"\'<eof>\'$\" then\n            -- Lua expects some more input\n            s:verb \"advance requested\"\n            results = \'advance\'\n         else\n            -- make the error into the result\n            results = { toError(err),\n                        n = 1,\n                        loadtime = true,\n                        error = true, }\n         end\n      end\n   end\n   collectgarbage()\n   _res[results] = true\n   return success, results\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(require \"core:fn\" . curry)\n\nlocal function new(env, _now, anti_G, reader, compread)\n   assert(env, \"must provide at least one environment\")\n   reader = reader or μread\n   compread = compread or μcompread\n   local valiant = setmetatable({}, Valiant)\n   valiant.read = reader\n   valiant.label = reader and reader.label or μread.label\n   valiant.compread = compread\n   valiant.mods = {}\n   valiant.cleared = {}\n   anti_G = anti_G or assert(names.anti_G) -- #todo get names from env if not provided\n   local eval_M, _Mac_env = { __index = env,\n                              __newindex = make__newindex(anti_G) }, nil\n   if _now then\n      _Mac_env = { __index = _now,\n                   __newindex = make__newindex(anti_G) }\n   else\n      -- trivial case\n      _Mac_env = { __index = env,\n                   __newindex = make__newindex(anti_G) }\n   end\n   valiant.require = curry(_require, valiant)\n   valiant.eval_env = { require = valiant.require }\n   valiant.comptime_env = { require = valiant.require }\n   setmetatable(valiant.comptime_env, _Mac_env)\n   setmetatable(valiant.eval_env, eval_M)\n   return valiant\nend\n\n\n\nreturn new\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "valiant",
branch = "valiant-jr",
},
  { 
hash = "a48229f4e7ac50da1da7da98ee1d239088ad52a54683d70475be36f5fb5914ce",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal require = assert(require)\nlocal tostring = assert(tostring)\nlocal loadstring = assert(loadstring)\nlocal setmetatable = assert(setmetatable)\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\nlocal lua_read = require \"lun:lua-parser\"\nlocal names      = require \"repr:repr/names\"\nlocal transplant = require \"valiant:transplant\"\n\nlocal core = require \"qor:core\" -- #Todo more qor to remove\nlocal string = assert(core.string)\n\nlocal meta = assert(core.cluster.meta)\nlocal weak = assert(core.meta.weak)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Valiant = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\n\nfunction Valiant.reset(valiant)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal pget = assert(require \"core:table\" . pget)\n\nlocal rawset = assert(rawset)\n\nlocal loadNames = assert(names.loadNames)\n\nlocal function make__newindex(anti_G)\n   return function (eval_ENV, key, value)\n      rawset(eval_ENV, key, value)\n      -- Use loadNames() to get the key added to all_symbols\n      loadNames({ [key] = value }, nil, anti_G)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal μreader = meta {}\n\nμreader.name = \'Lua\'\n\nμreader.label = \'Lua Reader\'\n\nlocal sub = assert(string.sub)\n\nfunction μreader.__call(reader, expr)\n   local return_expr, reddit;\n   local returned = false -- we haven\'t put \"return \" on the head\n\n   -- check for leading =, old-school style\n   local head = sub(expr, 1, 1)\n   if head == \"=\" then -- take pity on old-school Lua hackers\n       return_expr = \"return \" .. sub(expr, 2)\n       returned = true\n   end\n   -- add \"return\" and see if it parses\n   if not returned then\n      return_expr = \"return \" .. expr\n   end\n\n   local parsed_expr = lua_read(return_expr)\n   if parsed_expr then\n      -- check for errors and return vs. not return, if the parser fails,\n      -- we nil out parsed_expr and try it with =loadstring=\n      local err = parsed_expr:errorAt()\n      if not err then\n         -- `\"return \" .. expr` parses correctly with our Lua parser\n         reddit = return_expr\n      else\n         parsed_expr = lua_read(expr)\n         err = parsed_expr:errorAt()\n         if not err then\n            -- `expr` parses correctly with our Lua parser\n            reddit = expr\n         else\n            parsed_expr = nil\n         end\n      end\n   end\n\n   if not parsed_expr then\n      -- try the stock Lua parser, which is after all the final judge\n      -- note: we could just include the chunk if we make it? ehhhh...\n\n      local chunk = loadstring(return_expr)\n      if chunk then\n         reddit = return_expr\n      else\n         chunk = loadstring(expr)\n         if chunk then\n            reddit = expr\n         end\n      end\n   end\n\n   return reddit\nend\n\n\n\n\n\n\nlocal μread = setmetatable({}, μreader)\n\n\n\n\n\n\nlocal Error = meta {}\n\nfunction Error.__repr(err)\n   return string.lines(err[1])\nend\n\nfunction Error.__tostring(err)\n   return err[1]\nend\n\nlocal function toError(err)\n   return setmetatable({err}, Error)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _res = weak \'k\'\n\n\n\n\n\n\n\n\n\nlocal function gatherResults(success, ...)\n  -- check for a thrown result\n  if _res[select(2, ...)] then\n     -- \'true\' because any error is already packaged for us\n     return true, select(2, ...)\n  end\n  return success, pack(...)\nend\n\n\n\n\nfunction Valiant.__call(valiant, expr)\n   if valiant.fresh then\n      transplant()\n   end\n   valiant.fresh = nil\n   local label,  read = valiant.label, valiant.read\n\n   local success, results;\n   local read_expr = tostring(read(tostring(expr)))\n\n\n   local f, err = loadstring(read_expr, label)\n   if f then\n      setfenv(f, valiant.eval_env)\n      s:bore \"begins evaluation\"\n      success, results = gatherResults(xpcall(f, debug.traceback))\n      s:bore \"ends evaluation\"\n      if not success then\n         -- error\n         s:verb \"error in evaluation\"\n         results.error = true\n         results.runtime = true\n         results[1] = toError(results[1])\n      end\n   else\n      success = false\n      s:verb \"parse error\"\n      if err:match \"\'<eof>\'$\" then\n         -- Lua expects some more input\n         s:verb \"advance requested\"\n         results = \'advance\'\n      else\n         -- make the error into the result\n         results = { toError(err),\n                     n = 1,\n                     loadtime = true,\n                     error = true, }\n      end\n\n   end\n   collectgarbage()\n   _res[results] = true\n   return success, results\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Valiant.callRound(valiant, round)\n   valiant.fresh = nil\n   local label,  read = valiant.label, valiant.read\n   local line, response = round.line, round.response\n   local success, results;\n   local read_expr = tostring(read(tostring(expr)))\n   local f, err = loadstring(read_expr, label)\n   if f then\n      setfenv(f, valiant.eval_env)\n      s:bore \"begins evaluation\"\n      success, results = gatherResults(xpcall(f, debug.traceback))\n      s:bore \"ends evaluation\"\n      if not success then\n         -- error\n         s:verb \"error in evaluation\"\n         results.error = true\n         results.runtime = true\n         results[1] = toError(results[1])\n      end\n   else\n      success = false\n      s:verb \"parse error\"\n      if err:match \"\'<eof>\'$\" then\n         -- Lua expects some more input\n         s:verb \"advance requested\"\n         results = \'advance\'\n      else\n         -- make the error into the result\n         results = { toError(err),\n                     n = 1,\n                     loadtime = true,\n                     error = true, }\n      end\n\n   end\n   collectgarbage()\n   if type(results) ~= string then\n      _res[results] = true\n   end\n   response[1] = results\n   return success\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(require \"core:fn\" . curry)\n\nlocal function new(env, _now, anti_G, reader)\n   assert(env, \"must provide at least one environment\")\n   reader = reader or μread\n   local valiant = setmetatable({}, Valiant)\n   valiant.fresh = true\n   valiant.read = reader\n   valiant.label = reader and reader.label or μread.label\n   valiant.mods = {}\n   valiant.cleared = {}\n   anti_G = anti_G or assert(names.anti_G) -- #todo get names from env if not provided\n   local eval_M = { __index = env,\n                    __newindex = make__newindex(anti_G) }\n   valiant.eval_env = {}\n   setmetatable(valiant.eval_env, eval_M)\n   return valiant\nend\n\n\n\nreturn new\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "valjr",
branch = "valiant-jr",
},
  { 
hash = "397501238ad7722f62cfb289cf378a10c740c33045ced3636f313a10de29d7ff",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njit.off()\nlocal uv = require \"luv\"\n\nlocal Valiant = require \"valiant:valiant\"\nlocal fn = require \"core:fn\"\nlocal kit = require \"valiant:replkit\"\nlocal persist_tabulate = require \"repr:repr/persist-tabulate\"\nlocal names = require \"repr:repr/names\"\nlocal tabulate = persist_tabulate.tabulate\nlocal result_M = persist_tabulate.db_result_M\nlocal ts = require \"repr:repr\" . ts_color\nlocal helm_db = require \"helm:helm/helm-db\"\nlocal Path = require \"fs:fs/path\"\nlocal Set = require \"set:set\"\nlocal sha = require \"util:sha\" . shorthash\n\nlocal a = require \"anterm:anterm\"\nlocal s = require \"status:status\"()\ns.chatty = true\ns.verbose = false\n\n\n\n\n\nlocal bridge = require \"bridge\"\n\n\n\nlocal session = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"qor:core\"\nlocal names = require \"repr:repr/names\"\nnames.loadNames(package.loaded)\nnames.loadNames(_G)\nnames.loadNames({ core = core })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anti_G_M = {__index = assert(names.anti_G), __mode = \'k\'}\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function evalSessionById(stmts, session_id, run_deprecated)\n   -- #todo valiant should create a throwaway anti_G internally as well\n   local aG  = setmetatable({}, anti_G_M)\n   local eval_G = { core = core,\n                    kit  = kit }\n   setmetatable(eval_G, {__index = _G})\n   local eval = Valiant(eval_G, nil, aG)\n   -- retrieve session\n   local sesh = stmts.get_session_by_id\n                        :bind(session_id) :resultset()\n   if not sesh then return nil end\n   -- run session again\n   local _session = { prem_count = 0, pass_count = 0, fail_count = 0 }\n   _session.session_title = sesh.session_title and sesh.session_title[1]\n   _session.session_id = sesh.session_id and sesh.session_id[1]\n   _session.project = sesh.project and sesh.project[1]\n   _session.accepted = sesh.session_accepted and sesh.session_accepted[1] ~= 0\n   -- bail on deprecated sessions\n   if (not _session.accepted) and (not run_deprecated) then return nil end\n\n   for i, line in ipairs(sesh.line) do\n      -- set up a container\n      _session[i] = {}\n      local premise = _session[i]\n      premise.ordinal = i\n      premise.status = sesh.status[i]\n      premise.title  = sesh.title[i]\n      premise.time = sesh.time[i]\n      premise.line = line\n      premise.same = false\n      -- Nothing which passed can fail but not passing is not itself failure\n      premise.failed = false\n      premise.passed = false\n      -- re-evaluate line\n      local ok, result = eval(line)\n      -- handle error-type results here:\n\n      -- avoid empty results\n      if result.n > 0 then\n         if not result.error then\n            premise.new_result = tabulate(result, aG)\n         else\n            -- propagate error directly\n            premise.new_result = result\n         end\n      end\n      local old_repr = stmts.get_results :bind(sesh.line_id[i]) :resultset()\n      old_repr = old_repr and old_repr.repr\n      -- we do need to handle the absence of results, but for now:\n      if old_repr then\n         premise.old_result = old_repr or {}\n      end\n      -- might need to handle all four cases instead of just two...\n      if premise.new_result and premise.old_result then\n         local same = true\n         for j, res in ipairs(premise.new_result) do\n            same = same and premise.new_result[j] == premise.old_result[j]\n         end\n         premise.same = same\n      end\n\n      -- handle zero-result lines correctly:\n      if (not premise.old_result) and (not premise.new_result) then\n         premise.same = true\n      end\n      if premise.status == \'accept\' and premise.same then\n         premise.passed = true\n      elseif premise.status == \'reject\' and (not premise.same) then\n         premise.changed = true\n      end\n      if (not premise.same) and premise.status == \'accept\' then\n         premise.failed = true\n      end\n      if premise.status ~= \'ignore\' then\n         _session.prem_count = _session.prem_count + 1\n      end\n      if premise.passed then\n         _session.pass_count = _session.pass_count + 1\n      end\n      if premise.failed then\n         _session.fail_count = _session.fail_count + 1\n         bridge.retcode = bridge.retcode + 1\n      end\n   end\n   return _session, sesh\nend\n\nsession.evalSessionById = evalSessionById\n\n\n\n\n\n\n\n\nlocal function evalProjectById(stmts, project_id, run_all)\n   local session_ids = stmts.get_sessions_by_project\n                          :bind(project_id) :resultset()\n   if not session_ids then return end\n\n   local sessions = {}\n   for _, sesh in ipairs(session_ids.session_id) do\n      local result = evalSessionById(stmts, sesh, run_all) or {}\n      insert(sessions, result)\n   end\n   return sessions\nend\n\nsession.evalProjectById = evalProjectById\n\n\n\n\n\n\n\n\n\nlocal function evalProjectByDir(stmts, dir, run_all)\n   local project_id = stmts.get_project_by_dir :bind(dir) :value()\n   if not project_id then return end\n   return evalProjectById(stmts, project_id, run_all)\nend\n\nsession.evalProjectByDir = evalProjectByDir\n\n\n\n\n\n\n\n\nlocal function getSessionsByDir(stmts, dir)\n   dir = dir or uv.cwd()\n   local project_id = stmts.get_project_by_dir :bind(dir) :value()\n   if not project_id then return nil end\n   local iter = stmts.get_sessions_for_project :bind(project_id)\n   local sessions = {}\n   for sesh in iter:rows() do\n      sesh.accepted = sesh.accepted ~= 0\n      sessions[#sessions + 1] = sesh\n   end\n   return sessions\nend\n\nsession.getSessionsByDir = getSessionsByDir\n\n\n\n\n\n\n\n\n\n\nlocal function refineSessions(select_list, sessions)\n   local selected = {}\n   if type(select_list) == \'string\' then\n      for _, sesh in ipairs(sessions) do\n         s:verb(sesh.session_title)\n         if sesh.session_title == select_list then\n            insert(selected, sesh)\n         end\n      end\n   elseif type(select_list) == \'number\' then\n       insert(selected, sessions[select_list])\n   else\n      -- we have an array of either session indices (number),\n      -- or ranges (table).\n      -- we only want to update a session once, so we cache indices, in case\n      -- ranges overlap.\n      local idx_cache = Set()\n      for _, range in ipairs(select_list) do\n         if type(range) == \'number\' then\n            if not idx_cache(range) then\n               insert(selected, sessions[range])\n               idx_cache[range] = true\n            end\n         elseif type(range) == \'table\' then\n            local start, finish = range[1], range[2]\n            finish = type(finish) == \'number\' and finish or #sessions\n            for i = start, finish do\n               if not idx_cache(i) then\n                  insert(selected, sessions[i])\n                  idx_cache[i] = true\n               end\n            end\n         end\n      end\n   end\n   if #selected == 0 then\n      if type(select_list) == \'table\' then\n         s:warn(\"Didn\'t find sessions in that list\")\n      else\n         s:warn(\"Didn\'t find a session %s\", tostring(select_list))\n      end\n      return nil\n   end\n   return selected\nend\n\nsession.refineSessions = refineSessions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function updateSession(stmts, sesh)\n   local insert_line = stmts.insert_line\n   local insert_result_hash = stmts.insert_result_hash\n   local insert_repr = stmts.insert_repr\n   local update_premise = stmts.update_premise_line\n   for _, premise in ipairs(sesh) do\n      if (not premise.same) and premise.status == \'accept\' then\n         -- add line and new results to DB\n         insert_line :bind(sesh.project, premise.line, premise.time)\n                     :value()\n         local line_id = stmts.lastRowId()\n         for _, result in ipairs(premise.new_result) do\n            local hash = sha(result)\n            insert_repr :bind(hash, result) :value()\n            insert_result_hash :bind(line_id, hash) :value()\n         end\n         -- update premise to point at new line\n         update_premise :bind(line_id, sesh.session_id, premise.ordinal)\n                        :value()\n      end\n   end\nend\n\n\n\n\nlocal function updateSessions(stmts, args)\n   local will_update = refineSessions(args.to_update,\n                                      evalProjectByDir(stmts, uv.cwd()))\n   if not will_update then return end\n   -- begin transaction\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_update) do\n      updateSession(stmts, sesh)\n   end\n   -- commit transaction\n   stmts.commit()\nend\n\nsession.updateSessions = updateSessions\nsession.updateSession  = updateSession\n\n\n\n\n\n\nfunction deleteDeprecatedSessions(stmts, args)\n   local will_delete = refineSessions(args.to_delete, getSessionsByDir(stmts))\n   if not will_delete then return end\n   -- set up prepared statements\n   local delete_sesh = stmts.delete_session_by_id\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_delete) do\n      if sesh.accepted then\n         s:chat(\"Not deleting \\\"%s\\\" (accepted)\", sesh.session_title)\n      else\n         s:chat(\"Deleting \\\"%s\\\" (deprecated)\", sesh.session_title)\n         delete_sesh :bind(sesh.session_id) :value()\n      end\n   end\n   stmts.commit()\nend\n\n\n\n\nfunction deleteSessions(stmts, args)\n   local will_delete = refineSessions(args.to_delete, getSessionsByDir(stmts))\n   if not will_delete then return end\n   io.write \"Deleting sessions cannot be undone. Continue (y/n)? \"\n   if io.read():sub(1,1):lower() ~= \"y\" then\n      print \"Ok, bailing out.\"\n      return\n   end\n   -- set up prepared statements\n   local delete_sesh = stmts.delete_session_by_id\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_delete) do\n      s:chat(\"Deleting \\\"%s\\\"\", sesh.session_title)\n      delete_sesh :bind(sesh.session_id) :value()\n   end\n   stmts.commit()\nend\n\n\n\n\n\n\n\n\n\nfunction _alterAcceptance(accept, stmts, args)\n   local list = accept and args.to_accept or args.to_deprecate\n   local will_alter = refineSessions(list, getSessionsByDir(stmts))\n   if not will_alter then return end\n   local accept_sesh = stmts.update_accepted_session\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_alter) do\n      local state = accept and \"accepted\" or \"deprecated\"\n      s:chat(\"\\\"%s\\\" now %s\", sesh.session_title, state)\n      accept_sesh :bind(accept, sesh.session_id) :value()\n   end\n   stmts.commit()\nend\n\n\n\nlocal curry = assert(fn.curry)\n\nlocal acceptSessions = curry(_alterAcceptance, true)\nlocal deprecateSessions = curry(_alterAcceptance, false)\n\nsession.acceptSessions = acceptSessions\nsession.deprecateSessions = deprecateSessions\n\n\n\n\n\n\n\n\nfunction renameSession(stmts, args)\n   local sesh = refineSessions(args.old_name, getSessionsByDir(stmts))\n   if not sesh then\n      return\n   end\n   sesh = sesh[1]\n   stmts.update_title_session :bind(args.new_name, sesh.session_id) :step()\n   s:chat(\"%s is now \\\"%s\\\"\", args.old_name, args.new_name)\nend\n\nsession.renameSession = renameSession\n\n\n\n\n\n\n\n\n\nlocal Bundle, serpent;\n\nlocal function bundleSessions(stmts, args, dir)\n   Bundle = Bundle or require \"valiant:bundle\"\n   serpent = serpent or require \"util:serpent\"\n   dir = dir or uv.cwd()\n   local project = Path(dir):basename()\n   local list = args.to_export\n   local bundle = Bundle.create(stmts, project)\n   local sessions = refineSessions(list, getSessionsByDir(stmts, dir))\n   if not sessions then\n      return serpent.bundle(bundle)\n   end\n   for _, sesh in ipairs(sessions) do\n      Bundle.addSession(stmts, bundle, sesh)\n   end\n   return serpent.bundle(bundle)\nend\n\nsession.bundleSessions = bundleSessions\n\n\n\n\nlocal File;\n\nlocal function exportSessions(stmts, args, dir)\n   local bundle = bundleSessions(stmts, args, dir)\n   if args.outfile then\n      File = File or require \"fs:file\"\n      local out = File(args.outfile)\n      out:write(bundle)\n   else\n      io.stdout:write(bundle)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function loadBundle(args)\n   local bundle_str;\n   if not args.infile then\n      bundle_str = io.stdin:read \"*a\"\n   else\n      File = File or require \"fs:file\"\n      bundle_str = File(args.infile):read()\n   end\n   if not bundle_str then return nil end\n   serpent = serpent or require \"util:serpent\"\n   local bundle = serpent.load(bundle_str)\n   -- do something with it, to wit:\n   return bundle\nend\n\nsession.loadBundle = loadBundle\n\n\n\nlocal function importSession(stmts, sesh, project_id)\n   sesh.project_id = project_id\n   local existing_id = stmts.get_session_by_project_and_title\n                           :bind(project_id, sesh.session_title)\n                           :value()\n   if existing_id then\n      io.write((\'A session named \"%s\" already exists. \' ..\n                       \"Do you want to replace it (y/n)? \")\n                       :format(sesh.session_title))\n      if io.read():sub(1,1):lower() == \"y\" then\n         sesh.session_id = existing_id\n         stmts.update_session:bindkv(sesh):value()\n         -- Get rid of any extra premises in the old session. Existing ones\n         -- up to the length of the new session will be overwritten\n         stmts.truncate_session:bind(existing_id, #sesh):value()\n      else\n         -- Or bail out if the user said no\n         return nil\n      end\n   else\n      s:chat(\"Adding session: %s\", sesh.session_title)\n      stmts.insert_session:bindkv(sesh):value()\n      sesh.session_id = stmts.lastRowId()\n   end\n   for ordinal, premise in ipairs(sesh) do\n      stmts.insert_line :bind(project_id, premise.line, premise.time) :value()\n      local line_id = stmts.lastRowId()\n      -- add the results if any\n      local results = premise.results\n      for i = 1, results.n do\n         local hash = sha(results.repr[i])\n         stmts.insert_repr :bind(hash, results.repr[i]) :value()\n         stmts.insert_result_hash :bind(line_id, hash) :value()\n      end\n      -- add the premise\n      stmts.insert_premise\n         :bind(sesh.session_id, ordinal, line_id, premise.title, premise.status)\n         :value()\n   end\nend\n\n\n\nlocal fromkeys = assert(require \"core:table\" . fromkeys)\nlocal function importSessions(stmts, args)\n   local bundle = loadBundle(args)\n   if not bundle then\n      s:chat(\"Unable to read bundle\")\n      return nil\n   end\n   -- check version and bundle type\n   if not bundle.bundle_type == \'session\' then\n      s:halt(\"Don\'t know what to do with a bundle of type %s\",\n             bundle.bundle_type)\n   end\n   if not bundle.version == 1 then\n      s:halt(\"Can only import bundles with version 1\")\n   end\n   -- get all project directories\n   local project_info, n = stmts.get_project_info()\n   -- iterate until we find the project_id matching the basename\n   local project_id;\n   for i = 1, n do\n      local basename = Path(project_info.directory[i]):basename()\n      if basename == bundle.project then\n         project_id = project_info.project_id[i]\n         break\n      end\n   end\n   if not project_id then\n      s:chat(\"Unable to find project named %s\", bundle.project)\n      s:chat(\"Run `br helm` in %s\'s root directory to add it to the database\",\n             bundle.project)\n      return nil\n   end\n   stmts.beginTransaction()\n   -- prepare the statements we\'ll need, :value() will reset them\n   local prepared_stmts = fromkeys(stmts, \"get_session_by_project_and_title\",\n                                    \"update_session\", \"truncate_session\",\n                                    \"insert_session\", \"insert_line\",\n                                    \"insert_result_hash\", \"insert_repr\",\n                                    \"insert_premise\", \"lastRowId\")\n   for _, sesh in ipairs(bundle) do\n      importSession(prepared_stmts, sesh, project_id)\n   end\n   -- commit\n   stmts.commit()\n   return true\nend\n\nsession.importSessions = importSessions\nsession.importSession  = importSession\n\n\n\n\n\n\n\n\nlocal null_result = {\"no saved result (presumed error)\", n = 1, error = true}\nlocal function printPremise(premise)\n   local no_title = premise.title ~= \"\"\n   local indent = \"   \"\n   local title = no_title and premise.title or \"«\" .. premise.line .. \"»\"\n   local passed = premise.same and \"✅ \" or \"❌ \"\n   -- #todo \'reject\' is the wrong semantic, we want \'watch\', hence the eye\n   -- these results are to be printed in diff form when they change from the\n   -- recorded state.\n   if premise.status == \'reject\' then\n      if premise.changed then\n         passed = \"❗️ \"\n      else\n         passed = \"👁  \"\n      end\n   end\n   if not (premise.status == \'ignore\') then\n      s:chat(indent .. passed .. title)\n      if (not premise.same) then\n         if premise.status == \'accept\' then\n            if not no_title then\n               s:chat(\"for `\" .. premise.line .. \"`:\")\n            end\n            local old_res = premise.old_result or null_result\n            local complaint = \"given: %s\\n%sexpected:\"\n            s:chat(complaint, premise.line, indent)\n            s:chat(ts(setmetatable(old_res, result_M)))\n         else\n            s:chat(a.bold(\"   New return value for %s:\"), premise.line)\n         end\n         local new_result_ts = premise.new_result.error\n                               and ts(premise.new_result[1])\n                               or ts(setmetatable(premise.new_result, result_M))\n         local nr_message = premise.new_result.error\n                            and \"received error:\"\n                            or  \"received:\"\n         s:chat(\"\\n\" .. indent .. nr_message)\n         s:chat(new_result_ts)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function listSessionsByProject(stmts, dir, print_accepted)\n   local sesh = stmts.get_session_list_by_dir :bind(dir)\n   local count_premises = stmts.count_premises\n   if not sesh then return nil end\n   for i, title, accepted, session_id in sesh:cols() do\n      -- cast accepted to a true boolean\n      accepted = accepted ~= 0 and true or false\n      local num_prems = count_premises :bind(session_id) :value()\n      if print_accepted then\n         local accept = accepted and \"▶️\" or \"⏸\"\n         s:chat(\"%s %3d: %s (%d)\", accept, i, title, num_prems or 0)\n      elseif accepted then\n         s:chat(\"%3d: %s (%d)\", i, title, num_prems or 0)\n      end\n   end\nend\n\n\n\n\n\n\n\nfunction printSession(sesh)\n   local prem_count, pass_count = sesh.prem_count, sesh.pass_count\n   -- skip empty sessions\n   if not prem_count then return end\n   local hl, gr = pass_count == prem_count and a.green or a.red, a.green\n   local prem_head = \"[\" .. hl(pass_count) .. \"/\" .. gr(prem_count) .. \"] \"\n   s:chat(a.bold(prem_head .. sesh.session_title))\n   for _, premise in ipairs(sesh) do\n      printPremise(premise)\n   end\nend\n\n\n\n\n\n\n\n\nfunction runSessionById(stmts, session_id)\n   local session = evalSessionById(stmts, session_id)\n   if not session then return nil end\n   printSession(session)\n   return session\nend\nsession.runSessionById = runSessionById\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction session.runProjectByDir(stmts, dir, run_all, to_refine)\n   local sessions;\n   if not to_refine then\n      sessions = evalProjectByDir(stmts, dir, run_all)\n   else\n      -- really we shouldn\'t run the other sessions at all\n      -- #Todo rewrite this so only selected sessions run\n      sessions = refineSessions(to_refine,\n                                evalProjectByDir(stmts, dir, run_all))\n   end\n   if not sessions then return end\n   local all_pass, all_premise, all_fail = 0, 0, 0\n   for _, sesh in ipairs(sessions) do\n      if sesh.pass_count then\n         all_pass = all_pass + sesh.pass_count\n         all_premise = all_premise + sesh.prem_count\n         printSession(sesh)\n      end\n      if sesh.fail_count > 0 then\n         all_fail = all_fail + 1\n      end\n   end\n   local gr = a.green\n   local hl;\n   if all_fail > 0 then\n      hl = a.red\n   elseif all_pass < all_premise then\n      hl = a.magenta\n   else\n      hl = a.green\n   end\n   local icon = all_fail > 0 and \"   ❌\" or \"   ✅\"\n\n   local passphrase = a.bold(\"%s  total passed: [\"..hl\"%d\"..\"/\"..gr\"%d\"..\"], \")\n   local failphrase = all_fail > 0 and\n                      format(a.bold(\"failed: %s\"), hl(all_fail))\n                      or\n                      a.bold(\"failed: none \")\n   s:chat \"\"\n   s:chat(passphrase .. failphrase, icon, all_pass, all_premise)\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _runAllSessions(stmts, run_all)\n   -- obtain project list\n   local project_info = stmts.get_project_info()\n   if not project_info then return end\n   local project_ids, dirs = project_info.project_id, project_info.directory\n   local all_prem, all_pass = 0, 0\n   for i, proj_id in ipairs(project_ids) do\n      local session_ids = stmts.get_sessions_from_project\n                               :bind(proj_id)\n                               :resultset()\n      if session_ids then\n         local project = Path(dirs[i]):basename()\n         s:chat(\"\\n\" .. a.bold(project) .. \":\\n\")\n         local proj_prem, proj_pass = 0, 0\n         for j, session_id in ipairs(session_ids.session_id) do\n            if run_all or session_ids.accepted[j] == 1 then\n               local sesh = runSessionById(stmts, session_id)\n               if sesh then\n                  proj_prem = proj_prem + sesh.prem_count\n                  proj_pass = proj_pass + sesh.pass_count\n               end\n            end\n         end\n         local hl, gr = proj_pass == proj_prem and a.green or a.red, a.green\n         s:chat(a.bold(\"\\n\" .. hl(project)\n                .. \": [\" .. hl(proj_pass) .. \"/\" .. gr(proj_prem) .. \"]\\n\"))\n         all_prem = all_prem + proj_prem\n         all_pass = all_pass + proj_pass\n      end\n   end\n   local hl, gr = all_pass == all_prem and a.green or a.red, a.green\n   s:chat(a.bold(\"total passed: [\"\n                 .. hl(all_pass) .. \"/\" .. gr(all_prem) .. \"]\"))\nend\n\nfunction session.runAllSessions(stmts)\n   return _runAllSessions(stmts, true)\nend\n\n\n\n\n\n\n\n\n\n\nfunction session.runAllAcceptedSessions(stmts)\n   return _runAllSessions(stmts, false)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction session.session(args, conn_handle)\n   local stmts = helm_db.session(conn_handle)\n   if args.all then\n      _runAllSessions(stmts, false)\n   -- other options go here, as we add them.\n   elseif args.accepted then\n      error \"NYI\"\n   elseif args.list then\n      if args.list_all then\n         listSessionsByProject(stmts, uv.cwd(), true)\n      else\n         listSessionsByProject(stmts, uv.cwd())\n      end\n   elseif args.to_update then\n      updateSessions(stmts, args)\n   elseif args.delete then\n      deleteDeprecatedSessions(stmts, args)\n   elseif args[\"force-delete\"] then\n      deleteSessions(stmts, args)\n   elseif args.accept then\n      acceptSessions(stmts, args)\n   elseif args.deprecate then\n      deprecateSessions(stmts, args)\n   elseif args.rename then\n      renameSession(stmts, args)\n   elseif args.export then\n      exportSessions(stmts, args)\n   elseif args.import then\n      importSessions(stmts, args)\n   else\n      session.runProjectByDir(stmts, uv.cwd(), args.every, args.some)\n   end\n\n   helm_db.close()\nend\n\n\n\njit.on()\nreturn session\n\n",
vc_hash = "34703597c240784d53688d9845ddd3ba77951bfd\n",
name = "session",
branch = "valiant-jr",
},
} },
{
  project = {
    home = "",
    repo_type = "git",
    repo_alternates = "",
    website = "",
    name = "vizier",
},
  version = {    special = "no",
    stage = "SNAPSHOT",
    edition = "",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "825bb52bd0bb8016d334db8dc5b92742a71cecc7e1f346f9713378aa57707c02",
binary = "\n\n\n\n\nlocal core = require \"qor:core\"\nlocal cluster = require \"cluster:cluster\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal newAttr, Attr, Attr_M = cluster.order()\n\n\n\n\n\ncluster.create(newAttr, function(_new, attr)\n   return attr\nend)\n\n\n\n\n\n\n\nlocal table = assert(core.table)\nlocal insert, remove = assert(table.insert), assert(table.remove)\n\nfunction Attr.toDot(attr)\n   local scroll = {\"[\"}\n   for key, value in pairs(attr) do\n      -- mere insertion is not sufficient\n      insert(scroll, key)\n      insert(scroll, \" = \")\n      insert(scroll, value)\n      insert(scroll, \",\")\n      insert(scroll, \"\\n\")\n   end\n   remove(scroll); remove(scroll); -- pug ugly, long day\n   insert(scroll, \"]\")\n   return scroll, table.concat(scroll)\nend\n\n\n\nreturn {attr = newAttr}\n\n",
vc_hash = "6e5a44e552f79866de1a1a20ad62df796b52239e\n",
name = "dotgen",
branch = "trunk",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/voltron.git\n",
    repo_type = "git",
    repo_alternates = "",
    website = "",
    name = "voltron",
    home = "",
},
  version = {    special = "no",
    stage = "SNAPSHOT",
    edition = "",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "9bd5a2203fc20c97181f8c048015d2ee671d4a3e0e90cd793669281ce5e492b1",
binary = "\n\n\n\n\n\n\n\nlocal load = assert(load)\n\nlocal function beltaLowda(chunk)\n   local l, why = load(chunk)\n   if not l then\n      error(why)\n   end\n   setfenv(l, {})\n   return l()\nend\n\n\n\n\nlocal bridge = use \"bridge\"\nlocal insert, remove = assert(table.insert), assert(table.remove)\nlocal loaded, load_hashes = assert(bridge.loaded),\n                            assert(bridge.load_hashes)\nlocal package_loaded = assert(package.loaded)\n\nlocal _loader;\n\nlocal function patchLoad(voltstr)\n   if voltstr == false then\n      for i = 1, #package_loaded do\n         if _loader == package_loaded[i] then\n            remove(package_loaded, i)\n            _loader = nil\n            return\n         end\n      end\n      return\n   end\n\n   -- one voltron at a time\n   if _loader then\n      patchLoad(false)\n      assert(_loader == nil)\n   end\n\n   local volts = beltaLowda(voltstr)\n\n   local function loader(mod_name)\n      local mod = volts[mod_name]\n      if mod then\n         local hash, chunk = assert(mod[1]),\n                             assert(mod[2])\n         if loaded[hash] then\n            return function()\n               return package_loaded[loaded[hash]]\n            end\n         end\n         local load, err = load(chunk, \"@\" .. mod_name)\n         if load then\n            loaded[hash] = mod_name\n            load_hashes[mod_name] = hash\n            return load\n         else\n            error(err)\n         end\n      else\n         return nil, \"didn\'t load \" .. mod_name\n      end\n   end\n\n   _loader = loader\n   insert(assert(package.loaders), 2, loader)\nend\n\n\n\nreturn patchLoad\n\n",
vc_hash = "4ac3db658b8297062d385c220c4f8aa985108560\n",
name = "load",
branch = "trunk",
},
  { 
hash = "1904ed7ec03e311d2cfab874fe3df5b1ef1d7fffb68a5a494366cd78484381e1",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core, cluster = use (\"qor:core\", \"cluster:cluster\")\nlocal table, string = core.table, core.string\nlocal Scry = use \"scry:scry\"\nlocal Deque = use \"deque:deque\"\n\nlocal Set = core.set\n\nlocal Serpent = use \"util:serpent\"\n\nlocal s = use \"status:status\" ()\ns.chatty = true\n\n\n\n\nlocal new, Voltron, Volt_M = cluster.order()\n\n\n\nlocal getLua;\n\nlocal cleave = assert(string.cleave)\n\ncluster.construct(new, function(_new, voltron, main)\n   assert(main and type(main) == \'string\',\n          \'a main require string must be provided\')\n   local project, mod = cleave(main, \":\")\n   if mod then\n      voltron.main_mod = main\n      voltron.main = main\n   else\n      voltron.main = main\n      voltron.main_mod = main .. \":\" .. main\n   end\n\n   local bytecode, hash = getLua(voltron.main_mod)\n   if not bytecode then\n      error (\"can\'t make a Voltron out of \" .. main)\n   end\n   voltron.mods = { [voltron.main_mod] = {hash, bytecode}}\n\n   return voltron\nend)\n\n\n\n\n\n\nlocal bytecode_by_module = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nWHERE module.name = :name\nORDER BY module.time desc limit 1\n;\n]]\n\nlocal bytecode_by_module_and_project = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nINNER JOIN project\nON project.project_id = module.project\nWHERE project.name = :project_name\nAND module.name = :module_name\nORDER BY module.time desc limit 1\n;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _open(conn_str)\n   if type(conn_str) == \'string\' then\n      return sql.open(conn)\n   elseif type(conn_str) == \'cdata\' then\n      -- guess it\'s a conn ¯\\_(ツ)_/¯\n      return conn_str\n   else\n      error (\"illegal \'conn string\' of type \" .. type(conn_str))\n   end\nend\n\nlocal modules_conn, modNames = assert(_Bridge.modules_conn),\n                               assert(_Bridge.modNames)\n\nlocal toRow = assert(sql.toRow)\n\nlocal function resultMap(result)\n   if result == nil then return nil end\n   return toRow(result)\nend\n\nlocal _luaMagic = Set {\'bit\', \'jit\', \'jit.zone\'}\n\nfunction getLua(mod_name, conn_str)\n   -- two reasons to ignore a string: preload, or magic Lua summonings\n   if package.preload[mod_name] or _luaMagic[mod_name] then\n      return nil\n   end\n\n\n   -- mostly cribbed from preamble.orb\n   local conn = conn_str and _open(conn_str) or modules_conn\n                or error \"No bridge.modules conn?\"\n   local module_stmt = conn:prepare(bytecode_by_module)\n   local project_stmt = conn:prepare(bytecode_by_module_and_project)\n   local project, mod, proj_double, mod_double = modNames(mod_name)\n   local bytecode = nil\n\n   if project then\n      -- retrieve bytecode by project and module\n      bytecode = resultMap(project_stmt :bind(project, mod) :resultset())\n      if not bytecode then\n         -- try mod_double\n         project_stmt:reset()\n         bytecode = resultMap(project_stmt :bind(project, mod_double)\n                                 :resultset())\n      end\n      if not bytecode then\n         -- try proj_double\n         project_stmt:reset()\n         bytecode = resultMap(project_stmt :bind(project, proj_double)\n                                 :resultset())\n      end\n      project_stmt:reset()\n   else\n      -- retrieve by bare module name\n      bytecode = resultMap(module_stmt :bind(mod) :resultset())\n      if not bytecode then\n         module_stmt:reset()\n         bytecode = resultMap(module_stmt :bind(mod_double) :resultset())\n      end\n      module_stmt:reset()\n   end\n\n   if bytecode then\n      return bytecode.binary, bytecode.hash\n   end\n\n\n\n   return nil\nend\n\n\n\n\n\n\n\n\n\nlocal function jankLoad(str)\n   return load(\"return \" .. str)()\nend\n\n\n\nlocal requirements;\n\nfunction Voltron.assemble(voltron)\n   local main = Scry(voltron.mods[voltron.main_mod][2]) . synth\n   local reqs = requirements(main)\n   local seen = Set {voltron.main}\n   local shuttle = Deque()\n   for _, req in ipairs(reqs) do\n      seen[req] = true\n      shuttle:push(req)\n   end\n   for req in shuttle:popAll() do\n      s:chat(\"assembling %s\", req)\n      local modname = jankLoad(req)\n      local lua, hash = getLua(modname)\n      if lua then\n         voltron.mods[modname] = {hash, lua}\n         local syn = Scry(lua).synth\n         local reqs = requirements(syn)\n         for _, req in ipairs(reqs) do\n            if not seen[req] then\n               seen[req] = true\n               shuttle:push(req)\n            end\n         end\n      else\n         s:chat(\"no module found\")\n      end\n   end\n   voltron.reqSet = seen\n   return seen\nend\n\nlocal insert = table.insert\n\nlocal function requirePred(node)\n   if node.class == \'call\' then\n      local caller = node :take \'caller\'\n      if not caller then return false end\n\n      local ref = caller :take \'reference\'\n      if not ref then return false end\n\n      if ref.ID == \'require\' or ref.ID == \'use\' then\n         return true\n      end\n   else\n      return false\n   end\nend\n\nfunction requirements(synth)\n   local reqs = {}\n   for call in synth :filter(requirePred) do\n      insert(reqs, call)\n   end\n   local req_strings = {require = 0, use = 0}\n   for _, req in ipairs(reqs) do\n      local args = req :take \'arguments\'\n      local ID = req :take \'caller\' :take \'reference\' . ID\n      if ID == \'require\' then\n         req_strings.require = req_strings.require + 1\n         if args[1].class == \'string\' then\n            insert(req_strings, args[1].token)\n         end\n      elseif ID == \'use\' then\n         req_strings.use = req_strings.use + 1\n         for _, arg in ipairs(args) do\n            if arg.class == \'string\' then\n               insert(req_strings, arg.token)\n            end\n         end\n      end\n   end\n   return req_strings\nend\n\n\n\n\n\n\n\nlocal upsert_voltron = [[\nINSERT INTO voltron (voltron, name) VALUES (\n  :voltron, :name\n) ON CONFLICT DO UPDATE\nSET\n   voltron = :voltron,\n   name = :name,\n   time = strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')\n;\n]]\n\n\nfunction Voltron.voltron(volt)\n   if not volt.reqSet then\n      volt:assemble()\n      assert(volt.reqSet)\n   end\n   local voltaire = { voltron = Serpent.bundle(volt.mods),\n                      name = volt.main }\n   modules_conn :prepare(upsert_voltron) :bindkv(voltaire) :value()\nend\n\n\n\n\nreturn new\n\n",
vc_hash = "4ac3db658b8297062d385c220c4f8aa985108560\n",
name = "voltron",
branch = "trunk",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/wcwidth.git",
    repo_type = "git",
    repo_alternates = "",
    website = "",
    name = "wcwidth",
    home = "",
},
  version = {    special = "no",
    stage = "SNAPSHOT",
    edition = "",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {}\n\n",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn {}\n\n",
vc_hash = "5ccdc43c8fb80075c92cba14d522f459f4f6e5a7",
name = "wcwidth",
branch = "trunk",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/window.git\n",
    repo_type = "git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/window\n\n",
    website = "",
    name = "window",
    home = "",
},
  version = {    special = "no",
    stage = "SNAPSHOT",
    edition = "",
    patch = 0,
    minor = 0,
    major = 0,
},
  modules = {   { 
hash = "7778bab090fce993457a598aac1903dff6ec838896b78280776dc36746711cb2",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Fn = require \"core:core/fn\"\n\nlocal s = require \"status:status\"()\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _backer_store = setmetatable({}, {__mode = \'kv\'})\n\nlocal function _backer(window)\n   return assert(_backer_store[window], \"no backer found for this window\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal partial = assert(Fn.partial)\n\nlocal function _make_closure(fn, window, field)\n   return function(...)\n             local back = _backer(window)\n             return fn(back, window, field, ...)\n          end\nend\n\nlocal function _default__index(backer, window, field)\n   return backer[field]\nend\n\nlocal function _method_call(backer, window, field, ...)\n   return backer[field](backer, ...)\nend\n\n\n\n\n\n\n\n\nlocal iscallable, assertfmt = assert(Fn.iscallable), assert(Fn.assertfmt)\n\nlocal function _make__index(backer, window, config)\n   -- we need containers for the configuration contents.\n   local fields, values, fns = {}, {}, {}\n   -- and for our closure partials\n   local closure_fns = {}\n\n   -- we\'ve already checked that at most one of these flags are set\n   local array_is_field = config.array_is_field\n   local array_is_value = config.array_is_value\n   -- need to handle array_is_fn differently\n   local array_is_fn = config.array_is_fn\n   if array_is_fn then\n      if type(array_is_fn) == \'table\' then\n         assertfmt(iscallable(array_is_fn[1])\n                or array_is_fn[1] == nil\n                or array_is_fn[1] == true,\n                \"bad value at [1] in array_is_fn table of type %s\",\n                type(array_is_fn[1]))\n         if array_is_fn[1] == true then\n            array_is_fn = _default__index\n         else\n            array_is_fn = array_is_fn[1]\n         end\n      elseif not iscallable(array_is_fn) then\n         s:halt(\"bad fn value of type %s on array_is_fn\",\n                type(config.array_is_fn))\n      end\n   end\n\n   -- copy over keys for field and value tables\n   if config.field or array_is_field then\n      local _field = config.field or {}\n      for k, v in pairs(_field) do\n         fields[k] = true\n      end\n   end\n   if config.value or array_is_value then\n      local _value = config.value or {}\n      for k, v in pairs(_value) do\n         values[k] = true\n      end\n   end\n   -- copy over the callables on config.fn\n   if config.fn then\n      for k, v in pairs(config.fn) do\n         -- handle a pair of callables differently from a simple callable\n         if iscallable(v) then\n            fns[k] = v\n         elseif type(v) == \'table\' then\n            assertfmt(iscallable(v[1]) or v[1] == nil or v[1] == true,\n                   \"bad value at [1] of type %s in fn field %s\",\n                   type(v[1]), k)\n            if v[1] == true then\n               fns[k] = _default__index\n            else\n               fns[k] = v[1]\n            end\n         else\n            s:halt(\"bad fn value of type %s on key %s\", type(v), k)\n         end\n      end\n   end\n   -- build a closure for each method\n   if config.closure then\n      for k, v in pairs(config.closure) do\n         assertfmt(iscallable(v) or v == true,\n                   \"bad closure value of type %s on key %s\", type(v), k)\n         if v == true then\n            closure_fns[k] = _make_closure(_method_call, window, k)\n         else\n            closure_fns[k] = _make_closure(v, window, k)\n         end\n      end\n   end\n   -- remove the reference to the backer\n   backer = nil\n\n   -- now construct the actual index function\n   return function(_, field) -- we already have a reference to the window\n      -- retrieve the backer\n      local backer = _backer(window)\n      -- handle arrays first\n      if type(field) == \'number\' then\n         if array_is_field then\n            return backer[field]\n         elseif array_is_value then\n            local win_val = rawget(window, field)\n            if win_val ~= nil then return win_val end\n            return backer[field]\n         elseif array_is_fn then\n            return array_is_fn(backer, window, field)\n         else\n            s:halt \"array part of window isn\'t readable\"\n         end\n      end\n\n      -- Now everything else:\n      if fields[field] then\n         return backer[field]\n      elseif values[field] then\n         local win_val = rawget(window, field)\n         if win_val ~= nil then return win_val end\n         return backer[field]\n      elseif fns[field] then\n         return fns[field](backer, window, field)\n      elseif closure_fns[field] then\n         return closure_fns[field]\n      else\n         s:halt(\"illegal field for window: %s\", field)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _make__newindex(backer, window, config)\n   local value, fn = config.value, config.fn\n   local array_is_value = config.array_is_value\n   local array_is_fn = config.array_is_fn\n   if array_is_fn then\n      if type(array_is_fn == \'table\')\n         and (not iscallable(array_is_fn)) then\n         assertfmt(iscallable(array_is_fn[2])\n                   or array_is_fn[2] == nil,\n                   \"bad value at [2] of type %s in array_is_fn table\",\n                   type(array_is_fn[2]))\n         array_is_fn = array_is_fn[2]\n      else\n         -- otherwise we have a callable array_is_fn, which only applies to\n         -- the rvalue case.\n         array_is_fn = nil\n      end\n   end\n   local closed_value, closed_lfn = {}, {}\n   if value then\n      for k, v in pairs(value) do\n         closed_value[k] = v\n      end\n   end\n   if fn then\n      for k, v in pairs(fn) do\n         -- same sort of check as for array_is_fn\n         if type(v == \'table\')\n            and (not iscallable(v)) then\n            assertfmt(iscallable(v[2]) or v[2] == nil,\n                      \"bad value [2] of type %s in config.fn slot %s\",\n                      type(v[2]), k)\n            closed_lfn[k] = v[2]\n         end\n      end\n   end\n   -- remove the reference to the backer\n   backer = nil\n\n   return function(_, field, value)\n      -- retrieve the backer\n      local backer = _backer(window)\n      if closed_value[field] then\n         return rawset(window, field, value)\n      end\n      if closed_lfn[field] then\n         return closed_lfn[field](backer, window, field, value)\n      end\n      if type(field) == \'number\' then\n         if array_is_value then\n            return rawset(window, field, value)\n         elseif array_is_fn then\n            return array_is_fn(backer, window, field, value)\n         end\n      end\n      s:halt(\"can\'t set field %s on window\", field)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _make__len(window)\n   return function(_)\n      local backer = _backer(window)\n      local back_len, win_len = rawlen(backer), rawlen(window)\n      return win_len > back_len and win_len or back_len\n   end\nend\n\n\n\n\n\n\n\n\nlocal function _illegal__len(window)\n   s:halt \"cannot read # of window\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal New_M = {}\nlocal new = setmetatable({}, New_M)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _setBacker(backer, window, field, value)\n   backer[field] = value\nend\n\nlocal function _setWindow(backer, window, field, value)\n   rawset(window, field, value)\nend\n\nNew_M.__index = { setBacker = _setBacker,\n                setWindow = _setWindow }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _assert_unique_fields(config)\n   local dupe, count = {}, 0\n   for category, v in pairs(config) do\n      if type(v) == \'table\' then\n         for key in pairs(v) do\n            count = count + 1\n            if dupe[key] then\n               s:halt(\"duplicate of field %s in \'%s\' table\", key, category)\n            end\n            dupe[key] = true\n         end\n      end\n   end\n   if count == 0 then\n      assert(config.array_is_field\n             or config.array_is_value\n             or config.array_is_fn,\n             \"empty config table, would mean useless window\")\n   end\nend\n\nlocal function _one_array_field(config)\n   return not ((config.array_is_value and config.array_is_field)\n               or (config.array_is_value and config.array_is_fn)\n               or (config.array_is_field and config.array_is_fn))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _add_idEst_to_config(config)\n   for k, v in pairs(config) do\n      if type(v) == \"table\" and v.idEst then\n         return\n      end\n   end\n   config.fn = config.fn or {}\n   config.fn.idEst = function() return new end\nend\n\n\n\n\nfunction New_M.__call(_, backer, config)\n   -- validate our data is sanely shaped\n   assert(config and type(config) == \'table\', \"#2 (config) must be a table\")\n   assert(_one_array_field(config),\n          \"only one of array_is_[value | field | fn] may be set\")\n   _assert_unique_fields(config)\n   _add_idEst_to_config(config)\n\n   local window = {}\n   _backer_store[window] = backer\n   local __len = (config.array_is_value\n                  or config.array_is_field\n                  or config.array_is_fn)\n                  and _make__len(window)\n                  or _illegal__len\n   local __newindex = _make__newindex(backer, window, config)\n   local __index = _make__index(backer, window, config)\n   local Win_M = { __index    =  __index,\n                   __newindex =  __newindex,\n                   __len      =  __len }\n   return setmetatable(window, Win_M)\nend\n\n\n\nreturn new\n\n",
vc_hash = "96b9937f2c4af06173805fb6dc7b138e40a4cda0\n",
name = "window",
branch = "2022-02-28_RELEASE_BRANCH",
},
} },
}