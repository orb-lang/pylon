return { {
  project = {
    repo = "git@gitlab.com:special-circumstance/anterm.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/anterm.git",
    home = "",
    website = "",
    name = "anterm",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/palette",
hash = "89437f487d213e08db42a32554c1a131874a47aba8a52312038a723f91ebe41c",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal meta = assert(require \"core:core/meta\".meta)\nlocal table = require \"core:core/table\"\n\n\n\nlocal Palette = meta {}\n\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(table.cloneinstance)\n\nfunction Palette.__newindex(palette, name, color)\n   color = type(color) == \'table\' and cloneinstance(color) or color\n   if type(color) == \'table\' then\n      color.name = name\n   end\n   rawset(palette, name, color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Palette.change(palette, name, color)\n   local old_c = palette[name]\n   color = cloneinstance(color)\n   color.name = name\n   palette[name] = color\n   if not old_c then\n      return false\n   end\n   for n, c in pairs(palette) do\n      if c.kind == \'embedded\'\n         and c.reset == old_c\n         and c.reset.name == old_c.name then\n         c.reset = color\n      end\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(color_tab)\n   local palette = setmetatable({}, Palette)\n   if color_tab then\n      for name, color in pairs(color_tab) do\n         palette[name] = color\n      end\n   end\n   return palette\nend\n\nPalette.idEst = new\n\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm",
hash = "87e25a0d0ba09f96910198c1543f13a8c98d49fb92e4f23757f9b3f466919e0d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert (pairs)\nlocal tostring = assert (tostring)\nlocal setmeta = assert (setmetatable)\nlocal error = assert (error)\nlocal require = assert (require)\nlocal rawget = assert (rawget)\n\nlocal schar = assert(string.char)\nlocal sub   = assert(string.sub)\nlocal byte  = assert(string.byte)\nlocal bit   = assert(bit, \"anterm requires Luajit \'bit\' or compatible in _G\")\nlocal rshift = assert(bit.rshift)\nlocal core = require \"core:core\"\nbit = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anterm = {}\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\'\n\n\n\n\n\n\n\n\n\n\n\nlocal colormt = {}\ncolormt.__index = colormt\n\n\n\n\n\n\n\n\nfunction colormt.__eq(a,b)\n   return a.value == b.value and a.reset == b.reset\nend\n\n\n\n\n\n\n\n\n\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        bold = 1,\n        dim = 2,\n        italic = 3,\n        underscore = 4,\n        underline = 4,\n        reverse = 7,\n        hidden = 8,\n        strikeout = 9,\n        double_underscore = 21,\n        clear_bold = 22,\n        clear_dim  = 22,\n        clear_italic = 23,\n        clear_underline = 24,\n        clear_inverse = 27,\n        clear_hidden = 28,\n        clear_strikeout = 29 },\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = CSI .. value ..\"m\",\n        name = name,\n        kind = kind }\n    return setmeta(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        anterm[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt.__tostring(color)\n    return color.value\nend\n\nfunction colormt.__concat(color, other)\n    return tostring(color) .. tostring(other)\nend\n\nlocal clear_fg, clear_bg, clear = anterm.clear_fg.value,\n                                  anterm.clear_bg.value,\n                                  anterm.clear.value\n\nlocal clear_attribute = { bright = anterm.clear_bold,\n                          bold = anterm.clear_bold,\n                          dim = anterm.clear_dim,\n                          italic = anterm.clear_italic,\n                          underscore = anterm.clear_underline,\n                          underline = anterm.clear_underline,\n                          reverse = anterm.clear_reverse,\n                          hidden = anterm.clear_hidden,\n                          strikeout = anterm.clear_strikeout,\n                          double_underscore = anterm.clear_underline }\n\nsetmeta(clear_attribute, {__index = function() return clear end})\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    if color.kind == \"fg\" then\n        return clear_fg\n    elseif color.kind == \"bg\" then\n        return clear_bg\n    elseif color.kind == \"attribute\" then\n       return clear_attribute[color.name]\n    elseif color.kind == \"embedded\" then\n       return color.reset.value\n    end\nend\n\nlocal __ts = colormt.__tostring\n\nfunction colormt.__call(color, str)\n    if str then\n        return __ts(color) .. str .. reset(color)\n    else\n        return __ts(color)\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function byte_panic(byte_p)\n   if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n      error \"xterm value must be 8 bit unsigned\"\n   end\nend\n\nlocal _color_cache = setmeta({}, {__mode = \"v\"})\n\nlocal function _make_color(value, kind)\n   if _color_cache[value] then\n       return _color_cache[value]\n   end\n   local color = setmeta({value = value, kind = kind}, colormt)\n   _color_cache[value] = color\n   return color\nend\n\n\nlocal ansi_fg_pre = CSI .. \"38;5;\"\n\nlocal function ansi_fg(byte)\n   byte_panic(byte)\n   local value = ansi_fg_pre .. byte .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal ansi_bg_pre = CSI .. \"48;5;\"\n\nlocal function ansi_bg(byte)\n   byte_panic(byte)\n   local value = ansi_bg_pre .. byte .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fg24pre = CSI .. \"38;2;\"\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = fg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"fg\")\nend\n\nlocal bg24pre = CSI .. \"48;2;\"\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local value = bg24pre .. r .. \";\" .. g .. \";\" .. b .. \"m\"\n   return _make_color(value, \"bg\")\nend\n\nanterm[\"fg\"], anterm[\"bg\"] = ansi_fg, ansi_bg\n\nanterm[\"fg24\"], anterm[\"bg24\"] = fg24, bg24\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction anterm.embedded(outer, inner)\n   outer = cloneinstance(outer)\n   outer.kind = \"embedded\"\n   outer.reset = inner\n   return outer\nend\n\n\n\n\n\n\nlocal cursor = require \"anterm/cursor\"\nanterm.cursor = cursor\nanterm.jump = cursor.jump\nanterm.erase = cursor.erase\n\n\n\n\n\nlocal mouse = {}\nanterm.mouse = mouse\n\nlocal buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}\n\n\n\n\n\n\n\n\n\n\nfunction mouse.track(on)\n   if on == true then\n      return \"\\x1b[?1003h\"\n   end\n\n   return \"\\x1b[?1003l\"\nend\n\n\n\nfunction mouse.ismousemove(seq)\n   if sub(seq, 1, 3) == \"\\x1b[M\" then\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction mouse.parse_fast(seq)\n   local kind, col, row = byte(seq,4), byte(seq, 5), byte(seq, 6)\n   kind = kind - 32\n   local m = {row = row - 32, col = col - 32}\n   -- Get button\n   m.button = buttons[kind % 4]\n   -- Get modifiers\n   kind = rshift(kind, 2)\n   m.shift = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.meta = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.ctrl = kind % 2 == 1\n   kind = rshift(kind, 1)\n   m.moving = kind % 2 == 1\n   -- we skip a bit that seems to just mirror .moving\n   m.scrolling = kind == 2\n   return m\nend\n\n\n\n\n\n\n\n\nfunction mouse.parse(seq)\n   if mouse.ismousemove(seq) then\n      return mouse.parsefast(seq)\n   else\n      return nil, \"sequence was not a mouse move\", seq\n   end\nend\n\n\n\n\n\nfunction anterm.alternate_screen(use_alt)\n  return CSI .. \"?47\" .. (use_alt and \"h\" or \"l\")\nend\n\n\n\n\n\nfunction anterm.paste_bracketing(bracket_enable)\n   return CSI .. \"?2004\" .. (bracket_enable and \"h\" or \"l\")\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal report = {}\n\nfunction report.area()\n   return \"\\x1b[18t\"\nend\nanterm.report = report\n\n\n\n\n\n\n\n\n\nlocal totty = {}\nlocal lines = assert(core.lines)\nlocal collect = assert(core.collect)\n\n\n\n\n\n\n\n\n\n\n\nfunction totty.nl_to_jumps(str)\n  local l = collect(lines, str)\n  local phrase = \"\"\n  local length = 0\n  for i,v in ipairs(l) do\n    phrase = phrase..v..a.jump.down()..a.jump.back(utf8.width(v))\n    if length < utf8.width(v) then\n      length = utf8.width(v)\n    end\n  end\n  return phrase, length, #l\nend\n\n--- takes a string and a width in columns.\n--  Returns the amount of string which fits the width.\nfunction totty.truncate(str, width)\n  local trunc = utf8.sub(str,1,width)\n  if utf8.len(trunc) == utf8.width(trunc) then\n    return trunc\n  else\n    local i = 1\n    while utf8.width(trunc) > width do\n      -- io.write(\"width is \", utf8.width(trunc), \"  target: \", width, \"\\n\")\n      trunc = utf8.sub(str,1,width-i)\n      i = i + 1\n    end\n    return trunc\n  end\nend\n\n-- takes a string, returning a string which, when printed, will:\n-- print the string as a column, return to the top, and move one beyond\n-- the column thereby printed.\nfunction totty.collimate(str)\n  local phrase, length, lines = totty.nl_to_jumps(str)\n  return phrase..a.jump.up(lines)..a.jump.forward(length)\nend\n\nanterm.totty = totty\n\n\n\n\n\n\n\n\n\n\n\nanterm.iTerm = {}\nlocal iTerm = anterm.iTerm\nlocal LEET = OSC .. \"1337;\"\n\n\n\n\n\n\n\n\nlocal function iTerm__call(_anterm)\n   local term_str = os.getenv \"TERM_PROGRAM\"\n   if term_str == \"iTerm.app\" then\n      return true\n   else\n      return false\n   end\nend\n\nsetmeta(iTerm, {__call = iTerm__call})\n\n\n\n\n\n\n\n\nfunction iTerm.notify(msg)\n   return OSC .. \"9;\" .. msg .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal _iTerm_cursors = { block = 0,\n                         vertical = 1,\n                         underline = 2,\n                         [0] = \'0\', \'1\', \'2\' }\n\nfunction iTerm.cursor_shape(shape)\n   if not _iTerm_cursors[shape] then\n      error(\"bad parameter passed to cursor_shape: \" .. tostring(shape))\n   end\n   return LEET .. \"CursorShape=\" .. _iTerm_cursors[shape] .. \"\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.yank(text)\n   return LEET .. \"CopyToClipboard=general\\a\" .. text\n       .. LEET .. \"EndCopy\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.link(url, slug)\n   return OSC .. \"8;;\" .. url .. \'\\a\' .. slug .. OSC .. \"8;;\\a\"\nend\n\n\n\n\n\n\n\n\n\nfunction iTerm.annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\nfunction iTerm.hidden_annotation(msg, length, col, row)\n   local phrase = msg\n   if length and not (col or row) then\n      phrase = length .. \"|\" .. phrase\n   end\n   if col and row then\n      phrase = phrase .. \"|\" .. length .. \"|\" .. col .. \"|\" .. row\n   end\n   return LEET .. \"AddHiddenAnnotation=\" .. phrase .. \"\\a\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction iTerm.fireworks()\n   return LEET .. \"RequestAttention=fireworks\\a\"\nend\n\n\n\n\n\n\n\n\nfunction iTerm.bounce_icon()\n   return LEET .. \"RequestAttention=yes\\a\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __navigation = {  UP          = \"\\x1b[A\",\n                        DOWN        = \"\\x1b[B\",\n                        RIGHT       = \"\\x1b[C\",\n                        LEFT        = \"\\x1b[D\",\n                        SHIFT_UP    = \"\\x1b[1;2A\",\n                        SHIFT_DOWN  = \"\\x1b[1;2B\",\n                        SHIFT_RIGHT = \"\\x1b[1;2C\",\n                        SHIFT_LEFT  = \"\\x1b[1;2D\",\n                        PAGE_UP     = \"\\x1b[5~\",\n                        PAGE_DOWN   = \"\\x1b[6~\",\n                        HOME        = \"\\x1b[H\",\n                        END         = \"\\x1b[F\",\n                        ALT_UP      = \"\\x1b[1;3A\",\n                        ALT_DOWN    = \"\\x1b[1;3B\",\n                        ALT_RIGHT   = \"\\x1b[1;3C\", -- heh\n                        ALT_LEFT    = \"\\x1b[1;3D\",\n                        CTRL_UP     = \"\\x1b[1;5A\",\n                        CTRL_DOWN   = \"\\x1b[1;5B\",\n                        CTRL_RIGHT  = \"\\x1b[1;5C\",\n                        CTRL_LEFT   = \"\\x1b[1;5D\",\n                        SHIFT_ALT_UP    = \"\\x1b[1;10A\",\n                        SHIFT_ALT_DOWN  = \"\\x1b[1;10B\",\n                        SHIFT_ALT_RIGHT = \"\\x1b[1;10C\",\n                        SHIFT_ALT_LEFT  = \"\\x1b[1;10D\",\n                        TAB        = \"\\t\",\n                        SHIFT_TAB  = \"\\x1b[Z\",\n                        ALT_TAB    = \"\\x1b\\t\",\n                        NEWLINE    = \"\\n\",\n                        RETURN       = \"\\r\",\n                        SHIFT_RETURN = \"\\x1b[13;2u\",\n                        ALT_RETURN   = \"\\x1b\\r\",\n                        CTRL_RETURN  = \"\\x1b[13;5u\",\n                        BACKSPACE      = \"\\x7f\",\n                        ALT_BACKSPACE  = \"\\x1b\\x7f\",\n                        CTRL_BACKSPACE = \"\\x1b[127;5u\",\n                        DELETE      = \"\\x1b[3~\",\n                        ALT_DELETE  = \"\\x1b[3;3~\",\n                        CTRL_DELETE = \"\\x1b[3;5~\",\n                        ESC        = \"\\x1b\",\n                     }\n\n\n\n\n\n\nlocal __alt_nav = {  UP    = \"\\x1bOA\",\n                     DOWN  = \"\\x1bOB\",\n                     RIGHT = \"\\x1bOC\",\n                     LEFT  = \"\\x1bOD\"\n                  }\n\n\n\n\n\n\n\n__alt_nav.ALT_LEFT  = \"\\x1bb\"\n__alt_nav.ALT_RIGHT = \"\\x1bf\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal navigation = {}\n\nfor k,v in pairs(__navigation) do\n   navigation[v] = k\nend\nfor k,v in pairs(__alt_nav) do\n   navigation[v] = k\nend\n\n__navigation, __alt_nav = nil, nil\n\n\n\n\n\n\nlocal __nav_annex = { ALT_UP      = \"\\x1b[1;9A\",\n                      ALT_DOWN    = \"\\x1b[1;9B\",\n                      ALT_RIGHT   = \"\\x1b[1;9C\",\n                      ALT_LEFT    = \"\\x1b[1;9D\", }\n\nfor k, v in pairs(__nav_annex) do\n   navigation[v] = k\nend\n\n__nav_annex = nil\n\n\n\n\n\nanterm.navigation = navigation\n\nfunction anterm.is_nav(seq)\n   if navigation[seq] then\n      return navigation[seq]\n   else\n      return false, \"not a recognized NAV token\", seq\n   end\nend\n\n\n\n\n\n\nlocal PASTE_START = CSI .. \"200~\"\nlocal PASTE_END   = CSI .. \"201~\"\nfunction anterm.is_paste(seq)\n   if seq:sub(1, #PASTE_START) == PASTE_START then\n      assert(seq:sub(-#PASTE_END) == PASTE_END, \"Partial paste encountered\")\n      return true\n   else\n      return false\n   end\nend\n\nfunction anterm.parse_paste(seq)\n   return seq:sub(#PASTE_START + 1, -#PASTE_END - 1)\nend\n\n\n\nreturn anterm\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/input-parser",
hash = "a8565ac4b539973584a9720e6502f551973df29b01afe6f0431b57dace3350f4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier:elpatt\"\nlocal C, Cc, Cg, Ct = L.C, L.Cc, L.Cg, L.Ct\nlocal M, P, R, S, U, V = L.M, L.P, L.R, L.S, L.U, L.V\n\nlocal bit = require \"bit\"\nlocal band, bor, rshift = assert(bit.band), assert(bit.bor), assert(bit.rshift)\n\nlocal concat = assert(table.concat)\nlocal core_table = require \"core:table\"\nlocal addall, keys = assert(core_table.addall), assert(core_table.keys)\n\n\n\n\n\n\nlocal seq_grammar = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naddall(seq_grammar,{\nESC = P\"\\x1b\",\nCSI = V\"ESC\" * P\"[\",\nPs  = (R\"09\" ^ 1) / tonumber,\nany_ctrl = R\"\\x00\\x1f\",\nspecial_ctrl = M{\n   [\"\\t\"]   = \"TAB\",\n   [\"\\r\"]   = \"RETURN\",\n   [\"\\x7F\"] = \"BACKSPACE\",\n   -- Does any terminal ever send this for anything other than a\n   -- Ctrl-J, which we should treat as such?\n   -- [\"\\n\"] = \"NEWLINE\"\n},\n-- Escape is only matched as such if it appears at the end of the input\nbare_ESC = V\"ESC\" * -1 * Cc(\"ESC\"),\n-- Any single character that maps directly to a key name\n-- Ordered choice, so the expression at the end will never match backspace\nbare_char = V\"bare_ESC\" + V\"special_ctrl\" + (U(1) - V\"any_ctrl\"),\nmodifiers = Cg(V\"Ps\" / function(n) return n - 1 end, \"modifiers\")\n})\n\n\n\n\n\n\n\n\n\n\nlocal CSI_tilde_map = {}\nfor k, v in pairs{\n   nil,\n   \"INSERT\",\n   \"DELETE\",\n   nil,\n   \"PAGE_UP\",\n   \"PAGE_DOWN\",\n   \"HOME\",\n   \"END\",\n   nil, nil,\n   \"F1\", \"F2\", \"F3\", \"F4\", \"F5\",\n   nil,\n   \"F6\", \"F7\", \"F8\", \"F9\", \"F10\",\n   nil,\n   \"F11\", \"F12\", \"F13\", \"F14\", \"F15\"\n} do\n   CSI_tilde_map[tostring(k)] = v\nend\n\nseq_grammar.CSI_tilde_seq = V\"CSI\" *\n   Cg(M(CSI_tilde_map), \"key\") *\n   (P\";\" * V\"modifiers\")^-1 *\n   P\"~\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal CSI_letter_map = {\n   A = \"UP\",\n   B = \"DOWN\",\n   C = \"RIGHT\",\n   D = \"LEFT\",\n   F = \"END\",\n   H = \"HOME\",\n   P = \"F1\",\n   Q = \"F2\",\n   R = \"F3\",\n   S = \"F4\",\n   -- There\'s a legacy of encoding Shift-Tab as CSI Z, and under CSI u\n   -- combinations containing Shift-Tab (e.g. Ctrl-Shift-Tab) are modified\n   -- on top of that similar to other letters. We\'ll put the Shift modifier\n   -- where it belongs later, for now just get this parsed somehow\n   Z = \"SHIFT_TAB\"\n}\n\nseq_grammar.CSI_letter_special_key = V\"CSI\" *\n   (P\"1;\" * V\"modifiers\")^-1 *\n   Cg(M(CSI_letter_map), \"key\")\n\n\n\n\n\n\n\n\n\n\nlocal utf8_char = assert(require \"lua-utf8\" . char)\nseq_grammar.CSIu_seq = V\"CSI\" *\n              Cg(V\"Ps\" / utf8_char, \"key\") *\n              P\";\" *\n              V\"modifiers\" *\n              P\"u\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ctrl_char_convert(ch)\n   if ch:byte() == 0 then\n      return \" \"\n   else\n      -- We represent letters as lowercase, but the symbols are still those\n      -- adjacent to the uppercase letters\n      return string.char(ch:byte() + (\"@\"):byte()):lower()\n   end\nend\n\naddall(seq_grammar, {\nALT_seq      = V\"ESC\" * Cg(V\"bare_char\", \"key\") *\n               Cg(Cc(2), \"modifiers\"),\nCTRL_char    = Cg((V\"any_ctrl\" - V\"special_ctrl\" - V\"ESC\") / ctrl_char_convert, \"key\"),\nCTRL_seq     = V\"CTRL_char\" *\n               Cg(Cc(4), \"modifiers\"),\nCTRL_ALT_seq = V\"ESC\" * V\"CTRL_char\" *\n               Cg(Cc(6), \"modifiers\")\n})\n\n\n\n\n\n\nlocal key_seq = (Cg(V\"bare_char\", \"key\") +\n          V\"CSIu_seq\" + V\"CSI_tilde_seq\" + V\"CSI_letter_special_key\" +\n          V\"CTRL_ALT_seq\" + V\"ALT_seq\" + V\"CTRL_seq\") *\n          Cg(Cc(\"keypress\"), \"type\")\n\nlocal key_modifiers = {\n   shift = 1,\n   alt   = 2,\n   ctrl  = 4\n}\n\nlocal function parse_modifiers(event, modifier_flags)\n   for key, mask in pairs(modifier_flags) do\n      event[key] = band(event.modifiers, mask) ~= 0\n   end\nend\n\nseq_grammar.key_seq = Ct(key_seq) / function(event)\n   event.modifiers = event.modifiers or 0\n   -- Convert CSI Z\n   if event.key == \"SHIFT_TAB\" then\n      event.modifiers = bor(event.modifiers, key_modifiers.shift)\n      event.key = \"TAB\"\n   end\n   parse_modifiers(event, key_modifiers)\n   return event\nend\n\n\n\n\n\n\n\n\n\n\nlocal byteR = assert(require \"lpeg\" . R)\nseq_grammar.x10_number = byteR\"\\x20\\xff\" / function(ch)\n   return ch:byte() - 32\nend\nlocal mouse_seq = V\"CSI\" * P\"M\" *\n                  Cg(V\"x10_number\", \"kind\") *\n                  Cg(V\"x10_number\", \"col\") *\n                  Cg(V\"x10_number\", \"row\") *\n                  Cg(Cc(\"mouse\"), \"type\")\n\n-- Although xterm uses Alt as Meta if no Meta is specifically declared,\n-- they are distinct keys, and in fact iTerm on macOS uses the Command key\n-- as Meta by default\nlocal mouse_modifiers = {\n   shift = 1,\n   meta  = 2,\n   ctrl  = 4\n}\n\nlocal buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}\n\nseq_grammar.mouse_seq = Ct(mouse_seq) / function(event)\n   event.button = buttons[event.kind % 4]\n   event.modifiers = band(rshift(event.kind, 2), 7)\n   parse_modifiers(event, mouse_modifiers)\n   event.moving = band(event.kind, 2 ^ 5) ~= 0\n   event.scrolling = band(event.kind, 2 ^ 6) ~= 0\n   event.kind = nil\n   return event\nend\n\n\n\n\n\n\n\n\n\naddall(seq_grammar, {\n   paste_bracket_start = V\"CSI\" * P\"200~\",\n   paste_bracket_end   = V\"CSI\" * P\"201~\",\n   bracketed_paste     = V\"paste_bracket_start\" *\n      Cg((P(1) - V\"paste_bracket_end\") ^ 0, \"text\") * (\n         -- If we reach the end of the string without encountering the\n         -- closing escape sequence, still treat this as a paste--\n         -- we never want to reinterpret the =CSI 200 ~= sequence as\n         -- =Alt-[= =2= =0= ..etc...\n         V\"paste_bracket_end\" +\n         P(-1) * Cg(Cc(true), \"error\")\n      ) * Cg(Cc(\"paste\"), \"type\")\n})\n\nseq_grammar.special_seq = Ct(V\"bracketed_paste\")\n\n\n\n\n\n\nseq_grammar[1] = Ct((V\"special_seq\" + V\"mouse_seq\" + V\"key_seq\") ^ 1) * -1\nseq_grammar = P(seq_grammar)\n\nreturn function(seq)\n   return seq_grammar:match(seq)\nend\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/cursor",
hash = "93a8fb4514866a8890c0f95947fec56ba86ce826281cfd791bd6e205f58a4866",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Point = require \"anterm/point\"\nlocal Rectangle = require \"anterm/rectangle\"\nlocal instanceof = assert(require \"core/meta\" . instanceof)\n\n\n\nlocal cursor = {}\n\nlocal CSI = \'\\x1b[\'\nlocal OSC = \'\\x1b]\'\n\n\n\nfunction cursor.stash()\n   return \"\\x1b7\"\nend\n\nfunction cursor.pop()\n   return \"\\x1b8\"\nend\n\nfunction cursor.hide()\n   return \"\\x1b[?25l\"\nend\n\nfunction cursor.show()\n   return \"\\x1b[?25h\"\nend\n\n\n\n\n\nlocal jump = {}\n\nfor dir, letter in pairs {\n   up    = \"A\",\n   down  = \"B\",\n   right = \"C\",\n   left  = \"D\",\n   nl    = \"E\",\n   col   = \"G\"\n} do\n   jump[dir] = function(num)\n      num = num or 1\n      return num == 0 and \"\" or CSI..num..letter\n   end\nend\njump.forward = jump.right\njump.back    = jump.left\n\nlocal function _jump(row, col)\n   if instanceof(row, Point) then\n      row, col = row:rowcol()\n   end\n   return CSI .. row .. \";\" .. col .. \"H\"\nend\n\nlocal J = { __call = function(_, ...) return _jump(...) end }\nsetmetatable(jump,J)\n\njump.rc = _jump\njump.rowcol = _jump\n\nfunction jump.colrow(col, row)\n   return _jump(row, col)\nend\n\n\n\n\n\n\n\nlocal erase = {}\n\nfor key, value in pairs {\n   below = \"0J\",\n   above = \"1J\",\n   all   = \"2J\",\n   right = \"0K\",\n   left  = \"1K\",\n   line  = \"2K\"\n} do\n   local escape = CSI .. value\n   erase[key] = function() return escape end\nend\n\n\n\n\n\n\n\nlocal rep = assert(string.rep)\nfunction erase.box(rect, dash)\n   dash = dash or \" \"\n   rect:assertNotEmpty(\"Cannot erase empty region\")\n   local phrase = cursor.stash() .. _jump(rect:origin())\n   local blanks = rep(dash, rect:width())\n   local nl = jump.col(rect.left) .. jump.down(1)\n   for i = 1, rect:height() do\n      phrase = phrase .. blanks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\n\n\nlocal random = assert(math.random)\n\nfunction erase.checker(rect, dash, mod)\n   mod = mod or 3\n   dash = dash or \".\"\n   local space = jump.forward()\n   rect:assertNotEmpty(\"Cannot erase empty region\")\n   local skip = random(1, mod)\n   local phrase = cursor.stash()\n               .. _jump(rect:origin())\n\n   local nl = jump.col(rect.left) .. jump.down(1)\n   for i = 1, rect:height() do\n      local checks = \"\"\n      for j = 1, rect:width() do\n         if skip % mod == 0 then\n            checks = checks .. dash\n         else\n            checks = checks .. space\n         end\n         skip = skip + 1\n      end\n      phrase = phrase .. checks .. nl\n   end\n   return phrase .. cursor.pop()\nend\n\n\n\ncursor.jump = jump\ncursor.erase = erase\n\nreturn cursor\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/box",
hash = "096c5c975f8a151aa4eb581230ea8547990c91eac099599c9732ecb049c0b964",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal box_parts = { \"horiz\", \"vert\",\n                    \"tl_square\", \"tr_square\", \"bl_square\", \"br_square\",\n                    \"left_tee\", \"top_tee\", \"right_tee\", \"bottom_tee\", \"cross\" }\nlocal boxen = {}\n\n\n\n\n\n\n\n\nboxen.light = { \"─\", \"│\",\n                \"┌\", \"┐\", \"└\", \"┘\",\n                \"├\", \"┬\", \"┤\", \"┴\", \"┼\" }\n\n\n\n\n\n\n\n\nboxen.heavy = { \"━\", \"┃\",\n                \"┏\", \"┓\", \"┗\", \"┛\",\n                \"┣\", \"┳\", \"┫\", \"┻\", \"╋\" }\n\n\n\n\n\n\n\n\nboxen.double = { \"═\", \"║\",\n                 \"╔\", \"╗\", \"╚\", \"╝\",\n                 \"╠\", \"╦\", \"╣\", \"╩\", \"╬\" }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:meta\" . meta)\nlocal Rectangle = require \"anterm:rectangle\"\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal jump = assert(require \"anterm:cursor\" . jump)\nlocal Box = meta {}\n\n\n\n\n\n\n\n\nlocal function _addLineUsing(phrase, left, middle, right, line, ...)\n   local column_widths = {...}\n   for i, cols in ipairs(column_widths) do\n      insert(phrase, i == 1 and left or middle)\n      insert(phrase, line:rep(cols))\n   end\n   insert(phrase, right)\nend\n\nlocal function _lineUsing(box, fn, ...)\n   local phrase = {}\n   box[fn](box, phrase, ...)\n   return concat(phrase)\nend\n\nfunction Box.addTopLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.tl_square, box.top_tee, box.tr_square, box.horiz, ...)\nend\nfunction Box.topLine(box, ...)\n   return _lineUsing(box, \"addTopLine\", ...)\nend\n\nfunction Box.addSpanningLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.left_tee, box.cross, box.right_tee, box.horiz, ...)\nend\nfunction Box.spanningLine(box, ...)\n   return _lineUsing(box, \"addSpanningLine\", ...)\nend\n\nfunction Box.addBottomLine(box, phrase, ...)\n   return _addLineUsing(phrase, box.bl_square, box.bottom_tee, box.br_square, box.horiz, ...)\nend\nfunction Box.bottomLine(box, ...)\n   return _lineUsing(box, \"addBottomLine\", ...)\nend\n\n\n\n\n\n\n\n\n\n\n-- #todo consider extending to support multiple columns?\nfunction Box.addContentLine(box, phrase, ...)\n   local column_widths = {...}\n   local total_width = 0\n   for _, width in ipairs(column_widths) do\n      insert(phrase, box.vert)\n      insert(phrase, jump.forward(width))\n      total_width = total_width + width + 1\n   end\n   insert(phrase, box.vert)\n   -- Leave 1 column of left padding\n   insert(phrase, jump.back(total_width - 1))\nend\nfunction Box.contentLine(box, ...)\n   return _lineUsing(box, \"addContentLine\", ...)\nend\n\n\n\n\n\n\n\n\n\nfunction Box.__call(box, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectange(rect, ...)\n   end\n   local width = rect:width()\n   local phrase = {}\n   insert(phrase, jump(rect:origin()))\n   box:addTopLine(phrase, width - 2)\n   local backup  = jump.back(width) .. jump.down(1)\n   local forward = jump.forward(width - 2)\n   for j = 1, rect:height() - 2 do\n      -- jump back and forth\n      insert(phrase, backup)\n      insert(phrase, box.vert) -- │\n      insert(phrase, forward)\n      insert(phrase, box.vert)\n   end\n   insert(phrase,backup)\n   box:addBottomLine(phrase, width - 2)\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nlocal box = {}\nfor box_type, slug in pairs(boxen) do\n   local this_box = meta(Box)\n   for i = 1, #box_parts do\n      this_box[box_parts[i]] = slug[i]\n   end\n   box[box_type] = this_box\nend\n\n\n\nreturn box\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/point",
hash = "aa0a1f90d79c547e1a5c3e8830a5337f95451d8c858c33d9e431214809f09c2f",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal meta = assert(require \"core/meta\" . meta)\nlocal Point = meta {}\nlocal new\n\n\n\n\n\n\n\nfunction Point.rowcol(point)\n   return point.row, point.col\nend\nfunction Point.colrow(point)\n   return point.col, point.row\nend\n\n\n\n\n\nfunction Point.__eq(point, other)\n   return point.row == other.row and\n          point.col == other.col\nend\n\n\n\n\n\n\n\n\nlocal instanceof = assert(require \"core/meta\" . instanceof)\nfunction Point.__add(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row + other, point.col + other)\n   elseif instanceof(other, new) then\n      return new(point.row + other.row, point.col + other.col)\n   else\n      error(\"Cannot add \" .. type(other) .. \" to Point\")\n   end\nend\n\nfunction Point.__unm(point)\n   return new(-point.row, -point.col)\nend\n\nfunction Point.__sub(point, other)\n   return point + -other\nend\n\nfunction Point.__mul(point, other)\n   if not instanceof(point, new) then\n      local tmp = point\n      point = other\n      other = tmp\n   end\n   if type(other) == \"number\" then\n      return new(point.row * other, point.col * other)\n   elseif instanceof(other, new) then\n      return new(point.row * other.row, point.col * other.col)\n   else\n      error(\"Cannot multiply Point by \" .. type(other))\n   end\nend\n\nfunction Point.__div(point, other)\n   if not instanceof(point, new) then\n      if type(point) ~= \"number\" then\n         error(\"Cannot divide \" .. type(point) .. \" by Point\")\n      end\n      point = new(point, point)\n   elseif not instanceof(other, new) then\n      if type(other) ~= \"number\" then\n         error (\"Cannot divide Point by \" .. type(other))\n      end\n      other = new(other, other)\n   end\n   return new(point.row / other.row, point.col / other.col)\nend\n\n\n\n\n\n\n\nlocal floor, ceil = assert(math.floor), assert(math.ceil)\nfunction Point.floor(point)\n   return new(floor(point.row), floor(point.col))\nend\nfunction Point.ceil(point)\n   return new(ceil(point.row), ceil(point.col))\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Point.__repr(point, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Point\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      yield(nameFor(point.row))\n      yield(Token(\", \", { color = \"operator\" }))\n      yield(nameFor(point.col))\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\n\n\nnew = function(row, col)\n   local point = meta(Point)\n   point.row = assert(row)\n   point.col = assert(col)\n   return point\nend\n\n\n\nPoint.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "ac0be24955b6ad8f7c78db9b5b01aa4fb0677565",
name = "anterm/rectangle",
hash = "a8d088db473046aefeed644da59ac5298ef0dd1cf790fa2c42e0daa9d6af2c80",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal core_meta = require \"core:meta\"\nlocal meta, instanceof = assert(core_meta.meta), assert(core_meta.instanceof)\nlocal Point = require \"anterm/point\"\nlocal Rectangle = meta {}\nlocal new\n\n\n\n\n\n\n\nfunction Rectangle.width(rect)\n   return rect.right - rect.left + 1\nend\nfunction Rectangle.height(rect)\n   return rect.bottom - rect.top + 1\nend\nfunction Rectangle.extent(rect)\n   return Point(rect:height(), rect:width())\nend\n\n\n\n\n\nfunction Rectangle.origin(rect)\n   return Point(rect.top, rect.left)\nend\nfunction Rectangle.corner(rect)\n   return Point(rect.bottom, rect.right)\nend\n\n\n\n\n\nfunction Rectangle.intersects(rect, other)\n   return rect.left   <= other.right  and\n          rect.right  >= other.left   and\n          rect.top    <= other.bottom and\n          rect.bottom >= other.top\nend\n\n\n\n\n\n\n\n\n\nfunction Rectangle.contains(rect, point, col)\n   local row\n   if instanceof(point, Point) then\n      row, col = point:rowcol()\n   else\n      row = point\n   end\n   return row >= rect.top  and row <= rect.bottom\n      and col >= rect.left and col <= rect.right\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rectangle.insetBy(rect, offset)\n   if not instanceof(offset, Point) then\n      offset = Point(offset, offset)\n   end\n   return new(rect.top    + offset.row,\n              rect.left   + offset.col,\n              rect.bottom - offset.row,\n              rect.right  - offset.col)\nend\n\n\n\n\n\nfunction Rectangle.__eq(rect, other)\n   return rect.left   == other.left   and\n          rect.top    == other.top    and\n          rect.right  == other.right  and\n          rect.bottom == other.bottom\nend\n\n\n\n\n\nlocal assertfmt = assert(require \"core/fn\" . assertfmt)\nfunction Rectangle.assertNotEmpty(rect, msg)\n   msg = msg or \"Empty rectangle\"\n   assertfmt(rect:height() > 0, \"%s: top: %d bottom: %d\", msg, rect.top, rect.bottom)\n   assertfmt(rect:width() > 0, \"%s: left: %d right: %d\", msg, rect.left, rect.right)\nend\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal Token, nameFor\nfunction Rectangle.__repr(rect, window, c)\n   return wrap(function()\n      Token = Token or require \"repr:token\"\n      nameFor = nameFor or assert(require \"repr:names\" . nameFor)\n      yield(Token(\"Rectangle\", { color = \"field\" }))\n      yield(Token(\"(\", { color = \"operator\" }))\n      for i, k in ipairs{\"top\", \"left\", \"bottom\", \"right\"} do\n         if i ~= 1 then\n            yield(Token(\", \", { color = \"operator\" }))\n         end\n         yield(nameFor(rect[k]))\n      end\n      yield(Token(\")\", { color = \"operator\" }))\n   end)\nend\n\n\n\n\n\nnew = function(top, left, bottom, right)\n   local rect  = meta(Rectangle)\n   rect.top    = assert(top)\n   rect.left   = assert(left)\n   rect.bottom = assert(bottom)\n   rect.right  = assert(right)\n   return rect\nend\n\n\n\nRectangle.idEst = new\nreturn new\n\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/bridge",
    repo_alternates = "https://gitlab.special-circumstanc.es/atman/br.git",
    home = "",
    website = "",
    name = "br",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "letters/mikemike",
hash = "ddb756597b1b1a21c36847fc1ad03cf4f94029b95e75b3822ed0b26853916b02",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _doSeveralThings(obj)\n   obj:doFirstThing()\n   yield(obj:secondMessage(_passed))\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "s/kore/status",
hash = "9b40f01d5c9c80ad53b1272377b901b4d2e6bffcea4a5be6d41c8f63dbfe0357",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- #todo this should just be anterm\nlocal a = pcall(require, \"anterm\") or require \"ansi\"\nlocal debug = require \"debug\"\n\nlocal status = {}\n\nstatus.DjikstraWasRight = true -- I swear I\'m going to use this for something. Watch.\n\nstatus.chatty = true\nstatus.verbose = false\nstatus.grumpy = true\nstatus.angry = true\n\nstatus.traceOnComplain = true\n\n-- ** Status:halt(message)\n--\n--   This dies in pipeline modes.\n--\n-- In the fleshed-out Lun/Clu environment, this will pause execution\n-- and present as much of a debugger as it can.\n\nfunction status.halt(statusQuo, message, exitCode)\n    local bye = exitCode or 1\n    io.write(message.. \"\\n\")\n    assert(false)\n    os.exit(bye)\nend\n\nfunction status.chat(statusQuo, message)\n    if statusQuo.chatty then\n        io.write(message .. \"\\n\")\n    end\nend\n\nfunction status.verb(statusQuo, message)\n    if statusQuo.verbose then\n        io.write(message .. \"\\n\")\n    end\nend\n\n\n-- Complaints are recoverable problems that still shouldn\'t happen.\n--\n--  Almost time to orbify the library collection...\n--  The value parameter is being passed in so improved Status can\n--  do things with it.\n--\nfunction status.complain(statusQuo, topic, message, value)\n    if not message then\n        message = topic\n    else\n        topic = a.red(topic)\n    end\n    if statusQuo.grumpy then\n        io.write(topic .. \": \" .. message .. \"\\n\")\n    end\n    if statusQuo.traceOnComplain then\n        io.write(debug.traceback())\n    end\n    if statusQuo.angry then\n        os.exit(1)\n    end\nend\n\nlocal function call(statusQuo)\n    return setmetatable({}, {__index = statusQuo, __call = call})\nend\n\n\nreturn setmetatable(status, {__call = call})\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "s/kore/color",
hash = "4103fe9aaa6844fd0f9451fe98f6c0b3614a1e75847a66cdc767d6dcc3de89c2",
branch = "master",
binary = "\n\n\n\n\nlocal a = require \"kore/ansi\"\n\nlocal C = {}\nC.color = {}\nC.color.number = a.fg(42)\nC.color.string = a.fg(222)\nC.color.table  = a.fg(64)\nC.color.func   = a.fg24(210,12,120)\nC.color.truth  = a.fg(231)\nC.color.falsehood  = a.fg(94)\nC.color.nilness   = a.fg(93)\nC.color.field  = a.fg(111)\n\nC.color.alert = a.fg24(250, 0, 40)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hints = { field = C.color.field,\n                  fn  = C.color.func }\n\nlocal anti_G = {}\n\nfor k, v in pairs(_G) do\n   anti_G [v] = k\nend\n\nfunction C.ts(value, hint)\n   local c = C.color\n   local str = tostring(value)\n   if hint == \"\" then\n      return str -- or just use tostring()?\n   end\n   if hint then\n      return hints[hint](str)\n   end\n\n   local typica = type(value)\n   if typica == \'number\' then\n      str = c.number(str)\n   elseif typica == \'table\' then\n      str = c.table(str)\n   elseif typica == \'function\' then\n      if anti_G[value] then\n         -- we have a global name for this function\n         str = c.func(anti_G[value])\n      else\n         local func_handle = \"func:\" .. string.sub(str, -6)\n         str = c.func(func_handle)\n      end\n   elseif typica == \'boolean\' then\n      str = value and c.truth(str) or c.falsehood(str)\n   elseif typica == \'string\' then\n      str = c.string(str)\n   elseif typica == \'nil\' then\n      str = c.nilness(str)\n   end\n   return str\nend\n\n\n\nreturn C\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "cluster/idEst",
hash = "2fb7ce2117fc679dec89e0d1f8a69cc5353e337835ad1f3d131a7af0911388f1",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\nNode = require \"espalier:espalier/node\"\n\nnode = Node(\"a new node\")\n\nif node.idEst == Node then\n   -- do class-specific stuff here\nend\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "s/kore/ansi",
hash = "f9a3cff6a40f56ea70864a0170fa3cf3501fc1d0c9f07391b8e2b14ae7a1a869",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = pairs\nlocal tostring = tostring\nlocal setmetatable = setmetatable\nlocal error = error\nlocal require = require\nlocal rawget = rawget\nlocal io = io\nlocal schar = string.char\n\nlocal _M = {}\n\n\nlocal colormt = {}\n\nlocal colors = {\n    -- attributes\n    attribute = {\n        reset = 0,\n        clear = 0,\n        bright = 1,\n        dim = 2,\n        underscore = 4,\n        blink = 5,\n        reverse = 7,\n        hidden = 8},\n    -- foreground\n    fg = {\n        black = 30,\n        red = 31,\n        green = 32,\n        yellow = 33,\n        blue = 34,\n        magenta = 35,\n        cyan = 36,\n        white = 37,\n        clear_fg = 39  },\n    -- background\n    bg = {\n        onblack = 40,\n        onred = 41,\n        ongreen = 42,\n        onyellow = 43,\n        onblue = 44,\n        onmagenta = 45,\n        oncyan = 46,\n        onwhite = 47,\n        clear_bg = 49}\n}\n\nlocal function makecolor(value, name, kind)\n    local color = {\n        value = schar(27)..\'[\'..tostring(value)..\'m\',\n        name = name,\n        kind = kind }\n    return setmetatable(color, colormt)\nend\n\nfor kind, val in pairs(colors) do\n    for c, v in pairs(val) do\n        _M[c] = makecolor(v, c, kind)\n    end\nend\n\nfunction colormt:__tostring()\n    return self.value\nend\n\nfunction colormt:__concat(other)\n    return tostring(self) .. tostring(other)\nend\n\n\nlocal function reset(color)\n    -- given a color, reset its action.\n    -- simple for fg and bg\n    -- complex but tractable for attributes\n    if color.kind == \"fg\" then\n        return _M.clear_fg\n    elseif color.kind == \"bg\" then\n        return _M.clear_bg\n    elseif color.kind == \"attribute\" then\n        --error \"attribute reset NYI\"\n        return _M.clear\n    end\nend\n\nfunction colormt:__call(s)\n    if s then\n        return tostring(self) .. s .. reset(self)\n    else\n        return tostring(self)\n    end\nend\n\ncolormt.__metatable = {}\n\nlocal function byte_panic(byte_p)\n       if not byte_p or not (0 <= byte_p and byte_p <= 255) then\n        error \"xterm value must be 8 bit unsigned\"\n    end\nend\n\nlocal function ansi_fg(byte)\n    local store = {} -- repeated allocation is a sin.\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[38;5;\"..byte..\"m\",\n                        kind = \"fg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function ansi_bg(byte)\n    local store = {}\n    local function make (byte)\n        byte_panic(byte)\n        local color = { value = schar(27)..\"[48;5;\"..byte..\"m\",\n                        kind = \"bg\" }\n        return setmetatable(color, colormt)\n    end\n    if store[byte] then\n        return store[byte]\n    else\n        local color = make(byte)\n        store[byte] = color\n        return color\n    end\nend\n\nlocal function fg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[38;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"fg\" }\n   return setmetatable(color, colormt)\nend\n\nlocal function bg24(r,g,b)\n   byte_panic(r)\n   byte_panic(g)\n   byte_panic(b)\n   local color = { value = schar(27) .. \"[48;2;\"\n                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",\n                   kind = \"bg\" }\n   return setmetatable(color, colormt)\nend\n\n_M[\"fg\"], _M[\"bg\"] = ansi_fg, ansi_bg\n\n_M[\"fg24\"], _M[\"bg24\"] = fg24, bg24\n\n--- Jumps\n\nlocal jump = {}\n\nlocal CSI = schar(27)..\'[\'\n\njump.up = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"A\"\nend\n\njump.down = function(num)\n    if not num then num = \"\" end\n        return CSI..num..\"B\"\nend\n\njump.forward = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"C\"\nend\n\njump.back = function(num)\n    if not num then num = \"\" end\n    return CSI..num..\"D\"\nend\n\nlocal function Jump(_,row,column)\n    return CSI..row..\";\"..column..\"H\"\nend\n\nlocal J = { __call = Jump}\nsetmetatable(jump,J)\n\n_M[\"jump\"] = jump\n\n\nreturn _M\n\n\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "design/lun",
hash = "47adf325fa39924ba8afc3f798a33519e2e5cfb7752177bc0d6d0e85f9e00e0b",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wallet = {} -- must declare local\n\nlocal function stash(cash)\n   wallet[#wallet + 1] = cash\n   return wallet\nend\n\nlocal function grab()\n   local module_wallet = wallet\n   local wallet = {}\n   wallet[#wallet + 1] = module_wallet[#module_wallet]\n   return wallet\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobj:method(first):method(second, v):third()\n\n",
},
  { 
vc_hash = "a61b013e0e3493440cbffebb4cf94a4c9df4b412",
name = "s/kore/check",
hash = "e70d49711816ae27deb15bff7edbd49892fa2887f58e50dad537a0333b198cbf",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = require \"kore/color\"\nlocal ts = c.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ItIndex(Itself, verb)\n\tif verb == \"won\" or verb == \"did\" then\n\t\treturn nil\n\tend\n\tverb = verb and verb or \"\"\n\tlocal it = Itself.current\n\tlocal result = {success = false}\n\tresult.why = \"`check` does not understand the verb \" .. ts(verb)\n\t\t\t\t\t.. \" at least, not yet\"\n\tio.write(result.why .. \"\\n\")\n\tit.did.also(result)\n\treturn function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal call = function (it)\n\tif it.won == nil then\n\t\tit = it:collate()\n\tend\n\tif it.won then\n\t\treturn it.subject, it\n\telse\n\t\treturn nil, it\n\tend\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n\tif Object.isIt and Object.isIt == It then\n\t\treturn Object\n\tend\n\n\tlocal itself = setmetatable({}, {__index = It,\n\t\t                              __call = call})\n\tIt.current  = itself  -- THIS IS NOT RE_ENTRANT FIND A BETTER WAY\n\titself.isIt = It\n\titself.name = name and name or \"it\"\n\titself.subject = Object\n\titself = must(itself)\n\titself.did = {}\n\titself.did.also = function(result)\n\t\t\t\t\t\t result.modal = itself.modal\n\t\t                 itself.did[#itself.did + 1] = result\n\t\t                 return itself\n\t\t              end\n \titself.did.last = function() return itself.did[#itself.did] end\n\n\treturn itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\nlocal function verdict(it, subject, verb, object)\n\tlocal subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n\treturn it.name .. \": \" .. subj .. it.modal.inThatIt\n\t       .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal must = setmetatable({}, Modal)\n\tmust.beTrue = true\n\tmust.because = because\n\tmust.inThatIt = \"must\"\n\tit.modal = must\n\treturn it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n\tassert(it.isIt == It, \"it isn\'t It\")\n\tlocal mustnt = setmetatable({}, Modal)\n\tmustnt.because = because or \"\"\n\tmustnt.beTrue = false\n\tmustnt.inThatIt = \"mustn\'t\"\n\tit.modal = mustnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n\tlocal should = setmetatable({}, Modal)\n\tshould.because = because or \"\"\n\tshould.beTrue = true\n\tshould.inThatIt = \"should\"\n\tit.modal = should\n\treturn it\nend\n\nfunction It.shouldnt(it, because)\n\tlocal shouldnt = setmetatable({}, Modal)\n\tshouldnt.because = because or \"\"\n\tshouldnt.beTrue = false\n\tshouldnt.inThatIt = \"shouldn\'t\"\n\tit.modal = shouldnt\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n\tlocal result = {}\n\tlocal success = it.subject == rValue and true or false\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tif success then\n\t\tresult.why =  verdict(it, it.subject, \"equal\", rValue)\n\telse\n\t\tresult.why = verdict(it, it.subject, \"not equal\", rValue)\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal having = it.subject[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having[field]\n\tif having then\n\t\tsuccess = true\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tlocal clause = \" -> \" .. ts(having)\n\tif success then\n\t\tresult.why =  because or it.modal.inThatIt .. \" have .\"\n\t\t              .. ts(field, \"field\") .. clause\n\telse\n\t\tresult.why =  because or it.modal.inThatIt .. \" not have .\"\n\t\t                 .. ts(field, \"field\") .. clause\n\tend\n\n\tresult.having = having\n\tresult.field  = field\n\tresult.success = success\n\tit.did.also(result)\n\n\treturn it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did.last()\n\tlocal having = last.having\n\n\tif having == nil then\n\t\t-- todo better message if \'has\' failed,\n\t\t-- the more common case.\n\t\tresult.why = \"equalTo must follow have/has\"\n\telse\n\t\tsuccess = having == rValue and true or false\n\t\tlocal subj, obj\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\t\tsubj, obj = having, rValue\n\t\telse\n\t\t\tsubj, obj = rValue, having\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because or verdict(it, subj, \"==\", obj)\n\t    else\n\t    \tresult.why = because or verdict(it, subj, \"~=\", obj)\n\t    end\n\t    result.having = having -- to chain field checks\n\tend\n\n\tresult.success = success\n\treturn it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n\tlocal result = {}\n\tlocal success = false\n\tlocal last = it.did[#it.did]\n\tlocal having = last.having\n\tif type(len) ~= \"number\" then\n\t\tresult.why = \"ofLen param must be a number\"\n\telseif not having then\n\t\tresult.why = \"ofLen must have a value on it.did\"\n\telse\n\t\tsuccess = #having == len and true or false\n\t\tif not it.modal.beTrue then\n\t\t\tsuccess = not success\n\t\tend\n\t\tif success then\n\t\t\tresult.why = because\n\t\t\t             or verdict(it, \"#\" .. ts(having), \"==\", len)\n\t    else\n\t    \tresult.why = because\n\t    \t             or verdict(it, \"#\" .. ts(having), \"~=\", len)\n\t    end\n\tend\n\n\tresult.success = success\n\tresult.inThatIt = it.modal.inThatIt\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n\tlocal result = { success = false,\n                     why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n\treturn {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n\tlocal method = last.having\n\tif not method then\n\t\tresult.why = \"calling must be performed on a value\"\n\telseif not type(method) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name .. \" field must be function: \" .. last.field)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = method(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.field  = last.field\n\t\tlocal callee = ts(last.field, \"field\") .. \"(\"\n\t\tif result.arg and result.arg.n >= 1 then\n\t\t\tfor i = 1, result.arg.n do\n\t\t\t\tcallee = callee .. ts(result.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tcallee = string.sub(callee, 1, -3)\n\t\tend\n\t\tcallee = callee .. \")\"\n\t\tresult.why    = verdict(it, \"\", \"be callable with\", callee)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n\t\t-- #todo add a check for callable tables\n\t\tresult.why = verdict(it.name\n\t\t\t          .. \" passedTo needs a function: \" .. fn)\n\telse\n\t\tsuccess = true\n\t\tresult.arg = pack(...)\n\t\tlocal b, c, d, e\n\t\tresult.answer, b, c, d, e = fn(it.subject, ...)\n\t\tif b then\n\t\t\tresult.b, result.c, result.d, result.e = b, c, d, e\n\t\tend\n\t\tresult.fn     = fn\n\t\tresult.why    = verdict(it, \"\", \"be passed to\", fn)\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\tresult.success = success\n\n\treturn it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n\tlocal success = false\n\tlocal result = {}\n\tlocal last = it.did.last()\n\tlocal answer = last.answer\n\tif answer == nil then\n\t\tresult.why = \"prior clause must provide an answer\"\n\telse\n\t\t-- build strings for verdict\n\t\tlocal callee = \":anon:\"\n\t\tif last.field then\n\t\t\tcallee = it.name .. ts(\":\" ..last.field, \"field\")\n\t\telseif last.fn then\n\t\t\tcallee = ts(last.fn)\n\t\tend\n\t\tlocal param = \"(\"\n\t\tif last.fn then\n\t\t\tparam = param .. it.name\n\t\tend\n\t\tif last.arg and last.arg.n >= 1 then\n\t\t\tif last.fn then param = param .. \", \" end\n\t\t\tfor i = 1, last.arg.n do\n\t\t\t\tparam = param .. ts(last.arg[i]) .. \", \"\n\t\t\tend\n\t\t\tparam = string.sub(param, 1, -3)\n\t\tend\n\t\tparam = param .. \")\"\n\n\t\tlocal isSame = answer == rValue and true or false\n\t\tif isSame then\n\t\t\tif not last.b then\n\t\t\t\tsuccess = true\n\t\t\t\tresult.why = verdict(it, callee .. param, \"give\", ts(answer))\n\t\t\telseif b then\n\t\t\t\tlocal gives = {ts(answer)}\n\t\t\t\tlocal is_b_same  = last.b == b and true or false\n\t\t\t\tgives[2] = ts(last.b)\n\t\t\t\tsuccess = true and is_b_same\n\t\t\t\tresult.why = vertict(it, callee .. param, \"give\", gives[1]\n\t\t\t\t\t          .. \" \" .. gives[2])\n\t\t\tend\n\t\telse\n\t\t\tresult.why = it.name .. \":\" .. callee .. param .. \" \" .. it.modal.inThatIt\n\t\t\t              .. \" give \" .. ts(rValue) .. \" not \" .. ts(answer)\n\t\tend\n\tend\n\tif not it.modal.beTrue then\n\t\tsuccess = not success\n\tend\n\n\tresult.success = success\n\n\n\treturn it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n\treturn it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n\tphrase = \"\"\n\tlocal Yes, No\n\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\tYes, No = \"✅   \",  \"❌   \"\n\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\tYes, No = \"🌟   \",  \"😡   \"\n\telseif mood == \"can\" then\n\t\tYes, No = \"👍   \",  \"👎   \"\n\tend\n\tif did.success then\n\t\tphrase = phrase .. \"   \" .. Yes .. did.why\n\telse\n\t\tphrase = phrase .. \"   \" .. No .. did.why\n\tend\n\tphrase = phrase .. \"\\n\"\n\tdid.digest = phrase\n\treturn phrase\nend\n\n\n\n\nfunction It.collate(it)\n\tlocal winning = true\n\tlocal wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n\tlocal musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n\tlocal phrase = it.name .. \":\\n\"\n\tfor _, did in ipairs(it.did) do\n\t\twinning = winning and did.success\n\t\tlocal mood = did.modal.inThatIt\n\t\tlocal digest = digestLine(did, mood)\n\t\tphrase = phrase .. digest\n\n\t\tif mood == \"must\" or mood == \"mustn\'t\" then\n\t\t\tmusts = musts + 1\n\t\t\tif did.success then\n\t\t\t\twins.must = wins.must + 1\n\t\t\tend\n\t\telseif mood == \"should\" or mood == \"shouldn\'t\" then\n\t\t\tshoulds = shoulds + 1\n\t\t\tif did.success then\n\t\t\t\twins.should = wins.should + 1\n\t\t\tend\n\t\tend\n\t-- etc\n\tend\n\tif musts > 0 then\n\t\tphrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n\tend\n\tif shoulds > 0 then\n\t\tphrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n\tend\n\tit.won = winning\n\tif it.won then\n\t\tphrase = \"All clear!\\n\" .. phrase\n\telse\n\t\tphrase = \"Needs work:\\n\" .. phrase\n\tend\n\tphrase = phrase .. \"\\n\"\n\tit.digest = phrase\n\n\treturn it\nend\n\n\n\nfunction It.report(it)\n \tit = it:collate()\n\tio.write(it.digest)\n\treturn it\nend\n\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n\tIt[#It + 1] = it\n\treturn it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n\tlocal winning = true\n\tfor _, that in ipairs(It) do\n\t\tthat:report()\n\t\twinning = winning and that.won\n\tend\n\treturn it, winning\nend\n\nfunction It.allFailure(it)\n\tfor _, that in ipairs(It) do\n\t\tthat:check()\n\t\tfor _, did in ipairs(that.did) do\n\t\t\tif not did.success then\n\t\t\t\tio.write(did.digest)\n\t\t\tend\n\t\tend\n\tend\n\treturn it\nend\n\n\n\nreturn check\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/bundle.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/bundle.git",
    home = "",
    website = "",
    name = "bundle",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "f429f50be27625a84c882051c45ed68feac10d24",
name = "revert",
hash = "6d2f9d733a9e2fe7dd87d866bad242427a64fb444220df0d67f2ad672694f5ad",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal Dir = require \"fs:directory\"\nlocal s = require \"status:status\" ()\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT\n   bundle_id, time\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project_id = project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time DESC\nLIMIT 1\n;\n]]\n\nlocal delete_from_bundle = [[\nDELETE FROM bundle WHERE bundle_id = ? ;\n]]\n\n\n\nlocal function revert()\n   local pwd = Dir(uv.cwd())\n   local conn = _Bridge.modules_conn\n   conn.pragma.foreign_keys(true)\n   local project = _Bridge.args.project or pwd.path[#pwd.path]\n   s:chat(\"reverting latest commit to project %s\", project)\n   local result = conn:prepare(get_latest_bundle):bind(project):stepkv()\n   if not result then\n      s:chat(\"no bundles found for project %s\", project)\n      return\n   end\n   s:chat(\"deleting bundle from %s\", result.time)\n   conn:prepare(delete_from_bundle):bind(result.bundle_id):step()\n   result = conn:prepare(get_latest_bundle):bind(project):stepkv()\n   if result then\n      s:chat(\"newest remaining bundle is from %s\", result.time)\n   else\n      s:chat(\"no bundles remain\")\n   end\nend\n\n\n\n\nreturn revert\n\n",
},
  { 
vc_hash = "f429f50be27625a84c882051c45ed68feac10d24",
name = "import",
hash = "4d9072cab079073b19963086deea2baadf6b38f0550288e3adf4154b6dc10174",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n\n\n\n\nreturn import\n\n",
},
  { 
vc_hash = "f429f50be27625a84c882051c45ed68feac10d24",
name = "export",
hash = "4cfa6316446fa9d335b682f99b262a0a3cba9123005009d1d05d427102f9b232",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal Phrase = require \"singletons/phrase\"\n\n\n\nlocal Export = {}\n\n\n\n\n\nlocal latest_ids = [[\nSELECT\n   bundle_id, version, project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nWHERE\n   project.name = ?\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal latest_versioned_ids = [[\nSELECT\n   bundle_id, bundle.version, bundle.project\nFROM\n   bundle\nINNER JOIN\n   project\nON\n   project.project_id = bundle.project\nINNER JOIN\n   version\nON\n   version.version_id = bundle.version\nWHERE\n   project.name = :project\nAND\n   version.major = :major\nAND\n   version.minor = :minor\nAND\n   version.patch = :patch\nORDER BY\n   bundle.time\nDESC LIMIT 1\n;\n]]\n\n\n\nlocal get_modules = [[\nSELECT\n   module.name, module.vc_hash, module.branch,\n   code.hash, code.binary\nFROM\n   module\nINNER JOIN\n   code\nON\n   module.code = code.code_id\nWHERE\n   module.bundle = ?\n;\n]]\n\n\n\nlocal get_version = [[\nSELECT * FROM version WHERE version_id = ?;\n]]\n\n\n\nlocal get_project = [[\nSELECT * FROM project WHERE project_id = ?;\n]]\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function exportProject(project, version)\n   -- lame hack to get rid of this pset atrocity\n   -- #todo remove\n   if project == \'pset\' then return nil end\n   local conn = _Bridge.modules_conn\n   local bundle_result\n   if version then\n      version.project = project\n      bundle_result = conn:prepare(latest_versioned_ids)\n                                :bindkv(version):step()\n      if not bundle_result then\n         error(\"unable to find \" .. project .. \" in the specified version\")\n      end\n   else\n      bundle_result = conn:prepare(latest_ids):bind(project):step()\n      if not bundle_result then\n         error(\"no bundle found for project \" .. project)\n      end\n   end\n   local bundle_id = bundle_result[1]\n   local version_id = bundle_result[2]\n   local project_id = bundle_result[3]\n   local mods = toRow(conn:prepare(get_modules):bind(bundle_id):resultset(\"ihk\"))\n   local version = conn:prepare(get_version):bind(version_id):resultset(\"ihk\")\n   local project = conn:prepare(get_project):bind(project_id):resultset(\"ihk\")\n   version = toRow(version)\n   project = toRow(project)\n   return version, mods, project\nend\n\nExport.exportProject = exportProject\n\n\n\n\n\n\nlocal toLuaString = Codepoints.toLuaString\n\nlocal function bundle(version, modules, project)\n   -- A project can exist without modules, in which case, we skip it\n   if modules == nil then return nil end\n   local phrase = Phrase \"{\\n  project = {\\n\"\n   for key, val in pairs(project) do\n      if key ~= \"project_id\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n            error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  version = {\"\n   for key, val in pairs(version) do\n      if key ~= \"version_id\" and key ~= \"project\" then\n         phrase = phrase .. \"    \" .. key .. \" = \"\n         if type(val) == \"string\" then\n            phrase = phrase .. toLuaString(val)\n         elseif type(val) == \"number\" then\n            phrase = phrase .. tostring(val)\n         else\n             error (\"invalid type \" .. type(val))\n         end\n         phrase = phrase .. \",\\n\"\n      end\n   end\n   phrase = phrase .. \"},\\n  modules = { \"\n   for _, mod in ipairs(modules) do\n      phrase = phrase .. \"  { \\n\"\n      for key, val in pairs(mod) do\n         phrase = phrase .. key .. \" = \" .. toLuaString(val) .. \",\\n\"\n      end\n      phrase = phrase .. \"},\\n\"\n   end\n   phrase = phrase .. \"} }\"\n   return tostring(phrase)\nend\nExport.bundle = bundle\n\n\n\n\n\n\n\n\n\n\nfunction Export.export(projects, version)\n   if type(projects) == \"table\" then\n      local phrase = Phrase \"return { \"\n      for _, project in ipairs(projects) do\n         local bundle_str = bundle(exportProject(project, version))\n         if bundle_str then\n            phrase = phrase .. bundle_str .. \",\\n\"\n         end\n      end\n      phrase = phrase .. \"}\"\n      return tostring(phrase)\n   elseif type(projects) == \"string\" then\n      local phrase = Phrase \"return \"\n      phrase = phrase .. bundle(exportProject(projects, version))\n      return tostring(phrase)\n   else\n      error(\"bad argument to export of type \" .. type(projects))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Export.exportAll(version)\n   -- ignoring the version parameter for now.\n   if not version then\n      local conn = _Bridge.modules_conn\n      local projects = conn:exec \"SELECT name FROM project;\"\n      return Export.export(projects.name, version)\n   end\nend\n\n\n\nreturn Export\n\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/atman/clu.git",
    repo_alternates = "https://gitlab.com/special-circumstance/clu.git",
    home = "",
    website = "",
    name = "clu",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/templates",
hash = "5eed977590e132f7bcfb6ac0ad28eb2f9413682b6051581de1d39ff088146861",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\nlocal Node = require \"espalier/node\"\nlocal s    = require \"status\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal Templates, temps = Twig:inherit()\nTemplates.__index = Templates\nTemplates.isTemplate = true\n\n\n\n\n\n\n\n\nlocal Use = Templates:inherit()\nUse.id = \"use\"\n\nfunction Use.toLua(use, st, par_expr)\n   local phrase = st.phrase()\n   return \"local \" .. par_expr[3]:toLua(st()) .. \" = \"\n          .. \"require \\\"\" .. par_expr[2]:toLua(st()) .. \"\\\"\",\n          st\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Def = Templates:inherit()\nDef.id = \"def\"\n\nfunction Def.toLua(def, st, par_expr)\n   return \"local \" .. par_expr[2]:toLua(st())\n          .. \" = \" .. par_expr[3]:toLua(st()) .. \"\\n\",\n          st\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Fn = Templates:inherit()\nFn.id = \"fn\"\n\n\n\n\n\n\nfunction Fn.toLua(fn, st, par_expr)\n   local phrase = Phrase \"function \"\n   local params = \"(\"\n   local len = #par_expr\n   if par_expr[2].id == \"expr\" then\n      error(\"two-form λ is not yet implemented\")\n   end\n   if par_expr[2].id == \'vector\' then\n      for i, v in ipairs(par_expr[2]) do\n         local expr = v:toLua(st())\n         params = params .. expr\n         if i < #par_expr[2] then\n            params = params .. \", \"\n         end\n      end\n   elseif par_expr[2].id == \'symbol\' then\n      params = params .. par_expr[2]:toLua(st())\n   else\n      s:halt(\"arguments to λ must be symbol or vector, given \" .. par_expr[2].id)\n   end\n   phrase = phrase .. params .. \")\\n\"\n\n   st.dent = st.dent + 1\n   for i = 3, len do\n      local mayReturn = \"\"\n      -- A\n      if i == len then\n         local head = par_expr[len][1] and par_expr[len][1].id or \"\"\n         if head ~= \"if\"\n            and head ~= \"do\"\n            and head ~= \"set\"\n            and head ~= \"def\"\n            and head ~= \"let\" then\n\n            mayReturn = \"return \"\n         end\n      end\n      phrase =  phrase .. st:indent() .. mayReturn .. par_expr[i]:toLua(st()) .. \"\\n\"\n   end\n   st.dent = st.dent -1\n   return phrase .. st:indent() .. \"end\", st\nend\n\n\n\n\n\n\n\nlocal If = Templates:inherit()\nIf.id = \"if\"\n\nfunction If.toLua(fn, st, par_expr)\n   assert(3 <= #par_expr and #par_expr <= 4,\n         \"if must have two or three forms, not \" .. tostring(#par_expr))\n   local phrase = st.phrase\n   local isElse = (par_expr[4] ~= nil)\n   phrase = phrase .. st:indent() .. \"if (\"\n   local predicate = par_expr[2]:toLua(st())\n    phrase = phrase .. predicate .. \")\"\n    phrase = phrase .. \" then\\n\"\n    st.dent   = st.dent + 1\n   local ifTrue = par_expr[3]:toLua(st()) .. \"\\n\"\n   phrase = phrase .. st:indent() .. ifTrue\n   if isElse then\n      local ifFalse = par_expr[4]:toLua(st()) .. \"\\n\"\n      phrase = phrase .. st:dedent() .. \"else\\n\" .. st:indent() .. ifFalse\n   end\n   st.dent = st.dent - 1\n   return phrase .. st:indent() .. \"end\", st\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal For = Templates:inherit()\nFor.id = \"for\"\n\nfunction For.toLua(fn, st, par_expr)\n   assert(#par_expr >= 3, \"for takes at least two forms, given \" .. tostring(#par_expr))\n   local phrase = st.phrase.idEst() .. st:indent() .. \"for \"\n   local params = par_expr[2]\n   if params.id == \'vector\' then\n      --  Build parameters\n      phrase = phrase .. params[1]:toLua(st()) .. \" = \" -- catch non-symbol?\n             .. params[2]:toLua(st()) .. \", \" .. params[3]:toLua(st())\n      if params[4] then\n         phrase = phrase .. \", \" .. params[4]:toLua(st())\n      end\n   elseif params.id == \'map\' then\n      local key, val = params[1], params[2]\n      if key.id == \'vector\' or key.id == \'multiple\' then\n         for i = 1, #key do\n            phrase = phrase .. key[i]:toLua(st())\n            if i ~= #key then\n               phrase = phrase .. \", \"\n            end\n         end\n      elseif key.id == \'symbol\' then\n         phrase = phrase .. key:toLua(st())\n      else\n         s:halt(\"key of map parameter in for must be symbol or vector, given \" .. key.id)\n      end\n      phrase = phrase .. \" in \" .. val:toLua(st())\n   else\n      s:halt(\"second parameter of for must be a vector, given \" .. par_expr[2].id)\n   end\n\n   phrase = phrase .. \" do\\n\"\n   --  Add chunk\n   st.dent = st.dent + 1\n   for i = 3, #par_expr do\n      phrase = phrase .. st:indent() .. par_expr[i]:toLua(st()) .. \"\\n\"\n   end\n   st.dent = st.dent - 1\n   return phrase  .. st:indent() .. \"end\\n\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"clu/set\"\nSet.isTemplate = true\n\nlocal function new(template, str)\n   local id = Node.span(template)\n\n   if id == \"fn\" or id == \"λ\" then\n     return setmetatable(template, Fn)\n   elseif id == \"if\" then\n        return setmetatable(template, If)\n   elseif id == \"for\" then\n        return setmetatable(template, For)\n   elseif id == \"set\" then\n        return setmetatable(template, Set)\n   elseif id == \"def\" then\n        return setmetatable(template, Def)\n   elseif id == \"let\" then\n        return setmetatable(template, Let)\n   elseif id == \"use\" then\n      return setmetatable(template, Use)\n   end\n\n   return setmetatable(template, Templates)\nend\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/unary",
hash = "9ff38c2193874ec70277841f6857602b853fd24232f280d6a6b12b0cdf70c48f",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal Unary = require \"clu/twig\" : inherit ()\n\nfunction Unary.toLua(unary, st)\n   if unary[1].id == \"quote\" then\n      return unary[1]:toLua(st(), unary)\n   end\nend\n\nreturn Unary\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/vararg",
hash = "3cb736714892d720fba33fc8a279e87c5ffb034faac52dc403ecdd8bd83352cd",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Vararg = Twig : inherit ()\n\nfunction Vararg.toLua(vararg, st)\n   return vararg:span()\nend\n\nreturn Vararg\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/comment",
hash = "3832498597713382c721407daa8d6c88567246ad87a76f76499277df5d59e8c7",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Comment = require \"clu/twig\" : inherit ()\n\nfunction Comment.toLua(comment, st)\n   return st:indent() .. \"--\" .. string.sub(comment:span(), 2) .. \"\\n\"\nend\n\nreturn Comment\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu",
hash = "dd4044e5d0641b1a4f4ef87367f60869088d33a21279cea9834c039cead667ae",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal br = nil\nlocal ok, br = pcall(require, \"br/br\")\n\nif not ok then\n   br = require \"src/br/br\"\nend\n\n\n\n\n\npackage.path  = br:init()\n\n\n\n\n\nlocal cluster = require \"clu:cluster\"\nClu  = require \"clu:clu/clu\" ()\nlocal s = require \"singletons/status\" ()\nlocal a = require \"singletons/anterm\"\n\ns():chat(\"hello\")\n\n\n\n\n\n\nlocal clu_bar =    [==[\n(clu 12)\n\n(def con {answer 42})\n\n(fn\n  [bar bingo bongo]\n   (baz)\n   (query forth)\n   bux.quux\n   (fn\n     [who dat]\n     (it dis)\n     (oh yeah))\n   5)\n\n(for [i 1 10]\n     (print i)\n     (print con))\n\n(for { [key val]  (ipairs con) }\n     (print val))\n\n#_(if this\n    th2at\n    !?the-other) ]==]\n\nlocal why_hello =  [==[\n(use lpeg lpeg)\n(def con 34)\n(def con-print(fn\n    [x%+!?*] ; unused parameter...\n    (set con 23)\n    (print con)\n    (print (string.sub \"hello world\" 2 3))))\n\n((λ x (print 23)) Clu)\n\n(def \\my-map my-fn\\\n         \\{ one-form two-form\n            red-form blue-form }\n          ((λ x (print x)) Clu)\\)\n\n(def ten (< 1 2 3 4))\n\n(for { \\k v\\ (ipairs [1 2 3]) }\n   (print v))\n\n(print ten)\n\ncon-print ; this works\n]==]\n\n\nlocal long_fn = [[\n(set long-fn\n  (λ [_ x bar baz]\n    (if _\n       (print bar)\n       (print baz))))\n\n(long-fn true \"bar\" \"baz\")\n\n;((fn z (print z )) 12)\n\n(print \'(print 23) \"\\n\")\n\n;((fn (print $) \"quux\")\n]]\n\n\nlocal long_fn_ast = Clu.read(long_fn)\nlong_fn_ast:validate()\nio.write(tostring(long_fn_ast))\nio.write(a.cyan(tostring(long_fn_ast:toLua())))\nClu(long_fn)\nio.write(\"that\'s all folks!\\n\")\n\n\n\n\n\n\n\n\nbr:exit()\nreturn require \"clu/clu\"\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/nil",
hash = "e4e95e240e3f5ec33860283315ded695ffd2f965f182fc95c4f1427ef65ec555",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Nil = Twig : inherit()\n\n\n\nfunction Nil.toLua(null, st)\n   return null:span()\nend\n\n\n\nreturn Nil\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/map",
hash = "542dc8ce168c1e3e1a19ed0ba2eb9da1e7e1993a35bff25bc051e8528fb66e8b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Map = require \'clu/twig\' : inherit ()\n\n\nfunction Map.toLua(map, st)\n   assert(st.indent)\n   assert(#map % 2 == 0, \'maps must have an even number of forms\')\n   local phrase = st.phrase\n   local longMap = #map > 2\n   phrase = \'(function() local MAP = {} \'\n   if longMap then\n      st.dent = st.dent + 1\n      phrase = phrase .. \';\\n\'\n   end\n   for i = 1, #map, 2 do\n      local key, keyId = map[i]:toLua(st()), map[i].id\n      local val = map[i + 1]:toLua(st())\n      if longMap then \n         phrase = phrase .. st:indent()\n      end\n      phrase = phrase .. \' MAP\'\n      if keyId == \'symbol\' then\n         phrase = phrase .. \".\" .. key\n      else \n         phrase = phrase .. \"[\" .. key .. \"]\"\n      end\n      phrase = phrase .. \" = \" .. val .. \" \"\n      if longMap then\n         phrase = phrase .. \";\\n\"\n      end\n   end\n   if longMap then\n      st.dent = st.dent - 1\n      phrase = phrase .. st:indent()\n   else \n      phrase = phrase .. \" \"\n   end\n   phrase = phrase .. \"return MAP end)()\"\n   return phrase, st \nend\n\nreturn Map\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/multiple",
hash = "a572720f7cd1539b62c316ed76b7f6cbdea9f8278a9064b6678537a81c9208e5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Multi = require \"clu/twig\" : inherit ()\n\n\nfunction Multi.toLua(multi, st)\n   local phrase = st.phrase\n      for i = 1, #multi do\n      phrase = phrase .. multi[i]:toLua(st())\n      if i < #multi then\n         phrase = phrase .. \", \"\n      end\n   end\n\n   return phrase, st\nend\n\n\n\nreturn Multi\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/field",
hash = "5512b9aa415112cdef2f48cb20f5f9158ac92411721d1936b3e70e889d16507d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Field = Twig:inherit()\n\nfunction Field.toLua(field, st)\n   return field[1]:toLua() .. \".\" .. field[2]:toLua(), st\nend\n\nreturn Field\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/expr",
hash = "dccee97766bf2aae8f498601db5f5eafa3e8312464feb47ef8420b9fa372839b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal Twig = require \"clu/twig\"\nlocal s = require \"status\"\n\nlocal Expr = Twig:inherit()\n\n\n\n\nfunction Expr.toLua(expr, st)\n   local phrase = st.phrase.idEst()\n   if not expr[1] then return phrase end\n\n   if expr[1].isTemplate\n      or expr[1].id == \"operator\"\n      or expr[1].id == \"comparison\" then\n      return phrase .. expr[1]:toLua(st(), expr)\n   else\n      if expr[1].id == \"expr\" then\n         phrase = st:indent() .. \"(\" .. expr[1]:toLua(st()) .. \")(\"\n      else\n         phrase =  expr[1]:toLua(st()) .. \" (\"\n      end\n      local len = #expr\n      for i = 2, len do\n         phrase = phrase .. expr[i]:toLua(st())\n         if i < len then\n            phrase = phrase .. \", \"\n         end\n      end\n      return phrase .. \")\", st\n   end\nend\n\n\n\nreturn Expr\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/comparison",
hash = "7bbfb5ee9b4a8604bfd2e6f53bd01f9bf6b0db13930f16a6da5b6e8cb07c7932",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Compare = require \"clu/twig\" : inherit ()\n\nfunction Compare.toLua(comp, st, par_expr)\n   local op = par_expr[1]:span()\n   local phrase = st.phrase\n   phrase = phrase .. \"(\" .. par_expr[2]:toLua(st()) .. \" \"\n                  .. op .. \" \" ..  par_expr[3]:toLua(st())\n   if #par_expr > 3 then\n      for i = 4, #par_expr do\n         phrase = phrase .. \" and \" .. par_expr[i - 1]:toLua(st())\n                  .. \" \" .. op .. \" \" .. par_expr[i]:toLua(st())\n       end\n   end\n\n   return phrase .. \")\", st\nend\n\nreturn Compare\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/quote",
hash = "1c1b60eb70620c4f1d97099997f9061d7525c6b402311b38d470ac705261fdd8",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Quote = require \"clu/twig\" : inherit ()\n\nfunction Quote.toLua(quote, st, par_expr)\n   local phrase = st.phrase.idEst()\n   phrase = phrase .. st:indent() .. \"read([==[\\n\"\n   for i = 2, #par_expr do\n        phrase = phrase .. st:indent() .. par_expr[i]:span()\n   end\n   return phrase .. st:indent() ..  \"]==])\\n\"\nend\n\nreturn Quote\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/cluprime",
hash = "a7e90170e383a57f0b9e8ee8e6b1aeb3046bdc78124aad4fe4de1b9ee8004a62",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\nlocal Stator = require \"clu/stator\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal s = require \"status\" ()\n\nassert(Stator.indent)\n\nlocal CluPrime = Twig:inherit()\nCluPrime.isClu = true\n\nfunction CluPrime.toLua(clu)\n   local phrase = Phrase()\n   local st = Stator()\n   st.phrase = phrase\n   st.dent = 0\n   local len = #clu\n   for i = 1, len - 1 do\n      if clu[i].toLua then\n         phrase = phrase .. clu[i]:toLua(st()) .. \"\\n\"\n      else\n         s:halt(\"no toLua method for \" .. clu[i].id)\n      end\n   end\n   phrase = phrase .. \"return \" .. clu[len]:toLua(st()) .. \"\\n\"\n   return phrase\nend\n\nreturn CluPrime\n\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/boolean",
hash = "2811cdcb0f8e7d1b023b2ca8ed024a55b24c78e1eb199479d13bdede6ced5a1b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Boolean = Twig : inherit()\n\n\n\nfunction Boolean.toLua(bool, st)\n   return bool:span()\nend\n\n\n\nreturn Boolean\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/methodcall",
hash = "53e385553b7f27ddf705539f9dba2fd44b60c2181b9d1bb57e4d717f61296112",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Meth = Twig:inherit()\n\nfunction Meth.toLua(meth, st)\n   return meth[1]:span() .. \":\" .. meth[2]:toLua(), st\nend\n\nreturn Meth\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/clu",
hash = "245df119ddee4402ac81e2c5bc4a8bc925e5393e55e5ffaa324225182df3faf2",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal s = require \"singletons/status\" ()\nlocal a = require \"singletons/anterm\"\ns.verbose = true\ns.angry = false\n\n\n\n\n\n\n\n\nlocal Clu = {}\n\nlocal read = require \"clu/reader\"\n\nClu.read = read\n\nlocal _C, macroEnv = require \"clu/C\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compile\nif _VERSION == \"Lua 5.1\" then\n   compile = load\nelse\n   compile = loadstring\nend\n\nlocal function eval(ast, name, env)\n   local env = env or _C\n   local name = name or \"\"\n   local lua_chunk = tostring(ast:toLua())\n    -- This is 5.2 style\n   local catch, err = load(lua_chunk, name, nil, env)\n   if not catch and err then\n      s:complain(\"load error\", tostring(err))\n   else\n      return catch()\n   end\nend\n\nClu.eval = eval\n\n\n\n\n\n\n\n\n\nlocal function reader_evaluator(name, env, _Mac)\n   local env = env or _C\n   local name = name or \"Clu\"\n\n   --  Return anonymous method\n   return function (_, str)\n      if type(str) == \'table\' then\n         --  A couple possibilities\n         if str.isNode then\n            return eval(str, name, env, _Mac)\n         elseif str.isPhrase then\n            return eval(read(tostring(str)), name, env, Mac)\n         else\n            s:complain(\"table error in read_eval\",\n                      \"don\'t know what to do with\" .. tostring(str))\n         end\n      end\n      local ast, err = read(str)\n\n      if err then\n         s:complain(\"reader error\", err.msg)\n         return ast, err\n      end\n\n      return eval(ast, name, env)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function new_reader_evaluator(name, env, _Mac)\n   local Meta = { __index = Clu }\n   Meta.__call = reader_evaluator(name, env, _Mac)\n   local clu = setmetatable({}, Meta)\n   if _Mac then\n      clu._Mac = _Mac\n   end\n   return clu\nend\n\n\n\nlocal function new(CluInstance, name, env, _Mac)\n   local _Mac =  new_reader_evaluator(\"CluMacro\", macroEnv, _Mac)\n   return new_reader_evaluator(name, env, _Mac)\nend\n\n\n\n\n\nreturn setmetatable({}, {__call = new,\n                         __index = Clu})\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/C",
hash = "03b7c96b2f28b36acf8674ca19e2c701b5c65805b989d6fa205383e20a7247cd",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = { _VERSION =  \'Clu 0.0.18 SNAPSHOT\',\n               read     =  require \"clu/reader\",\n               assert   =  assert,\n               require  =  require,\n               print    =  print,\n               getfenv  =  getfenv,\n               getmeta  =  getmetatable,\n               ipairs   =  ipairs,\n               pairs    =  pairs,\n               next     =  next,\n               pcall    =  pcall,\n               eq       =  rawequal,\n               get      =  rawget,\n               rawget   =  rawget,\n               rawset   =  rawset,\n               select   =  select,\n               tonum    =  tonumber,\n               repr     =  tostring,\n               type     =  type,\n               unpack   =  unpack,\n               xpcall   =  xpcall,\n               coro     =  coroutine.create,\n               resume   =  coroutine.resume,\n               running  =  coroutine.running,\n               status   =  coroutine.status,\n               wrap     =  coroutine.wrap,\n               yield    =  coroutine.yield,  }\n\n\n\n\n\n\n\n\n\n\nlocal libs  = { string   =  string,\n                debug    =  debug,\n                io       =  io,\n                math     =  math,\n                os       =  os,\n                package  =  package,\n                table    =  table,\n                L        =  require \"lpeg\",\n                _S       =  require \"status\",\n                _B       =  require \"br/br\",\n                _A       =  require \"ansi\",      }\n\n\n\nlocal _C = {}\n\nfor k, v in pairs(core) do\n   _C[k] = v\nend\n\nfor k, v in pairs(libs) do\n   -- iterating a table to own the libs\n   _C[k] = v\nend\n\n\n\n\nreturn _C, core, libs\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/operator",
hash = "03bdc83d15349fd5e07e2c523a2ababaca6598b2e43360aa1e1b5aee3533142c",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Operator = require \"clu/twig\" : inherit ()\nlocal Phrase = require \"singletons/phrase\"\n\n\nfunction Operator.toLua(operator, st, par_expr)\n   local op = par_expr[1]:span()\n   local phrase = Phrase \"(\"\n   phrase = phrase .. par_expr[2]:toLua(st()) .. \" \" .. op\n                  .. \" \" ..  par_expr[3]:toLua(st())\n   if par_expr[4] then\n      for i = 4, #par_expr do\n         phrase = phrase .. \" \" .. op .. \" \" .. par_expr[i]:toLua(st())\n      end\n   end\n   return phrase .. \")\", st\nend\n\nreturn Operator\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "br/br",
hash = "ceaccb131cc22b389bf98e5d69403768153efa6bea72e9f918fa2a763cded1ad",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--require \"pl.strict\"\nlocal Bridge = {} -- This should inherit from a Cluster base type\n\n\n\n\n\n\n\n\n\n\nBridge.CODEX_PATH =  \"./?.lua;./?/?.lua;./lib/?.lua;./src/?.lua;./src/?/?.lua;\"\n                  .. \"./lib/?/?.lua;./lib/?/src/?.lua;./lib/?/src/?/?.lua;\"\n\nfunction Bridge.init(bridge)\n   io.write \"Welcome to bridge\\n\"\n   bridge.cache_PATH = \"\"\n   if package.path then\n      bridge.cache_PATH = package.path\n      return Bridge.CODEX_PATH .. package.path\n   end\n   return bridge.cache_PATH\nend\n\n\n\nfunction Bridge.exit(bridge)\n   package.path = bridge.cache_PATH or \"\"\nend\n\n\n\n\nreturn Bridge\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/clupeg",
hash = "383ecd99fccd022adfd5034eb52fa43cd96935b5a4209e166d259278ca8902b6",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal clu_peg = [[\n         clu :  _ form* / EOF\n\n        form : _  unarymark* (atom / compound ) _\n\n `unarymark` :  ( quote\n             /    splice\n             /    unquote\n             /    quasiquote\n             /    readermacro ) _\n\n       quote : \"\'\"\n      splice : \"~@\"\n     unquote : \"~\"\n  quasiquote : \"`\"\n readermacro : \"#\" ; this rule bears some expansion...\n\n    `atom` :  null\n           /  boolean\n           /  ssyntax\n           /  keyword\n           /  symbol\n           /  number\n           /  vararg\n\n`compound` :  expr\n           /  map\n           /  vector\n           /  multiple\n\n   symbol  :  latin !(forbidden) ANYTHING\n   keyword :  \":\" symbol\n\n    expr   :  \"(\" form* \")\"\n    hash   :  \"{\" (form form)* \"}\"\n    vector :  \"[\" form* \"]\"\n  multiple :  \"\\\\\" form \"\\\\\"\nforbidden  : {\\t\\r\\n\\\"\\\'[]()~@#`:.,} / \"{\" / \"}\"\n\n     latin :  ([A-Z] / [a-z])\n\n   comment :  \";\" (!\"\\n\" 1)* \"\\n\"\n\n         _ :  comment / { \\t\\r\\n}*\n]]\n\n\n\nreturn Peg(clu_peg) -- add Reader metatables from separate module\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/reader",
hash = "e8cbdd782eb8b02f31ed107588cf5a70b596a3c7b3e6fa8a664fe75beb5a86f3",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal Clu_metas = { require \"clu/twig\",\n                    clu        =  require \"clu/cluprime\",\n                    template   =  require \"clu/templates\",\n                    expr       =  require \"clu/expr\",\n                    vector     =  require \"clu/vector\",\n                    symbol     =  require \"clu/symbol\",\n                    map        =  require \"clu/map\",\n                    multiple   =  require \"clu/multiple\",\n                    null       =  require \"clu/nil\",\n                    boolean    =  require \"clu/boolean\",\n                    vararg     =  require \"clu/vararg\",\n                    number     =  require \"clu/number\",\n                    operator   =  require \"clu/operator\",\n                    quote      =  require \"clu/quote\",\n                    comparison =  require \"clu/comparison\",\n                    methodcall =  require \"clu/methodcall\",\n                    field      =  require \"clu/field\",\n                    comment    =  require \"clu/comment\",\n                    string     =  require \"clu/string\",\n                    unary      =  require \"clu/unary\"  }\n\n\n\nlocal L = require \"espalier/elpatt\"\n\nlocal V, P, R, S, E, EOF = L.V, L.P, L.R, L.S, L.E, L.EOF\n\nlocal Grammar = require \"espalier/grammar\"\n\nlocal glyph_symbol =  S(\"!\", \"$\", \"%\", \"^\", \"*\",\n                        \"+\", \"=\", \"<\", \">\", \"&\",\n                        \"?\", \"-\", \"/\")\n\n\n\n\nlocal function clu_fn(_ENV)\n   START \"clu\"\n   SUPPRESS (\"compound\", \"form\", \"atom\", \"unarymark\", \"WS\",\n             \"verb\", \"letter\", \"digit\", \"ssyntax\", \"symchars\")\n\n   clu = V\"form\"^1 * V\"pipe\"^0 * EOF(\"no-end\")\n\n   pipe = P\"|\"\n\n   form =  V\"WS\" * ( (V\"unary\")\n                +  (V\"atom\")\n                +  (V\"compound\") ) * V\"WS\"\n\n\n   unary = V\"unarymark\"^1 * P\" \"^0 * (V\"atom\" + V\"compound\")\n\n   unarymark = V\"quote\"\n         + V\"unquote_splice\"\n         + V\"unquote\"\n         + V\"quasiquote\"\n         + V\"reader_macro\"\n\n      quote = P\"\'\"\n\n      unquote = P\"~\"\n\n      quasiquote = P\"`\"\n\n      unquote_splice = P\"~@\"\n\n   atom = V\"WS\" * ( V\"ssyntax\"\n                  + V\"number\"\n                  + V\"boolean\"\n                  + V\"null\"\n                  + V\"vararg\"\n                  + V\"symbol\"\n                  + V\"string\" ) * V\"WS\"\n\n   compound = V\"WS\" * ( V\"expr\"\n                      + V\"map\"\n                      + V\"vector\"\n                      + V\"type_rule\"\n                      + V\"multiple\" ) * V\"WS\"\n\n   expr = P\"(\" * (V\"verb\" * V\"form\"^0)^0 * P\")\"\n\n   verb  = V\"WS\" * ( V\"template\"\n                   + V\"comparison\"\n                   + V\"operator\"\n                   + V\"ssyntax\"\n                   + V\"symbol\" ) * V\"WS\"\n\n   template = S(\"def\", \"for\", \"fn\", \"if\", \"λ\", \"set\", \"use\")\n\n   operator = S(\"+\", \"-\", \"*\", \"/\", \"%\", \"..\",\n                \"==\", \"~=\", \"and\", \"or\", \"not\")\n\n   comparison = S(\"<\", \">\", \"<=\", \"=>\")\n\n   map = P\"{\" * (V\"form\" * (V\"form\" + E\"noform\"))^0 * V\"WS\" * P\"}\"\n\n   vector = P\"[\" * V\"form\"^0 * V\"WS\" * P\"]\"\n\n   type_rule =  P\"⟨\" * V\"form\"^0 * P\"⟩\"\n             +  P\"#|\" * V\"form\"^0 * P\"|#\"\n\n   multiple = P\"\\\\\" * (V\"form\"^1 - P\"\\\\\") * P\"\\\\\"\n\n   digit    = R\"09\"\n\n   number   =  V\"float\" + V\"int\"\n   int    = P\"-\"^-1 * V\"digit\"^1\n   float  = P\"-\"^-1 * V\"digit\"^1 * P\".\" * V\"digit\"^1\n               * ((P\"e\" + P\"E\") * V\"digit\"^1)^0\n\n   boolean = P\"true\" + P\"false\"\n\n   null    = P\"nil\"\n\n   vararg  = P\"...\"\n\n   letter = R\"AZ\" + R\"az\"\n\n   symchars = (V\"letter\" + V\"digit\" + glyph_symbol)\n   symbol = ((V\"letter\" + glyph_symbol)^1 * V\"symchars\"^0) + \"_\"\n\n   ssyntax = V\"methodcall\" + V\"field\"\n\n   methodcall = V\"symbol\" * \":\" * (V\"symbol\" + V\"ssyntax\")\n   field      = V\"symbol\" * \".\" * (V\"symbol\" + V\"ssyntax\")\n\n   string = P\"\\\"\" * (P(1) - (P\"\\\"\" * - P\"\\\\\\\"\"))^0 * P\"\\\"\"\n\n   WS = V\"comment\" + V\"dent\" + (P\" \" + P\"\\t\" + P\",\")^0\n   comment = P\";\" * (-P\"\\n\" * P(1))^0 * V\"WS\"\n   dent = P\"\\n\" * (P\" \" + P\"\\t\" + P\"\\n\")^0\n\n   reader_macro = P\"Hashtags are ossum, possum\"\nend\n\nreturn Grammar(clu_fn, Clu_metas)\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/number",
hash = "04156c666493b2750a30c5b60d016e6fb3f6f8412c957bba5faac4e0c2893ae4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Num = Twig:inherit()\n\nfunction Num.toLua(number, st)\n   return number.span(number), st\nend\n\nreturn Num\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/set",
hash = "bba141e325fdcc2b9607620123469c093312cdfd76ae7bcf9c2f68de423005b6",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"clu/twig\" : inherit()\nSet.id = \"set\"\n\n\n\n\nfunction Set.toLua(set, st, par_expr)\n   local phrase = st.phrase() .. st:indent()\n   assert(#par_expr >= 3, \"missing parameter(s) in set\")\n   phrase = phrase .. par_expr[2]:toLua(st()) .. \" = \"\n            .. par_expr[3]:toLua(st())  .. \"\\n\"\n   return phrase, st\nend\n\n\n\nreturn Set\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/symbol",
hash = "7ec0b8d558c23d1391beb0f2085163cff65543c74c12e29fa45ba50af57156f8",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Symbol = Twig:inherit()\n\n\n\n\n\n\n\n\n\n\nlocal function mangle(span)\n   return span:gsub(\"!\", \"_ZAP\"):gsub(\"?\", \"_WUT\"):gsub(\"%+\", \"_LUS\")\n            -- and so on for really quite awhile, let\'s add an important one\n            :gsub(\"-\", \"_\"):gsub(\"%%\", \"_CEN\"):gsub(\"%*\", \"_TAR\")\nend\n\nfunction Symbol.toLua(symbol)\n   if symbol.__MANGLED then\n      return symbol.__MANGLED\n   else\n      symbol.__MANGLED = mangle(symbol:span())\n      return symbol.__MANGLED\n   end\nend\n\nreturn Symbol\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/string",
hash = "5bae1fe01282852d70ed90185fcdbfd94e68999e6646a673ca1bf32acb2d59f5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Str = Twig:inherit()\n\nfunction Str.toLua(str)\n   return str:span()\nend\n\nreturn Str\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/twig",
hash = "911c85595d00530583e2c6295a5c25a14d65d9d337ac9815ba4ed53cb36a6aee",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"espalier/node\" : inherit ()\n\n\n\nfunction Twig.toLua(twig, st)\n   error(\"no toLua method for \" .. twig.id)\nend\n\nreturn Twig\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "clu/vector",
hash = "c02e25f813e442a77d143457dee5c684ad54119b092f274c53b4974302fa02ab",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal Twig = require \"clu/twig\"\n\nlocal Vec = Twig:inherit()\n\nfunction Vec.toLua(vector)\n   local phrase = \"{ \"\n   for i, v in ipairs(vector) do\n      phrase = phrase .. v:toLua() .. \", \"\n   end\n   return phrase .. \" }\"\nend\n\nreturn Vec\n\n\n",
},
  { 
vc_hash = "ca6438a00d1628624d5abdd930ad1848f5001f8d",
name = "cluster/cluster",
hash = "8318fd93276c75ec3f4054d7547a2ab1a176ea583106cec5dc61c24b2f048ce0",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cluster = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction cluster.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n-- Function to export modules\n-- \n-- The first argument of util.inherit being filled with methods,\n-- the second argument is passed to util.export as =mod=, along\n-- with a function =constructor= which will serve to create a\n-- new instance.\n-- \nfunction cluster.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n-- A synonym is \"build\" because we don\'t always use it as a return\n-- value\ncluster.build = cluster.export\nreturn cluster\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/core.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/core.git",
    home = "",
    website = "",
    name = "core",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/coro",
hash = "db16b77e8d4861a38bc6ac31f9d55f71d78c3bb4227a65f3d3d47eaaa6e94d54",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal coro = {}\n\n\n\n\nlocal _base = require \"core:core/_base\"\nlocal thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\nlocal coro = {}\nfor k,v in next, coroutine do\n   coro[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, status, resume = assert(coroutine.create),\n                               assert(coroutine.status),\n                               assert(coroutine.resume)\n\nlocal remove = assert(table.remove)\n\nfunction coro.safewrap(f)\n   local wrapped_fn = create(f)\n   return function(...)\n      if status(wrapped_fn) == \'dead\' then\n         return nil, \"cannot resume dead coroutine inside safewrap\"\n      else\n         local rets  =  pack(resume(wrapped_fn, ...))\n         if rets[1] then\n             return unpack(rets, 2, rets.n)\n         else\n            return nil, rets[2]\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\n\nfunction coro.wrapgen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return wrap(body)\n   end\nend\n\n\n\n\n\n\n\n\nfunction coro.cogen(fn, ...)\n   local body = thunk(fn, ...)\n   return function()\n      return create(body)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction coro.fire(co, ...)\n   local cotype = type(co)\n   if cotype == \'thread\' then\n      -- check the status\n      if status(co) == \'dead\' then\n         return nil, \"fire cannot resume dead coroutine\"\n      end\n      local rets = pack(resume(co, ...))\n      if rets[1] == true then\n         remove(rets, 1)\n         rets.n = rets.n -1\n         return unpack(rets)\n      elseif rets[1] == false then\n         return nil, rets[2]\n      end\n   elseif cotype == \'function\' then\n      return co(...)\n   else\n      error(\"cannot fire on a \" .. cotype)\n   end\nend\n\n\n\n\nreturn coro\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/thread",
hash = "2017c116e0450f5e8c91391cffdf6efbedf44c529b77cddcc908e19b940ebd09",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal thread = {}\n\n\n\nlocal running, yield = assert(coroutine.running),\n                       assert(coroutine.yield)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.onloop()\n   local _, main = running()\n   return main and uv.loop_alive()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction thread.canyield(...)\n   local _, main = running()\n   if not main then\n      yield(...)\n   else\n      return ...\n   end\nend\n\n\n\nreturn thread\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core",
hash = "b0fe69dd48326e71ed83f1c108e5162175da94d77e4abe641b0652839125afd7",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal mods = {}\nlocal core = {}\nlocal insert = assert(table.insert)\ninsert(mods, require \"core:core/cluster\")\ninsert(mods, require \"core:core/coro\")\ninsert(mods, require \"core:core/fn\")\ninsert(mods, require \"core:core/math\")\ninsert(mods, require \"core:core/meta\")\ninsert(mods, require \"core:core/module\")\ninsert(mods, require \"core:core/string\")\ninsert(mods, require \"core:core/table\")\ninsert(mods, require \"core:core/thread\")\n\nfor _, mod in ipairs(mods) do\n   for k,v in pairs(mod) do\n      core[k] = v\n   end\nend\nreturn core\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/module",
hash = "a49f5f894fcf917e4ad09e8f264f2d7799601abda568c94c5d4a4833ac0e803e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Mod = {}\n\n\n\n\nlocal assert = assert(require \"core:core/_base\" . assertfmt)\nlocal require, pack, unpack = assert(require), assert(pack), assert(unpack)\n\n\n\n\n\n\n\n\n\n\n\nfunction Mod.import(req_str, ...)\n   local mod = require(req_str)\n   local fields, exports = pack(...), {}\n   for i = 1, fields.n do\n       exports[i] = assert(mod[fields[i]], \"can\'t require %s\", fields[i])\n   end\n   exports.n = fields.n\n   return unpack(exports)\nend\n\n\n\n\n\n\n\n\nlocal pcall = assert(pcall)\n\nfunction Mod.request(module)\n   local ok, mod = pcall(require, module)\n   if ok then\n      return mod\n   else\n      return nil\n   end\nend\n\n\n\nreturn Mod\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/string",
hash = "746ad00ff04e093a8be0a0c472194ea0b1f38d9fed7c61cd763ab4806e290f38",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal String = {}\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/_base\".assertfmt\nlocal byte = assert(string.byte)\nlocal find = assert(string.find)\nlocal sub = assert(string.sub)\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nfor k, v in next, string do\n  String[k] = v\nend\n\n\n\n\n\n\n\n\n\nString.assertfmt = assertfmt\n\n\n\n\n\n\n\n\n\n\n\nlocal function continue(c)\n   return c >= 128 and c <= 191\nend\n\nlocal function _offsideErr(str, offset)\n   return nil, \"out of bounds: #str: \" .. tostring(#str)\n                  .. \", offset: \" .. tostring(offset)\nend\nfunction String.utf8(str, offset)\n   offset = offset or 1\n   local byte = byte\n   local head = byte(str, offset)\n   if not head then\n      return _offsideErr(str, offset)\n   end\n   if head < 128 then\n      return 1\n   elseif head >= 194 and head <= 223 then\n      local two = byte(str, offset + 1)\n      if not two then\n         return _offsideErr(str, offset + 1)\n      end\n      if continue(two) then\n         return 2\n      else\n         return nil, \"utf8: bad second byte\"\n      end\n   elseif head >= 224 and head <= 239 then\n      local two, three = byte(str, offset + 1), byte(str, offset + 2)\n      if (not two) or (not three) then\n         return _offsideErr(str, offset + 2)\n      end\n      if continue(two) and continue(three) then\n         return 3\n      else\n         return nil, \"utf8: bad second and/or third byte\"\n      end\n   elseif head >= 240 and head <= 244 then\n      local two, three, four = byte(str, offset + 1),\n                               byte(str, offset + 2),\n                               byte(str, offset + 3)\n      if (not two) or (not three) or (not four) then\n         return _offsideErr(str, offset + 3)\n      end\n      if continue(two) and continue(three) and continue(four) then\n         return 4\n      else\n         return nil, \"utf8: bad second, third, and/or fourth byte\"\n      end\n   elseif continue(head) then\n      return nil, \"utf8: continuation byte at head\"\n   elseif head == 192 or head == 193 then\n      return nil, \"utf8: 192 or 193 forbidden\"\n   else -- head > 245\n      return nil, \"utf8: byte > 245\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction String.findall(str, patt)\n   local matches = {}\n   local index = 1\n   local left, right\n   repeat\n     left, right = find(str, patt, index)\n     if left then\n        matches[#matches + 1] = {left, right}\n        index = right + 1\n     end\n   until left == nil\n   if #matches > 0 then\n      return matches\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal fmt_set = {\"*\", \"C\", \"L\", \"R\", \"T\", \"U\", \"b\", \"n\", \"q\", \"s\", \"t\" }\n\nfor i, v in ipairs(fmt_set) do\n   fmt_set[i] = \"%%\" .. v\nend\n\n--[[\nlocal function next_fmt(str)\n   local head, tail\n   for _, v in ipairs(fmt_set) do\n      head, tail = 2\nend]]\n\nfunction String.format_safe(str, ...)\n\nend\n\n\n\n\n\n\n\n\n\nlocal matches =\n  {\n    [\"^\"] = \"%^\";\n    [\"$\"] = \"%$\";\n    [\"(\"] = \"%(\";\n    [\")\"] = \"%)\";\n    [\"%\"] = \"%%\";\n    [\".\"] = \"%.\";\n    [\"[\"] = \"%[\";\n    [\"]\"] = \"%]\";\n    [\"*\"] = \"%*\";\n    [\"+\"] = \"%+\";\n    [\"-\"] = \"%-\";\n    [\"?\"] = \"%?\";\n    [\"\\0\"] = \"%z\";\n  }\n\nfunction String.litpat(s)\n    return (s:gsub(\".\", matches))\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function cleave(str, pat)\n   local at = find(str, pat)\n   if at then\n      return sub(str, 1, at - 1), sub(str, at + 1)\n   else\n      return str, nil\n   end\nend\nString.cleave = cleave\n\n\n\n\n\n\n\n\n\n\nlocal find = assert(string.find)\nfunction String.isidentifier(str)\n   return find(str, \"^[a-zA-Z_][a-zA-Z0-9_]+$\") == 1\nend\n\n\n\n\n\n\n\nfunction String.lines(str)\n   local pos = 1;\n   return function()\n      if not pos then return nil end\n      local p1 = find(str, \"[\\r\\n]\", pos)\n      local line\n      if p1 then\n         local p2 = p1\n         if sub(str, p1, p1) == \"\\r\" and sub(str, p1+1, p1+1) == \"\\n\" then\n            p2 = p1 + 1\n         end\n         line = sub(str, pos, p1 - 1 )\n         pos = p2 + 1\n      else\n         line = sub(str, pos )\n         pos = nil\n      end\n      return line\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function _str__repr(str_tab)\n    return str_tab[1]\nend\n\nlocal _str_M = {__repr = _str__repr}\n\nfunction String.to_repr(str)\n   str = tostring(str)\n   return setmetatable({str}, _str_M)\nend\n\n\n\n\n\n\n\n\n\n\nfunction String.slurp(filename)\n  local f = io.open(tostring(filename), \"rb\")\n  if not f then\n     error (\"no such file: \" .. tostring(filename))\n  end\n  local content = f:read(\"*all\")\n  f:close()\n  return content\nend\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction String.splice(to_split, to_splice, index)\n   assert(type(to_split) == \"string\", \"bad argument #1 to splice: \"\n           .. \"string expected, got %s\", type(to_split))\n   assert(type(to_splice) == \"string\", \"bad argument #2 to splice: \"\n           .. \"string expected, got %s\", type(to_splice))\n   assert(type(index) == \"number\", \"bad argument #2 to splice: \"\n          .. \" number expected, got %s\", type(index))\n   assert(index >= 0 and index <= #to_split, \"splice index out of bounds\")\n   local head, tail = sub(to_split, 1, index), sub(to_split, index + 1)\n   return head .. to_splice .. tail\nend\n\n\n\nreturn String\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/table",
hash = "26834176b541a5d68c620ebabddb42e7e72f45144b8135df75ccbd7f23a649be",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\nlocal meta = require \"core/meta\"\nlocal Tab = {}\nfor k, v in pairs(table) do\n   Tab[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal N_M = {}\nN_M.__index = N_M\n\nfunction N_M.__len(tab)\n   return tab.n\nend\n\nfunction N_M.__ipairs(tab)\n   local i = 1\n   return function()\n      if i >= tab.n then return nil end\n      i = i + 1\n      return i - 1, tab[i - 1]\n   end\nend\n\nfunction Tab.n_table(tab, djikstra)\n   tab = tab or {}\n   tab.n = 0\n   return setmetatable(tab, N_M)\nend\n\n\n\n\n\n\n\n\nlocal function RO_M__newindex(tab, key, value)\n   error(\"attempt to write value `\" .. tostring(value)\n         .. \"` to read-only table slot `.\" .. tostring(key) .. \"`\")\nend\n\nfunction Tab.readOnly(tab)\n   return setmetatable({}, {__index = tab, __newindex = RO_M__newindex})\nend\n\n\n\n\n\n\n\n\n\nlocal function _hasfield(tab, field)\n   if type(tab) == \"table\" and rawget(tab, field) then\n      return tab[field]\n   elseif getmetatable(tab) then\n      local _M = getmetatable(tab)\n      local maybeIndex = rawget(_M, \"__index\")\n      if type(maybeIndex) == \"table\" then\n         return _hasfield(maybeIndex, field)\n      elseif type(maybeIndex) == \"function\" then\n         local success, result = pcall(maybeIndex, tab, field)\n         if success and result ~= nil then\n            return result\n         end\n      end\n   end\n   return nil\nend\n\nlocal function _hf__index(_, field)\n   return function(tab)\n      return _hasfield(tab, field)\n   end\nend\n\nlocal function _hf__call(_, tab, field)\n   return _hasfield(tab, field)\nend\n\nTab.hasfield = setmetatable({}, { __index = _hf__index,\n                                   __call  = _hf__call })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _clone(tab, depth)\n   depth = depth or 1\n   assert(depth > 0, \"depth must be positive \" .. tostring(depth))\n   local clone = {}\n   for k,v in next, tab do\n      if depth > 1 and type(v) == \"table\" then\n        v = _clone(v, depth - 1)\n      end\n      clone[k] = v\n   end\n   return setmetatable(clone, getmetatable(tab))\nend\nTab.clone = _clone\n\n\n\n\n\n\n\n\nfunction Tab.deepclone(tab)\n   assert(type(tab) == \"table\",\n          \"cannot deepclone value of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            -- copy the metatable after, in case it contains\n            -- __index or __newindex behaviors\n            copy = setmetatable(copy, _deep(getmetatable(val)))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.cloneinstance(tab)\n   assert(type(tab) == \"table\",\n          \"cannot cloneinstance of type \" .. type(tab))\n   local dupes = {}\n   local function _deep(val)\n      local copy = val\n      if type(val) == \"table\" then\n         if dupes[val] then\n            copy = dupes[val]\n         else\n            copy = {}\n            dupes[val] = copy\n            for k,v in next, val do\n               copy[_deep(k)] = _deep(v)\n            end\n            copy = setmetatable(copy, getmetatable(val))\n         end\n      end\n      return copy\n   end\n   return _deep(tab)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.isarray(tab)\n   local i = 1\n   for k,_ in pairs(tab) do\n      if k ~= i then return false end\n      i = i + 1\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Tab.arraymap(tab, fn)\n   local ret, ret_val = {}\n   for _, val in ipairs(tab) do\n      ret_val = fn(val) -- necessary to avoid unpacking multiple values\n                        -- in insert (could be =insert(ret, (fn(val)))=...)\n      insert(ret, ret_val)\n   end\n   return ret\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.compact(tab, n)\n   n = assert(n or tab.n, \"a numeric value must be provided for non-ntables\")\n   local cursor, slot, empty = 1, nil, nil\n   while cursor <= n do\n      slot = tab[cursor]\n      if slot == nil and empty == nil then\n         -- mark the empty position\n         empty = cursor\n      end\n      if slot ~= nil and empty ~= nil then\n         tab[empty] = slot\n         tab[cursor] = nil\n         cursor = empty\n         empty = nil\n      end\n      cursor = cursor + 1\n   end\n   if tab.n then\n      tab.n = #tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.inverse(tab)\n   local bat = {}\n   for k,v in pairs(tab) do\n      if bat[v] then\n         error(\"duplicate value on key \" .. k)\n      end\n      bat[v] = k\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.flatten(tab, level)\n   local ret, copies = {}, {}\n   local function _flat(t, depth)\n      if level and depth > level then\n         ret[#ret + 1] = t\n         return nil\n      end\n      for _,v in ipairs(t) do\n         if type(v) ~= \"table\" then\n            ret[#ret + 1] = v\n         else\n            if not copies[v] then\n               copies[v] = true\n               _flat(v, depth + 1)\n            end\n         end\n      end\n   end\n   _flat(tab, 0)\n   return ret\nend\n\n\n\n\n\n\n\n\n\nTab.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\nfunction Tab.arrayof(tab)\n   local arr = {}\n   for i,v in ipairs(tab) do\n      arr[i] = v\n   end\n   return arr\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.collect(iter, tab, ...)\n   local k_tab, v_tab = {}, {}\n   for k, v in iter(tab, ...) do\n      k_tab[#k_tab + 1] = k\n      v_tab[#v_tab + 1] = v\n   end\n   return k_tab, v_tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _select(collection, tab, key, cycle)\n   cycle = cycle or {}\n   for k,v in pairs(tab) do\n      if key == k then\n         collection[#collection + 1] = v\n      end\n      if type(v) == \"table\" and not cycle[v] then\n         cycle[v] = true\n         collection = _select(collection, v, key, cycle)\n      end\n   end\n   return collection\nend\n\nfunction Tab.select(tab, key)\n   return _select({}, tab, key)\nend\n\n\n\n\n\n\n\n\nfunction Tab.reverse(tab)\n   if type(tab) ~= \"table\" or #tab == 0 then\n      return {}\n   end\n   local bat = {}\n   for i,v in ipairs(tab) do\n      bat[#tab - i + 1] = v\n   end\n   return bat\nend\n\n\n\n\n\n\n\n\n\n\nfunction Tab.deleterange(tab, start, stop)\n   if start > stop then return end\n   local offset = stop - start + 1\n   for i = start, #tab do\n      tab[i] = tab[i + offset]\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.keys(tab)\n   assert(type(tab) == \"table\", \"keys must receive a table\")\n   local keys = {}\n   for k, _ in pairs(tab) do\n      keys[#keys + 1] = k\n   end\n\n   return keys, #keys\nend\n\n\n\n\n\n\nfunction Tab.values(tab)\n   assert(type(tab) == \"table\", \"values must receive a table\")\n   local vals = {}\n   for _, v in pairs(tab) do\n      vals[#vals + 1] = v\n   end\n\n   return vals, #vals\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.slice(tab, from, to)\n   to = to or #tab\n   if from < 0 then\n      from = #tab + 1 + from\n   end\n   if to < 0 then\n      to = #tab + 1 + to\n   end\n   local answer = {}\n   for i = 0, to - from do\n      answer[i + 1] = tab[from + i]\n   end\n   return answer\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal sp_er = \"table<core>.splice: \"\nlocal _e_1 = sp_er .. \"$1 must be a table\"\nlocal _e_2 = sp_er .. \"$2 must be a number\"\nlocal _e_3 = sp_er .. \"$3 must be a table\"\n\nlocal function push(queue, x)\n   queue.tail = queue.tail + 1\n   queue[queue.tail] = x\nend\n\nlocal function pop(queue)\n   if queue.tail == queue.head then return nil end\n   queue.head = queue.head + 1\n   return queue[queue.head]\nend\n\nfunction Tab.splice(tab, index, to_add)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(index) == \"number\" or index == nil, _e_2)\n   if index == nil then\n      index = #tab + 1\n   end\n   assert(type(to_add) == \"table\", _e_3)\n    index = index - 1\n    local queue = { head = 0, tail = 0}\n    local i = 1\n    -- replace elements, spilling onto queue\n    for j = 1, #to_add do\n        push(queue, tab[i + index])\n        tab[i + index] = to_add[j]\n        i = i + 1\n    end\n    -- run the queue up the remainder of the table\n    local elem = pop(queue)\n    while elem ~= nil do\n       push(queue, tab[i + index])\n       tab[i + index] = elem\n       i = i + 1\n       elem = pop(queue)\n    end\n    return tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compact, splice = Tab.compact, Tab.splice\n\nfunction Tab.replace(tab, index, to_add, span)\n   assert(type(tab) == \"table\", _e_1)\n   assert(type(index) == \"number\", _e_2)\n   assert(type(to_add) == \"table\", _e_3)\n   span = span or #to_add\n   -- easiest to handle the three cases as distinct.\n   if span == #to_add then\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n   elseif span > #to_add then\n      local top = #tab\n      -- replace #to_add worth of elements\n      for i = index, index + #to_add - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- nil out remaining elements\n      for i = index + #to_add, index + span - 1 do\n         tab[i] = nil\n      end\n      compact(tab, top)\n   else -- if span < #to_add\n      -- replace span worth of elements\n      for i = index, index + span - 1 do\n         tab[i] = to_add[i - index + 1]\n      end\n      -- make a table to hold the rest, copy\n      local spill = {}\n      for i = 1, #to_add - span do\n        spill[i] = to_add[i + span]\n      end\n      splice(tab, index + span, spill)\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.addall(tab, to_add)\n   for k, v in pairs (to_add) do\n      tab[k] = v\n   end\nend\n\n\n\n\n\n\n\n\nfunction Tab.pget(tab, key)\n   local ok, val = pcall(function() return tab[key] end)\n   if ok then\n      return val\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Tab.safeget(tab, key)\n   while tab ~= nil do\n      local val = rawget(tab, key)\n      if val ~= nil then return val end\n      local M = getmetatable(tab)\n      if M then\n         tab = rawget(M, \'__index\')\n         if type(tab) ~= \'table\' then\n            return nil\n         end\n      else\n         tab = nil\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Tab.fromkeys(tab, ...)\n   local answer = {}\n   local keys = pack(...)\n   for _, k in ipairs(keys) do\n      answer[k] = tab[k]\n   end\n   return answer\nend\n\n\n\nreturn Tab\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/string/escape",
hash = "d19df2dcc1031aebb22e2ee17b675a51c1e7f2d2cf9620379c4e21ac88e81b4e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal elpatt = require \"espalier:elpatt\"\nlocal C, P, R, S = assert(L.C), assert(L.P), assert(L.R), assert(L.S)\nlocal gsub, M = assert(elpatt.gsub), assert(elpatt.M)\n\n\n\n\nlocal escape_module = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_map = {\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nlocal function _generic_escape(ch)\n   return (\"\\\\x%02x\"):format(ch:byte())\nend\n\nlocal needs_escape = M(escape_map) + (R\"\\x00\\x1f\" + P\"\\x7f\") / _generic_escape\n\nfunction escape_module.escape(str, quotes)\n   local patt = needs_escape\n   if quotes then\n      patt = S(quotes) / \"\\\\%0\" + patt\n   end\n   return gsub(str, patt)\nend\n\nfunction escape_module.escape_char(ch, quotes)\n   local escaped = escape_map[ch]\n   if escaped then\n      return escaped\n   elseif quotes and quotes:find(ch) then\n      return \"\\\\\" .. ch\n   elseif ch:find(\"%c\") then\n      return _generic_escape(ch)\n   else\n      return ch\n   end\nend\n\n\n\n\n\n\n\n\nlocal char = assert(string.char)\n\nlocal unescape_map = {}\nfor k, v in pairs(escape_map) do\n   unescape_map[v] = k\nend\n\nlocal higit = R\"09\" + R\"af\"\n\nlocal escaped_char = M(unescape_map) +\n                     (P\"\\\\\" * C(S\"\'\\\"[]\")) / 1 +\n                     (P\"\\\\x\" * C(higit * higit)) / function(hex)\n                        return char(tonumber(\"0x\" .. hex))\n                     end\n\nfunction escape_module.unescape(str)\n   return gsub(str, escaped_char)\nend\n\n\n\nreturn escape_module\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/_base",
hash = "b5f239f7495f22395e7a1bb04c096a520f8c91b3caf9460c9d8a38d18ebd9581",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal _base = {}\n\n\n\n\n\n\n\n\n\nfunction _base.thunk(fn, ...)\n   local args = pack(...)\n   return function()\n      return fn(unpack(args, 1, args.n))\n   end\nend\n\n\n\n\n\n\nlocal format = assert(string.format)\n\nfunction _base.assertfmt(pred, msg, ...)\n   if pred then\n      return pred\n   else\n      error(format(msg, ...), 2)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction _base.iscallable(val)\n   if type(val) == \'function\' then return true end\n   if type(val) == \'table\' then\n      local M = getmetatable(val)\n      if M and rawget(M, \"__call\") then\n         return true\n      end\n   end\n   return false\nend\n\n\n\nreturn _base\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/fn",
hash = "648f4fcbac9f71f4555c54943f00908cc4db01b0dcf060d81c7ba651506f43c9",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _base = require \"core:core/_base\"\n\n\n\n\n\n\nlocal fn = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _curried = setmetatable({}, { __mode = \'k\' })\n\nlocal currier = {\n   false, -- this shouldn\'t happen\n   function(fn, a, b) -- [2]\n      return function(...)\n         return fn(a, b, ...)\n      end\n   end,\n   function(fn, a, b, c) -- [3]\n      return function(...)\n         return fn(a, b, c, ...)\n      end\n   end,\n   function(fn, a, b, c, d) -- [4]\n      return function(...)\n         return fn(a, b, c, d, ...)\n      end\n   end,\n   function(fn, a, b, c, d, e) -- [5]\n      return function(...)\n         return fn(a, b, c, d, e, ...)\n      end\n   end,\n}\n\nlocal function curry(fn, param)\n   assert(type(fn) == \'function\' or\n          type(fn) == \'table\' and getmetatable(fn).__call,\n          \'#1 of curry must be a function or callable table\')\n   local curried;\n   local pre = _curried[fn]\n   if not pre then\n      curried = function(...) return fn(param, ...) end\n      _curried[curried] = { param, n = 1 , fn = fn }\n   else\n      if pre.n <= 4 then\n         local post = {}\n         for i = 1, pre.n do\n            post[i] = pre[i]\n         end\n         post.n = pre.n + 1\n         post.fn = pre.fn\n         post[post.n] = param\n         curried = currier[post.n](post.fn, unpack(post, 1, post.n))\n         _curried[curried] = post\n      else\n         curried = function(...) return fn(param, ...) end\n      end\n   end\n\n   return curried\nend\n\nfn.curry = curry\n\n\n\n\n\n\n\n\n\n\nfn.thunk = assert(_base.thunk)\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.deferSend(obj, msg, ...)\n   assert(type(obj) == \'table\', \"#1 to deferSend must be a table\")\n   assert(type(msg) == \'string\', \"#2 to deferSend must be a string\")\n   local packed = pack(...)\n   return function()\n      return obj[msg](obj, unpack(packed))\n   end\nend\n\n\n\n\n\n\n\n\nfn.iscallable = assert(_base.iscallable)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.partial(fn, ...)\n   for i = 1, select(\'#\', ...) do\n      fn = curry(fn, select(i, ...))\n   end\n   return fn\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction fn.itermap(fn, iter)\n   local ret, res = {}\n   while true do\n      res = pack(fn(iter()))\n      if #res == 0 then\n         return ret\n      else\n         ret[#ret + 1] = res\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _dynamics_call = setmetatable({}, {__mode = \'k\'})\nlocal _dynamics_registry  = setmetatable({}, {__mode = \'kv\'})\n\nlocal function dynamic(fn)\n   -- make a unique table as key\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local function dyn_fn(...)\n      return _dynamics_call[uid](...)\n   end\n   _dynamics_registry[dyn_fn] = uid\n   return dyn_fn\nend\n\nfn.dynamic = dynamic\n\n\n\n\n\n\n\n\n\nfunction fn.patch_dynamic(dyn_fn, fn)\n   assert(_dynamics_registry[dyn_fn], \"cannot patch a non-dynamic function\")\n   local uid = _dynamics_registry[dyn_fn]\n   _dynamics_call[uid] = fn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _pre_hook, _post_hook = setmetatable({}, {__mode = \'k\'}),\n                              setmetatable({}, {__mode = \'k\'})\n\nlocal function _call_with_hooks(uid, ...)\n   local fn = _dynamics_call[uid]\n   assert(fn, \"_dynamics_call is missing a hookable function\")\n   local pre, post = _pre_hook[uid], _post_hook[uid]\n\n   if pre and post then\n      local new_arg = pack(pre(...))\n      local rets = pack(fn(unpack(new_arg)))\n      -- make into one pack, because you can only apply multiple arguments at\n      -- the end of a function call\n      for i = 1, rets.n do\n         new_arg[#new_arg + 1] = rets[i]\n      end\n      new_arg.n = new_arg.n + rets.n\n      return post(unpack(rets))\n   elseif pre then\n      return fn(pre(...))\n   elseif post then\n      local args, rets = pack(...), pack(fn(...))\n      -- same trick here...\n      for i = 1, args.n do\n         rets[#rets + 1] = args[i]\n      end\n      rets.n = rets.n + args.n\n      return post(unpack(rets))\n   else\n      return fn(...)\n   end\nend\n\nlocal function prehook(hooked, pre_hook)\n   _pre_hook[_dynamics_registry[hooked]] = pre_hook\nend\n\nlocal function posthook(hooked, post_hook)\n   _post_hook[_dynamics_registry[hooked]] = post_hook\nend\n\nfn.prehook, fn.posthook = prehook, posthook\n\nfunction fn.hookable(fn, pre, post)\n   -- make a uid, add to _dynamics_call\n   local uid = {}\n   _dynamics_call[uid] = fn\n   local hookable = function(...)\n                       return _call_with_hooks(uid, ...)\n                    end\n   -- register the hookable in the dynamics registry\n   _dynamics_registry[hookable] = uid\n   return hookable\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfn.assertfmt = _base.assertfmt\n\n\n\nreturn fn\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/cluster",
hash = "5dc9ce4272a42f30f20b23d1974aaef9bc974099715ddc91b820ac1bc231b3c4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal cluster = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal isempty = table.isempty\n                or\n                function(tab)\n                   local empty = true\n                   for _, __ in pairs(tab) do\n                      empty = false\n                      break\n                   end\n                   return empty\n                end\n\nfunction cluster.Meta(Meta)\n   if Meta and Meta.__index then\n      -- inherit\n      local tab = {}\n      for field, value in next, Meta, nil do\n         if sub(field, 1, 2) == \"__\" then\n            tab[field] = value\n         end\n      end\n      tab.__index = Meta\n      return setmetatable(tab, Meta)\n   elseif Meta\n      and type(Meta) == \'table\'\n      and isempty(Meta) then\n      -- decorate\n      Meta.__index = Meta\n      return Meta\n   elseif not Meta then\n      local _M = {}\n      _M.__index = _M\n      return _M\n   end\n   error \"cannot make metatable\"\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _bind(obj, fn)\n  if not fn then return nil end\n  return function(...)\n     return fn(obj, ...)\n  end\nend\n\nlocal function _get_idx(obj)\n   local M = getmetatable(obj)\n   return M and M.__index\nend\n\nfunction cluster.super(obj, field)\n   local super_idx\n   -- If the object has such a field directly, consider the implementation\n   -- from the metatable to be the \"super\" implementation\n   if rawget(obj, field) then\n      super_idx = _get_idx(obj)\n   -- Otherwise, look one step further up the inheritance chain\n   else\n      local M_idx = _get_idx(obj)\n      super_idx = type(M_idx) == \'table\' and _get_idx(M_idx) or nil\n   end\n   if super_idx then\n      return type(super_idx) == \'table\'\n         and _bind(obj, super_idx[field])\n         or  _bind(obj, super_idx(obj, field))\n   end\n   -- No superclass, or our class uses an __index function so we can\'t\n   -- meaningfully figure out what to do\n   return nil\nend\n\n\n\nreturn cluster\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/meta",
hash = "75c3269c5de9774ef9f134403a4238e6a568ae523c15ca9e21739398860ea0cd",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal meta = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.inherit(meta)\n  local MT = meta or {}\n  local M = setmetatable({}, MT)\n  M.__index = M\n  local m = setmetatable({}, M)\n  m.__index = m\n  return M, m\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.export(mod, constructor)\n  mod.__call = constructor\n  return setmetatable({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function hasmetamethod(mmethod, tab)\n   assert(type(mmethod) == \"string\", \"metamethod must be a string\")\n   local M = getmetatable(tab)\n   if not M then\n      return false\n   end\n   if sub(mmethod,1,2) == \"__\" then\n      return rawget(M, mmethod)\n   else\n      return rawget(M, \"__\" .. mmethod)\n   end\nend\n\nmeta.hasmetamethod = hasmetamethod\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pairs = assert(pairs)\n\nfunction meta.endow(Meta)\n   local MC = {}\n   for k, v in pairs(Meta) do\n      MC[k] = v\n   end\n   return MC\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction meta.instanceof(obj, Class)\n   if type(Class) == \'string\' then\n      return type(obj) == Class\n   else\n      return type(obj) == \'table\' and obj.idEst == Class\n   end\nend\n\n\n\nreturn meta\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/string/print",
hash = "7e64796a80b79f1e3f3924a93fa562a66218b47a73a056c2d4516062dc375b5d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nPrint = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\nlocal floor, max = assert(math.floor), assert(math.max)\nlocal inbounds = assert(require \"core:math\" . inbounds)\n\nlocal split_at = {}\nfor _, v in ipairs{\" \", \"-\", \"(\", \"{\", \"[\"} do\n   split_at[v] = v == \" \" and -1 or 0\nend\n\nfunction Print.breakascii(str, width)\n   if #str <= width then\n      return str, 1, #str\n   end\n   local lines = {}\n   local actual_width = 0\n   local left = 1\n   local min_width = floor(width / 2)\n   while left <= #str do\n      local min_right = left + min_width - 1\n      local max_right = left + width - 1\n      local line\n      if max_right >= #str then\n         line = str:sub(left)\n         lines[#lines + 1] = line\n         actual_width = max(actual_width, #line)\n         break\n      end\n      local split_index, offset\n      -- Check one past the max width because we might be able to\n      -- remove a trailing space\n      for i = max_right + 1, min_right, -1 do\n         offset = split_at[str:sub(i, i)]\n         -- But now we do need to check if we\'ll actually be in bounds\n         if offset and inbounds(i + offset, min_right, max_right) then\n            split_index = i\n            break\n         end\n      end\n      if not split_index then\n         -- Didn\'t find a natural breakpoint, just chop at the max width\n         split_index = max_right\n         offset = 0\n      end\n      line = str:sub(left, split_index + offset)\n      lines[#lines + 1] = line\n      actual_width = max(actual_width, #line)\n      left = split_index + 1\n   end\n   return concat(lines, \"\\n\"), #lines, actual_width\nend\n\n\n\n\nfunction Print.center(str, width)\n   local diff = width - #str\n   local lmargin, rmargin\n   if diff % 2 ~= 0 then\n      lmargin, rmargin = math.floor(diff / 2), math.floor(diff / 2) + 1\n   else\n      lmargin, rmargin = diff / 2, diff / 2\n   end\n   return  (\" \"):rep(lmargin) .. str .. (\" \"):rep(rmargin)\nend\n\n\n\n\nreturn Print\n\n",
},
  { 
vc_hash = "304c54f57d81eafcef438c36e3547563351a4db7",
name = "core/math",
hash = "5d2b2c4f1552dc0c7405f5320db001b80c6c7a236d444b184f0a251df09b70fb",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Math = {}\n\n\n\n\n\n\n\n\nfunction Math.inbounds(value, lower, upper)\n  if lower and value < lower then\n    return false\n  end\n  if upper and value > upper then\n    return false\n  end\n  return true\nend\n\n\n\n\n\n\n\n\n\nlocal assertfmt = assert(require \"core:_base\" . assertfmt)\nfunction Math.clamp(value, lower, upper)\n   if lower and upper then\n      assertfmt(lower <= upper, \"Clamp range must be nonempty (lower <= upper), got (%d, %d)\", lower, upper)\n   end\n   if lower and value < lower then\n      value = lower\n   end\n   if upper and value > upper then\n      value = upper\n   end\n   return value\nend\n\n\n\n\nreturn Math\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/deque.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/deque.git",
    home = "",
    website = "",
    name = "deque",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "ddb64fbe303a859a04b37bb5733ff5dff2a5f3fa",
name = "deque",
hash = "05c0ce6462ef34282c12eded37d089453c8314c99080f48fbc86025a9dd97f73",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal Deque;\n\n\n\n\n\n\nlocal function flipped_contents(deque)\n   local r = {}\n   for i = deque.tail, deque.head + 1, -1 do\n      r[#r + 1] = deque[i]\n   end\n   return r\nend\n\nlocal directions = { push = \"push_left\",\n                     pop  = \"pop_right\",\n                     peek = \"peek_right\",\n                     iter = \"iter_right\",\n                     push_right = \"push_left\",\n                     push_left  = \"push_right\",\n                     peek_right = \"peek_left\",\n                     peek_left  = \"peek_right\",\n                     pop_right  = \"pop_left\",\n                     pop_left   = \"pop_right\",\n                     rotate_right = \"rotate_left\",\n                     rotate_left  = \"rotate_right\",\n                     remove_right = \"remove_left\",\n                     remove_left  = \"remove_right\",\n                     iter_right   = \"iter_left\",\n                     iter_left    = \"iter_right\",\n                     contents     = true, }\n\nlocal function _flip(deque)\n   if deque.flipped then return end\n   for method, reversal in pairs(directions) do\n      deque[method] = Deque[reversal]\n   end\n   -- add backward contents\n   deque.contents = flipped_contents\n   deque.flipped = true\nend\n\nlocal function _unflip(deque)\n   if not deque.flipped then return end\n   for method in pairs(directions) do\n      deque[method] = nil\n   end\n   deque.flipped = nil\nend\n\nlocal function reverse_queue(deque)\n   if deque.flipped then\n      _unflip(deque)\n   else\n      _flip(deque)\n   end\nend\n\nlocal function _reset_on_empty(deque)\n   if deque.head == deque.tail then\n      deque.head, deque.tail = 0,0\n      _unflip(deque)\n   end\nend\n\nlocal function push_right(deque, x)\n   assert(x ~= nil, \"can\'t enqueue nil\")\n   deque.tail = deque.tail + 1\n   deque[deque.tail] = x\nend\n\nlocal function push_left(deque, x)\n   assert(x ~= nil, \"can\'t enqueue nil\")\n   deque[deque.head] = x\n   deque.head = deque.head - 1\nend\n\nlocal function peek_right(deque)\n   return deque[deque.tail]\nend\n\nlocal function peek_left(deque)\n   return deque[deque.head+1]\nend\n\nlocal function pop_right(deque)\n   if deque:is_empty() then return nil end\n   local r = deque[deque.tail]\n   deque[deque.tail] = nil\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\n   return r\nend\n\nlocal function pop_left(deque)\n   if deque:is_empty() then return nil end\n   deque.head = deque.head + 1\n   local r = deque[deque.head]\n   deque[deque.head] = nil\n   _reset_on_empty(deque)\n   return r\nend\n\nlocal function rotate_right(deque, n)\n   n = n or 1\n   if deque:is_empty() then return nil end\n   for i = 1, n do deque:push_left(deque:pop_right()) end\nend\n\nlocal function rotate_left(deque, n)\n   n = n or 1\n   if deque:is_empty() then return nil end\n   for i = 1, n do deque:push_right(deque:pop_left()) end\nend\n\nlocal function _remove_at_internal(deque, idx)\n   for i = idx, deque.tail do deque[i] = deque[i+1] end\n   deque.tail = deque.tail - 1\n   _reset_on_empty(deque)\nend\n\nlocal function remove_right(deque, x)\n   for i = deque.tail, deque.head + 1, -1 do\n     if deque[i] == x then\n        _remove_at_internal(deque, i)\n        return true\n      end\n   end\n   return false\nend\n\nlocal function remove_left(deque, x)\n   for i = deque.head + 1, deque.tail do\n      if deque[i] == x then\n         _remove_at_internal(deque, i)\n         return true\n      end\n   end\n   return false\nend\n\nlocal function length(deque)\n   return deque.tail - deque.head\nend\n\nlocal function is_empty(deque)\n   return deque.tail == deque.head\nend\n\nlocal function contents(deque)\n   local r = {}\n   for i = deque.head + 1, deque.tail do\n      r[i-deque.head] = deque[i]\n   end\n   return r\nend\n\nlocal function iter_right(deque)\n   local i = deque.tail + 1\n   return function()\n      if i > deque.head + 1 then\n         i = i - 1\n         return deque[i]\n      end\n   end\nend\n\nlocal function iter_left(deque)\n   local i = deque.head\n   return function()\n      if i < deque.tail then\n         i = i + 1\n         return deque[i]\n      end\n   end\nend\n\nDeque = { push = push_right,\n          pop = pop_left,\n          peek = peek_left,\n          iter = iter_left,\n          push_right = push_right,\n          push_left = push_left,\n          peek_right = peek_right,\n          peek_left = peek_left,\n          pop_right = pop_right,\n          pop_left = pop_left,\n          rotate_right = rotate_right,\n          rotate_left = rotate_left,\n          remove_right = remove_right,\n          remove_left = remove_left,\n          iter_right = iter_right,\n          iter_left = iter_left,\n          length = length,\n          is_empty = is_empty,\n          contents = contents,\n          reverse = reverse_queue }\n\nDeque.__index = Deque\n\nlocal t_new = assert(table.new)\n\nlocal function new(size)\n   local deque;\n   if size then\n       deque = t_new(size, 8)\n   else\n      deque = {}\n   end\n   deque.head, deque.tail = 0, 0\n   return setmetatable(deque, Deque)\nend\n\nDeque.idEst = new\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/espalier",
    repo_alternates = "https://gitlab.com/special-circumstance/espalier.git/\nhttps://gitlab.special-circumstanc.es/bridge-tools/espalier.git",
    home = "",
    website = "",
    name = "espalier",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/luatoken",
hash = "9c429d20d64211fc9f0c3c322e7177b78bacc5a0abdc5be1d654042a771b8a83",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal lua_tok_str = [[\nlua = _ (token _)+\n`token` = keyword / operator\n\nkeyword = \"function\" / \"local\" / \"for\" / \"in\" / \"do\"\n           / \"and\" / \"or\" / \"not\" / \"true\" / \"false\"\n           / \"while\" / \"break\" / \"if\" / \"then\" / \"else\" / \"elseif\"\n           / \"goto\" / \"repeat\" / \"until\" / \"return\" / \"nil\"\n           / \"end\"\n\noperator = \"+\" / \"-\" / \"*\" / \"/\" / \"%\" / \"^\" / \"#\"\n           / \"==\" / \"~=\" / \"<=\" / \">=\" / \"<\" / \">\"\n           / \"=\" / \"(\" / \")\" / \"{\" / \"}\" / \"[\" / \"]\"\n           / \";\" / \":\" / \"...\" / \"..\" / \".\" / \",\"\n\n _     = { \\t\\n,}*\n\n]]\n\n\n\nreturn Peg(lua_tok_str):toGrammar()\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "phrase",
hash = "96f2260f49305bda65bbc4f0df84df48535b2178feefe4229604f1f645d5d2e6",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal init, new\nlocal s = require \"core/status\" ()\ns.angry = false\nlocal Phrase = {}\nPhrase.it = require \"core/check\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function spill(phrase)\n   local new_phrase = init()\n   for k, v in pairs(phrase) do\n      new_phrase[k] = v\n   end\n   new_phrase.intern = nil\n\n   return new_phrase\nend\n\n\nlocal function __concat(head_phrase, tail_phrase)\n   if type(head_phrase) == \'string\' then\n      -- bump the tail phrase accordingly\n      if tail_phrase.intern then\n         tail_phrase = spill(tail_phrase)\n      end\n\n      table.insert(tail_phrase, 1, head_phrase)\n      tail_phrase.len = tail_phrase.len + #head_phrase\n      return tail_phrase\n   end\n   local typica = type(tail_phrase)\n   if typica == \"string\" then\n      if head_phrase.intern then\n         head_phrase = spill(head_phrase)\n      end\n      head_phrase[#head_phrase + 1] = tail_phrase\n      head_phrase.len = head_phrase.len + #tail_phrase\n      return head_phrase\n      elseif typica == \"table\" and tail_phrase.idEst == new then\n      local new_phrase = init()\n      head_phrase.intern = true -- head_phrase is now in the middle of a string\n      tail_phrase.intern = true -- tail_phrase shouldn\'t be bump-catted\n      new_phrase[1] = head_phrase\n      new_phrase[2] = tail_phrase\n      new_phrase.len = head_phrase.len + tail_phrase.len\n      return new_phrase\n   end\n\n   return nil, \"tail phrase was unsuitable for concatenation\"\nend\n\n\n\n\n\n\n\n\nlocal function __tostring(phrase)\n   local str = \"\"\n   for i,v in ipairs(phrase) do\n      str = str .. tostring(v)\n   end\n\n   return str\nend\n\n\n\nlocal PhraseMeta = {__index = Phrase,\n                  __concat = __concat,\n                  __tostring = __tostring}\n\n\n\n\ninit = function()\n   return setmetatable ({}, PhraseMeta)\nend\n\nnew = function(phrase_seed)\n   phrase_seed = phrase_seed or \"\"\n   local phrase = init()\n   local typica = type(phrase_seed)\n   if typica == \"string\" then\n      phrase[1] = phrase_seed\n      phrase.len = #phrase_seed\n   else\n      s:complain(\"Error in Phrase\", \"cannot accept phrase seed of type\" .. typica,\n                 phrase_seed)\n   end\n   return phrase\nend\n\nPhrase.idEst = new\n\n\n\n\n\n\n\n\nlocal function spec()\n   local a = new \"Sphinx of \" .. \"black quartz \"\n   a: it \"phrase-a\"\n      : passedTo(tostring)\n      : gives \"Sphinx of black quartz \"\n      : fin()\n\n   local b = a .. \"judge my \" .. \"vow.\"\n   b: it \"phrase-b\"\n      : passedTo(tostring)\n      : gives \"Sphinx of black quartz judge my vow.\"\n      : fin()\n\nend\n\nspec()\n\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/serve",
hash = "883255db98c5d92fab4cfcdb76af3ff0bb13d57676d5a62965cb659a91b2925e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\nlocal input = \"\"\nwhile true do\n   local newline = io.stdin:read()\n   if newline == nil or string.byte(newline) == 17 then\n      os.exit(0)\n   end\n   input = input .. newline .. \"\\n\"\n   local res, err = loadstring(input)\n   if res then\n      res_tab = res()\n      if type(res_tab) == table and res_tab.grammar and res_tab.input then\n         local ok, peg = pcall(Peg, res_tab.grammar)\n         if ok then\n            local output = {grammar = peg:toString()}\n            local parse = peg:toGrammar()\n            local tree\n            ok, tree = pcall(parse, res_tab.input)\n            if ok then\n               output.tree = tree:toString()\n            end\n            io.stdout:write(output.grammar .. \"\\n\\n\")\n            if output.tree then\n               io.stdout:write(output.tree)\n            end\n         end\n      else\n         io.stdout:write \"must return a table with grammar and input fields\"\n      end\n      input = \"\"\n   end\nend\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "stator",
hash = "0ffd0f68228d27dae4a962f367981b6fc07829a9b319af29472e42ce8c4b8e62",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable)\n\n\n\nlocal Stator = meta {}\n\n\n\n\n\n\n\n\n-- local _weakstate = setmeta({}, {__mode = \'v\'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(stator, _weakstate)\n   local _weakstate = _weakstate or setmeta({}, {__mode = \'v\'})\n   local _M = setmeta({}, {__index = stator, __call = call })\n   _M._weakstate =  _weakstate\n   return _M\nend\n\n\n\n\n\n\n\n\n\nlocal function new(Stator, _weakstate)\n   local stator = call(Stator, _weakstate)\n   stator.g, stator.G, stator._G = stator, stator, stator\n   return stator\nend\n\n\n\n\nreturn setmetatable(Stator, {__call = new})\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/node",
hash = "0cc3de00ecabf3fb0df8fc726aee8a5bf5ce2621b8dab1362b69f8668e188f49",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal yield = assert(coroutine.yield, \"uses coroutines\")\nlocal wrap = assert(coroutine.wrap)\nlocal sub, find = assert(string.sub, \"uses string\"), assert(string.find)\nlocal setmeta, getmeta = assert(setmetatable), assert(getmetatable)\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal a = require \"anterm:anterm\"\nlocal c_bw = require \"singletons/color\" . no_color\nlocal core = require \"core:core\"\n--local Phrase = require \"singletons/phrase\"\nlocal dot = require \"espalier/dot\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = {}\nNode.__index = Node\nNode.isNode = Node\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNode.super = core.super\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.bustCache(node)\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toLua(node)\n  s:halt(\"No toLua method for \" .. node.id)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction  Node.strTag(node, c)\n   c = c or c_bw\n   return c.bold(node.id) .. \"    \"\n      .. c.number(node.first) .. \"-\" .. c.number(node.last)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.strExtra(node, c)\n   return \"\"\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _truncate(str, base_color, c)\n   local phrase\n   if #str > 56 then\n       --  Truncate in the middle\n       local pre, post = sub(str, 1, 26), sub(str, -26, -1)\n       phrase = base_color(pre)\n                     .. c.bold(\"………\") .. base_color(post)\n   else\n       phrase = base_color(str)\n   end\n   return phrase\n           : gsub(\"\\n\", \"◼︎\")\n           : gsub(\"[ ]+\", c.greyscale(\"␣\")\n           .. base_color())\nend\n\nfunction Node.strLine(node, c)\n   c = c or c_bw\n   local phrase =  \"\"\n   phrase = phrase .. node:strTag(c)\n   if node[1] then\n      phrase = phrase .. \" \" .. node:strExtra(c) .. \"   \"\n               .. _truncate(node:span(), c.greyscale, c) .. \"\\n\"\n   else\n      local val = node.str:sub(node.first, node.last)\n      phrase = phrase .. \"    \" .. _truncate(val, c.string, c)  .. \"\\n\"\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toString(node, depth, c)\n   depth = depth or 0\n   local line =  node:strLine(c)\n   local phrase = \"\"\n   if tostring(line) ~= \"\" then\n      phrase = phrase .. (\"  \"):rep(depth)\n      phrase = phrase .. line\n   end\n   ---[[\n   if node[1] then\n      for _,v in ipairs(node) do\n         if (v.isNode) then\n            phrase = phrase .. v:toString(depth + 1, c)\n         end\n      end\n   end\n   --]]\n   return phrase\nend\n\n\n\nlocal function __tostring(node)\n   if not node.str then\n      return \"Node\"\n   end\n   return tostring(node:toString())\nend\n\nNode.__tostring = __tostring\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nlocal function __repr(node, phrase, c)\n   local node__repr = tostring(node:toString(0, c))\n   return lines(node__repr)\nend\n\nNode.__repr = __repr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.span(node)\n   return sub(node.str, node.first, node.last)\nend\n\n\n\n\n\n\n\n\n\nfunction Node.bounds(node)\n   return node.first, node.last\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.len(node)\n    return 1 + node.last - node.first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gap(left, right)\n  assert(left.last, \"no left.last\")\n  assert(right.first, \"no right.first\")\n  assert(right.last, \"no right.last\")\n  assert(left.first, \"no left.first\")\n  if left.first >= right.last then\n    local left, right = right, left\n  elseif left.last > right.first then\n    s:halt(\"overlapping regions or str issue\")\n  end\n  local gap = left - right - 1\n  if gap >= 0 then\n    return gap\n  else\n    s:halt(\"some kind of situation where gap is \" .. tostring(gap))\n  end\n\n  return nil\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.dotLabel(node)\n  return node.id\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.label(node)\n   return node.id\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.toMarkdown(node)\n  if not node[1] then\n    return sub(node.str, node.first, node.last)\n  else\n    s:halt(\"no toMarkdown for \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\nfunction Node.dot(node)\n  return dot.dot(node)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.toValue(node)\n  if node.__VALUE then\n    return node.__VALUE\n  end\n  if node.str then\n    return node.str:sub(node.first,node.last)\n  else\n    s:halt(\"no str on node \" .. node.id)\n  end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _root(node)\n   if node.parent == node then\n      return node\n   end\n   return _root(node.parent)\nend\n\nNode.root = _root\n\n\n\n\n\n\n\n\nfunction Node.walkPost(node)\n    local function traverse(ast)\n        if not type(ast) == \'table\' and ast.isNode then return nil end\n\n        for _, v in ipairs(ast) do\n            if type(v) == \'table\' and v.isNode then\n              traverse(v)\n            end\n        end\n        yield(ast)\n    end\n\n    return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\nfunction Node.walk(node)\n  local function traverse(ast)\n    if not type(ast) == \'table\' and ast.isNode then return nil end\n    yield(ast)\n    for _, v in ipairs(ast) do\n      if type(v) == \'table\' and v.isNode then\n        traverse(v)\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function qualifies(ast, pred)\n    if type(pred) == \'string\' then\n       if type(ast) == \'table\'\n        and ast.id and ast.id == pred then\n          return true\n       else\n          return false\n       end\n    elseif type(pred) == \'function\' then\n       return pred(ast)\n    else\n       s:halt(\"cannot select on predicate of type \" .. type(pred))\n    end\n end\n\nlocal remove = assert(table.remove)\n\nfunction Node.select(node, pred)\n   -- build up all the nodes that match\n   local matches = {}\n   local function traverse(ast)\n      -- depth-first, right to left\n      if type(ast) == \'table\' and ast.isNode then\n         for i = #ast, 1, -1 do\n            traverse(ast[i])\n         end\n      end\n      if qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n   traverse(node)\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Node.selectFrom(node, pred, index)\n   index = index or node.last\n   assert(type(index) == \'number\', \"index must be a number\")\n   -- build up all the nodes that match\n   local matches = {}\n\n   local function traverse(ast)\n      -- depth-first, right to left\n      for i = #ast, 1, -1 do\n        if ast[i].last >= index then\n            traverse(ast[i])\n        end\n      end\n      if ast.first > index and qualifies(ast, pred) then\n         matches[#matches + 1] = ast\n      end\n   end\n\n   traverse(node:root())\n\n   return function()\n      return remove(matches)\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Node.selectBack(node, pred)\n   -- reject any node after this\n   local boundary = node.first\n   -- set up a function which moonwalks the tree\n   local function moonwalk(ast)\n      -- depth first, right to left, starting with peers of the node\n      for i = #ast, 1, -1 do\n         local suspect = ast[i]\n         -- don\'t check anything if ast[i].first >= boundary\n         if suspect.first < boundary then\n            -- candidate\n            moonwalk(suspect)\n         end\n      end\n      if ast.first < boundary and qualifies(ast, pred) then\n         yield(ast)\n      end\n   end\n   return wrap(function() return moonwalk(node:root()) end)\nend\n\n\n\n\n\n\n\nfunction Node.tokens(node)\n  local function traverse(ast)\n    for node in Node.walk(ast) do\n      if not node[1] then\n        yield(node:toValue())\n      end\n    end\n  end\n\n  return wrap(function() traverse(node) end)\nend\n\n\n\n\n\n\n\n\n\nlocal lines = assert(core.lines)\n\nfunction Node.lines(node)\n  return lines(node:span())\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _nl_map = setmetatable({}, { __mode = \'kv\' })\nlocal findall = assert(require \"core:core/string\".findall)\n\nlocal function _findPos(nl_map, target, start)\n   local line = start or 1\n   local cursor = 0\n   local col\n   while true do\n      if line > #nl_map then\n         -- technically two possibilities: node.last is after the\n         -- end of node.str, or it\'s on a final line with no newline.\n         -- the former would be quite exceptional, so we assume the latter\n         -- here.\n         -- so we need the old cursor back:\n         cursor = nl_map[line - 1][1] + 1\n         return line, target - cursor + 1\n      end\n      local next_nl = nl_map[line][1]\n      if target > next_nl then\n         -- advance\n         cursor = next_nl + 1\n         line = line + 1\n      else\n         return line, target - cursor + 1\n      end\n   end\nend\n\nfunction Node.linePos(node)\n   local nl_map\n   if _nl_map[node.str] then\n      nl_map = _nl_map[node.str]\n   else\n      nl_map = findall(node.str, \"\\n\")\n      _nl_map[node.str] = nl_map\n   end\n   if not nl_map then\n      -- there are no newlines:\n      return 1, node.first, 1, node.last\n   end\n   -- otherwise find the offsets\n   local line_first, col_first = _findPos(nl_map, node.first)\n   local line_last, col_last = _findPos(nl_map, node.last, line_first)\n   return line_first, col_first, line_last, col_last\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _lastLeaf(node)\n  if #node == 0 then\n    return node\n  else\n    return _lastLeaf(node[#node])\n  end\nend\n\nNode.lastLeaf = _lastLeaf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.gather(node, pred)\n  local gathered = {}\n  for ast in node:select(pred) do\n    gathered[#gathered + 1] = ast\n  end\n\n  return gathered\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal cloneinstance = assert(core.cloneinstance)\n\nfunction Node.clone(node)\n   return cloneinstance(node)\nend\n\n\n\n\n\n\n\n\n\nlocal function _pluck(node, str, offset, parent)\n   local clone = setmetatable({}, getmetatable(node))\n   parent = parent or clone\n   for k, v in pairs(node) do\n      if type(k) == \"number\" then\n        clone[k] = _pluck(v, str, offset, clone)\n      elseif k == \"first\" or k == \"last\" then\n        clone[k] = v + offset\n      elseif k == \"parent\" then\n        clone.parent = parent\n      else\n        clone[k] = v\n      end\n   end\n   clone.str = str\n   return clone\nend\n\nfunction Node.pluck(node)\n   local str = node:span()\n   local offset = - node.first + 1\n   local plucked = _pluck(node, str, offset)\n--   assert(plucked.first == 1)\n   return plucked\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal inbounds = assert(require \"core:math\" . inbounds)\nlocal insert = assert(table.insert)\n\nlocal function _offsetBy(node, str, offset, dupes)\n   if dupes[node] then return end\n   node.str = str\n   node.first = node.first + offset\n   node.last = node.last + offset\n   dupes[node] = true\n   node:bustCache()\n   for i = 1, #node do\n      _offsetBy(node[i], str, offset, dupes)\n   end\nend\n\nlocal function _applyGraft(node, branch, index, insertion, replace)\n   local branch = cloneinstance(branch)\n   if replace then\n      assert(node[insertion].first == index,\n             \"illegal replacement: index is \" .. index .. \" but first of \"\n             .. node.id .. \", \'\" .. node:span() .. \"\', is \" .. node.first)\n   end\n   -- create new string\n   local str = \"\"\n   if replace then\n      str = sub(node.str, 1, index - 1)\n            .. branch.str .. sub(node.str, node[insertion].last + 1)\n   else\n      str = sub(node.str, 1, index - 1) .. branch.str .. sub(node.str, index)\n   end\n   -- calculate offset for first and last adjustment\n   local offset\n   if replace then\n      -- difference between new span and old (could be negative)\n      local old_span = node[insertion].last - node[insertion].first + 1\n      offset = #branch.str - old_span\n   else\n      offset = #branch.str\n   end\n   -- avoid offsetting nodes more than once by keeping a dupes collection:\n   local dupes = {}\n\n   -- offset the branch clone to the new index\n   _offsetBy(branch, str, index - 1, dupes)\n   -- now graft\n   branch.parent = node\n   if replace then\n      node[insertion] = branch\n   else\n      insert(node, insertion, branch)\n   end\n   -- - all parents must be adjusted on .last += offset\n   -- - all left peers of any parent get strings replaced, no adjustment\n   -- - any right peers of any parent must be adjusted by offset\n   local walking = true\n   local parent = node\n   local child = node[insertion]\n   repeat\n      if parent.parent == parent then\n         -- this is the root\n         walking = false\n      end\n      dupes[parent] = true\n      parent.last = parent.last + offset\n      parent.str = str\n      local on_left = true\n      for i, sibling in ipairs(parent) do\n         if on_left and sibling ~= child then\n            -- (only) replace the string\n            _offsetBy(sibling, str, 0, dupes)\n         elseif sibling == child then\n            on_left = false\n          -- we\'ve offset this already\n         else\n            _offsetBy(sibling, str, offset, dupes)\n         end\n      end\n      child = parent\n      parent = parent.parent\n   until not walking\n\nend\n\nlocal function graft(node, branch, index, replace)\n   assert(type(index) == \'number\', \"index must be a number\")\n   if #node == 0 then\n     -- we can\'t graft onto a token\n     local line, col = node:linePos()\n     error(\"can\'t graft in the middle of token \" .. node.id\n           .. \"at line: \" .. line .. \", col: \" .. col .. \", index: \" .. index)\n   end\n   -- search for a graft point at index\n   -- we can graft anywhere between node.first and node[1].first:\n   if inbounds(index, node.first, node[1].first) then\n      return _applyGraft(node, branch, index, 1, replace)\n   -- same for node[#node].last + 1 and node.last + 1:\n   elseif inbounds(index, node[#node].last + 1, node.last + 1) then\n      return _applyGraft(node, branch, index, #node + 1, replace)\n   end\n   -- we either find a gap, or a sub-node we should search through.\n   -- first we look for gaps:\n   for i = 2, #node do\n      if inbounds(index, node[i - 1].last + 1, node[i].first) then\n         return _applyGraft(node, branch, index, i, replace)\n      end\n   end\n   -- now, check for compatible subnodes:\n   for _, twig in ipairs(node) do\n     if inbounds(index, twig.first + 1, twig.last) then\n        return graft(twig, branch, index, replace)\n     end\n   end\n   -- here we\'re just stuck: bad index is likely\n   error(\"unable to graft \" .. branch.id .. \" onto \" .. node.id\n         .. \"\'\" .. node:span().. \"\'\" .. \" at index \" .. index\n         .. \". #node.str == \" .. #node.str)\nend\n\nfunction Node.graft(node, branch, index)\n   return graft(node, branch, index)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.replace(node, branch, index)\n   return graft(node, branch, index, true)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.isValid(node)\n  assert(node.id, \"node must have an id\")\n  assert(node.isNode == Node, \"isNode flag must be Node metatable, id: \"\n         .. node.id .. \" \" .. tostring(node))\n  assert(node.first, \"node must have first\")\n  assert(type(node.first) == \"number\", \"node.first must be of type number\")\n  assert(node.last, \"node must have last\")\n  assert(type(node.last) == \"number\", \"node.last must be of type number\")\n  assert(node.str, \"node must have str\")\n  assert(type(node.str) == \"string\"\n         or node.str.isPhrase, \"str must be string or phrase\")\n  assert(getmetatable(node), \"node must have a metatable: \" .. node.id)\n  assert(node.parent and node.parent.isNode == Node,\n         \"node must have parent: \" .. node.id)\n  assert(type(node:span()) == \"string\", \"span() must yield string\")\n  return true\nend\n\n\n\n\n\n\n\n\nlocal function _validate(node)\n   node:isValid()\n   for _, twig in ipairs(node) do\n      assert(twig.parent == node, \"illegal parent \" .. twig.parent.id\n             .. \" should be a \" .. node.id)\n      _validate(twig)\n   end\n   return true\nend\nNode.validate = _validate\n\n\n\n\n\n\n\n\n\n\nlocal function _isCompact(node, breaks)\n   local is_compact = true\n   local subCompact\n   if #node > 0 then\n      -- node.first must match first of subnode\n      local first_match = node.first == node[1].first\n      if not first_match then\n        -- register the \'break\'\n        local line, col = node:linePos()\n        insert(breaks.pre, {node.id, node[1].first - node.first,\n                            line, col,\n                            node.str:sub(node.first, node[1].first - 1)})\n      end\n      is_compact = is_compact and first_match\n      for i = 2, #node do\n        -- check gap between subNodes\n        local left, right = node[i-1].last, node[i].first\n        local inter_match = left == right - 1\n        if not inter_match then\n           local _, __, line, col =  node[i-1]:linePos()\n           insert(breaks.inter, {node[i-1].id, i, node[i].id,\n                                 right - left - 1, line, col + 1,\n                                 node.str:sub(left + 1, right - 1)})\n        end\n        is_compact = is_compact and inter_match\n        -- run isCompact recursively\n        subCompact = _isCompact(node[i-1], breaks)\n        is_compact = is_compact and subCompact\n      end\n      -- test last node\n      subCompact = _isCompact(node[#node], breaks)\n      is_compact = is_compact and subCompact\n      -- node.last must match last of subnode\n      local last_match = node.last == node[#node].last\n      if not last_match then\n        local _, __, line, col = node[#node]:linePos()\n        insert(breaks.post, {node.id, node.last - node[#node].last,\n                             line, col + 1,\n                             node.str:sub(node[#node].last + 1, node.last)})\n      end\n      is_compact = is_compact and last_match\n   end\n   return is_compact\nend\n\nfunction Node.isCompact(node)\n   local breaks = { pre = {}, inter = {}, post = {} }\n   local is_compact = _isCompact(node, breaks)\n   return is_compact, breaks\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.inherit(node, id)\n  local Meta = setmeta({}, node)\n  Meta.__index = Meta\n  local _repr, _tostring = __repr, __tostring\n  local node_M = getmetatable(node)\n  if node_M then\n    _repr = node_M.__repr\n    _tostring = node_M.__tostring\n  end\n  Meta.__repr = _repr\n  Meta.__tostring = _tostring\n  if id then\n    Meta.id = id\n  end\n  return Meta\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Node.export(_, mod, constructor)\n  mod.__call = constructor\n  return setmeta({}, mod)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn Node\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier",
hash = "05aa2de1c1af0302f89baf415672d5c4e632feeeb2c54980c2af2b8762a95d3f",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal Phrase  = require \"singletons/phrase\"\nlocal Stator  = require \"singletons/stator\"\nlocal dot     = require \"espalier/dot\"\nlocal elpatt  = require \"espalier/elpatt\"\nlocal Node    = require \"espalier/node\"\n-- local Spec    = require \"espalier/spec\"\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg  = require \"espalier/peg\"\n\nlocal ortho8600 = require \"espalier/grammars/ortho-8600\"\n\nlocal dot_grammar  = require \"espalier/grammars/dot\"\n\nlocal lua_grammar  = require \"espalier/grammars/lua\"\n\n\n\nlocal lisp_grammar = require \"espalier/grammars/microlisp\"\n\nlocal date_grammar = require \"espalier/grammars/date\"\n\nlocal luatoken_grammar = require \"espalier/grammars/luatoken\"\n\nlocal lexemes = require \"espalier/lexemes\"\n\nlocal grammars = { ortho8600 = ortho8600,\n                   dot       = dot_grammar,\n                   lua       = lua_grammar,\n                   lisp      = lisp_grammar,\n                   date      = date_grammar,\n                   luatoken  = luatoken_grammar }\n\nreturn { dot      = dot,\n         elpatt   = elpatt,\n         node     = Node,\n         lex      = lexemes,\n         peg      = Peg,\n --        spec    = Spec,\n         phrase   = Phrase,\n         grammar  = Grammar,\n         grammars = grammars,\n         stator   = Stator }\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/peg",
hash = "6671baad633dc166b354afa8a771c4a19989e51549873d0c69683922515cf29b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"espalier/elpatt\"\nlocal P, R, V = L.P, L.R, L.V\nlocal Grammar = require \"espalier/grammar\"\nlocal pegMetas = require \"espalier/grammars/pegmeta\"\n\n\n\n\n\n\nlocal function pegylator(_ENV)\n   START \"rules\"\n   ---[[\n   SUPPRESS (\"enclosed\", \"form\",\n            \"element\" , \"WS\",\n            \"elements\", \"allowed_repeated\",\n            \"allowed_prefixed\", \"allowed_suffixed\", \"allowed_referred\",\n            \"simple\", \"compound\", \"prefixed\", \"suffixed\",\n            \"referred\", \"named_suffix\", \"back_referred\", \"equal_referred\",\n            \"greater_equal_referred\", \"greater_referred\",\n            \"lesser_equal_referred\", \"lesser_referred\",\n            \"pel\", \"per\" )\n   --]]\n   local comment_m  = -P\"\\n\" * P(1)\n   local comment_c =  comment_m^0\n   local letter = R\"AZ\" + R\"az\"\n   local valid_sym = letter + P\"-\" + P\"_\"\n   local digit = R\"09\"\n   local sym = valid_sym + digit\n   local symbol = letter * (sym)^0\n   local d_string = P \"\\\"\" * (P \"\\\\\" * P(1) + (1 - P \"\\\"\"))^0 * P \"\\\"\"\n   local h_string = P \"`\" * (P \"\\\\\" * P(1) + (1 - P \"`\"))^0 * P \"`\"\n   local s_string = P \"\'\" * (P \"\\\\\" * P(1) + (1 - P \"\'\"))^0 * P \"\'\"\n   local range_match =  -P\"-\" * -P\"\\\\\" * -P\"]\" * P(1)\n   local range_capture = (range_match + P\"\\\\-\" + P\"\\\\]\" + P\"\\\\\")^1\n   local range_c  = range_capture^1 * P\"-\" * range_capture^1\n   local set_match = -P\"}\" * -P\"\\\\\" * P(1)\n   local set_c    = (set_match + P\"\\\\}\" + P\"\\\\\")^1\n   local some_num_c =   digit^1 * P\"..\" * digit^1\n                +   (P\"+\" + P\"-\")^0 * digit^1\n\n\n   rules   =  V\"rule\"^1\n   rule    =  V\"lhs\" * V\"rhs\"\n\n\n   lhs     =  V\"WS\" * V\"pattern\" * V\"WS\" * (P\"=\" + \":=\" + P\"<-\" + P\"←\")\n   rhs     =  V\"form\" * V\"WS\"\n\n   pattern =  symbol\n           +  V\"hidden_pattern\"\n           +  V\"ws\"\n\n   hidden_pattern =  P\"`\" * symbol * P\"`\"\n                  +  P\"`_`\"\n\n   -- SUPPRESSED\n   form    =  V\"element\" * V\"elements\"\n\n   element  =   -V\"lhs\" * V\"WS\"\n            *  ( V\"simple\"\n            +    V\"compound\")\n\n   elements  =  V\"choice\"\n             +  V\"cat\"\n             +  P\"\"\n   -- /SUPPRESSED\n\n   choice =  V\"WS\" * P\"/\" * V\"form\"\n   cat =  V\"WS\" * V\"form\"\n\n   -- SUPPRESSED\n   compound =  V\"group\"\n          +  V\"enclosed\"\n          +  V\"hidden_match\"\n   -- /SUPPRESSED\n\n   group   =  V\"WS\" * V\"pel\"\n           *  V\"WS\" * V\"form\" * V\"WS\"\n           *  V\"per\"\n\n   hidden_match =  V\"WS\" * P\"``\"\n                *  V\"WS\" * V\"form\" * V\"WS\"\n                *  P\"``\"\n   -- SUPPRESSED\n   pel     = P \"(\"\n   per     = P \")\"\n\n   simple   =  V\"repeated\"\n            +  V\"named\"\n            +  V\"prefixed\"\n            +  V\"suffixed\"\n            +  V\"atom\"\n            +  V\"number\"\n\n   enclosed =  V\"literal\"\n            +  V\"hidden_literal\"\n            +  V\"set\"\n            +  V\"range\"\n\n   prefixed =  V\"not_predicate\"\n            +  V\"and_predicate\"\n\n   suffixed =  V\"zero_or_more\"\n            +  V\"one_or_more\"\n            +  V\"optional\"\n\n   allowed_prefixed =  V\"suffixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n   allowed_suffixed =  V\"prefixed\" + V\"compound\" +  V\"atom\" + V\"number\"\n\n   allowed_repeated =  V\"prefixed\"\n                    +  V\"suffixed\"\n                    +  V\"compound\"\n                    +  V\"atom\"\n                    +  V\"number\"\n\n   -- /SUPPRESSED\n\n   not_predicate = P\"!\" * V\"WS\" * V\"allowed_prefixed\"\n   and_predicate = P\"&\" * V\"WS\" * V\"allowed_prefixed\"\n\n   literal =  d_string\n           +  s_string\n\n   hidden_literal =  h_string\n\n           set =  P\"{\" * set_c^1 * P\"}\"\n\n       range   =  P\"[\" * V\"range_start\" * P\"-\" * V\"range_end\" * P\"]\"\n   range_start = range_capture\n   range_end   = range_capture\n\n    zero_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"*\"\n     one_or_more =  V\"allowed_suffixed\" * V\"WS\" * P\"+\"\n        optional =  V\"allowed_suffixed\" * V\"WS\" * P\"?\"\n        repeated =  V\"allowed_repeated\" * V\"WS\" * P\"%\" * V\"number_repeat\"\n           named =  V\"allowed_repeated\" * V\"WS\" * V\"named_suffix\"\n\n   named_suffix  =  P\"@\" * ( V\"named_match\"\n                           + V\"back_referred\"\n                           + V\"equal_referred\"\n                           + V\"greater_equal_referred\"\n                           + V\"greater_referred\"\n                           + V\"lesser_equal_referred\"\n                           + V\"lesser_referred\" )\n\n   back_referred   =  P\"(\" * V\"back_reference\" * P\")\"\n   equal_referred  =  P\"(#\" * V\"equal_reference\" * P\")\"\n   greater_equal_referred = P\"(>=\" * V\"gte_reference\" * P\")\"\n   greater_referred = P\"(>\" * V\"gt_reference\" * P\")\"\n   lesser_equal_referred = P\"(<=\" * V\"lte_reference\" * P\")\"\n   lesser_referred = P\"(<\" * V\"lt_reference\" * P\")\"\n\n   named_match     = symbol\n   back_reference  = symbol\n   equal_reference = symbol\n   gte_reference   = symbol\n   gt_reference    = symbol\n   lte_reference   = symbol\n   lt_reference    = symbol\n\n   number_repeat =  some_num_c\n   named_repeat  =  symbol\n\n   comment  =  P\";\" * comment_c\n\n   atom =  V\"ws\" + symbol\n\n   number = P\"-\"^-1 * digit^1\n\n   WS = (V\"comment\" + V\"dent\" + P\' \' + P\'\\t\' + P\'\\r\')^0\n\n   dent = P\"\\n\" * (P\"\\n\" + P\" \")^0\n\n   ws = P\"_\"\nend\n\n\n\nlocal PegGrammar = Grammar(pegylator, pegMetas)\n\n\n\nlocal function new(peg_str, metas, pre, post)\n   local peg_node = PegGrammar(peg_str)\n   if not peg_node then return nil end\n   local ok\n   ok, peg_node.parse, peg_node.grammar = pcall(Grammar,peg_node:toLpeg(),\n                                              metas, pre, post)\n   if not ok then\n      peg_node.parse, peg_node.grammar = nil, nil\n   end\n   return peg_node\nend\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/dot",
hash = "176b4cb59e474387f2411bf1df7e08dbe4b6d034d8276be528f15ef9971fa62d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal t = {}\n\nlocal dot_header = [=[\ndigraph lpegNode {\n\nnode [fontname=Helvetica]\nedge [style=dashed]\n\n]=]\n\nlocal dot_footer = [=[\n\n}\n]=]\n\nlocal leaf_font  = \"Inconsolata\"\nlocal leaf_color = \"Gray\"\n\nlocal function sanitize_string(str)\n   -- filter \\ and \"\n   local phrase = str:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\'\"\', \'\\\\\"\')\n   if phrase:sub(-1,-1) == \"\\n\" then\n      return phrase:sub(1, -2)\n   else\n      return phrase\n   end\nend\n\nlocal function ast_to_label(ast, leaf_count)\n   -- nodes need unique names, so we append a leaf_count and increment it\n   local label      = ast.id.. \"_\" .. leaf_count \n   local label_line = label .. \" [label=\\\"\"\n      .. sanitize_string(ast:dotLabel()) .. \"\\\"]\\n\"\n   return label, label_line, leaf_count + 1\nend\n\nlocal function list_from_table(tab)\n   local table_list = \"\"\n   for _,v in ipairs(tab) do\n      table_list = table_list..\" \"..v\n   end\n   return table_list\nend\n\nlocal function value_to_label(value, leaf_count)\n   -- Generates a name and label for a leaf node.\n   -- Returns these with an incremented leaf_count.\n   local value = sanitize_string(value)\n   local name  = \"leaf_\"..leaf_count\n   local label = \" [color=\"..leaf_color..\",shape=rectangle,fontname=\"\n         ..leaf_font..\",label=\\\"\"..value..\"\\\"]\\n\"\n\n   return name, label, leaf_count + 1\nend\n\n\n\n\n\n\n\n\n\nlocal function dot_ranks(ast, phrase, leaf_count, ast_label)\n   local leaf_count = leaf_count or 0\n\n   -- Add the node we\'re working on\n   if ast.isNode then\n      local label = \"\"\n      local label_line = \"\"\n      local child_labels = {}\n      local child_label_lines = {}\n\n      -- Handle anonymous nodes\n      if not ast_label then\n         label, label_line, leaf_count = ast_to_label(ast, leaf_count)\n         phrase = phrase .. label_line .. \"\\n\\n\"\n      else \n         label = ast_label \n      end\n\n      -- Document child nodes\n      for i,v in ipairs(ast) do\n         -- assemble labels and label lines for all child nodes\n         if v.isNode then\n            child_labels[i], child_label_lines[i], leaf_count = \n               ast_to_label(v, leaf_count)\n         end\n      end\n\n      local child_list = list_from_table(child_labels)\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..label..\" -> {\"..child_list..\"}\\n\"\n         phrase = phrase..\"{rank=same;\"..list_from_table(child_labels)..\"}\\n\\n\"\n      end\n\n      -- Concatenate child label lines\n      for _, v in ipairs(child_label_lines) do\n         phrase = phrase..v..\"\\n\"\n      end\n\n      if next(child_labels) ~= nil then\n         phrase = phrase..\"\\n\"\n      end\n\n      local leaf_val = nil\n\n      if ast.val then\n         leaf_val = ast.val\n      elseif ast.toValue then\n         leaf_val = ast:toValue()\n      end\n\n      -- Document value of leaf nodes\n      if (not ast[1]) and leaf_val then\n         local name = \"\" ; local val_label = \"\"\n         name, val_label, leaf_count = value_to_label(leaf_val, leaf_count)\n         phrase = phrase..label..\" -> \"..name..\"\\n\"\n         phrase = phrase..name..\" \"..val_label\n      end\n\n      local separator = \"// END RANK \" .. label .. \"\\n\\n\"\n      phrase = phrase .. separator\n\n      -- Execute recursively for all nodes\n      for i, v in ipairs(ast) do\n         if v.isNode  then\n            phrase, leaf_count = dot_ranks(v, phrase, leaf_count, child_labels[i])\n         end\n      end\n   end\n\n   return phrase, leaf_count\nend\n\n\n\n\n\nfunction t.dot(ast)\n   local phrase = dot_header\n\n   return  dot_ranks(ast, phrase) .. dot_footer\nend\n\nreturn t\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/toml",
hash = "2ce6c0bc3b9307b3b33f2f5b1a13d082a8cf0ee3665d41003dcef2a53b0d3ebe",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\n\n\nlocal toml_str = [=[\n\n;; Overall Structure\n\n   toml    <-  expression (nl expression)*\n\n`expression` <-  ws keyval ws comment?\n             /  ws table  ws comment?\n             /  ws comment\n             /  ws &nl\n\n;; Whitespace\n\n        `ws`  <-  {\\t }*\n    `wschar`  <-  {\\t }+\n\n;; Newline\n\n        `nl`  <- \"\\n\" / \"\\r\\n\"\n\n;; Comment\n\n     comment  <- \"#\" (!nl 1)*\n\n;; Key-Value pairs\n\n      keyval  <-  key ws \"=\" ws val\n               /  key ws \"=\" ws Error\n\n         key  <-  dotted-key / simple-key ; / (!\"=\" 1) &\"=\" Error\n\n`simple-key`  <-  quoted-key / unquoted-key\n\nunquoted-key  <-  ([A-Z] / [a-z] / [0-9] / \"-\" / \"_\")+\n\n  quoted-key  <-  basic-string / literal-string\n\n  dotted-key  <-  simple-key (\".\" simple-key)+\n\n         val  <-  string / boolean / array / inline-table\n                  / date-time / float / integer\n\n;; String\n\n        `string`  <-  ml-basic-string   / basic-string\n                  /   ml-literal-string / literal-string\n\n;; Note: this isn\'t technically TOML, because we\'ll use Lua string\n;; conventions. I have no interest in implementing \\u.\n\n    basic-string  <-  \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n                  /   \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* &\"\\n\" Error\n\n ml-basic-string  <- \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' 1) / &\'\"\"\"\"\' \'\"\')* \'\"\"\"\'\n                  /  \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' !-2 1))* Error\n\n  literal-string  <-  \"\'\"  (!\"\'\" !\"\\n\" 1)* \"\'\"\n                  /   \"\'\"  (!\"\'\" !\"\\n\" 1)* &\"\\n\" Error\n\nml-literal-string <- \"\'\'\'\" (!\"\'\'\'\" 1 / &\"\'\'\'\'\" \"\'\")* \"\'\'\'\"\n                  /  \"\'\'\'\" (!\"\'\'\'\" !-2 1)* Error\n\n;; Integer\n\n    integer  <-  hexadecimal / octal / binary / decimal\n\n    decimal  <-  sign? dec-int\n\n       sign  <-  \"+\" / \"-\"\n\n  `dec-int`  <-  [0-9] / [1-9] ([0-9] / \"_\" [0-9])+\n\nhexadecimal  <-  \"0x\" higit (higit / \"_\" higit)*\n\n    `higit`  <- [A-F] / [a-f] / [0-9]\n\n      octal  <- \"0o\" [0-7] ([0-7] / \"_\" [0-7])*\n\n     binary  <- \"0b\" [0-1] ([0-1] / \"_\" [0-1])*\n\n;; Float\n\nfloat <- decimal \".\" decimal* ((\"e\" / \"E\") \"-\"? decimal)?\n      /  special-float\n\nspecial-float = sign? (\"inf\" / \"nan\")\n\n;; Boolean\n\nboolean = \"true\" / \"false\"\n\n;;; Not in the mood to port dates from \'ortho8600\'\n;; Date and Time (as defined in RFC 3339)\n\ndate-time <- \"placeholder@#$%@$#%\"\n\n;; Offset Date-Time\n\noffset-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date-Time\n\nlocal-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date\n\nlocal-date <- \"placeholder@#$%@$#%\"\n\n;; Local Time\n\nlocal-time <- \"placeholder@#$%@$#%\"\n\n;; Array\n\n        array  <-  \"[\" array-values? opt-comment \"]\"\n\n`opt-comment`  <-  (ws comment? nl ws)+ / ws\n\n array-values  <-  opt-comment val (opt-comment \",\" opt-comment val)* \",\"*\n\n;; Table\n\ntable  <-  std-table / array-table\n\n;; Standard Table\n\nstd-table  <-  \"[\" ws key ws \"]\"\n\n;; Inline Table\n\ninline-table <-  \"{\" ws (keyval (ws \",\" ws keyval)*)* ws \"}\"\n\n;; Array Table\n\narray-table <- \"[[\" ws key ws \"]]\"\n\n;; Error\n\nError  <-  1*\n]=]\n\n\nreturn Peg(toml_str)\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/pegmeta",
hash = "d5f38dd301a8146c22ad6d05ddeacd732ffa7d9e76356b9e1c24189051cbcaea",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier/node\"\nlocal Grammar = require \"espalier/grammar\"\nlocal Phrase = require \"singletons/phrase\"\n\nlocal inherit = assert(require \"core:core/meta\" . inherit)\nlocal insert, remove, concat = assert(table.insert),\n                               assert(table.remove),\n                               assert(table.concat)\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal ok, lex = pcall(require, \"helm:helm/lex\")\nif not ok then\n   lex = function(repr, window, c) return tostring(repr) end\nelse\n   local lua_thor = lex.lua_thor\n   lex = function(repr, window, c)\n            local toks = lua_thor(tostring(repr))\n            for i, tok in ipairs(toks) do\n              toks[i] = tok:toString(c)\n            end\n            return concat(toks)\n         end\nend\n\n\n\n\n\n\nlocal Peg, peg = Node : inherit()\nPeg.id = \"peg\"\n\n\n\n\n\n\n\n\n\nlocal PegPhrase = Phrase : inherit ({__repr = lex})\n\n\n\n\n\n\nlocal nl_map = { rule = true }\nlocal function _toSexpr(peg)\n   depth = depth or 0\n   local sexpr_line = { (\" \"):rep(depth), \"(\" } -- Phrase?\n   local name = peg.name or peg.id\n   insert(sexpr_line, name)\n   insert(sexpr_line, \" \")\n   for _, sub_peg in ipairs(peg) do\n      local _toS = sub_peg.toSexpr or _toSexpr\n      insert(sexpr_line, _toS(sub_peg))\n      insert(sexpr_line, \" \")\n   end\n   remove(sexpr_line)\n   insert(sexpr_line, \")\")\n   if nl_map[name] then\n      insert(sexpr_line, \"\\n\")\n   end\n\n   return concat(sexpr_line)\nend\n\nPeg.toSexpr = _toSexpr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __repr(repr, phrase, c)\n   return _toSexpr(repr[1])\nend\n\nlocal ReprMeta = { __repr = __repr,\n                   __tostring = __repr }\nReprMeta.__index = ReprMeta\n\nlocal function newRepr(peg)\n   local repr = setmetatable({}, ReprMeta)\n   repr[1] = peg\n   return repr\nend\n\n\n\nfunction Peg.toSexprRepr(peg)\n   return newRepr(peg)\nend\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nfunction Peg.toLpeg(peg)\n   local phrase = PegPhrase \"\"\n   for _, sub in ipairs(peg) do\n      phrase = phrase .. sub:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\nlocal PegMetas = Peg : inherit()\nPegMetas.id = \"pegMetas\"\n\n\n\n\n\n\n\n\n\n\n\nlocal Rules = PegMetas : inherit \"rules\"\n\n\n\n\n\n\n\n\nfunction Rules.__call(rules, str, start, finish)\n   if not rules.parse then\n      rules.parse, rules.grammar = Grammar(rules:toLpeg())\n   end\n   return rules.parse(str, start, finish)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = PegPhrase ([[\nlocal L = assert(require \"lpeg\")\nlocal P, V, S, R = L.P, L.V, L.S, L.R\nlocal C, Cg, Cb, Cmt = L.C, L.Cg, L.Cb, L.Cmt\n]])\n\n\n\nlocal backref_rules = {\n   back_reference = [[\nlocal function __EQ_EXACT(s, i, a, b)\n   return a == b\nend\n]],\n   equal_reference = [[\nlocal function __EQ_LEN(s, i, a, b)\n   return #a == #b\nend\n]],\n   gte_reference = [[\nlocal function __GTE_LEN(s, i, a, b)\n   return #a >= #b\nend\n]],\n   gt_reference = [[\nlocal function __GT_LEN(s, i, a, b)\n   return #a > #b\nend\n]],\n   lte_reference = [[\nlocal function __LTE_LEN(s, i, a, b)\n   return #a <= #b\nend\n]],\n   lt_reference = [[\nlocal function __LT_LEN(s, i, a, b)\n   return #a < #b\nend\n]]\n}\n\n\n\n\n\n\n\n\nlocal function _normalize(str)\n   return str:gsub(\"%-\", \"%_\")\nend\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function _suppressHiddens(peg_rules)\n   local hiddens = {}\n   for hidden_patt in peg_rules : select \"hidden_pattern\" do\n      local normal = _normalize(hidden_patt:span():sub(2,-2))\n      insert(hiddens, normal)\n   end\n   if #hiddens == 0 then\n      -- no hidden patterns\n      return nil\n   end\n   local len = 14\n   local phrase = PegPhrase \"   \" .. \"SUPPRESS\" .. \" \" .. \"(\"\n   for i, patt in ipairs(hiddens) do\n      phrase = phrase .. \"\\\"\" .. patt .. \"\\\"\"\n      len = len + #patt + 2\n      if i < #hiddens then\n         phrase = phrase .. \",\" .. \" \"\n         if len > 80 then\n            phrase = phrase .. \"\\n\" .. (\" \"):rep(14)\n            len = 14\n         end\n      end\n   end\n   return phrase .. \")\" .. \"\\n\\n\"\nend\n\nfunction Rules.toLpeg(peg_rules, extraLpeg)\n   local phrase = PegPhrase()\n   -- Add matching functions if those rules are used\n   for rule, fn_str in pairs(backref_rules) do\n       if peg_rules:select(rule)() then\n          phrase = phrase .. fn_str\n       end\n   end\n   phrase = phrase .. \"\\n\"\n   -- the first rule should have an atom:\n   -- peg_rules[1]   -- this is the first rule\n   local grammar_patt = peg_rules : select \"rule\" ()\n                         : select \"pattern\" ()\n   local grammar_name = grammar_patt:span()\n   -- the root pattern can conceivably be hidden:\n   if grammar_name:sub(1,1) == \"`\" then\n      grammar_name = grammar_name:sub(2,-2)\n   end\n   grammar_name = _normalize(grammar_name)\n   local grammar_fn  = \"_\" .. grammar_name ..\"_fn\"\n   phrase = phrase .. \"local function \" .. grammar_fn .. \"(_ENV)\\n\"\n   phrase = phrase .. \"   \" .. \"START \" .. \"\\\"\" .. grammar_name .. \"\\\"\\n\"\n   -- Build the SUPPRESS function here, this requires finding the\n   -- hidden rules and suppressing them\n   local suppress = _suppressHiddens(peg_rules)\n   if suppress then\n      phrase = phrase .. suppress\n   end\n   -- add initial indentation:\n   phrase = phrase .. \"\\n\"\n   --\n   -- stick everything else in here...\n   ---[[\n   for rule in peg_rules : select \"rule\" do\n      phrase = phrase .. rule:toLpeg()\n   end\n   --]]\n   phrase = phrase .. (extraLpeg or \"\")\n   phrase = phrase .. \"\\nend\\n\\n\"\n   local appendix = PegPhrase \"return \" .. grammar_fn .. \"\\n\"\n   return _PREFACE .. phrase .. appendix\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rules.toGrammar(rules, metas, pre, post, extraLpeg, header)\n   metas = metas or {}\n   header = header or \"\"\n   local rule_str = rules:toLpeg(extraLpeg)\n   rule_str = header .. rule_str\n   rules.parse, rules.grammar = Grammar(rule_str, metas, pre, post)\n   return rules.parse\nend\n\n\n\n\n\n\n\n\nlocal Rule = PegMetas : inherit \"rule\"\n\nlocal function _pattToString(patt)\n   local is_hidden = patt : select \"hidden_pattern\" ()\n   if is_hidden then\n      return is_hidden:span():sub(2, -2)\n   else\n      return patt:span()\n   end\nend\n\nfunction Rule.toLpeg(rule)\n   local phrase = PegPhrase \"\"\n   local patt = _normalize(_pattToString(rule:select \"pattern\" ()))\n   phrase = phrase .. patt .. \" = \"\n   return phrase .. rule:select \"rhs\" () : toLpeg ()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rhs = PegMetas : inherit \"rhs\"\n\nfunction Rhs.toLpeg(rhs)\n   local phrase = PegPhrase()\n   for _, twig in ipairs(rhs) do\n      phrase = phrase .. \" \" .. twig:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Choice = PegMetas : inherit \"choice\"\n\nfunction Choice.toLpeg(choice)\n   local phrase = PegPhrase \"+\"\n   for _, sub_choice in ipairs(choice) do\n      phrase = phrase .. \" \" .. sub_choice:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Cat = PegMetas : inherit \"cat\"\n\nfunction Cat.toLpeg(cat)\n   local phrase = PegPhrase \"*\"\n   for _, sub_cat in ipairs(cat) do\n      phrase = phrase .. \" \" .. sub_cat:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Group = PegMetas : inherit \"group\"\n\nfunction Group.toLpeg(group)\n   local phrase = PegPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. \" \" .. sub_group:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Not_predicate = PegMetas : inherit \"not_predicate\"\n\nfunction Not_predicate.toLpeg(not_pred)\n   local phrase = PegPhrase \"-(\"\n   for _, sub_not_pred in ipairs(not_pred) do\n      phrase = phrase .. sub_not_pred:toLpeg()\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\n\n\nlocal And_predicate = PegMetas : inherit \"and_predicate\"\n\nfunction And_predicate.toLpeg(and_predicate)\n   local phrase = PegPhrase \"#\"\n   for _, sub_and_predicate in ipairs(and_predicate) do\n      phrase = phrase .. \" \" .. sub_and_predicate:toLpeg()\n   end\n   return phrase\nend\n\n\n\n\n\n\n\n\nlocal Literal = PegMetas : inherit \"literal\"\n\nfunction Literal.toLpeg(literal)\n   return PegPhrase \"P\" .. literal:span()\nend\n\n\n\n\n\n\nlocal Set = PegMetas : inherit \"set\"\n\nfunction Set.toLpeg(set)\n   return PegPhrase \"S\\\"\" .. set:span():sub(2,-2) .. \"\\\"\"\nend\n\n\n\n\n\n\nlocal Range = PegMetas : inherit \"range\"\n\n\n\nfunction Range.toLpeg(range)\n   local phrase = PegPhrase \"R\\\"\"\n   phrase = phrase .. range : select \"range_start\" () : span()\n   return phrase .. range : select \"range_end\" () : span() .. \"\\\" \"\nend\n\n\n\n\n\n\nlocal Zero_or_more = PegMetas : inherit \"zero_or_more\"\n\nfunction Zero_or_more.toLpeg(zero_or_more)\n   local phrase = PegPhrase()\n   for _, sub_zero in ipairs(zero_or_more) do\n      phrase = phrase .. \" \" .. sub_zero:toLpeg()\n   end\n   return phrase .. \"^0\"\nend\n\n\n\n\n\n\nlocal One_or_more = PegMetas : inherit \"one_or_more\"\n\nfunction One_or_more.toLpeg(one_or_more)\n   local phrase = PegPhrase()\n   for _, sub_more in ipairs(one_or_more) do\n      phrase = phrase .. \" \" .. sub_more:toLpeg()\n   end\n   return phrase .. \"^1\"\nend\n\n\n\n\n\n\nlocal Optional = PegMetas : inherit \"optional\"\n\nfunction Optional.toLpeg(optional)\n   local phrase = PegPhrase()\n   for _, sub_optional in ipairs(optional) do\n      phrase = phrase .. \" \" .. sub_optional:toLpeg()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Repeated = PegMetas : inherit \"repeated\"\n\nfunction Repeated.toLpeg(repeated)\n   local phrase = PegPhrase \"\"\n   local condition = repeated[1]:toLpeg():intern()\n   local times = repeated[2]:span()\n      -- match at least times - 1 and no more than times\n   phrase = phrase .. \"#\" .. condition .. \"^\" .. times\n               .. \" * \" .. condition .. \"^-\" .. PegPhrase(times)\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nlocal Named = PegMetas : inherit \"named\"\n\nfunction Named.toLpeg(named)\n   local phrase = PegPhrase \"\"\n   local condition = named[1]:toLpeg():intern()\n   if named[2].id == \"named_match\" then\n     -- make a capture group\n     phrase = phrase .. \"Cg(\" .. condition .. \",\'\" .. named[2]:span()\n               .. PegPhrase \"\')\"\n   elseif named[2].id == \"back_reference\" then\n     -- make a back reference with equality comparison\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_EXACT)\"\n   elseif named[2].id == \"equal_reference\" then\n     -- make a back reference, compare by length\n     phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __EQ_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GTE_LEN)\"\n   elseif named[2].id == \"gt_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __GT_LEN)\"\n   elseif named[2].id == \"lte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LTE_LEN)\"\n   elseif named[2].id == \"gte_reference\" then\n      phrase = phrase .. \"Cmt(C(\" .. condition\n               .. \") * Cb(\'\" .. named[2]:span()\n               .. PegPhrase\"\'), __LT_LEN)\"\n   else\n      error(\"unexpected back reference, id \" .. tostring(named[2].id))\n   end\n   return phrase\nend\n\n\n\n\n\n\nlocal Comment = PegMetas : inherit \"comment\"\n\nfunction Comment.toSexpr(comment)\n   return \"\"\nend\n\nfunction Comment.toLpeg(comment)\n   local phrase = PegPhrase \"--\"\n   return phrase .. comment:span():sub(2)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Atom = PegMetas : inherit \"atom\"\n\nfunction Atom.toLpeg(atom)\n   local phrase = PegPhrase \"V\"\n   phrase = phrase .. \"\\\"\" .. _normalize(atom:span()) .. \"\\\"\"\n   return phrase\nend\n\n\n\n\n\n\nlocal Number = PegMetas : inherit \"number\"\n\nfunction Number.toLpeg(number)\n   local phrase = PegPhrase \"P(\"\n   return phrase .. number:span() .. \")\"\nend\n\n\n\n\n\n\n\n\n\nlocal Dent = PegMetas : inherit \"dent\"\n\nfunction Dent.toLpeg(dent)\n   return dent:span()\nend\n\nfunction Dent.strLine(dent)\n   return \"\"\nend\n\n\n\n\n\n\nlocal Whitespace = PegMetas : inherit \"WS\"\n\nfunction Whitespace.toLpeg(whitespace)\n   return PegPhrase(whitespace:span())\nend\n\n\n\nreturn { Peg,\n         rules   = Rules,\n         rule    = Rule,\n         rhs     = Rhs,\n         comment = Comment,\n         choice  = Choice,\n         cat     = Cat,\n         group   = Group,\n         atom    = Atom,\n         number  = Number,\n         set     = Set,\n         range   = Range,\n         literal = Literal,\n         zero_or_more  = Zero_or_more,\n         one_or_more   = One_or_more,\n         not_predicate = Not_predicate,\n         and_predicate = And_predicate,\n         optional  = Optional,\n         repeated  = Repeated,\n         named     = Named,\n         WS        = Whitespace,\n         dent      = Dent }\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/dot",
hash = "ce68309e144a69ddd34a52b87da3c66f3601b1ee1b2d3f90689bf2df54dc77b4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\nlocal L       =  require \"espalier/elpatt\"\n\nlocal P, R, E, V, S    =  L.P, L.R, L.E, L.V, L.S\n\nlocal _ = (P\" \" + P\"\\n\" + P\"\\t\" + P\"\\r\")^0\n\nlocal IDstart =  R(\"az\", \"AZ\") + \"_\" -- dot is actually latin-1 but\nlocal IDrest  =  IDstart + R\"09\"\n\nlocal num     =  P\"-\"^0 * (P\".\" + R\"09\"^1)\n              +  R\"09\"^1 * P\".\"^0 * R\"09\"^0\n\nlocal string_patt = P\"\\\"\" * (P(1) - (P\"\\\"\" * - P\"\\\\\\\"\"))^0 * P\"\\\"\"\n\nlocal function dot_fn(_ENV)\n   START \"dot\"\n\n   dot =  _ * P\"strict\"^0 * _ * (P\"graph\" + P\"digraph\")\n       *  _ * V\"ID\"^0 * _ * \"{\" * _ * V\"statment_list\" * _ * \"}\" * _\n\n   statement_list =  V\"statement\"^0 * _ * P\";\"^0 * _ * V\"statement\"^0\n\n   statement  =  V\"node_statement\"\n              +  V\"edge_statement\"\n              +  V\"attr_statement\"\n              +  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n              +  V\"subgraph\"\n\n   attr_statement =  (P\"graph\" + \"node\" + \"edge\") * V\"attr_list\"\n   attr_list      =  P\"[\" * _ * V\"a_list\"^0 * _ * P\"]\" * _ * V\"attr_list\"^0\n   a_list         =  V\"ID\" * _ * \"=\" * _ * V\"ID\"\n                  * (P\";\" + P\",\")^0 * _ * V\"a_list\"^0\n\n   edge_statement =  (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\" * V\"attr_list\"^0\n   edgeRHS        =  V\"edgeop\" * _ * (V\"node_id\" + V\"subgraph\") * _ * V\"edgeRHS\"^0\n\n   node_statement =  V\"node_id\" * _ * V\"attr_list\"^0\n   node_id        =  V\"ID\" * _ * V\"port\"^0\n   port           =  P\":\" * _ * V\"ID\" * _ * (P\":\" * _ * V\"compass_point\")^0\n\n   subgraph       =  (V\"subgraph\" * _ * V\"ID\"^0)^0 * _\n                  *  \"{\" * _ * V\"statement_list\" * _ * \"}\"\n\n   compass_point  =  S(\"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\",\"_\")\n\n   ID    =  (V\"IDstart\"^1 * V\"IDrest\"^0) + V\"num\" + V\"string_patt\"\n\n   -- Add C-style comments\n\nend\n\nreturn Grammar(dot_fn)\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/date",
hash = "4b8433dc412e98d4d51c9e3a4a6574f9f741ab971e2f23eec609be4e84b5bede",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\nlocal date_peg = [[\n   date  =  yearMonthDayTime\n         /  yearMonthDay\n         /  yearMonth\n         /  year\n\n   `yearMonthDay` = year \"-\" monthDay\n   `yearMonth` = year \"-\" month\n\n   year = positiveYear / negativeYear / \"0000\"\n\n   `positiveYear` =  [1-9] [0-9] [0-9] [0-9]\n                  /  \"0\"   [1-9] [0-9] [0-9]\n                  /  \"00\"        [1-9] [0-9]\n                  /  \"000\"             [1-9]\n   `negativeYear` = \"-\" positiveYear\n\n   `monthDay` =  m31 \"-\" day\n              /  m30 \"-\" (!longMonth day)\n              /  mFeb \"-\" (!threeDecan day)\n   m31      =  \"01\" / \"03\" / \"05\" / \"07\" / \"08\" / \"10\" / \"12\"\n   m30      =  \"06\" / \"04\" / \"09\" / \"11\"\n   mFeb     =  \"02\"\n\n   ; only used in negative lookahead\n   longMonth = \"31\"\n   threeDecan = \"31\" / \"30\"\n\n   month  =  m31 / m30 / mFeb\n\n   day  =  \"0\" [1-9]\n        /  (\"1\" / \"2\") [0-9]\n        /  (\"30\" / \"31\")\n\n   `yearMonthDayTime` = yearMonthDay separator time\n   `separator` = \"T\" / \" \" / \"::\" ; opinionated!\n\n\n   time = hourMinuteSecond\n        / hourMinute\n        / hour\n\n   `hourMinuteSecond` = hour \":\" minute \":\" second fracSecond? timeZone?\n   `hourMinute` = hour \":\" minute\n   hour = [0-1] [1-9] / \"2\" [0-3]\n   minute = sexigesimal\n   second = sexigesimal\n   fracSecond = \".\" [0-9] [0-9]? [0-9]?\n\n   timeZone = zulu /  offset\n   `offset` = (positive / negative) (hour \":\" minute / hour minute / hour)\n   positive = \"+\"\n   negative = \"-\"\n   zulu = \"Z\"\n   `sexigesimal` = [0-5] [0-9]\n]]\n\n\n\nreturn Peg(date_peg):toGrammar()\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/lua",
hash = "f5bb65ad2a8cd0c3ac52e6a3fae57023448fc02aa817244aa052afcd34dd33b0",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier/peg\"\n\n\n\n\n\nlocal lua_str = [[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr \",\" expr (\",\" expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\nreturn Peg(lua_str)\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/ortho-8600",
hash = "e200a7129a10a073c6a02e5593211edb81c4bc7145241b291d818354c9635060",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--local Node    =  require \"espalier/node\"\n--local Grammar =  require \"espalier/grammar\"\nlocal require = assert(require)\nlocal L       =  require \"espalier/elpatt\"\nlocal Node    =  require \"espalier/node\"\nlocal Grammar =  require \"espalier/grammar\"\n\nlocal P, R, E, V, S, D   =  L.P, L.R, L.E, L.V, L.S, L.D\n\n\n\n\n\n\nlocal Day = Node : inherit ()\nDay.id = \"day\"\nlocal Month = Node : inherit ()\nMonth.id = \"month\"\nlocal Year = Node : inherit ()\nYear.id =  \"year\"\n\nlocal date_metas = { oneThru30 = Day,\n                     oneThru29 = Day,\n                     m31       = Month,\n                     m30       = Month,\n                     mFeb      = Month,\n                     year      = Year }\n\n\n\n\n\nlocal function _date_fn(_ENV)\n\n   START \"date\"\n\n   SUPPRESS (\"positiveYear\", \"negativeYear\"\n            , \"yearMonth\", \"yearMonthDay\", \"monthDay\"\n             -- , \"oneThru12\", \"oneThru29\",\n             -- , \"oneThru30\", \"oneThru31\"\n             )\n\n   date         = V\"yearMonthDay\"\n                + V\"yearMonth\"\n                + V\"year\"\n\n   year         = V\"positiveYear\" + V\"negativeYear\" + P\"0000\"\n\n   positiveYear = R\"19\"  * R\"09\" * R\"09\" * R\"09\"\n                + P\"0\"   * R\"19\" * R\"09\" * R\"09\"\n                + P\"00\"  * R\"19\" * R\"09\"\n                + P\"000\" * R\"19\"\n\n   negativeYear =  P\"-\" * V\"positiveYear\"\n\n   monthDay     = V\"m31\"  * P\"-\" * V\"day\"\n                + V\"m30\"  * P\"-\" * (-V\"longMonth\" * V\"day\")\n                + V\"mFeb\" * P\"-\" * (-V\"threeDecan\" * V\"day\")\n\n   m31          = (P\"01\" + P\"03\" + P\"05\" + P\"07\" + \"08\" + \"10\" + \"12\")\n\n   m30          = (P\"04\" + P\"06\" + P\"09\" + P\"11\")\n\n   mFeb         = P\"02\"\n\n   yearMonth    = V\"year\" * P\"-\" * V\"month\"\n\n   yearMonthDay = V\"year\" * P\"-\" *  V\"monthDay\"\n\n   month        = V\"m31\" + V\"m30\" + V\"mFeb\"\n\n   day          = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n                + P\"30\"\n                + P\"31\"\n\n   oneThru12    = (P\"0\" *  R\"19\") + P\"10\" + P\"11\" + P\"12\"\n\n   oneThru29    = (P\"0\" * R\"19\")\n                + (P\"1\" + P\"2\") * R\"09\"\n\n   oneThru30    = P\"30\" + V\"oneThru29\"\n\n   oneThru31    = V\"longMonth\" + V\"oneThru30\"\n\n   longMonth    = P\"31\"\n\n   threeDecan   = V\"longMonth\" + P\"30\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   uaDate        = V\"yearMonthDay\" * V\"uaSymbol\"\n\n   uaSymbol      = P\"?\" + P\"~\" + P\"%\"\n\n   reducedDate   = (V\"year\" + V\"yearMonth\") * V\"uaSymbol\"\n\n   qualifiedDate = V\"uaSymbol\"^0 * V\"year\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"month\" * V\"uaSymbol\"^0 * P\"-\"\n                 * V\"uaSymbol\"^0 * V\"day\" * V\"uaSymbol\"^0\n\n   unspecifiedDate    = (V\"yearMonth\" * P\"-XX\")\n                      + (V\"year\" * P\"-XX-XX\")\n                      * P \"XXXX-XX-XX\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn Grammar(_date_fn, date_metas, nil, nil)\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammars/microlisp",
hash = "c913a21b877f6cf6e61b0ba4bbfdfb4e2edb8d379b7c2b07c4c4a07fbb1f6bdb",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Grammar = require \"espalier/grammar\"\nlocal Peg = require \"espalier/peg\"\nlocal Node = require \"espalier/node\"\n\n\n\n\n\n\nlocal micro_lisp_peg = [[\nlisp = _ ((atom)+ / list)\nlist = pel _ (atom / list)* per _\natom = _(number / symbol)_\nsymbol = _(alpha / other) (alpha / digit / other)*_\nnumber = float / integer\n`integer` = [0-9]+\n`float` = [0-9]+ \".\" [0-9]+ ; expand\n`pel` = \'(\'\n`per` = \')\'\n`alpha` = [A-Z]/[a-z]\n`digit` = [0-9]\n`other` = {-_-=+!@#$%^&*:/?.\\\\~}\n  `_`     = { \\t\\r\\n,}*\n]]\n\n\n\nlocal micro_lisp_metas = { lisp = Node : inherit \"lisp\",\n                           atom = Node : inherit \"atom\",\n                           symbol = Node : inherit \"symbol\",\n                           number = Node : inherit \"number\" }\n\n\n\nreturn Peg(micro_lisp_peg) : toGrammar(micro_lisp_metas)\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/error",
hash = "66874b127b44837ba9c69d22c690136344e1ab42931b4a178b0f9842d938691d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L   = require \"lpeg\"\nlocal s = require \"status:status\" ()\nlocal Carg, Cc, Cp, P = L.Carg, L.Cc, L.Cp, L.P\n\n\n\nlocal Err = require \"espalier/node\" : inherit()\nErr.id = \"ERROR\"\n\n\n\n\n\n\n\n\n\nfunction Err.toLua(err)\n  local line, col = err:linePos(err.first)\n  s:halt(\"ERROR at line: \" .. line .. \" col: \" .. col)\nend\n\n\n\n\n\n\n\n\nlocal function parse_error(pos, name, msg, patt, str)\n   local message = msg or name or \"Not Otherwise Specified\"\n   s:verb(\"Parse Error: \", message)\n   local errorNode =  setmetatable({}, Err)\n   errorNode.first =  pos\n   errorNode.last  =  #str -- See above\n   errorNode.msg   =  message\n   errorNode.name  =  name\n   errorNode.str   =  str\n   errorNode.rest  =  string.sub(str, pos)\n   errorNode.patt  =  patt\n\n   return errorNode\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Err.Err(name, msg, patt)\n  return Cp() * Cc(name) * Cc(msg) * Cc(patt) * Carg(1) / parse_error\nend\n\nErr.E = Err.Err\n\nfunction Err.EOF(name, msg)\n  return -P(1) + Err.Err(name, msg), Cp()\nend\n\nreturn Err\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/subgrammar",
hash = "23cd7ba7a0931b798ded5c1b959f86e394d83a43890d35f97088c13d70d66fbd",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\n\nlocal function subgrammar(grammar, meta, errstring)\n   meta = meta or Node\n   return function (t)\n      local match = grammar(t.str, t.first, t.last)\n      if match then\n         if match.last == t.last then\n            return match\n         else\n            match.should_be = match.id\n            match.id = \"INCOMPLETE\"\n            return match\n         end\n      end\n      if errstring then\n         t.errstring = errstring\n         t.should_be = t.id\n         t.id        = \"NOMATCH\"\n      end\n      return setmetatable(t, meta)\n   end\nend\n\nreturn subgrammar\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/elpatt",
hash = "d9db627b8d6b5049c79d0a34a7cd079d87f66cab4a81c19553a3768df526d7ee",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal lpeg = require \"lpeg\"\nlocal C, Cmt, Ct = assert(lpeg.C),\n                   assert(lpeg.Ct),\n                   assert(lpeg.Ct)\nlocal P, R, S, V = assert(lpeg.P),\n                   assert(lpeg.R),\n                   assert(lpeg.S),\n                   assert(lpeg.V)\n\n\n\n\n\nlocal elpatt = {}\nfor k, v in pairs(lpeg) do\n   elpatt[k] = v\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal I = lpeg.Cp()\n\nfunction elpatt.anywhere(p)\n     return P{ I * C(p) * I + 1 * V(1) }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function rep(patt, n, m)\n   patt = P(patt)\n   assert(n, \"missing argument #2 to \'rep\' (n is required)\")\n   assert(n >= 0, \"bad argument #2 to \'rep\' (n cannot be negative)\")\n   assert(not m or m >= n, \"bad argument #3 to \'rep\' (m must be >= n)\")\n   -- m == n is equivalent to omitting m altogether, easiest to\n   -- take care of this up front\n   if m == n then\n      m = nil\n   end\n   if n == 0 then\n      if m then\n         return patt ^ -m\n      else\n         return -patt\n      end\n   else\n      local answer = patt\n      for i = 1, n - 1 do\n         answer = answer * patt\n      end\n      if m then\n         answer = answer * patt^(n - m)\n      end\n      return answer\n   end\nend\n\nelpatt.rep = rep\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.M(tab)\n   local rule\n   for k in pairs(tab) do\n      assert(type(k) == \'string\', \"Keys passed to M() must be strings\")\n      rule = rule and rule + P(k) or P(k)\n   end\n   return rule / tab\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal utf8_cont = R\"\\x80\\xbf\"\nlocal utf8_char = R\"\\x00\\x7f\" +\n                  R\"\\xc2\\xdf\" * utf8_cont +\n                  R\"\\xe0\\xef\" * rep(utf8_cont, 2) +\n                  R\"\\xf0\\xf4\" * rep(utf8_cont, 3)\nlocal utf8_str  = Ct(C(utf8_char)^0) * -1\nlocal ascii_str = R\"\\x00\\x7f\"^0 * -1\n\n\n\n\n\n\n\n\nlocal codepoint = assert(require \"lua-utf8\" . codepoint)\nlocal inbounds = assert(require \"core:math\" . inbounds)\nlocal insert = assert(table.insert)\nlocal assertfmt = assert(require \"core:fn\" . assertfmt)\n\nlocal function R_unicode(...)\n   local args = pack(...)\n   local ascii_ranges, utf_ranges = {}, {}\n   for i, range in ipairs(args) do\n      if ascii_str:match(range) then\n         -- Throw this error here while we still know which argument this was\n         assertfmt(#range == 2,\n            \"bad argument #%d to \'R\' (range must have two characters)\", i)\n         insert(ascii_ranges, range)\n      else\n         range = utf8_str:match(range)\n         assertfmt(range, \"bad argument #%d to \'R\' (invalid utf-8)\", i)\n         assertfmt(#range == 2,\n            \"bad argument #%d to \'R\' (range must have two characters)\", i)\n         insert(utf_ranges, { codepoint(range[1]), codepoint(range[2]) })\n      end\n   end\n   local answer;\n   if #ascii_ranges > 0 then\n      answer = R(unpack(ascii_ranges))\n   end\n   if #utf_ranges ~= 0 then\n      local utf_answer =  P(function(subject, pos)\n           local char = C(utf8_char):match(subject, pos)\n           if not char then return false end\n           local code = codepoint(char)\n           for _, range in ipairs(utf_ranges) do\n              if inbounds(code, range[1], range[2]) then\n                 return pos + #char\n              end\n           end\n           return false\n        end)\n      answer = answer and answer + utf_answer or utf_answer\n   end\n   return answer\nend\n\nelpatt.R = R_unicode\n\n\n\n\n\n\n\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\nlocal function S_unicode(chars)\n   -- We *could* skip this early-out and we\'d still return an identical\n   -- pattern, since we separate out the ASCII characters below,\n   -- but let\'s keep the degenerate case clear and fast\n   if ascii_str:match(chars) then\n      return S(chars)\n   end\n   chars = utf8_str:match(chars)\n   assert(chars, \"bad argument #1 to \'S\' (invalid utf-8)\")\n   local patt;\n   local ascii_chars = {}\n   for _, char in ipairs(chars) do\n      if #char == 1 then\n         insert(ascii_chars, char)\n      else\n         patt = patt and P(char) + patt or P(char)\n      end\n   end\n   if #ascii_chars > 0 then\n      patt = patt and S(concat(ascii_chars)) + patt or S(concat(ascii_chars))\n   end\n   return patt\nend\n\nelpatt.S = S_unicode\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.U(n, m)\n   n = n or 1\n   return rep(utf8_char, n, m)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elpatt.split(str, sep)\n  sep = P(sep)\n  local elem = C((1 - sep)^0)\n  local patt = Ct(elem * (sep * elem)^0)   -- make a table capture\n  return patt:match(str)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cs = assert(lpeg.Cs)\nfunction elpatt.gsub(str, patt, repl)\n   patt = P(patt)\n   if repl then\n      patt = patt / repl\n   end\n   patt = Cs((patt + 1)^0)\n   return patt:match(str)\nend\n\n\n\n\nreturn elpatt\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/lexemes",
hash = "5be162bd3c36106e9bbf3711e66a3823d4fd6b73ec901a0530e264f5ba2fc442",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\n\n\n\n\n\n\n\n\n\n\n\nlocal Lex = meta {}\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal KW = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal OP = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\\\"\'[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (letter^1 + P\"_\"^1)\n               * (letter + digit + P\"_\")^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)\n\n\n\nreturn { lua = { number      = number,\n                 digit       = digit,\n                 symbol      = symbol,\n                 comment     = comment,\n                 string      = string_short,\n                 string_long = string_long,\n                 WS          = WS,\n                 terminal    = terminal,\n                 keyword     = KW,\n                 operator    = OP },\n         digit  = digit,\n         number = number,\n         string = { str        = string_short,\n                    single     = single_str,\n                    double     = double_str,\n                    str_escape = str_esc },\n         higit   = higit,\n         hex     = _hexadecimal,\n         decimal = _decimal,\n         letter  = { latin = letter } }\n\n",
},
  { 
vc_hash = "52d99c7f6336692fa6c23a9b109166505705cd5e",
name = "espalier/grammar",
hash = "0456ffa70deaaf78fdedc5854b03a223cead7e63eb2515a2d63d9a07a2eeef04",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.angry   = false\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal compact = assert(require \"core/table\" . compact)\nlocal Node = require \"espalier/node\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal assert = assert\nlocal string = assert(string)\nlocal sub = assert(string.sub)\nlocal remove = assert(table.remove)\nlocal VER = sub(assert(_VERSION), -4)\nlocal _G = assert(_G)\nlocal error = assert(error)\nlocal pairs = assert(pairs)\nlocal next = assert(next)\nlocal type = assert(type)\nlocal tostring = assert(tostring)\nlocal setmeta = assert(setmetatable)\nif VER == \" 5.1\" then\n   local setfenv = assert(setfenv)\n   local getfenv = assert(getfenv)\nend\n\n\n\n\n\n\n\n\nlocal function make_ast_node(id, first, t, last, str, metas, offset)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   t.first = first + offset\n   t.last  = last + offset - 1\n   t.str   = str\n   if metas[id] then\n      local meta = metas[id]\n      if type(meta) == \"function\" then\n        t.id = id\n        t = meta(t, offset)\n      else\n        t = setmeta(t, meta)\n      end\n      assert(t.id, \"no id on Node\")\n   else\n      t.id = id\n      setmeta(t, metas[1])\n   end\n\n   if not t.parent then\n      t.parent = t\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local top, touched = #t, false\n   for i = 1, top do\n      local cap = t[i]\n      if type(cap) ~= \"table\" or not cap.isNode then\n         touched = true\n         t[i] = nil\n      else\n         cap.parent = t\n      end\n   end\n   if touched then\n      compact(t, top)\n   end\n\n\n\n\n\n\n\n\n\n   -- post conditions\n   assert(t.isNode, \"failed isNode: \" .. id)\n   assert(t.str)\n   assert(t.parent, \"no parent on \" .. t.id)\n   return t\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Cp = L.Cp\nlocal Cc = L.Cc\nlocal Ct = L.Ct\nlocal arg1_str = L.Carg(1)\nlocal arg2_metas = L.Carg(2)\nlocal arg3_offset = L.Carg(3)\n\n\n\n\n\n\nlocal function define(func, g, e)\n   g = g or {}\n   if e == nil then\n      e = VER == \" 5.1\" and getfenv(func) or _G\n   end\n   local suppressed = {}\n   local env = {}\n   local env_index = {\n      START = function(name) g[1] = name end,\n      SUPPRESS = function(...)\n         suppressed = {}\n         for i = 1, select(\'#\', ...) do\n            suppressed[select(i, ... )] = true\n         end\n      end,\n      V = L.V,\n      P = L.P }\n\n    setmeta(env_index, { __index = e })\n    setmeta(env, {\n       __index = env_index,\n       __newindex = function( _, name, val )\n          if suppressed[ name ] then\n             g[ name ] = val\n          else\n             g[ name ] = Cc(name)\n                       * Cp()\n                       * Ct(val)\n                       * Cp()\n                       * arg1_str\n                       * arg2_metas\n                       * arg3_offset / make_ast_node\n          end\n       end })\n\n   -- call passed function with custom environment (5.1- and 5.2-style)\n   if VER == \" 5.1\" then\n      setfenv(func, env )\n   end\n   func( env )\n   assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )\n   return g\nend\n\n\n\n\n\n\n\n\nlocal function refineMetas(metas)\n  for id, meta in pairs(metas) do\n    if id ~= 1 then\n      if type(meta) == \"table\" then\n        -- #todo is this actually necessary now?\n        -- if all Node children are created with Node:inherit then\n        -- it isn\'t.\n        if not meta[\"__tostring\"] then\n          meta[\"__tostring\"] = Node.toString\n        end\n        if not meta.id then\n          meta.id = id\n        end\n      end\n    end\n  end\n  if not metas[1] then\n     metas[1] = Node\n  end\n  return metas\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _fromString(g_str)\n   local maybe_lua, err = loadstring(g_str)\n   if maybe_lua then\n      return maybe_lua()\n   else\n      s : halt (\"cannot make function:\\n\" .. err)\n   end\nend\n\nlocal function _toFunction(maybe_grammar)\n   if type(maybe_grammar) == \"string\" then\n      return _fromString(maybe_grammar)\n   elseif type(maybe_grammar) == \"table\" then\n      -- we may as well cast it to string, since it might be\n      -- and sometimes is a Phrase class\n      return _fromString(tostring(maybe_grammar))\n   end\nend\n\nlocal P = assert(L.P)\n\nlocal function new(grammar_template, metas, pre, post)\n   if type(grammar_template) ~= \"function\" then\n      -- see if we can coerce it\n      grammar_template = _toFunction(grammar_template)\n   end\n\n   local metas = metas or {}\n   metas = refineMetas(metas)\n   local grammar = define(grammar_template, nil, metas)\n\n   local function parse(str, start, finish)\n      local sub_str, begin = str, 1\n      local offset = start and start - 1 or 0\n      if start and finish then\n         sub_str = sub(str, start, finish)\n      end\n      if start and not finish then\n         begin = start\n         offset = 0\n      end\n      if pre then\n         str = pre(str)\n         assert(type(str) == \"string\")\n      end\n\n      local match = L.match(grammar, sub_str, begin, str, metas, offset)\n      if match == nil then\n         return nil\n      elseif type(match) == \'number\' then\n         return sub(sub_str, 1, match)\n      end\n      if post then\n        match = post(match)\n      end\n      match.complete = match.last == #sub_str + offset\n      return match\n   end\n\n   return parse, grammar\nend\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "",
    repo_alternates = "",
    home = "",
    website = "",
    name = "esquilite",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "f5296aca44675155bfb46a9969605306af0ae876",
name = "esquilite",
hash = "9849380641389389e7e1f4cd3e04cab27a5ccc1fa6068d490638776925b64691",
branch = "master",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migrate(conn, migration, ...)\n   if type(migration) == \'function\' then\n      migration(conn, ...)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, ...)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nlocal format = assert(string.format)\nlocal open = assert(sql.open)\n\nlocal function boot(conn, migrations)\n   version = #migrations\n   conn = type(conn) == \'string\' and open(conn) or conn\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         migrate(conn, migrations[i])\n      end\n      conn:exec \"COMMIT;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n   elseif user_version > version then\n      error(format(\"Error: helm.sqlite is version %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn { migrate = migrate,\n         boot    = boot }\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/fs.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/fs.git",
    home = "",
    website = "",
    name = "fs",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "75983d4a34cdf4fdb77c3b39adc3a0bb19917a6d",
name = "fs/directory",
hash = "de74423c5b567866329247d1f40c2c0aa125a608c92dbbefcd082c14ec1c17a2",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal s = require \"status:status\" ()\ns.chatty = true\ns.verbose = false\n\nlocal sh = require \"orb:util/sh\"\n\nlocal Path = require \"fs:fs/path\"\nlocal File = require \"fs:fs/file\"\n\n\n\nlocal new\n\n\n\nlocal Dir = {}\n\n-- Cache to keep each Dir unique by path name\nlocal __Dirs = setmetatable({}, {__mode = \"v\"})\n\n\n\n\n\n\nfunction Dir.exists(dir)\n   local stat = uv.fs_stat(tostring(dir.path))\n   if stat and stat.type == \"directory\" then\n      return true\n   elseif stat and stat.type ~= \"directory\" then\n      return false, tostring(dir.path) .. \" is a \" .. stat.type\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function mkdir(dir, mode)\n   if mode then\n      if type(mode) == \'string\' then\n         mode = tonumber(mode, 8)\n      elseif type(mode) ~= \'number\' then\n         error(\"bad argument #1 to mkdir method: expected string or number\"\n               .. \"got \" ..type(mode))\n      end\n   else\n      mode = 493 -- drwxr-xr-x\n   end\n\n   local exists, msg = dir:exists()\n   if exists or msg then\n      return false, msg or \"directory already exists\"\n   else\n      -- There is no good way to do recursive mkdir with primitives.\n      -- the filesystem will happily open, stat, etc. from memory, without\n      -- writing to disk; unless the directory actually exists on disk, mkdir\n      -- for the subdirectory will fail.\n      --\n      -- So, we shell out.\n      local parent = new(dir.path:parentDir())\n      if parent and (not parent:exists()) then\n         return sh.mkdir(\"-p\", \"\'\" .. dir.path.str:gsub(\"\'\", \"\'\\\\\'\'\") .. \"\'\")\n      else\n         local success, msg, code = uv.fs_mkdir(dir.path.str, mode)\n         if success then\n            return success\n         else\n            code = tostring(code)\n            s:complain(\"mkdir failure # \" .. code, msg, dir)\n            return false, msg\n         end\n      end\n   end\nend\n\nDir.mkdir = mkdir\n\n\n\n\n\nfunction Dir.basename(dir)\n   return dir.path:basename()\nend\n\n\n\n\n\nfunction Dir.parentDir(dir)\n   return new(dir.path:parentDir())\nend\n\n\n\n\n\n\nlocal insert, sort = assert(table.insert), assert(table.sort)\nlocal sub = assert(string.sub)\n\nlocal div = Path \"\" . divider\n\nfunction Dir.getsubdirs(dir)\n   local dir_str = tostring(dir)\n   if sub(dir_str, -1) == div then\n      dir_str = sub(dir_str, 1, -2)\n   end\n   local uv_fs_t = uv.fs_opendir(dir_str)\n   local subdirs, done = {}, false\n   repeat\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if file_obj then\n         if file_obj[1].type == \"directory\" then\n            insert(subdirs, dir_str .. div .. file_obj[1].name)\n         end\n      else\n         done = true\n      end\n   until done\n   uv.fs_closedir(uv_fs_t)\n   sort(subdirs)\n   for i, subdir in ipairs(subdirs) do\n      subdirs[i] = new(subdir)\n   end\n   return subdirs\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Dir.swapDirFor(dir, nestDir, newNest)\n   local dir_str, nest_str = tostring(dir), tostring(nestDir)\n   local first, last = string.find(dir_str, nest_str)\n   if first == 1 then\n      -- swap out\n      return new(Path(tostring(newNest) .. string.sub(dir_str, last + 1)))\n   else\n      return nil, nest_str.. \" not found in \" .. dir_str\n   end\nend\n\n\n\n\n\n\n\n\nfunction Dir.attributes(dir)\n   return uv.fs_stat(tostring(dir.path))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Dir.getfiles(dir)\n   local dir_str = tostring(dir)\n   local uv_fs_t, err = uv.fs_opendir(dir_str)\n   if not uv_fs_t then\n      return nil, err\n   end\n   local files, done = {}, false\n   repeat\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if file_obj then\n         if file_obj[1].type == \"file\" then\n            insert(files, dir_str .. div .. file_obj[1].name)\n         end\n      else\n         done = true\n      end\n   until done\n   uv.fs_closedir(uv_fs_t)\n   sort(files)\n   for i, file in ipairs(files) do\n      files[i] = File(file)\n   end\n   return files\nend\n\n\n\n\n\n\n\n\n\n\nfunction Dir.files(dir)\n   local dir_str = tostring(dir)\n   local uv_fs_t, err = uv.fs_opendir(dir_str)\n   if not uv_fs_t then\n      return nil, err\n   end\n   local iter = function()\n      if not uv_fs_t then return nil end\n      local file_obj = uv.fs_readdir(uv_fs_t)\n      if not file_obj then\n         uv.fs_closedir(uv_fs_t)\n         uv_fs_t = nil\n         return nil\n      end\n      if file_obj[1].type == \'file\' then\n         return File(dir_str .. div .. file_obj[1].name)\n      else\n         iter()\n      end\n   end\n   return iter\nend\n\n\n\n\n\nlocal function __tostring(dir)\n   return dir.path.str\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __concat(dir, path)\n      if type(dir) == \"string\" then\n            return new(dir .. path)\n      end\n      return new(dir.path.str .. tostring(path))\nend\n\n\n\n\n\n\n\n\nlocal function __eq(a, b)\n   local stat_a, stat_b = uv.fs_stat(a.path.str), uv.fs_stat(b.path.str)\n   if (not stat_a) or (not stat_b) then\n      -- same premise as NaN ~= NaN\n      return false\n   end\n   return stat_a.ino == stat_b.ino\nend\n\n\n\n\nlocal Dir_M = { __index    = Dir,\n                __tostring = __tostring,\n                __concat   = __concat,\n                __eq       = __eq }\n\nnew = function(path)\n   local path_str = tostring(path)\n   -- bail on empty string\n   if path_str == \"\" then\n      return nil, \"can\'t make directory from empty string\"\n   end\n   -- strip trailing \"/\"\n   if sub(path_str, -1) == div then\n      path_str = sub(path_str, 1, -2)\n   end\n   local stat = uv.fs_stat(path_str)\n   if stat and __Dirs[stat.ino] then\n      return __Dirs[stat.ino]\n   elseif __Dirs[path_str] then\n      return __Dirs[path_str]\n   end\n   if stat and stat.type ~= \"directory\" then\n      return nil, path_str .. \" is a \" .. stat.type .. \", not a directory\"\n   end\n   local dir = setmetatable({}, Dir_M)\n   dir.path = Path(path_str)\n   local key = stat and stat.ino or path_str\n   __Dirs[key] = dir\n\n   return dir\nend\n\n\n\nDir.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "75983d4a34cdf4fdb77c3b39adc3a0bb19917a6d",
name = "fs/path",
hash = "b4013f17e8827946d415737c300a08d1407b90ba5181dd2da195d07ccfa0965d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\n\n\nlocal new\nlocal Path = {}\nPath.__index = Path\n\nlocal __Paths = {} -- one Path per real Path\n\nlocal s = require \"status:status\" ()\ns.angry = false\n\nPath.it = require \"singletons/check\"\n\nPath.divider = \"/\"\nPath.div_patt = \"%/\"\nPath.dir_sep = \":\"\nPath.parent_dir = \"..\"\nPath.same_dir = \".\"\nlocal sub, find = assert(string.sub), assert(string.find)\n\n\n\n\n\n\n\n\n\n\n\nlocal function clone(path)\n   local new_path = {}\n   for k,v in pairs(path) do\n      new_path[k] = v\n   end\n   setmetatable(new_path, getmetatable(path))\n   return new_path\nend\n\n\n\n\n\n\n\n\n\nlocal function stringAwk(path, str)\n    local div, div_patt = Path.divider, Path.div_patt\n    local phrase = \"\"\n   if sub(str,1,1) == \"/\" then\n      path.is_abs = true\n   end\n    local remain = str\n   -- chew the string like Pac Man\n    while remain  do\n        local dir_index = find(remain, div_patt)\n        if dir_index then\n          -- add the handle minus div\n         local handle = sub(remain, 1, dir_index - 1)\n         if handle ~= \"\" then\n               path[#path + 1] = handle\n         end\n            -- then the div\n            path[#path + 1] = div\n            local new_remain = sub(remain, dir_index + 1)\n            assert(#new_remain < #remain, \"remain must decrease\")\n            remain = new_remain\n            if remain == \"\" then\n                remain = nil\n            end\n        else\n          -- single file/directory\n            path[#path + 1] = remain\n            path.filename = remain\n            remain = nil\n        end\n    end\n\n    return path\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __concat(head_path, tail_path)\n   local head, tail = tostring(head_path), tostring(tail_path)\n  return new(head .. tail)\nend\n\n\n\n\n\n\n\n\nlocal function __tostring(path)\n  return path.str\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function __eq(a,b)\n   return tostring(a) == tostring(b)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.parentDir(path)\n   local parent_offset\n   if path[#path] == Path.divider then\n      parent_offset = #path[#path-1] + 2\n   else\n      parent_offset = #path[#path] + 1\n   end\n   local parent = sub(path.str, 1, - parent_offset)\n   local p_last = sub(parent, -1)\n   -- make the parent of an abspath \"/\"\n   if parent == \"\" and path.is_abs then\n      parent = \"/\"\n   end\n   return new(parent)\nend\n\n\n\n\n\n\n\n\nlocal function fromString(path, str)\n   local div, div_patt = Path.divider, Path.div_patt\n   return stringAwk(path, str, div, div_patt)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.relPath(path, rel)\n   error \"no longer implemented\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Path.absPath(path, base)\n   if path.is_abs then return path end\n   base = base or uv.cwd()\n   local abspath\n   -- make a copy of base to \'re-base\' upon\n   if type(base) == \'string\' then\n      abspath = clone(new(base))\n   else\n      abspath = clone(base)\n   end\n   insert(abspath, Path.divider)\n   for _, element in ipairs(path) do\n      insert(abspath, element)\n   end\n   abspath.str = abspath.str .. Path.divider .. path.str\n   abspath.is_abs = true\n   return abspath\nend\n\n\n\n\n\n\n\n\n\n\nlocal litpat = assert(require \"core/string\" . litpat)\nlocal extension -- defined below\n\nfunction Path.subFor(path, base, newbase, ext)\n   local path, base, newbase = tostring(path),\n                               tostring(base),\n                               tostring(newbase)\n   if find(path, litpat(base)) then\n      local rel = sub(path, #base + 1)\n      if ext then\n         if sub(ext, 1, 1) ~= \".\" then\n            ext = \".\" .. ext\n         end\n         local old_ext = extension(path)\n         rel = sub(rel, 1, - #old_ext - 1) .. ext\n      end\n      return new(newbase .. rel)\n   else\n      s:complain(\"path error\", \"cannot sub \" .. newbase .. \" for \" .. base\n                 .. \" in \" .. path)\n   end\nend\n\n\n\n\n\n\n\n\nlocal function splitext(path)\n    local i = #path\n    local ch = sub(path, i, i)\n    while i > 0 and ch ~= \'.\' do\n        if ch == Path.divider or ch == Path.dir_sep then\n            return path, \'\'\n        end\n        i = i - 1\n        ch = sub(path, i, i)\n    end\n    if i == 0 then\n        return path, \'\'\n    else\n        return sub(path, 1, i-1), sub(path, i)\n    end\nend\n\nlocal function splitpath(path)\n    local i = #path\n    local ch = sub(path, i, i)\n    while i > 0 and ch ~= Path.divider and ch ~= Path.dir_sep do\n        i = i - 1\n        ch = sub(path,i, i)\n    end\n    if i == 0 then\n        return \'\', path\n    else\n        return sub(path, 1, i-1), sub(path, i+1)\n    end\nend\n\n\n\nfunction Path.extension(path)\n   local _ , ext = splitext(tostring(path))\n  return ext\nend\n\nextension = Path.extension\n\n\n\n\n\nfunction Path.basename(path)\n   local _, base = splitpath(tostring(path))\n   return base\nend\n\n\n\n\n\n\n\n\nfunction Path.dirname(path)\n   local dir = splitpath(tostring(path))\n   return dir\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Path.barename(path)\n   return sub(path:basename(), 1, -(#path:extension() + 1))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Path.has(path, substr)\n   for _, v in ipairs(path) do\n      if v == substr then\n         return true\n      end\n   end\n\n   return false\nend\n\n\n\n\n\n\n\n\n\nfunction Path.exists(path)\n   local stat = uv.fs_stat(tostring(path))\n   if not stat then\n      return false\n   else\n      return true, stat.type\n   end\nend\n\n\n\n\n\n\nfunction Path.isDir(path)\n   local stat = uv.fs_stat(tostring(path))\n   if stat and stat.type == \'directory\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\nfunction Path.isFile(path)\n   local stat = uv.fs_stat(tostring(path))\n   if stat and stat.type == \'file\' then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal PathMeta = {__index = Path,\n                  __concat = __concat,\n                  __tostring = __tostring}\n\nnew  = function (path_seed)\n   if __Paths[path_seed] then\n      return __Paths[path_seed]\n   end\n   local path = setmetatable({}, PathMeta)\n   if type(path_seed) == \'string\' then\n      path.str = path_seed\n      path =  fromString(path, path_seed)\n   elseif type(path_seed) == \'table\' then\n    if path_seed.idEst == new then return path_seed end\n      s:complain(\"NYI\", \'cannot construct Path from this table parameter\')\n   end\n\n   __Paths[path_seed] = path\n   return path\nend\n\nPath.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "75983d4a34cdf4fdb77c3b39adc3a0bb19917a6d",
name = "fs/file",
hash = "5dcb58eb70a0c257d687e82c6b64a0e94f7222cfed964baffa0a9954041dce24",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal s = require \"status:status\" ()\ns.verbose = false\ns.chatty = true\nlocal Path = require \"fs:path\"\nlocal running, resume, yield = assert(coroutine.running),\n                               assert(coroutine.resume),\n                               assert(coroutine.yield)\n\n\n\nlocal new\nlocal File = {}\nlocal _Files = setmetatable({}, {__mode = \"v\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction File.dirPath(file)\n   return file.path:parentDir()\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction File.exists(file)\n   local stat = uv.fs_stat(tostring(file.path))\n   if stat then\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\nfunction File.basename(file)\n   return file.path:basename()\nend\n\n\n\n\n\n\n\n\n\n\nfunction File.extension(file)\n   return file.path:extension()\nend\n\n\n\n\n\n\n\n\nfunction File.read(file)\n   local co, main = running()\n   local file_str = tostring(file.path)\n   s:verb(\"opening %s for read\", file_str)\n   if main or (not uv.loop_alive()) then\n      s:verb(\"blocking read\")\n      local f = io.open(file_str, \"r\")\n      if not f then\n         return nil, \"cannot open for read: \" .. file_str\n      end\n      local content = f:read(\"*a\")\n      f:close()\n      return content\n   else\n      -- 292 == 0444 == -r--r--r--\n      s:verb(\"opening %s\", file_str)\n      uv.fs_open(file_str, \"r\", 292, function(err, fd)\n         s:verb(\"entered open callback: %s\", file_str)\n         if err then\n            s:complain(\"failed to open %s: %s\", file_str, err)\n            return resume(co, nil, \"error opening \" .. file_str\n                                    .. \": \" .. err)\n         end\n         local stat, err = uv.fs_stat(file_str)\n         if not stat then\n            s:complain(\"failed to stat %s\", file_str)\n            return resume(co, nil, \"error statting file: \" .. err)\n         end\n         -- rejoin the threadpool on read\n         uv.fs_read(fd, stat.size, 0, function(err, content)\n            if err then\n               s:complain(\"failed to read %s: %s\", file_str, err)\n               return resume(co, nil, \"error reading \" .. file_str\n                                      .. \": \" .. err)\n            end\n            uv.fs_close(fd)\n            return resume(co, content)\n         end)\n      end)\n      return yield()\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _withMode(flags)\n   return function (file, doc)\n      if uv.loop_alive() then\n         -- 416 == 0640 == -rw-r-----\n         uv.fs_open(file.path.str, flags, 416, function(err, fd)\n            if err then\n               error(\"unable to open for write: \" .. file.path.str)\n            end\n            uv.fs_write(fd, tostring(doc), -1, function()\n               uv.fs_close(fd)\n            end)\n         end)\n      else\n         local f = io.open(file.path.str, flags)\n         if not f then\n            error(\"cannot open for write: \" .. file.path.str)\n         end\n         f:write(tostring(doc))\n         f:close()\n      end\n   end\nend\n\nFile.write = _withMode \"w\"\nFile.append = _withMode \"a\"\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function __eq(a,b)\n   local stat_a, stat_b = uv.fs_stat(a.path.str), uv.fs_stat(b.path.str)\n   if (not stat_a) or (not stat_b) then\n      return false\n   end\n   return stat_a.ino == stat_b.ino\nend\n\n\n\n\n\n\nlocal function __tostring(file)\n   return tostring(file.path)\nend\n\n\n\n\n\n\nlocal FileMeta = { __index    = File,\n                   __tostring = __tostring,\n                   __eq       = __eq }\n\nnew = function (file_path)\n   local file_str = tostring(file_path)\n   -- I believe it\'s safe to say that path is a sufficient, but not\n   -- necessary, guarantee of uniqueness:\n   if _Files[file_str] then\n      return _Files[file_str]\n   end\n   local stat = uv.fs_stat(file_str)\n   if stat and stat.type ~= \"file\" then\n      return nil, file_str .. \" is a \" .. stat.type .. \", not a file\"\n   end\n\n   local file = setmetatable({}, FileMeta)\n   local file_path = Path(file_str)\n   if file_path:isDir() then\n      error(\"cannot make file: \" .. file_path.str .. \" is a directory\")\n   end\n   file.path = file_path\n   _Files[file_str] = file\n\n   return file\nend\n\nFile.idEst = new\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/ggg.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/ggg.git",
    home = "",
    website = "",
    name = "ggg",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "e7a52548fe3bda377fba8b754ea3f432e4959403",
name = "gggmeta",
hash = "702914dd0c9705856648918b61ccaf9b5dec7169dc64ff35d25ad56252f1ca61",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal Phrase = require \"singletons/phrase\"\nlocal Node = require \"espalier/node\"\nlocal L = require \"lpeg\"\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\nlocal c_map = {a.fg(1), a.fg(2), a.fg(3), a.fg(4), a.fg(5), a.fg(6)}\nlocal function _G__repr(ggg)\n   local count = 0\n   local g_match = function(str)\n      local match = str\n      if str == \"(\" then\n         count = count + 1\n      end\n      if c_map[count] then\n         match = c_map[count](str)\n      end\n      if str == \")\" then\n         count = count - 1\n      end\n      return match\n   end\n   return tostring(ggg):gsub(\"[%(%)]\", g_match)\nend\nlocal GGGPhrase = Phrase:inherit{ __repr = _G__repr }\n\n\n\n\n\nlocal GGGMetas = Node : inherit \"ggg_metas\"\n\nfunction GGGMetas.toHammer(ggg_metas)\n   error (\"not yet implemented: \" .. ggg_metas.id)\nend\n\nfunction GGGMetas.normalize(ggg_metas)\n   return ggg_metas:span()\nend\n\nfunction GGGMetas.toParseIR(ggg_metas)\n   local phrase = \"(\" .. ggg_metas.id .. GGGPhrase \" \"\n   if #ggg_metas == 0 then\n      return phrase .. \")\"\n   end\n   for i = 1, #ggg_metas - 1 do\n      phrase = phrase .. ggg_metas[i]:toParseIR() .. \" \"\n   end\n   return phrase .. ggg_metas[#ggg_metas] : toParseIR() .. \")\"\nend\n\n\n\n\n\n\nlocal GGG  = { GGGMetas,\n   ggg       = GGGMetas : inherit \"ggg\",\n   rule      = GGGMetas : inherit \"rule\",\n   lhs       = GGGMetas : inherit \"lhs\",\n   rhs       = GGGMetas : inherit \"rhs\",\n   cat       = GGGMetas: inherit \"cat\",\n   regchoice = GGGMetas : inherit \"regchoice\",\n   pegchoice = GGGMetas : inherit \"pegchoice\",\n   alt       = GGGMetas : inherit \"alt\",\n   group     = GGGMetas : inherit \"group\",\n   action    = GGGMetas : inherit \"action\",\n   negativelook = GGGMetas : inherit \"negativelook\",\n   positivelook = GGGMetas : inherit \"positivelook\",\n   negativereg  = GGGMetas : inherit \"negativereg\",\n   many      = GGGMetas : inherit \"many\",\n   oneormore = GGGMetas : inherit \"oneormore\",\n   optional  = GGGMetas : inherit \"optional\",\n   lazymany  = GGGMetas : inherit \"lazymany\",\n   lazyoneormore = GGGMetas : inherit \"lazyoneormore\",\n   range     = GGGMetas : inherit \"range\",\n   wildcard  = GGGMetas : inherit \"wildcard\",\n   binary    = GGGMetas : inherit \"binary\",\n   hex       = GGGMetas : inherit \"hex\",\n   base64    = GGGMetas : inherit \"base64\",\n   litstring = GGGMetas : inherit \"litstring\",\n   litchar      = GGGMetas : inherit \"litchar\",\n   symbol    = GGGMetas : inherit \"symbol\",\n   indent    = GGGMetas : inherit \"indent\",\n}\n\n\n\n\n\n\n\n\n\nlocal _PREFACE = GGGPhrase [[\nlocal h = require \"ggg:hammer\"\nlocal hlib = require \"ggg:hlib\"\n\n]]\n\nfunction GGG.ggg.toHammer(ggg, actions)\n   local phrase = GGGPhrase \"\"\n   actions = actions and (\"--ACTIONS\\n\" .. actions) or \"\"\n   local first_name = ggg : select \"lhs\" () : span()\n   for lhs in ggg:select \"lhs\" do\n      phrase = phrase .. \"local \" .. lhs:span() .. \" = h.indirect()\\n\"\n   end\n   for i, rule in ipairs(ggg) do\n      if rule.toHammer then\n         phrase = phrase .. rule:toHammer()\n      end\n   end\n   phrase = phrase .. \"\\n\" .. \"return \" .. first_name\n   return _PREFACE .. actions .. \"\\n--BODY\\n\" .. phrase\nend\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParser(ggg, actions)\n   actions = actions or \"\"\n   local p_str= actions .. \"\\n\" .. tostring(ggg:toHammer(actions))\n   ggg.parser = loadstring(p_str)()\n   return function(str)\n      return ggg.parser:parse(str)\n   end, GGGPhrase(p_str)\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.toParseIR(ggg)\n   local phrase = GGGPhrase \"(grammar (rules (\"\n   for _, v in ipairs(ggg) do\n      phrase = phrase .. v:toParseIR() .. \" \"\n   end\n   return phrase .. \")))\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.ggg.__call(ggg, str)\n   if not ggg.parser then\n      ggg.parser = loadstring(tostring(ggg:toHammer()))()\n   end\n   return ggg.parser:parse(str)()\nend\n\n\n\n\n\n\nfunction GGG.rule.toHammer(rule)\n   return \"h.bind_indirect(\" .. rule:select \"lhs\" () : span()\n          .. \", \" .. rule:select \"rhs\" () : toHammer() .. GGGPhrase \")\\n\"\nend\n\n\n\n\n\n\nfunction GGG.lhs.toParseIR(lhs)\n   return lhs:span()\nend\n\n\n\n\n\n\nfunction GGG.rhs.toHammer(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toHammer() .. \" \"\n   end\n\n   return phrase\nend\n\n\n\n\n\n\n\n\n\nfunction GGG.rhs.toParseIR(rhs)\n   local phrase = GGGPhrase \"\"\n   for _, expr in ipairs(rhs) do\n      phrase = phrase .. expr:toParseIR()\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.cat.toHammer(cat)\n   local phrase = cat[1]:toHammer()\n   return phrase .. \" * \" .. cat[2]:toHammer()\nend\n\n\n\n\n\n\n\n\n\n\nfunction GGG.alt.toHammer(alt)\n   local phrase = alt[1]:toHammer()\n   return phrase .. \" + \" .. alt[2]:toHammer()\nend\n\nGGG.pegchoice.toHammer = GGG.alt.toHammer\nGGG.regchoice.toHammer = GGG.alt.toHammer\n\n\n\n\n\n\nfunction GGG.group.toHammer(group)\n   local phrase = GGGPhrase \"(\"\n   for _, sub_group in ipairs(group) do\n      phrase = phrase .. sub_group:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.action.toHammer(action)\n   local phrase = GGGPhrase \"/ \"\n   return phrase .. action[1]:span()\nend\n\n\n\n\n\n\nfunction GGG.positivelook.toHammer(poslook)\n   local phrase = GGGPhrase \"#\"\n   for _, sub_look in ipairs(poslook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.negativelook.toHammer(neglook)\n   -- use () to force unary minus\n   local phrase = GGGPhrase \"(-\"\n   for _, sub_look in ipairs(neglook) do\n      phrase = phrase .. sub_look:toHammer() .. \" \"\n   end\n   return phrase .. \")\"\nend\n\n\n\n\n\n\nfunction GGG.many.toHammer(many)\n   local phrase = GGGPhrase \"\"\n   for _, sub_many in ipairs(many) do\n      phrase = phrase .. sub_many:toHammer()\n   end\n   return phrase .. \"^0\"\nend\nGGG.lazymany.toHammer = GGG.many.toHammer\n\n\n\n\nfunction GGG.oneormore.toHammer(more)\n   local phrase = GGGPhrase \"\"\n   for _, sub_more in ipairs(more) do\n      phrase = phrase .. sub_more:toHammer()\n   end\n   return phrase .. \"^1\"\nend\nGGG.lazyoneormore.toHammer = GGG.oneormore.toHammer\n\n\n\nfunction GGG.optional.toHammer(optional)\n   local phrase = GGGPhrase \"\"\n   for _, sub_option in ipairs(optional) do\n      phrase = phrase .. sub_option:toHammer()\n   end\n   return phrase .. \"^-1\"\nend\n\n\n\n\n\n\nfunction GGG.range.toHammer(range)\n   local phrase = GGGPhrase \"hlib.from_range(\"\n   phrase = phrase .. \"\'\" .. range[1]:normalize()\n            .. \"\', \'\" .. range[2]:normalize()\n   return phrase .. \"\')\"\nend\n\n\n\n\n\n\nfunction GGG.wildcard.toHammer(wildcard)\n   local phrase = GGGPhrase \"hlib.from_wildcard(\'\"\n   phrase = phrase .. wildcard:span():sub(2) .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.symbol.toHammer(symbol)\n   return GGGPhrase(symbol:span())\nend\n\n\n\n\n\n\nGGG.symbol.toParseIR = GGG.symbol.toHammer\n\n\n\n\n\n\n\n\n\nlocal P, match = L.P, L.match\nlocal wrapper = P\'\"\' + P\"«\"^1 * (P\" \" * #P\"«\")^-1\nlocal sub = assert(string.sub)\n\n\nfunction GGG.litstring.toHammer(str)\n   local phrase = GGGPhrase \'h.token(\"\'\n   local span = str:span()\n   local begin = match(wrapper, span)\n   if not begin then\n      error \"didn\'t match the beginning of the literal string for some weird reason\"\n   end\n   phrase = phrase .. sub(span, begin, -begin) .. \'\") \'\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.litstring.toParseIR(litstring)\n   return \"(literal \" .. litstring:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\nlocal format = assert(string.format)\nfunction GGG.litchar.toHammer(char)\n   local phrase =  GGGPhrase \"h.token(\"\n   phrase = phrase  .. format(\"%q\", char:select \"utf8\" ():span()) .. \")\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.litchar.normalize(char)\n   return \"¢\" .. char:select\"utf8\"():span()\nend\n\n\n\n\n\n\nfunction GGG.binary.toHammer(binary)\n   local phrase = GGGPhrase \"hlib.from_binary(\'\"\n   phrase = phrase .. binary:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.binary.toParseIR(binary)\n   return \"(literal \" .. binary:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\nfunction GGG.hex.toHammer(hex)\n   local phrase = GGGPhrase \"hlib.from_hex(\'\"\n   phrase = phrase .. hex:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\nfunction GGG.hex.toParseIR(hex)\n   return \"(literal \" .. hex:span() .. GGGPhrase \")\"\nend\n\n\n\n\n\n\nfunction GGG.base64.toHammer(base64)\n   local phrase = GGGPhrase \"hlib.from_base64(\'\"\n   phrase = phrase .. base64:span() .. \"\')\"\n   return phrase\nend\n\n\n\n\n\n\nfunction GGG.base64.toParseIR(base64)\n   local phrase = GGGPhrase \'(literal (base64 \"\'\n   phrase = phrase .. base64:span():sub(3) -- £ is two bytes wide\n   return phrase .. \'\"))\'\n\nend\n\n\n\n\n\n\n\nfunction GGG.indent.toHammer(indent)\n   return indent:span()\nend\nGGG.indent.toParseIR = GGG.indent.toHammer\n\n\n\n\n\n\nGGG.indent.toParseIR = GGG.indent.toHammer\n\n\n\n\n\n\n\nreturn {GGG, GGGPhrase}\n\n",
},
  { 
vc_hash = "e7a52548fe3bda377fba8b754ea3f432e4959403",
name = "hammer",
hash = "9a0771a918c3e6967b11aaaa42d150301d36cfe2179fc8b0a10a33f8d578bcc9",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal ffi = require(\"ffi\")\nffi.cdef[[\ntypedef enum HParserBackend_ {\n  PB_MIN = 0,\n  PB_PACKRAT = PB_MIN, // PB_MIN is always the default.\n  PB_REGULAR,\n  PB_LLk,\n  PB_LALR,\n  PB_GLR,\n  PB_MAX = PB_GLR\n} HParserBackend;\n\ntypedef enum HTokenType_ {\n  TT_NONE = 1,\n  TT_BYTES = 2,\n  TT_SINT = 4,\n  TT_UINT = 8,\n  TT_SEQUENCE = 16,\n  TT_RESERVED_1, // reserved for backend-specific internal use\n  TT_ERR = 32,\n  TT_USER = 64,\n  TT_MAX\n} HTokenType;\n\ntypedef struct HBytes_ {\n  const uint8_t *token;\n  size_t len;\n} HBytes;\n\ntypedef struct HArena_ HArena ; // hidden implementation\n\ntypedef struct HCountedArray_ {\n  size_t capacity;\n  size_t used;\n  HArena * arena;\n  struct HParsedToken_ **elements;\n} HCountedArray;\n\ntypedef struct HParsedToken_ {\n  HTokenType token_type;\n  union {\n    HBytes bytes;\n    int64_t sint;\n    uint64_t uint;\n    double dbl;\n    float flt;\n    HCountedArray *seq; // a sequence of HParsedToken\'s\n    void *user;\n  };\n  size_t index;\n  size_t bit_length;\n  char bit_offset;\n} HParsedToken;\n\ntypedef struct HParseResult_ {\n  const HParsedToken *ast;\n  int64_t bit_length;\n  HArena * arena;\n} HParseResult;\n\ntypedef struct HParserVtable_ HParserVtable;\ntypedef struct HCFChoice_ HCFChoice;\n\ntypedef struct HParser_ {\n  const HParserVtable *vtable;\n  HParserBackend backend;\n  void* backend_data;\n  void *env;\n  HCFChoice *desugared;\n} HParser;\n\ntypedef struct HAllocator_ HAllocator;\n\ntypedef HParsedToken* (*HAction)(const HParseResult *p, void* user_data);\ntypedef bool (*HPredicate)(HParseResult *p, void* user_data);\ntypedef HParser* (*HContinuation)(HAllocator *mm__, const HParsedToken *x, void *env);\n\nHParseResult* h_parse(const HParser* parser, const uint8_t* input, size_t length);\nHParser* h_token(const uint8_t *str, const size_t len);\nHParser* h_ch(const uint8_t c);\nHParser* h_ch_range(const uint8_t lower, const uint8_t upper);\nHParser* h_int_range(const HParser *p, const int64_t lower, const int64_t upper);\nHParser* h_bits(size_t len, bool sign);\nHParser* h_int64();\nHParser* h_int32();\nHParser* h_int16();\nHParser* h_int8();\nHParser* h_uint64();\nHParser* h_uint32();\nHParser* h_uint16();\nHParser* h_uint8();\nHParser* h_whitespace(const HParser* p);\nHParser* h_left(const HParser* p, const HParser* q);\nHParser* h_right(const HParser* p, const HParser* q);\nHParser* h_middle(const HParser* p, const HParser* x, const HParser* q);\nHParser* h_action(const HParser* p, const HAction a, void* user_data);\nHParser* h_in(const uint8_t *charset, size_t length);\nHParser* h_not_in(const uint8_t *charset, size_t length);\nHParser* h_end_p();\nHParser* h_nothing_p();\nHParser* h_sequence(HParser* p, ...);\nHParser* h_choice(HParser* p, ...);\nHParser* h_permutation(HParser* p, ...);\nHParser* h_butnot(const HParser* p1, const HParser* p2);\nHParser* h_difference(const HParser* p1, const HParser* p2);\nHParser* h_xor(const HParser* p1, const HParser* p2);\nHParser* h_many(const HParser* p);\nHParser* h_many1(const HParser* p);\nHParser* h_repeat_n(const HParser* p, const size_t n);\nHParser* h_optional(const HParser* p);\nHParser* h_ignore(const HParser* p);\nHParser* h_sepBy(const HParser* p);\nHParser* h_sepBy1(const HParser* p);\nHParser* h_epsilon_p();\nHParser* h_length_value(const HParser* length, const HParser* value);\nHParser* h_attr_bool(const HParser* p, HPredicate pred, void* user_data);\nHParser* h_and(const HParser* p);\nHParser* h_not(const HParser* p);\nHParser* h_indirect(const HParser* p);\nvoid h_bind_indirect(HParser* indirect, const HParser* inner);\nHParser* h_with_endianness(char endianness, const HParser* p);\nHParser* h_put_value(const HParser* p, const char* name);\nHParser* h_get_value(const char* name);\nHParser* h_bind(const HParser *p, HContinuation k, void *env);\n\nint h_compile(HParser* parser, HParserBackend backend, const void* params);\n\nstatic const uint8_t BYTE_BIG_ENDIAN = 0x1;\nstatic const uint8_t BIT_BIG_ENDIAN = 0x2;\nstatic const uint8_t BYTE_LITTLE_ENDIAN = 0x0;\nstatic const uint8_t BIT_LITTLE_ENDIAN = 0x0;\n]]\nlocal h = ffi.load(\"hammer\")\n\nlocal function helper(a, n, b, ...)\n  if   n == 0 then return a\n  else             return b, helper(a, n-1, ...) end\nend\nlocal function append(a, ...)\n  return helper(a, select(\'#\', ...), ...)\nend\n\n-- Exponents do a lot of heavy lifting in Lpeg,\n-- which is the overloading template we\'re going to follow\nlocal function __pow(rule, power)\n  assert(type(power) == \"number\")\n  if power == 0 then\n    return h.h_many(rule)\n  elseif power == 1 then\n    return h.h_many1(rule)\n  elseif power == -1 then\n    return h.h_optional(rule)\n  end\nend\n\n\nlocal mt = {\n  __index = {\n    parse = function(p, str) return h.h_parse(p, str, #str) end,\n  },\n  __add = function(left, right)\n    return h.h_choice(left, right)\n  end,\n  __mul = function(left, right)\n    return h.h_sequence(left, right)\n  end,\n  __pow = __pow,\n  __len = function(rule)\n    return h.h_and(rule)\n  end,\n  __unm = function(rule)\n    return h.h_not(rule)\n  end,\n  __sub = function(left, right)\n    return h.h_sequence(left, h.h_not(right))\n  end,\n  -- Lpeg doesn\'t use modulus, let\'s use it for n number of\n  -- repetitions\n  __mod = function(rule, reps)\n    assert(type(reps) == \"number\")\n    return h.h_repeat_n(rule, reps)\n  end,\n  __div = function(rule, cb)\n    return h.h_action(rule, cb, nil)\n  end\n}\n\nlocal hammer = {}\nhammer.parser = ffi.metatype(\"HParser\", mt)\n\nlocal counted_array\n\n\n\nlocal function _castCountedArray(array)\n    if array == nil then return nil end\n    if array.elements == nil then return nil end\n    local ret = {}\n    for i = 0, tonumber(array.used) do\n       ret[#ret+1] = array.elements[i]()\n    end\n    if #ret == 1 and type(ret[1]) == \"table\" then\n       return ret[1]\n    end\n    if #ret == 0 then\n       return nil\n    end\n    return ret\nend\n\nlocal arr_mt = {\n  __index = function(table, key)\n    return table.elements[key]\n  end,\n  __len = function(table) return table.used end,\n  __ipairs = function(table)\n    local i, n = -1, #table\n    return function()\n      i = i + 1\n      if i < n then\n        return i, table.elements[i]\n      end\n    end\n  end,\n  __call = _castCountedArray,\n}\ncounted_array = ffi.metatype(\"HCountedArray\", arr_mt)\n\nlocal bytes_mt = {\n  __call = function(self)\n    local ret = \"\"\n    for i = 0, tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.len)))-1\n      do ret = ret .. string.char(self.token[i])\n    end\n    return ret\n  end\n}\nlocal byte_string = ffi.metatype(\"HBytes\", bytes_mt)\n\nlocal result_mt = {\n   __call = function(self)\n      if self == nil then return nil end\n      return self.ast()\n   end\n}\n\nlocal parse_result = ffi.metatype(\"HParseResult\", result_mt)\n\nlocal token_types = ffi.new(\"HTokenType\")\n\n\nlocal parsed_token\nlocal tok_mt = {\n  __call = function(self)\n     if self == nil then return nil end\n     if self.token_type == ffi.C.TT_BYTES then\n       return self.bytes()\n     elseif self.token_type == ffi.C.TT_SINT then\n       return tonumber(ffi.cast(\"intptr_t\", ffi.cast(\"void *\", self.sint)))\n     elseif self.token_type == ffi.C.TT_UINT then\n       return tonumber(ffi.cast(\"uintptr_t\", ffi.cast(\"void *\", self.uint)))\n     elseif self.token_type == ffi.C.TT_SEQUENCE then\n       return self.seq()\n     end\n     return nil\n  end\n}\nparsed_token = ffi.metatype(\"HParsedToken\", tok_mt)\n\nfunction hammer.token(str)\n  return h.h_token(str, #str)\nend\nfunction hammer.ch(c)\n  if type(c) == \"number\" then\n    return h.h_ch(c)\n  else\n    return h.h_ch(c:byte())\n  end\nend\nfunction hammer.ch_range(lower, upper)\n  if type(lower) == \"number\" and type(upper) == \"number\" then\n    return h.h_ch_range(lower, upper)\n  -- FIXME this is really not thorough type checking\n  else\n    return h.h_ch_range(lower:byte(), upper:byte())\n  end\nend\nfunction hammer.int_range(parser, lower, upper)\n  return h.h_int_range(parser, lower, upper)\nend\nfunction hammer.bits(len, sign)\n  return h.h_bits(len, sign)\nend\nfunction hammer.int64()\n  return h.h_int64()\nend\nfunction hammer.int32()\n  return h.h_int32()\nend\nfunction hammer.int16()\n  return h.h_int16()\nend\nfunction hammer.int8()\n  return h.h_int8()\nend\nfunction hammer.uint64()\n  return h.h_uint64()\nend\nfunction hammer.uint32()\n  return h.h_uint32()\nend\nfunction hammer.uint16()\n  return h.h_uint16()\nend\nfunction hammer.uint8()\n  return h.h_uint8()\nend\nfunction hammer.whitespace(parser)\n  return h.h_whitespace(parser)\nend\nfunction hammer.left(parser1, parser2)\n  return h.h_left(parser1, parser2)\nend\nfunction hammer.right(parser1, parser2)\n  return h.h_right(parser1, parser2)\nend\nfunction hammer.middle(parser1, parser2, parser3)\n  return h.h_middle(parser1, parser2, parser3)\nend\n-- There could also be an overload of this that doesn\'t\n-- bother with the env pointer, and passes it as NIL by\n-- default, but I\'m not going to deal with overloads now.\nfunction hammer.action(parser, action, user_data)\n  local cb = ffi.cast(\"HAction\", action)\n  return h.h_action(parser, cb, user_data)\nend\nfunction hammer.in_(charset)\n  local cs = ffi.new(\"const unsigned char[\" .. #charset .. \"]\", charset)\n  return h.h_in(cs, #charset)\nend\nfunction hammer.not_in(charset)\n  return h.h_not_in(charset, #charset)\nend\nfunction hammer.end_p()\n  return h.h_end_p()\nend\nfunction hammer.nothing_p()\n  return h.h_nothing_p()\nend\nfunction hammer.sequence(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_sequence(parser, parsers)\nend\nfunction hammer.choice(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_choice(parser, parsers)\nend\nfunction hammer.permutation(parser, ...)\n  local parsers = append(nil, ...)\n  return h.h_permutation(parser, parsers)\nend\nfunction hammer.butnot(parser1, parser2)\n  return h.h_butnot(parser1, parser2)\nend\nfunction hammer.difference(parser1, parser2)\n  return h.h_difference(parser1, parser2)\nend\nfunction hammer.xor(parser1, parser2)\n  return h.h_xor(parser1, parser2)\nend\nfunction hammer.many(parser)\n  return h.h_many(parser)\nend\nfunction hammer.many1(parser)\n  return h.h_many1(parser)\nend\nfunction hammer.repeat_n(parser, n)\n  return h.h_repeat_n(parser, n)\nend\nfunction hammer.optional(parser)\n  return h.h_optional(parser)\nend\nfunction hammer.ignore(parser)\n  return h.h_ignore(parser)\nend\nfunction hammer.sepBy(parser)\n  return h.h_sepBy(parser)\nend\nfunction hammer.sepBy1(parser)\n  return h.h_sepBy1(parser)\nend\nfunction hammer.epsilon_p()\n  return h.h_epsilon_p()\nend\nfunction hammer.length_value(length, value)\n  return h.h_length_value(length, value)\nend\nfunction hammer.attr_bool(parser, predicate, user_data)\n  local cb = ffi.cast(\"HPredicate\", predicate)\n  return h.h_attr_bool(parser, cb, user_data)\nend\nfunction hammer.and_(parser)\n  return h.h_and(parser)\nend\nfunction hammer.not_(parser)\n  return h.h_not(parser)\nend\nfunction hammer.indirect(parser)\n  return h.h_indirect(parser)\nend\nfunction hammer.bind_indirect(indirect, inner)\n  return h.h_bind_indirect(indirect, inner)\nend\nfunction hammer.with_endianness(endianness, parser)\n  return h.h_with_endianness(endianness, parser)\nend\nfunction hammer.put_value(parser, name)\n  return h.h_put_value(parser, name)\nend\nfunction hammer.get_value(name)\n  return h.h_get_value(name)\nend\nfunction hammer.bind(parser, continuation, env)\n  local cb = ffi.cast(\"HContinuation\", continuation)\n  return h.h_bind(parser, cb, env)\nend\n\nfunction hammer.compile(parser, backend, params)\n  return h.h_compile(parser, backend, params)\nend\n\nhammer.BYTE_BIG_ENDIAN = 0x1;\nhammer.BIT_BIG_ENDIAN = 0x2;\nhammer.BYTE_LITTLE_ENDIAN = 0x0;\nhammer.BIT_LITTLE_ENDIAN = 0x0;\nreturn hammer\n\n",
},
  { 
vc_hash = "e7a52548fe3bda377fba8b754ea3f432e4959403",
name = "hlib",
hash = "1d9cc99577511c3e5185bf76ea151ce396c66017190f0120df4e8db4d11d449a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal h = require \"ggg:hammer\"\nlocal utf8 = require \"lua-utf8\"\n\n\n\n\n\n\nlocal hlib = {}\n\n\n\n\n\n\nlocal sub = utf8.sub\n\n\nfunction hlib.from_range(head, tail)\n   local first = sub(head,1,1)\n   if first == \"¢\" then\n      -- character range\n      return h.ch_range(sub(head,2), sub(tail, 2))\n   elseif first == \"0\" then\n      -- binary or hex\n      local hnum, tnum = tonumber(head), tonumber(tail)\n      assert(hnum <= tnum, \"hnum cannot be greater than tnum\")\n      if tnum <= 255 then\n         return h.int_range(h.uint8(), hnum, tnum)\n      elseif tnum <= 65535 then\n         return h.int_range(h.unit16(), hnum, tnum)\n      elseif tnum <= 4294967295 then\n         return h.int_range(h.uint32(), hnum, tnum)\n      else\n         -- actually only 53 bits of range, for the usual reasons...\n         -- this will probably do something dumb like segfault if coerced into\n         -- a float\n         return h.int_range(h.uint64(), hnum, tnum)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction hlib.pR_toTok(hParseResult)\n   return ffi.cast(\"HParsedToken *\", hParseResult.ast)\nend\n\n\n\n\n\nfunction hlib.from_binary(bin)\n   error \"NYI: from_binary\"\nend\n\n\n\n\n\n\nfunction hlib.from_hex(hex)\n   error \"NYI: from_hex\"\nend\n\n\n\n\n\n\nfunction hlib.from_wildcard(wildcard)\n   error \"NYI: from_wildcard\"\nend\n\n\n\n\n\n\nfunction hlib.from_base64(base64)\n   error \"NYI: from_base64\"\nend\n\n\n\n\nreturn hlib\n\n",
},
  { 
vc_hash = "e7a52548fe3bda377fba8b754ea3f432e4959403",
name = "ggg",
hash = "d369e5da7a64649156a9c8ae9f2492df1374f7054957679d7388a1d6d8732653",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal GGG_M = require \"ggg:gggmeta\"\n\n\n\nlocal GGG_str = [[\nggg   ← rule+\nrule  ← _ lhs _ sep _ rhs _ \";\"\n`sep` ← \":=\" / \"=\" / \":\"\nlhs ← letter symbol-valid*\n\nrhs    ← rulexpr\n`rulexpr` ← operations+ / element\n\n`operations` ←  reg-choice / peg-choice / alt / cat / action\n\ncat ← element _ rulexpr\nreg-choice ← element _ \"|\" _ rulexpr\npeg-choice ← element _ \"/\" _ rulexpr\nalt      ← element _ \"¦\" _ rulexpr\naction   ← \"[\" _ rulexpr _ atom _ \"]\"\n\n`element`  ← simple / group\ngroup ← \"(\" _ rulexpr _ \")\" _\n\n`simple` ← prefixed / suffixed / atom\n\n`prefixed` ← negativelook / positivelook / negativereg\nnegativelook ← \"¿\" _ allowed-prefixed\npositivelook ← \"?\" _ allowed-prefixed\nnegativereg  ← \"!\" _ allowed-prefixed\n`allowed-prefixed` ← group / suffixed / atom\n\n`suffixed` ← many / oneormore / optional / lazymany / lazyoneormore\nmany       ← allowed-suffixed _ \"*\"\noneormore  ← allowed-suffixed _ \"+\"\noptional   ← allowed-suffixed _ \"±\"\nlazymany   ← allowed-suffixed _ \"\\\\*\"\nlazyoneormore ← allowed-suffixed _ \"\\\\+\"\n`allowed-suffixed` ← group / prefixed / atom\n\n`atom`   ← range / wildcard\n         / binary / hex / base64 / litstring / litchar\n         / symbol\n\nbinary   ← \"0b\" (\"0\"/\"1\")+\nhex      ← \"0x\" ([0-9]/[A-F]/[a-f])+\nbase64   ← (\"£\"/\"$$\") ([A-Z]/[a-z]/[0-9]/\"+\"/\"-\")+ (\"==\"/\"=\")?\n\nlitstring ← \"«\"+@lit-c (litstring / !(\"»\"+@(#lit-c)) 1)* \"»\"+@(#lit-c)\n          / jankstring\n`jankstring` ← \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' 1))* \'\"\'\nlitchar  ← (\"¢\"/\"\\\\\\\\\") utf8\nutf8 ← 1 ; this should actually match utf8...\n\n\nrange      ← binary \"..\" binary\n           / hex \"..\" hex\n           / litchar \"..\" litchar\nwildcard   ← \"~\" (\"#\"/\",\"/\"0\"/\"1\")+\n\n`_`  ← indent / { \\t}*\nindent ← (\"\\r\"? \"\\n\") { \\t}*\nsymbol ← letter symbol-valid*\n`letter` ← [a-z] / [A-Z]\n`symbol-valid` ← letter / digit / \"_\"\n`digit` ← [0-9]\n]]\n\n\n\n\n\nlocal GGG_peg = Peg(GGG_str)\nGGG_peg:toGrammar(GGG_M[1])\n\n\n\n\nreturn GGG_peg\n\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/femto",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/helm.git",
    home = "",
    website = "",
    name = "helm",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/zone",
hash = "89ee01053da5280ebb2d037e524c5b376f5088a186ce0bd414117b91dfd5d7f5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Txtbuf = require \"helm/txtbuf\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal a = require \"anterm:anterm\"\n\nlocal instanceof = import(\"core/meta\", \"instanceof\")\n\n\n\nlocal Zone = meta {}\nlocal Zoneherd = meta {}\n\n\n\n\n\n\n\nfunction Zone.height(zone)\n   return zone.bounds:height()\nend\nfunction Zone.width(zone)\n   return zone.bounds:width()\nend\n\n\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction Zone.clientBounds(zone)\n   if zone.border then\n      return zone.bounds:insetBy(Point(1,2))\n   else\n      return zone.bounds\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Zone.overlaps(zone, other_zone)\n   -- One or both zones may be uninitialized--treat this as nonoverlapping\n   return zone.bounds\n      and other_zone.bounds\n      and zone.bounds:intersects(other_zone.bounds)\nend\n\n\n\n\n\n\n\nfunction Zone.replace(zone, contents)\n   zone.contents = contents or \"\"\n   zone:beTouched()\n   return zone\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clamp = import(\"core/math\", \"clamp\")\nfunction Zone.scrollTo(zone, offset, allow_overscroll)\n   local buf = zone.contents\n   if not buf.is_rainbuf then\n      return false\n   end\n   -- Try to render the content that will be visible after the scroll\n   local client_height = zone:clientBounds():height()\n   buf:initComposition(zone:clientBounds():width())\n   buf:composeUpTo(offset + client_height)\n   local required_lines_visible = allow_overscroll and 1 or client_height\n   local max_offset = clamp(#buf.lines - required_lines_visible, 0)\n   offset = clamp(offset, 0, max_offset)\n   if offset ~= buf.offset then\n      buf.offset = offset\n      zone:beTouched()\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\nfunction Zone.scrollBy(zone, delta, allow_overscroll)\n   -- Need to check this here even though :scrollTo already does\n   -- because we talk to the Rainbuf to figure out the new offset\n   if not zone.contents.is_rainbuf then\n      return false\n   end\n   return zone:scrollTo(zone.contents.offset + delta, allow_overscroll)\nend\n\n\n\n\n\n\n\nfunction Zone.scrollUp(zone)\n   return zone:scrollBy(-1)\nend\nfunction Zone.scrollDown(zone)\n   return zone:scrollBy(1)\nend\n\nfunction Zone.pageUp(zone)\n   return zone:scrollBy(-zone:height())\nend\nfunction Zone.pageDown(zone)\n   return zone:scrollBy(zone:height())\nend\n\nlocal floor = assert(math.floor)\nfunction Zone.halfPageUp(zone)\n   return zone:scrollBy(-floor(zone:height() / 2))\nend\nfunction Zone.halfPageDown(zone)\n   return zone:scrollBy(floor(zone:height() / 2))\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zone.scrollToTop(zone)\n   return zone:scrollTo(0)\nend\n\nfunction Zone.scrollToBottom(zone, allow_overscroll)\n   zone.contents:composeAll()\n   -- Choose a definitely out-of-range value,\n   -- which scrollTo will clamp appropriately\n   return zone:scrollTo(#zone.contents.lines, allow_overscroll)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Zone.ensureVisible(zone, start_index, end_index)\n   end_index = end_index or start_index\n   local min_offset = clamp(end_index - zone:clientBounds():height(), 0)\n   local max_offset = clamp(start_index - 1, 0)\n   zone:scrollTo(clamp(zone.contents.offset, min_offset, max_offset))\nend\n\n\n\n\n\n\n\n\nlocal Rectangle  = require \"anterm/rectangle\"\nfunction Zone.setBounds(zone, rect, ...)\n   if not instanceof(rect, Rectangle) then\n      rect = Rectangle(rect, ...)\n   end\n   rect:assertNotEmpty(\"Zone must have non-zero area\")\n   if zone.bounds ~= rect then\n      if zone.bounds\n         and zone.bounds:width() ~= rect:width()\n         and zone.contents\n         and zone.contents.is_rainbuf then\n         zone.contents:clearCaches()\n      end\n      zone.bounds = rect\n      -- #todo technically this is incomplete as we need to care about\n      -- cells we may previously have owned and no longer do, and what zones\n      -- *are* now responsible for them. Doing that properly requires a real\n      -- two-step layout process, though (figure out where everything is going\n      -- to be, *then* put it there and mark things touched), so we\'ll\n      -- hold off for now\n      zone:beTouched()\n   end\n   return zone\nend\n\n\n\n\n\nfunction Zone.setVisibility(zone, new_visibility)\n   if new_visibility ~= zone.visible then\n      zone.visible = new_visibility\n      zone:beTouched()\n   end\n   return zone\nend\n\nfunction Zone.show(zone)\n   return zone:setVisibility(true)\nend\nfunction Zone.hide(zone)\n   return zone:setVisibility(false)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Zone.beTouched(zone)\n   if zone.touched then return end\n   zone.touched = true\n   for _, other_zone in ipairs(zone.zoneherd) do\n      if zone.z ~= other_zone.z and\n         zone.visible == (other_zone.z > zone.z) and\n         zone:overlaps(other_zone) then\n         other_zone.touched = true\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal box = require \"anterm/box\"\nfunction Zone.paintBorder(zone, write)\n   if zone.border then\n      write(box[zone.border](zone.bounds))\n   end\nend\n\n\n\n\n\nfunction Zone.erase(zone, write)\n   write(a.erase.box(zone.bounds))\nend\n\n\n\n\n\nlocal function _nl(zone)\n   return a.jump.col(zone:clientBounds().left) .. a.jump.down(1)\nend\n\nlocal lines = import(\"core/string\", \"lines\")\n\nlocal function _writeLines(write, zone)\n   local nl = _nl(zone)\n   local pr_row = zone.bounds.top\n   for line in lines(zone.contents) do\n       write(line, nl)\n       pr_row = pr_row + 1\n       if pr_row > zone.bounds.bottom then\n          break\n       end\n   end\nend\n\nlocal function _renderRainbuf(write, zone)\n   if not zone.contents then\n      return nil\n   end\n   assert(zone.contents.is_rainbuf)\n   local nl = _nl(zone)\n   for line in zone.contents:lineGen(zone:clientBounds():extent():rowcol()) do\n      write(line, nl)\n   end\nend\n\nfunction Zone.paint(zone, write)\n   if not (zone.visible and zone.touched) then\n      return\n   end\n   zone:erase(write)\n   zone:paintBorder(write)\n   if zone.contents then\n      write(a.jump(zone:clientBounds():origin()))\n      -- actually render ze contents\n      if type(zone.contents) == \"string\" then\n         _writeLines(write, zone)\n      else\n         _renderRainbuf(write, zone)\n      end\n   end\n   zone.touched = false\nend\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Zoneherd.addZone(zoneherd, zone)\n   zoneherd[zone.name] = zone\n   zone.zoneherd = zoneherd\n   local insert_index\n   for i, existing in ipairs(zoneherd) do\n      if existing.z > zone.z then\n         insert_index = i\n         break\n      end\n   end\n   if insert_index then\n      insert(zoneherd, insert_index, zone)\n   else\n      insert(zoneherd, zone)\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\nlocal function newZone(name, z, debug_mark)\n   local zone = meta(Zone)\n   zone.name = name\n   zone.debug_mark = debug_mark\n   zone.z = z\n   zone.visible = true\n   zone.touched = false\n   -- zone.contents, aspirationally a rainbuf, is provided later\n   return zone\nend\n\nfunction Zoneherd.newZone(zoneherd, name, z, debug_mark)\n   return zoneherd:addZone(newZone(name, z, debug_mark))\nend\n\n\n\n\n\nlocal function _zoneOffset(modeS)\n   local width = modeS.max_extent.col\n   if width <= 80 then\n      return 20\n   elseif width <= 100 then\n      return 30\n   elseif width <= 120 then\n      return 40\n   else\n      return 50\n   end\nend\n\n\n\n\n\nlocal ceil, floor = assert(math.ceil), assert(math.floor)\n\nfunction Zoneherd.reflow(zoneherd, modeS)\n   local right_col = modeS.max_extent.col - _zoneOffset(modeS)\n   local txt_off = modeS:continuationLines()\n   zoneherd.status:setBounds(  1, 1, 1, right_col)\n   zoneherd.stat_col:setBounds(1, right_col + 1,\n                               1, modeS.max_extent.col )\n   zoneherd.prompt:setBounds(  modeS.repl_top,\n                               1,\n                               modeS.repl_top + txt_off,\n                               modeS.PROMPT_WIDTH )\n   zoneherd.command:setBounds( modeS.repl_top,\n                               modeS.PROMPT_WIDTH + 1,\n                               modeS.repl_top + txt_off,\n                               right_col )\n   local results_right\n   if zoneherd.suggest.visible then\n      results_right = right_col\n      zoneherd.suggest:setBounds( modeS.repl_top + 1,\n                                  right_col + 1,\n                                  modeS.max_extent.row,\n                                  modeS.max_extent.col )\n   else\n      results_right = modeS.max_extent.col\n   end\n   zoneherd.results:setBounds( modeS.repl_top + txt_off + 1,\n                               1,\n                               modeS.max_extent.row,\n                               results_right )\n   -- Popup is centered and 2/3 of max width, i.e. from 1/6 to 5/6\n   zoneherd.popup:setBounds(   modeS.repl_top + txt_off + 1,\n                               floor(modeS.max_extent.col / 6),\n                               modeS.max_extent.row,\n                               ceil(modeS.max_extent.col * 5 / 6) )\n   -- Modal is centered vertically and horizontally, with the extent\n   -- determined by the contents. Modal only tells us the client area\n   -- required, we must account for the borders--seems like a good\n   -- division of responsibility.\n   if zoneherd.modal.visible then\n      local modal_extent = zoneherd.modal.contents[1]:requiredExtent() + Point(2, 4)\n      local margins = ((modeS.max_extent - modal_extent) / 2):floor()\n      zoneherd.modal:setBounds(margins.row, margins.col,\n                               (margins + modal_extent - 1):rowcol())\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\n\nfunction Zoneherd.paint(zoneherd, modeS)\n   local write = zoneherd.write\n   write(a.cursor.hide(), a.clear())\n   for i, zone in ipairs(zoneherd) do\n      zone:paint(write)\n   end\n   return zoneherd\nend\n\n\n\n\n\n\n\n\n\nlocal function new(modeS, writer)\n   local zoneherd = meta(Zoneherd)\n   zoneherd.write = writer\n   -- make Zones\n   -- correct values are provided by reflow\n   zoneherd:newZone(\"status\", 1, \".\")\n   zoneherd:newZone(\"stat_col\", 1, \"!\")\n   zoneherd:newZone(\"prompt\", 1, \">\")\n   zoneherd:newZone(\"command\", 1, \"$\")\n   zoneherd:newZone(\"results\", 1, \"~\")\n   zoneherd:newZone(\"suggest\", 1, \"%\")\n   zoneherd:newZone(\"popup\", 2, \"^\")\n   zoneherd.popup.visible = false\n   zoneherd.popup.border = \"light\"\n   zoneherd:newZone(\"modal\", 2, \"?\")\n   zoneherd.modal.visible = false\n   zoneherd.modal.border = \"light\"\n\n   return zoneherd\nend\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/txtbuf",
hash = "ed9e5f8eff7f530ceb4315cdef591d39a85f3056161eb68457a981c215c36be5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta)\nlocal Codepoints = require \"singletons/codepoints\"\nlocal lines = import(\"core/string\", \"lines\")\nlocal clone, collect, slice, splice =\n   import(\"core/table\", \"clone\", \"collect\", \"slice\", \"splice\")\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:rainbuf\"\nlocal Txtbuf = Rainbuf:inherit()\n\n\n\n\n\n\nlocal function cat(l)\n   if l == nil then\n      return \"\"\n   elseif type(l) == \"string\" then\n      return l\n   elseif type(l) == \"table\" then\n      return concat(l)\n   else\n      error(\"called private fn cat with type\" .. type(l))\n   end\nend\n\n\n\n\nfunction Txtbuf.__tostring(txtbuf)\n   local closed_lines = {}\n   for k, v in ipairs(txtbuf) do\n      closed_lines[k] = cat(v)\n   end\n   return concat(closed_lines, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.contentsChanged(txtbuf)\n   txtbuf.contents_changed = true\n   txtbuf:clearCaches()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.currentPosition(txtbuf)\n   local row, col = txtbuf.cursor:rowcol()\n   return txtbuf[row], col, row\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core_math = require \"core/math\"\nlocal clamp, inbounds = assert(core_math.clamp), assert(core_math.inbounds)\nlocal Point = require \"anterm/point\"\n\nfunction Txtbuf.setCursor(txtbuf, rowOrTable, col)\n   local row\n   if type(rowOrTable) == \"table\" then\n      row, col = rowOrTable.row, rowOrTable.col\n   else\n      row = rowOrTable\n   end\n   row = row or txtbuf.cursor.row\n   assert(inbounds(row, 1, #txtbuf))\n   txtbuf:openRow(row)\n   if col then\n      assert(inbounds(col, 1, #txtbuf[row] + 1))\n      -- Explicit horizontal motion, forget any remembered horizontal position\n      txtbuf.desired_col = nil\n   else\n      -- Remember where we were horizontally before clamping\n      txtbuf.desired_col = txtbuf.desired_col or txtbuf.cursor.col\n      col = clamp(txtbuf.desired_col, nil, #txtbuf[row] + 1)\n   end\n   txtbuf.cursor = Point(row, col)\n   txtbuf.cursor_changed = true\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.cursorIndex(txtbuf)\n   local index = txtbuf.cursor.col\n   for row = txtbuf.cursor.row - 1, 1, -1 do\n      index = index + #txtbuf[row] + 1\n   end\n   return index\nend\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.beginSelection(txtbuf)\n   txtbuf.mark = clone(txtbuf.cursor)\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.clearSelection(txtbuf)\n   if txtbuf:hasSelection() then\n      txtbuf.cursor_changed = true\n   end\n   txtbuf.mark = nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.hasSelection(txtbuf)\n   if not txtbuf.mark then return false end\n   if txtbuf.mark.row == txtbuf.cursor.row\n      and txtbuf.mark.col == txtbuf.cursor.col then\n      txtbuf.mark = nil\n      return false\n   else\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.selectionStart(txtbuf)\n   if not txtbuf:hasSelection() then return nil end\n   local c, m = txtbuf.cursor, txtbuf.mark\n   if m.row < c.row or\n      (m.row == c.row and m.col < c.col) then\n      return m.col, m.row\n   else\n      return c.col, c.row\n   end\nend\n\nfunction Txtbuf.selectionEnd(txtbuf)\n   if not txtbuf:hasSelection() then return nil end\n   local c, m = txtbuf.cursor, txtbuf.mark\n   if m.row > c.row or\n      (m.row == c.row and m.col > c.col) then\n      return m.col, m.row\n   else\n      return c.col, c.row\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.openRow(txtbuf, row_num)\n   if row_num < 1 or row_num > #txtbuf then\n      return nil\n   end\n   if type(txtbuf[row_num]) == \"string\" then\n      txtbuf[row_num] = Codepoints(txtbuf[row_num])\n   end\n   return txtbuf[row_num], row_num\nend\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.nl(txtbuf)\n   line, cur_col, cur_row = txtbuf:currentPosition()\n   -- split the line\n   local first = slice(line, 1, cur_col - 1)\n   local second = slice(line, cur_col)\n   txtbuf[cur_row] = first\n   insert(txtbuf, cur_row + 1, second)\n   txtbuf:contentsChanged()\n   txtbuf:setCursor(cur_row + 1, 1)\n   return false\nend\n\n\n\n\n\n\n\n\n\n\nlocal inverse = assert(require \"core:table\" . inverse)\nlocal _openers = { [\"(\"] = \")\",\n                   [\'\"\'] = \'\"\',\n                   [\"\'\"] = \"\'\",\n                   [\"{\"] = \"}\",\n                   [\"[\"] = \"]\"}\nlocal _closers = inverse(_openers)\n\nlocal function _should_insert(line, cursor, frag)\n   return not (frag == line[cursor] and _closers[frag])\nend\n\nlocal function _should_pair(line, cursor, frag)\n   -- Only consider inserting a pairing character if this is an \"opener\"\n   if not _openers[frag] then return false end\n   -- Translate end-of-line to the implied newline\n   local next_char = line[cursor] or \"\\n\"\n   -- Insert a pair if we are before whitespace, or the next char is a\n   -- closing brace--that is, a closing character that is different\n   -- from its corresponding open character, i.e. not a quote\n   return next_char:match(\"%s\") or\n      _closers[next_char] and _closers[next_char] ~= next_char\nend\n\nfunction Txtbuf.insert(txtbuf, frag)\n   local line, cur_col = txtbuf:currentPosition()\n   if _should_insert(line, cur_col, frag) then\n      if _should_pair(line, cur_col, frag) then\n         insert(line, cur_col, _openers[frag])\n      end\n      insert(line, cur_col, frag)\n      txtbuf:contentsChanged()\n   end\n   txtbuf:setCursor(nil, cur_col + 1)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.paste(txtbuf, frag)\n   frag = frag:gsub(\"\\t\", \"   \")\n   local frag_lines = collect(lines, frag)\n   for i, frag_line in ipairs(frag_lines) do\n      if i > 1 then txtbuf:nl() end\n      local codes = Codepoints(frag_line)\n      local line, cur_col, cur_row = txtbuf:currentPosition()\n      splice(line, cur_col, codes)\n      txtbuf:setCursor(nil, cur_col + #codes)\n   end\n   txtbuf:contentsChanged()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal deleterange = import(\"core/table\", \"deleterange\")\nfunction Txtbuf.killSelection(txtbuf)\n   if not txtbuf:hasSelection() then\n      return false\n   end\n   txtbuf:contentsChanged()\n   local start_col, start_row = txtbuf:selectionStart()\n   local end_col, end_row = txtbuf:selectionEnd()\n   if start_row == end_row then\n      -- Deletion within a line, just remove some chars\n      deleterange(txtbuf[start_row], start_col, end_col - 1)\n   else\n      -- Grab both lines--we\'re about to remove the end line\n      local start_line, end_line = txtbuf[start_row], txtbuf[end_row]\n      deleterange(txtbuf, start_row + 1, end_row)\n      -- Splice lines together\n      for i = start_col, #start_line do\n         start_line[i] = nil\n      end\n      for i = end_col, #end_line do\n         insert(start_line, end_line[i])\n      end\n   end\n   -- Cursor always ends up at the start of the formerly-selected area\n   txtbuf:setCursor(start_row, start_col)\n   -- No selection any more\n   txtbuf:clearSelection()\nend\n\n\n\n\n\n\n\n\nlocal function _delete_for_motion(motionName)\n   return function(txtbuf, ...)\n      txtbuf:beginSelection()\n      txtbuf[motionName](txtbuf, ...)\n      return txtbuf:killSelection()\n   end\nend\n\nfor delete_name, motion_name in pairs({\n   killForward = \"right\",\n   killToEndOfLine = \"endOfLine\",\n   killToBeginningOfLine = \"startOfLine\",\n   killToEndOfWord = \"rightWordAlpha\",\n   killToBeginningOfWord = \"leftWordAlpha\"\n}) do\n   Txtbuf[delete_name] = _delete_for_motion(motion_name)\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _is_paired(a, b)\n   -- a or b might be out-of-bounds, and if a is not a brace and b is nil,\n   -- we would incorrectly answer true, so check that both a and b are present\n   return a and b and _openers[a] == b\nend\n\nfunction Txtbuf.killBackward(txtbuf, disp)\n   disp = disp or 1\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   -- Only need to check the character immediately to the left of the cursor\n   -- since if we encounter paired braces later, we will delete the\n   -- closing brace first anyway\n   if _is_paired(line[cur_col - 1], line[cur_col]) then\n      txtbuf:right()\n      disp = disp + 1\n   end\n   txtbuf:beginSelection()\n   txtbuf:left(disp)\n   txtbuf:killSelection()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.left(txtbuf, disp)\n   disp = disp or 1\n   local line, new_col, new_row = txtbuf:currentPosition()\n   new_col = new_col - disp\n   while new_col < 1 do\n      line, new_row = txtbuf:openRow(new_row - 1)\n      if not new_row then\n         txtbuf:setCursor(nil, 1)\n         return false\n      end\n      new_col = #line + 1 + new_col\n   end\n   txtbuf:setCursor(new_row, new_col)\n   return true\nend\n\nfunction Txtbuf.right(txtbuf, disp)\n   disp = disp or 1\n   local line, new_col, new_row = txtbuf:currentPosition()\n   new_col = new_col + disp\n   while new_col > #line + 1 do\n      _, new_row = txtbuf:openRow(new_row + 1)\n      if not new_row then\n         txtbuf:setCursor(nil, #line + 1)\n         return false\n      end\n      new_col = new_col - #line - 1\n      line = txtbuf[new_row]\n   end\n   txtbuf:setCursor(new_row, new_col)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.up(txtbuf)\n   if not txtbuf:openRow(txtbuf.cursor.row - 1) then\n      txtbuf:setCursor(nil, 1)\n      return false\n   end\n   txtbuf:setCursor(txtbuf.cursor.row - 1, nil)\n   return true\nend\n\nfunction Txtbuf.down(txtbuf)\n   if not txtbuf:openRow(txtbuf.cursor.row + 1) then\n      txtbuf:setCursor(nil, #txtbuf[txtbuf.cursor.row] + 1)\n      return false\n   end\n   txtbuf:setCursor(txtbuf.cursor.row + 1, nil)\n   return true\nend\n\n\n\n\n\n\nfunction Txtbuf.startOfLine(txtbuf)\n   txtbuf:setCursor(nil, 1)\nend\n\nfunction Txtbuf.endOfLine(txtbuf)\n   txtbuf:setCursor(nil, #txtbuf[txtbuf.cursor.row] + 1)\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.startOfText(txtbuf)\n   txtbuf:setCursor(1, 1)\nend\n\nfunction Txtbuf.endOfText(txtbuf)\n   txtbuf:setCursor(#txtbuf, #txtbuf[#txtbuf] + 1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal match = assert(string.match)\n\nfunction Txtbuf.scanFor(txtbuf, pattern, reps, forward)\n   local change = forward and 1 or -1\n   reps = reps or 1\n   local found_other_char, moved = false, false\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local search_pos, search_row = cur_col, cur_row\n   local search_char\n   local epsilon = forward and 0 or -1\n   while true do\n      local at_boundary = (forward and search_pos > #line)\n                       or (not forward and search_pos == 1)\n      search_char = at_boundary and \"\\n\" or line[search_pos + epsilon]\n      if not match(search_char, pattern) then\n         found_other_char = true\n      elseif found_other_char then\n         reps = reps - 1\n         if reps == 0 then break end\n         found_other_char = false\n      end\n      if at_boundary then\n         -- break out on txtbuf boundaries\n         if search_row == (forward and #txtbuf or 1) then break end\n         line, search_row = txtbuf:openRow(search_row + change)\n         search_pos = forward and 1 or #line + 1\n      else\n         search_pos = search_pos + change\n      end\n      moved = true\n   end\n\n   return moved, search_pos - cur_col, search_row - cur_row\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.leftToBoundary(txtbuf, pattern, reps)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colΔ, rowΔ = txtbuf:scanFor(pattern, reps, false)\n   if moved then\n      txtbuf:setCursor(cur_row + rowΔ, cur_col + colΔ)\n      return true\n   else\n      return false\n   end\nend\n\nfunction Txtbuf.rightToBoundary(txtbuf, pattern, reps)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   local moved, colΔ, rowΔ = txtbuf:scanFor(pattern, reps, true)\n   if moved then\n      txtbuf:setCursor(cur_row + rowΔ, cur_col + colΔ)\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.firstNonWhitespace(txtbuf)\n   local line = txtbuf[txtbuf.cursor.row]\n   local new_col = 1\n   while new_col <= #line do\n      if match(line[new_col], \'%S\') then\n         txtbuf:setCursor(nil, new_col)\n         return true\n      end\n      new_col = new_col + 1\n   end\n   return false\nend\n\n\n\n\n\nfunction Txtbuf.leftWordAlpha(txtbuf, reps)\n   return txtbuf:leftToBoundary(\'%W\', reps)\nend\n\nfunction Txtbuf.rightWordAlpha(txtbuf, reps)\n   return txtbuf:rightToBoundary(\'%W\', reps)\nend\n\nfunction Txtbuf.leftWordWhitespace(txtbuf, reps)\n   return txtbuf:leftToBoundary(\'%s\', reps)\nend\n\nfunction Txtbuf.rightWordWhitespace(txtbuf, reps)\n   return txtbuf:rightToBoundary(\'%s\', reps)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.transposeLetter(txtbuf)\n   local line, cur_col, cur_row = txtbuf:currentPosition()\n   if cur_col == 1 then return false end\n   if cur_col == 2 and #line == 1 then return false end\n   local left, right = cur_col - 1, cur_col\n   if cur_col == #line + 1 then\n      left, right = left - 1, right - 1\n   end\n   local stash = line[right]\n   line[right] = line[left]\n   line[left] = stash\n   txtbuf:setCursor(nil, right + 1)\n   txtbuf:contentsChanged()\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.shouldEvaluate(txtbuf)\n   -- Most txtbufs are one line, so we always evaluate from\n   -- a one-liner, regardless of cursor location.\n   local linum = #txtbuf\n   if linum == 1 then\n      return true\n   end\n   local _, cur_col, cur_row = txtbuf:currentPosition()\n   -- Evaluate if we are at the end of the first or last line (the default\n   -- positions after scrolling up or down in the history)\n   if (cur_row == 1 or cur_row == linum) and cur_col > #txtbuf[cur_row] then\n      return true\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Txtbuf.initComposition(txtbuf, cols)\n   txtbuf:super\"initComposition\"(cols)\n   txtbuf.render_row = 1\nend\n\n\n\n\n\n\nlocal c = assert(require \"singletons:color\" . color)\nfunction Txtbuf._composeOneLine(txtbuf)\n   if txtbuf.render_row > #txtbuf then return nil end\n   local tokens = txtbuf:tokens(txtbuf.render_row)\n   local suggestion = txtbuf.active_suggestions\n      and txtbuf.active_suggestions:selectedItem()\n   for i, tok in ipairs(tokens) do\n      -- If suggestions are active and one is highlighted,\n      -- display it in grey instead of what the user has typed so far\n      -- Note this only applies once Tab has been pressed, as until then\n      -- :selectedItem() will be nil\n      if suggestion and tok.cursor_offset then\n         tokens[i] = txtbuf.active_suggestions:highlight(suggestion, txtbuf.cols, c)\n      else\n         tokens[i] = tok:toString(c)\n      end\n   end\n   txtbuf.render_row = txtbuf.render_row + 1\n   return concat(tokens)\nend\n\n\n\n\n\n\n\n\nfunction Txtbuf.tokens(txtbuf, row)\n   if row then\n      local cursor_col = txtbuf.cursor.row == row\n         and txtbuf.cursor.col or 0\n      return txtbuf.lex(cat(txtbuf[row]), cursor_col)\n   else\n      return txtbuf.lex(tostring(txtbuf), txtbuf:cursorIndex())\n   end\nend\n\n\n\n\n\nfunction Txtbuf.suspend(txtbuf)\n   for i, v in ipairs(txtbuf) do\n      txtbuf[i] = cat(v)\n   end\n   return txtbuf\nend\n\n\n\nfunction Txtbuf.resume(txtbuf)\n   txtbuf:openRow(txtbuf.cursor.row)\n   return txtbuf\nend\n\n\n\nfunction Txtbuf.clone(txtbuf)\n   -- Clone the lines as well as the Txtbuf itself\n   local tb = clone(txtbuf, 2)\n   return tb:resume()\nend\n\n\n\n\n\n\nfunction Txtbuf._init(txtbuf)\n   txtbuf:super\"_init\"()\n   -- Txtbuf needs to re-render in most event-loop cycles, detecting\n   -- whether a re-render is actually needed is tricky,\n   -- and it\'s reasonably cheap to just *always* re-render, so...\n   txtbuf.live = true\n   txtbuf.contents_changed = false\n   txtbuf.cursor_changed = false\nend\n\nfunction Txtbuf.replace(txtbuf, str)\n   txtbuf:super\"replace\"(str)\n   str = str or \"\"\n   -- We always have at least one line--will be overwritten\n   -- if there\'s actual content provided in str\n   txtbuf[1] = \"\"\n   local i = 1\n   for line in lines(str) do\n      txtbuf[i] = line\n      i = i + 1\n   end\n   for j = i, #txtbuf do\n      txtbuf[j] = nil\n   end\n   txtbuf:contentsChanged()\n   txtbuf:endOfText()\n   return txtbuf\nend\n\n\n\nlocal Txtbuf_class = setmetatable({}, Txtbuf)\nTxtbuf.idEst = Txtbuf_class\n\nreturn Txtbuf_class\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/watcher",
hash = "a3503c7346701cb6083b68e8d8e2dfbf5f2922922fb9228800f92bdc42cbe80a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n   watcher.dir = dir\n   -- default to a recursive watch\n   if recur == nil then\n      recur = true\n   end\n   local fse = uv.new_fs_event()\n   watcher.fse = fse\n   uv.fs_event_start(fse, dir,{recursive = recur},function (err,fname,status)\n      if(err) then\n         print(\"Error \"..err)\n      else\n         local ev = nil\n         for k,v in pairs(status) do\n            ev = k\n         end\n         if ev == \"change\" then\n            watcher:onchange(fname)\n         elseif ev == \"rename\" then\n            watcher:onrename(fname)\n         else\n            print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n         end\n      end\n   end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/luapersist",
hash = "2ea793dba059cb550d28c8d884ba28df9f09115ad1b97efaf8521f747f2fdcef",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--[[ luapersist3.lua  2004-Aug-31 e\n\n  The author disclaims copyright to this source code.  In place of\n  a legal notice, here is a blessing:\n      May you be healthy and well.\n      May you be free of all suffering.\n      May you be happy, giving more than you take.\n\n  Lua Persistent Tables\n  loosely based on the wiki page http://lua-users.org/wiki/PersistentTables\n  uses Lua SQLite 3 (see http://luaforge.net/projects/luasqlite/)\n  handles circular structures\n\n  DB Schema\n  the Lua tables are stored in a single SQL table with five columns\n  TID : Table ID that identifies the Lua table -- string\n  Key : index in the Lua Table -- TID, string, number, or boolean\n  Kyp : the data type of Key\n  Val : value in the Lua Table at index -- TID, string, number, or boolean\n  Vyp : the data type of Val\n\n  A row is created for each Lua Persistent Table to reserve its TID.\n  The Key, Kyp, Val, and Vyp columns are all set to \"_\".\n\n  Both Kyp and Vyp use the following encoding:\n  \"b\" -- boolean (Key/Val = \"t\" or \"f\")\n  \"n\" -- number\n  \"t\" -- TID\n  \"s\" -- string\n  \"e\" -- encoded string (the raw string has embedded NULs)\n   \"_\" -- null\n\n  Caveats\n  1. Strings used for Key and Val may contain embedded \'\\0\' NUL characters;\n     they are stored using sqlite blobs.\n     Strings used for TIDs must not have embedded NULs.\n  2. A table may not be used as a key unless the table is already persistent;\n      tables may always be used as vals.\n  3. Functions, threads, and userdata are not supported as keys or vals.\n  4. Lua Persistent Tables may not have user metatables (they will not be\n     persisted, and they may conflict with Lua Persistent Table events).\n\n  Implementation\n\n  Lua Persistent Tables are represented by an empty Lua Table and a\n  corresponding metatable.\n\n  Lua Persistent Table Metatable events:\n  \"lpt_TID\" -- the TID for this table\n  \"index\" -- handler for unmarshalling Key/Val from the DB\n  \"newindex\" -- handler for marshalling Key/Val to the DB\n  \"lpt_cache\" -- a Lua Table that caches Key/Val pairs\n  \"lpt_db\" -- the Lua Persistent Table database descriptor for this table\'s db\n\n  LuaPersist maintains one global weak table, map, that is used to find\n  Lua Persistent Tables that are already open. This insures that there\n  is at most one version of each Lua Persistent Table in memory.\n]]\n\n-- nb: accidentally corrupted this file (fuck) and am not using it so,\n-- removed all source code -Sam\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/session",
hash = "e912b66832764d35d0b61df9bd5137a9f3125bd5deefa54d3ef3b81d5588a760",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:meta\" . meta)\nlocal helm_db = require \"helm:helm-db\"\nlocal Session = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\nfunction Session.premiseCount(session)\n   local count = 0\n   for _, premise in ipairs(session) do\n      if premise.status == \"accept\" or premise.status == \"reject\" then\n         count = count + 1\n      end\n   end\n   return count\nend\n\n\n\n\n\n\n\nfunction Session.passCount(session)\n   local count = 0\n   for _, premise in ipairs(session) do\n      if premise.status == \"accept\" and premise.same then\n         count = count + 1\n      end\n   end\n   return count\nend\n\n\n\n\n\n\n\n\n\n\nlocal tabulate = assert(require \"repr:persist-tabulate\" . tabulate)\nfunction Session.evaluate(session, valiant, historian)\n   for _, premise in ipairs(session) do\n      local ok, result = valiant(premise.line)\n      -- #todo handle errors here\n\n      -- Avoid empty results\n      if result and result.n > 0 then\n         premise.live_result = result\n         -- #todo have the Historian handle this!\n         premise.new_result = tabulate(result, aG)\n      end\n      if premise.old_result and premise.new_result\n         and #premise.old_result == #premise.new_result then\n         premise.same = true\n         for i = 1, #premise.old_result do\n            if premise.old_result[i] ~= premise.new_result[i] then\n               premise.same = false\n               break\n            end\n         end\n      elseif (not premise.old_result) and (not premise.new_result) then\n         premise.same = true\n      else\n         premise.same = false\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _appendPremise(session, premise)\n   session.n = session.n + 1\n   session[session.n] = premise\nend\n\n-- #todo we should ideally ask the Historian for these results,\n-- in case it already has them\nlocal db_result_M = assert(require \"repr:persist-tabulate\" . db_result_M)\nlocal function _wrapResults(results)\n   local wrapped = { n = #results }\n   for i = 1, wrapped.n do\n      wrapped[i] = setmetatable({results[i]}, db_result_M)\n   end\n   return wrapped\nend\n\nlocal function _loadResults(session, premise)\n   local stmt = session.stmts.get_results\n   local results = stmt:bind(premise.old_line_id):resultset()\n   if results then\n      results = _wrapResults(results.repr)\n   end\n   premise.old_result = results\n   stmt:reset()\nend\n\nfunction Session.loadPremises(session)\n   local stmt = session.stmts.get_session_by_id\n                  :bind(session.session_id)\n   for result in stmt:rows() do\n      -- Left join may produce (exactly one) row with no status value,\n      -- indicating that we have no premises\n      if result.status then\n         local premise = {\n            title = result.title,\n            status = result.status,\n            line = result.line,\n            old_line_id = result.line_id,\n            line_id = result.line_id, -- These will be filled if/when we re-run\n            live_result = nil,\n            old_result = nil, -- Need a separate query to load this\n            new_result = nil\n         }\n         _loadResults(session, premise)\n         _appendPremise(session, premise)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction Session.append(session, line_id, line, results)\n   -- Require manual approval of all lines by default,\n   -- but do include them in the session, i.e. start with \'ignore\' status\n   local status = \'ignore\'\n   -- In macro mode we instead accept all lines with results by default\n   if session.mode == \"macro\" and results then\n      status = \'accept\'\n   end\n   local premise = {\n      title = \"\",\n      status = status,\n      line = line,\n      old_line_id = nil,\n      line_id = line_id,\n      live_result = results,\n      old_result = nil, -- These will be filled in later once generated\n      new_result = nil\n   }\n   _appendPremise(session, premise)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Session.resultsAvailable(session, line_id, results)\n   for _, premise in ipairs(session) do\n      if premise.line_id == line_id then\n         premise.new_result = _wrapResults(results)\n         break\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal compact = assert(require \"core:table\" . compact)\nfunction Session.save(session)\n   session.stmts.beginTransaction()\n   -- If the session itself hasn\'t been stored yet, do so and retrieve its id\n   if not session.session_id then\n      session.stmts.insert_session:bindkv(session):step()\n      session.session_id = session.stmts.lastRowId()\n   -- Otherwise possibly update its title and accepted status\n   else\n      session.stmts.update_session:bindkv(session):step()\n   end\n   -- First, remove any \"skip\"ped premises from the session\n   for i, premise in ipairs(session) do\n      if premise.status == \"skip\" then session[i] = nil end\n   end\n   compact(session)\n   -- And now from the DB (the query picks up session.n directly)\n   session.stmts.truncate_session:bindkv(session):step()\n   -- Now insert all of our premises--anything that is already there\n   -- will be replaced thanks to ON CONFLICT REPLACE\n   for i, premise in ipairs(session) do\n      session.stmts.insert_premise\n            :bindkv{ session_id = session.session_id, ordinal = i }\n            :bindkv(premise)\n            :step()\n   end\n   session.stmts.commit()\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal collect = assert(require \'core:table\' . collect)\n\nnew = function(db, project_id, title_or_index, cfg)\n   local session = meta(Session)\n   session.stmts = helm_db.session(db)\n   session.project_id = project_id\n   session.n = 0\n   if type(title_or_index) == \"number\" then\n      local stmt = session.stmts.get_sessions_for_project\n      stmt:bind(session.project_id)\n      local results = collect(stmt.rows, stmt)\n      stmt:clearbind():reset()\n      -- An index can only be used when intending to load\n      -- so out-of-bounds is an immediate error\n      if #results < title_or_index then\n         error((\'Cannot load session #%d, only %d available.\')\n                  :format(title_or_index, #results))\n      end\n      local result = results[title_or_index]\n      session.session_id = result.session_id\n      session.session_title = result.session_title\n      session.accepted = result.accepted ~= 0\n   else\n      session.session_title = title_or_index\n      local result = session.stmts.get_session_by_project_and_title\n                        :bind(session.project_id, session.session_title)\n                        :stepkv()\n      if result then\n         session.session_id = result.session_id\n         session.accepted = result.accepted ~= 0\n      end\n   end\n   for k, v in pairs(cfg) do\n      session[k] = v\n   end\n   return session\nend\n\n\n\nSession.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/edit",
hash = "4c3a746f9a4df5b6c481afbd483401dcb83fa30b9164b0ff4e46081787cbf54b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal addall, clone = import(\"core/table\", \"addall\", \"clone\")\nlocal RagaBase = require \"helm:helm/raga/base\"\nlocal Txtbuf = require \"helm/txtbuf\"\n\n\n\nlocal EditBase = clone(RagaBase, 2)\n\n\n\n\n\n\n\n\n\nlocal function toTxtbuf(fn)\n   return function(modeS, category, value)\n      return modeS.txtbuf[fn](modeS.txtbuf)\n   end\nend\n\n\n\n\n\n\nlocal function _insert(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n   end\n   modeS.txtbuf:insert(value)\nend\n\nEditBase.ASCII = _insert\nEditBase.UTF8 = _insert\n\nfunction EditBase.PASTE(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n   end\n   modeS.txtbuf:paste(value)\nend\n\n\n\n\n\n\n\nlocal NAV = EditBase.NAV\naddall(NAV, {\n   LEFT           = toTxtbuf \"left\",\n   RIGHT          = toTxtbuf \"right\",\n   ALT_LEFT       = toTxtbuf \"leftWordAlpha\",\n   ALT_RIGHT      = toTxtbuf \"rightWordAlpha\",\n   HOME           = toTxtbuf \"startOfLine\",\n   END            = toTxtbuf \"endOfLine\",\n   BACKSPACE      = toTxtbuf \"killBackward\",\n   DELETE         = toTxtbuf \"killForward\",\n   ALT_BACKSPACE  = toTxtbuf \"killToBeginningOfWord\",\n   ALT_DELETE     = toTxtbuf \"killToEndOfWord\",\n})\n\n\n\n\n\n\n\nlocal CTRL = EditBase.CTRL\n\nCTRL [\"^A\"] = NAV.HOME\nCTRL [\"^E\"] = NAV.END\n\nlocal function clear_txtbuf(modeS, category, value)\n   modeS:setTxtbuf(Txtbuf())\n   modeS:setResults(\"\")\n   modeS.hist.cursor = modeS.hist.n + 1\nend\n\nCTRL [\"^L\"] = clear_txtbuf\n\nCTRL [\"^R\"] = function(modeS, category, value)\n                 modeS:restart()\n              end\n\nCTRL [\"^K\"] = toTxtbuf \"killToEndOfLine\"\nCTRL [\"^U\"] = toTxtbuf \"killToBeginningOfLine\"\nCTRL [\"^T\"] = toTxtbuf \"transposeLetter\"\n\n\n\n\n\n\naddall(EditBase.ALT, {\n   [\"M-w\"] = NAV.ALT_RIGHT,\n   [\"M-b\"] = NAV.ALT_LEFT,\n   [\"M-d\"] = NAV.ALT_DELETE\n})\n\n\n\n\n\n\n\n\nfunction EditBase.getCursorPosition(modeS)\n   return modeS.zones.command.bounds:origin() + modeS.txtbuf.cursor - 1\nend\n\n\n\n\nreturn EditBase\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/resbuf",
hash = "ff5f133328dc9385117312f78019d68f4654fc0573ade8c8a08782ae44fea863",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal lineGen = import(\"repr:repr\", \"lineGen\")\nlocal cluster = require \"core:cluster\"\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:rainbuf\"\nlocal Resbuf = Rainbuf:inherit()\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\nfunction Resbuf.clearCaches(resbuf)\n   resbuf:super\"clearCaches\"()\n   resbuf.reprs = nil\n   resbuf.r_num = nil\nend\n\n\n\n\n\n\n\n\nlocal lines = import(\"core/string\", \"lines\")\nfunction Resbuf.initComposition(resbuf, cols)\n   resbuf:super\"initComposition\"(cols)\n   if not resbuf.reprs then\n      resbuf.reprs = {}\n      resbuf.r_num = 1\n      for i = 1, resbuf.n do\n         resbuf.reprs[i] = resbuf.frozen\n            and lines(resbuf[i])\n            or lineGen(resbuf[i], resbuf.cols)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal max = assert(math.max)\nfunction Resbuf.replace(resbuf, res)\n   resbuf:super\"replace\"(res)\n   if not res then\n      res = { n = 0 }\n   end\n   assert(res.n, \"must have n\")\n   for i = 1, max(resbuf.n, res.n) do\n      resbuf[i] = res[i]\n   end\n   -- Treat an error result from valiant as just a string,\n   -- not something to repr\n   resbuf.frozen = res.error\n   resbuf.n = res.n\nend\n\n\n\n\n\n\n\n\n\nfunction Resbuf._composeOneLine(resbuf)\n   assert(resbuf.r_num,\n      \"r_num has been niled (missing an :initComposition after :clearCaches?)\")\n   while resbuf.r_num <= resbuf.n do\n      local line = resbuf.reprs[resbuf.r_num]()\n      if line then\n         return line\n      end\n      resbuf.r_num = resbuf.r_num + 1\n   end\n   return nil\nend\n\n\n\n\nlocal Resbuf_class = setmetatable({}, Resbuf)\nResbuf.idEst = Resbuf_class\n\nreturn Resbuf_class\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/painter",
hash = "03d90442f202043c0cd00efcea862b62452485e900e7e4502d082c14aac32cd6",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta)\nassert(type)\n\n\n\nlocal Paint = meta {}\n\n\n\n\n\n\n\nlocal STATCOL = 81\nlocal STAT_TOP = 1\nlocal STAT_RUN = 2\n\nlocal function colwrite(str, col, row)\n   col = col or STATCOL\n   row = row or STAT_TOP\n   local dash = a.stash()\n             .. a.cursor.hide()\n             .. a.jump(row, col)\n             .. a.erase.right()\n             .. str\n             .. a.pop()\n             .. a.cursor.show()\n   write(dash)\nend\n\nlocal STAT_ICON = \"◉ \"\n\nlocal function tf(bool)\n   if bool then\n      return ts(\"t\", \"true\")\n   else\n      return ts(\"f\", \"false\")\n   end\nend\n\nlocal function pr_mouse(m)\n   local phrase = a.magenta(m.button) .. \": \"\n                     .. a.bright(m.kind) .. \" \" .. tf(m.shift)\n                     .. \" \" .. tf(m.meta)\n                     .. \" \" .. tf(m.ctrl) .. \" \" .. tf(m.moving) .. \" \"\n                     .. tf(m.scrolling) .. \" \"\n                     .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)\n   return phrase\nend\n\nlocal function mk_paint(fragment, shade)\n   return function(category, action)\n      return shade(category .. fragment .. action)\n   end\nend\n\nlocal act_map = { MOUSE  = pr_mouse,\n                  NAV    = mk_paint(\": \", a.italic),\n                  CTRL   = mk_paint(\": \", c.field),\n                  ALT    = mk_paint(\": \", a.underscore),\n                  ASCII  = mk_paint(\": \", c.table),\n                  NYI    = mk_paint(\": \", a.red)}\n\nlocal icon_map = { MOUSE = mk_paint(STAT_ICON, c.userdata),\n                   NAV   = mk_paint(STAT_ICON, a.magenta),\n                   CTRL  = mk_paint(STAT_ICON, a.blue),\n                   ALT   = mk_paint(STAT_ICON, c[\"function\"]),\n                   ASCII = mk_paint(STAT_ICON, a.green),\n                   NYI   = mk_paint(STAT_ICON .. \"! \", a.red) }\n\nlocal function icon_paint(category, value)\n   assert(icon_map[category], \"icon_paint NYI:\" .. category)\n   if category == \"MOUSE\" then\n      return colwrite(icon_map[category](\"\", pr_mouse(value)))\n    end\n   return colwrite(icon_map[category](\"\", ts(value)))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Paint.inBox(painter, rainbuf, box)\n   local tc, tr, bc, br = box[1], box[2], box[3], box[4]\n   if type(rainbuf) == \"string\" then\n      -- string painter\n   elseif type(rainbuf) == \"table\" then\n      -- Detect rainbuf.idEst, paint the rainbuf\n   end\nend\n\n\n\nlocal function new(_stdout)\n   local painter = meta(Paint)\n   painter.out  = _stdout\n   return painter\nend\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/suggest",
hash = "63464c3b1b946e572ad899a4dbdccc7a7f7f2a342b535a52188da071100a261e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm:selection_list\"\nlocal Resbuf = require \"helm:resbuf\"\nlocal names = require \"repr:names\"\nlocal insert, sort = assert(table.insert), assert(table.sort)\n\n\n\n\n\nlocal Suggest = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _cursorContext(modeS)\n   local lex_tokens = {}\n   -- Ignore whitespace and comments\n   for _, token in ipairs(modeS.txtbuf:tokens()) do\n      if token.color ~= \"no_color\" and token.color ~= \"comment\" then\n         insert(lex_tokens, token)\n      end\n   end\n   -- Find the index of the token containing the cursor\n   local index, context\n   for i, token in ipairs(lex_tokens) do\n      if token.cursor_offset then\n         index = i\n         context = token\n         break\n      end\n   end\n   -- #todo once we\'re using =palette=, we\'ll be able to check the name\n   -- of the color rather than needing the color table ourselves\n   if not context or context.color ~= \"field\" then\n      -- We\'re in a non-completable token\n      return nil\n   end\n   -- Work backwards from there to determine the dotted path, if any,\n   -- that we are completing within\n   local path = {}\n   local expect_field = false\n   index = index - 1\n   while index > 0 do\n      local path_token = lex_tokens[index]\n      if expect_field then\n         if path_token.color == \"field\" then\n            insert(path, 1, tostring(path_token))\n         else\n            -- If we expected an identifier/field and got something else,\n            -- we\'re likely in a situation like foo[bar].baz, having just\n            -- examined the dot. If the content of the braces is a literal,\n            -- we *could* deal with it anyway, but this is not yet implemented.\n            path = nil\n            break\n         end\n      elseif not tostring(path_token):find(\"^[.:]$\") then\n         -- Expected a . or :, got absolutely anything else, we\'ve finished\n         -- this dotted path.\n         break\n      end\n      expect_field = not expect_field\n      index = index - 1\n   end\n   return context, path\nend\n\n\n\n\n\n\n\n\nlocal function _suggest_sort(a, b)\n   if a.score ~= b.score then\n      return a.score < b.score\n   elseif #a.sym ~= #b.sym then\n      return #a.sym < #b.sym\n   else\n      return a.sym < b.sym\n   end\nend\n\nlocal isidentifier = import(\"core:string\", \"isidentifier\")\nlocal hasmetamethod = import(\"core:meta\", \"hasmetamethod\")\nlocal safeget = import(\"core:table\", \"safeget\")\nlocal fuzz_patt = require \"helm:fuzz_patt\"\nlocal Set = require \"set:set\"\n\nlocal function _suggestions_from(complete_against)\n   -- Either no path was provided, or some part of it doesn\'t\n   -- actually exist, fall back to completing against all symbols\n   if complete_against == nil then\n      return names.all_symbols\n   end\n   local count = 0\n   local candidate_symbols = Set()\n   repeat\n      -- Do not invoke any __pairs metamethod the table may have\n      for k, _ in next, complete_against do\n         if isidentifier(k) then\n            count = count + 1\n            candidate_symbols[k] = true\n         if count > 500 then\n               return candidate_symbols\n            end\n         end\n      end\n      local index_table = hasmetamethod(\"__index\", complete_against)\n      -- Ignore __index functions, no way to know what they might handle\n      complete_against = type(index_table) == \"table\" and index_table or nil\n   until complete_against == nil\n   return candidate_symbols\nend\n\nlocal function _set_suggestions(modeS, suggestions)\n   modeS.suggest.active_suggestions = suggestions\n   -- #todo Can\'t say I like assigning this twice like this\n   modeS.txtbuf.active_suggestions = suggestions\nend\n\n\nfunction Suggest.update(suggest, modeS)\n   local context, path = _cursorContext(modeS)\n   if context == nil then\n      suggest:cancel(modeS)\n      return\n   end\n\n   -- First, build a list of candidate symbols--those that would be valid\n   -- in the current position.\n   local complete_against\n   if path then\n      complete_against = __G\n      for _, key in ipairs(path) do\n         complete_against = safeget(complete_against, key)\n      end\n      -- If what we end up with isn\'t a table, we can\'t complete against it\n      if type(complete_against) ~= \"table\" then\n         complete_against = nil\n      end\n   end\n   local candidate_symbols = _suggestions_from(complete_against)\n\n   -- Now we can actually filter those candidates for whether they match or not\n   local suggestions = SelectionList()\n   suggestions.best = true\n   suggestions.frag = tostring(context):sub(1, context.cursor_offset)\n   suggestions.lit_frag = suggestions.frag\n   local match_patt = fuzz_patt(suggestions.frag)\n   local matches = {}\n   for sym in pairs(candidate_symbols) do\n      local score = match_patt:match(sym)\n      if score then\n         insert(matches, { score = score, sym = sym })\n      end\n   end\n   if #matches == 0 then\n      suggest:cancel(modeS)\n      return\n   end\n   sort(matches, _suggest_sort)\n   for _, match in ipairs(matches) do\n      insert(suggestions, match.sym)\n   end\n   if modeS.raga.name == \"complete\" then\n      suggestions.selected_index = 1\n   end\n   _set_suggestions(modeS, suggestions)\n   -- #todo Should this be a separate Rainbuf subclass,\n   -- or is the __repr approach fine?\n   modeS.zones.suggest:replace(Resbuf(\n      { suggestions, n = 1 },\n      { live = true, made_in = \"suggest.update\" }))\nend\n\n\n\n\n\n\nfunction Suggest.selectedSuggestion(suggest)\n   return suggest.active_suggestions and suggest.active_suggestions:selectedItem()\nend\n\n\n\n\n\nfunction Suggest.cancel(suggest, modeS)\n   _set_suggestions(modeS, nil)\n   modeS.zones.suggest:replace(\"\")\n   modeS.zones.command:beTouched()\nend\n\n\n\n\n\nfunction Suggest.accept(suggest, modeS)\n   local suggestion = suggest:selectedSuggestion()\n   local context = _cursorContext(modeS)\n   modeS.txtbuf:right(context.total_disp - context.cursor_offset)\n   modeS.txtbuf:killBackward(context.total_disp)\n   modeS.txtbuf:paste(suggestion)\nend\n\n\n\n\n\n\nnew = function()\n   local suggest = meta(Suggest)\n   return suggest\nend\n\n\n\n\nSuggest.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/nerf",
hash = "7f6022fa57e9c35818b31769c2fbf8f9e7350b058b4b2a1d27acbbb84de0fe3a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta, \"must have meta in _G\")\n\n\n\nlocal a         = require \"anterm:anterm\"\nlocal Txtbuf    = require \"helm/txtbuf\"\nlocal Rainbuf   = require \"helm/rainbuf\"\nlocal Historian = require \"helm/historian\"\nlocal Lex       = require \"helm/lex\"\n\nlocal concat         = assert(table.concat)\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\n\n\n\n\n\n\nlocal clone    = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal Nerf = clone(EditBase, 2)\nNerf.name = \"nerf\"\nNerf.prompt_char = \"👉\"\n\n\n\n\n\n\nlocal function _insert(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS:setResults \"\"\n      if value == \"/\" then\n         modeS.shift_to = \"search\"\n         return\n      end\n      if value == \"?\" then\n         modeS:openHelp()\n         return\n      end\n   end\n   modeS.txtbuf:insert(value)\nend\n\nNerf.ASCII = _insert\nNerf.UTF8 = _insert\n\n\n\n\n\n\n\nlocal NAV = Nerf.NAV\n\nlocal function _prev(modeS)\n   -- Save what the user is currently typing...\n   local linestash = tostring(modeS.txtbuf)\n   -- ...but only if they\'re at the end of the history,\n   -- and obviously only if there\'s anything there\n   if linestash == \"\" or modeS.hist.cursor <= modeS.hist.n then\n      linestash = nil\n   end\n   local prev_line, prev_result = modeS.hist:prev()\n   if linestash then\n      modeS.hist:append(linestash)\n   end\n   modeS:setTxtbuf(Txtbuf(prev_line))\n   modeS:setResults(prev_result)\n   return modeS\nend\n\nfunction NAV.UP(modeS, category, value)\n   local inline = modeS.txtbuf:up()\n   if not inline then\n      _prev(modeS)\n   end\n   return modeS\nend\n\nlocal function _advance(modeS)\n   local new_line, next_result = modeS.hist:next()\n   if not new_line then\n      local added = modeS.hist:append(tostring(modeS.txtbuf))\n      if added then\n         modeS.hist.cursor = modeS.hist.n + 1\n      end\n   end\n   modeS:setTxtbuf(Txtbuf(new_line))\n   modeS:setResults(next_result)\n   return modeS\nend\n\nfunction NAV.DOWN(modeS, category, value)\n   local inline = modeS.txtbuf:down()\n   if not inline then\n      _advance(modeS)\n   end\n\n   return modeS\nend\n\n\n\nfunction NAV.RETURN(modeS, category, value)\n   if modeS.txtbuf:shouldEvaluate() then\n      modeS:eval()\n   else\n      modeS.txtbuf:nl()\n   end\nend\n\nfunction NAV.CTRL_RETURN(modeS, category, value)\n   modeS:eval()\nend\n\nfunction NAV.SHIFT_RETURN(modeS, category, value)\n   modeS.txtbuf:nl()\nend\n\n-- Add aliases for terminals not in CSI u mode\nNerf.CTRL[\"^\\\\\"] = NAV.CTRL_RETURN\nNAV.ALT_RETURN = NAV.SHIFT_RETURN\n\nlocal function _activateCompletion(modeS)\n   if modeS.suggest.active_suggestions then\n      modeS.shift_to = \"complete\"\n      return true\n   else\n      return false\n   end\nend\n\nfunction NAV.SHIFT_DOWN(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.zones.results:scrollDown()\n   end\nend\n\nfunction NAV.SHIFT_UP(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.zones.results:scrollUp()\n   end\nend\n\nfunction NAV.TAB(modeS, category, value)\n   if not _activateCompletion(modeS) then\n      modeS.txtbuf:paste(\"   \")\n   end\nend\n\nfunction NAV.SHIFT_TAB(modeS, category, value)\n   -- If we can\'t activate completion, nothing to do really\n   _activateCompletion(modeS)\nend\n\n\n\n\n\n\n\n\n\n\nlocal CTRL = Nerf.CTRL\n\nCTRL [\"^B\"] = NAV.LEFT\nCTRL [\"^F\"] = NAV.RIGHT\nCTRL [\"^N\"] = NAV.DOWN\nCTRL [\"^P\"] = NAV.UP\n\n\n\n\n\n\nfunction Nerf.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.zones.results:scrollUp()\n      elseif value.button == \"MB1\" then\n         modeS.zones.results:scrollDown()\n      end\n   end\nend\n\n\n\n\n\n\nlocal ALT = Nerf.ALT\n\n\n\n\n\n\nALT [\"M-e\"] = function(modeS, category, value)\n   modeS:evalFromCursor()\nend\n\n\n\n\n\n\n\n\nfunction Nerf.onCursorChanged(modeS)\n   modeS.suggest:update(modeS)\n   EditBase.onCursorChanged(modeS)\nend\n\nfunction Nerf.onTxtbufChanged(modeS)\n   modeS.suggest:update(modeS)\n   EditBase.onTxtbufChanged(modeS)\nend\n\n\n\nreturn Nerf\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/ljprof",
hash = "2509b5daa493cebc41e0901d21fad4103167aa35b4e4126c42c61f31acda097d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n----------------------------------------------------------------------------\n-- LuaJIT profiler.\n--\n-- Copyright (C) 2005-2017 Mike Pall. All rights reserved.\n-- Released under the MIT license. See Copyright Notice in luajit.h\n----------------------------------------------------------------------------\n--\n-- This module is a simple command line interface to the built-in\n-- low-overhead profiler of LuaJIT.\n--\n-- The lower-level API of the profiler is accessible via the \"jit.profile\"\n-- module or the luaJIT_profile_* C API.\n--\n-- Example usage:\n--\n--   luajit -jp myapp.lua\n--   luajit -jp=s myapp.lua\n--   luajit -jp=-s myapp.lua\n--   luajit -jp=vl myapp.lua\n--   luajit -jp=G,profile.txt myapp.lua\n--\n-- The following dump features are available:\n--\n--   f  Stack dump: function name, otherwise module:line. Default mode.\n--   F  Stack dump: ditto, but always prepend module.\n--   l  Stack dump: module:line.\n--   <number> stack dump depth (callee < caller). Default: 1.\n--   -<number> Inverse stack dump depth (caller > callee).\n--   s  Split stack dump after first stack level. Implies abs(depth) >= 2.\n--   p  Show full path for module names.\n--   v  Show VM states. Can be combined with stack dumps, e.g. vf or fv.\n--   z  Show zones. Can be combined with stack dumps, e.g. zf or fz.\n--   r  Show raw sample counts. Default: show percentages.\n--   a  Annotate excerpts from source code files.\n--   A  Annotate complete source code files.\n--   G  Produce raw output suitable for graphical tools (e.g. flame graphs).\n--   m<number> Minimum sample percentage to be shown. Default: 3.\n--   i<number> Sampling interval in milliseconds. Default: 10.\n--\n----------------------------------------------------------------------------\n\n-- Cache some library functions and objects.\nlocal jit = require(\"jit\")\nassert(jit.version_num == 20100, \"LuaJIT core/library version mismatch\")\nlocal profile = require(\"jit.profile\")\nlocal vmdef = assert(jit.vmdef)\nlocal math = math\nlocal pairs, ipairs, tonumber, floor = pairs, ipairs, tonumber, math.floor\nlocal sort, format = table.sort, string.format\nlocal stdout = io.stdout\nlocal zone -- Load jit.zone module on demand.\n\n-- Output file handle.\nlocal out\n\n------------------------------------------------------------------------------\n\nlocal prof_ud\nlocal prof_states, prof_split, prof_min, prof_raw, prof_fmt, prof_depth\nlocal prof_ann, prof_count1, prof_count2, prof_samples\n\nlocal map_vmmode = {\n  N = \"Compiled\",\n  I = \"Interpreted\",\n  C = \"C code\",\n  G = \"Garbage Collector\",\n  J = \"JIT Compiler\",\n}\n\n-- Profiler callback.\nlocal function prof_cb(th, samples, vmmode)\n  prof_samples = prof_samples + samples\n  local key_stack, key_stack2, key_state\n  -- Collect keys for sample.\n  if prof_states then\n    if prof_states == \"v\" then\n      key_state = map_vmmode[vmmode] or vmmode\n    else\n      key_state = zone:get() or \"(none)\"\n    end\n  end\n  if prof_fmt then\n    key_stack = profile.dumpstack(th, prof_fmt, prof_depth)\n    key_stack = key_stack:gsub(\"%[builtin#(%d+)%]\", function(x)\n      return vmdef.ffnames[tonumber(x)]\n    end)\n    if prof_split == 2 then\n      local k1, k2 = key_stack:match(\"(.-) [<>] (.*)\")\n      if k2 then key_stack, key_stack2 = k1, k2 end\n    elseif prof_split == 3 then\n      key_stack2 = profile.dumpstack(th, \"l\", 1)\n    end\n  end\n  -- Order keys.\n  local k1, k2\n  if prof_split == 1 then\n    if key_state then\n      k1 = key_state\n      if key_stack then k2 = key_stack end\n    end\n  elseif key_stack then\n    k1 = key_stack\n    if key_stack2 then k2 = key_stack2 elseif key_state then k2 = key_state end\n  end\n  -- Coalesce samples in one or two levels.\n  if k1 then\n    local t1 = prof_count1\n    t1[k1] = (t1[k1] or 0) + samples\n    if k2 then\n      local t2 = prof_count2\n      local t3 = t2[k1]\n      if not t3 then t3 = {}; t2[k1] = t3 end\n      t3[k2] = (t3[k2] or 0) + samples\n    end\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Show top N list.\nlocal function prof_top(count1, count2, samples, indent)\n  local t, n = {}, 0\n  for k in pairs(count1) do\n    n = n + 1\n    t[n] = k\n  end\n  sort(t, function(a, b) return count1[a] > count1[b] end)\n  for i=1,n do\n    local k = t[i]\n    local v = count1[k]\n    local pct = floor(v*100/samples + 0.5)\n    if pct < prof_min then break end\n    if not prof_raw then\n      out:write(format(\"%s%2d%%  %s\\n\", indent, pct, k))\n    elseif prof_raw == \"r\" then\n      out:write(format(\"%s%5d  %s\\n\", indent, v, k))\n    else\n      out:write(format(\"%s %d\\n\", k, v))\n    end\n    if count2 then\n      local r = count2[k]\n      if r then\n   prof_top(r, nil, v, (prof_split == 3 or prof_split == 1) and \"  -- \" or\n             (prof_depth < 0 and \"  -> \" or \"  <- \"))\n      end\n    end\n  end\nend\n\n-- Annotate source code\nlocal function prof_annotate(count1, samples)\n  local files = {}\n  local ms = 0\n  for k, v in pairs(count1) do\n    local pct = floor(v*100/samples + 0.5)\n    ms = math.max(ms, v)\n    if pct >= prof_min then\n      local file, line = k:match(\"^(.*):(%d+)$\")\n      if not file then file = k; line = 0 end\n      local fl = files[file]\n      if not fl then fl = {}; files[file] = fl; files[#files+1] = file end\n      line = tonumber(line)\n      fl[line] = prof_raw and v or pct\n    end\n  end\n  sort(files)\n  local fmtv, fmtn = \" %3d%% | %s\\n\", \"      | %s\\n\"\n  if prof_raw then\n    local n = math.max(5, math.ceil(math.log10(ms)))\n    fmtv = \"%\"..n..\"d | %s\\n\"\n    fmtn = (\" \"):rep(n)..\" | %s\\n\"\n  end\n  local ann = prof_ann\n  for _, file in ipairs(files) do\n    local f0 = file:byte()\n    if f0 == 40 or f0 == 91 then\n      out:write(format(\"\\n====== %s ======\\n[Cannot annotate non-file]\\n\", file))\n      break\n    end\n    local fp, err = io.open(file)\n    if not fp then\n      out:write(format(\"====== ERROR: %s: %s\\n\", file, err))\n      break\n    end\n    out:write(format(\"\\n====== %s ======\\n\", file))\n    local fl = files[file]\n    local n, show = 1, false\n    if ann ~= 0 then\n      for i=1,ann do\n   if fl[i] then show = true; out:write(\"@@ 1 @@\\n\"); break end\n      end\n    end\n    for line in fp:lines() do\n      if line:byte() == 27 then\n   out:write(\"[Cannot annotate bytecode file]\\n\")\n   break\n      end\n      local v = fl[n]\n      if ann ~= 0 then\n   local v2 = fl[n+ann]\n   if show then\n     if v2 then show = n+ann elseif v then show = n\n     elseif show+ann < n then show = false end\n   elseif v2 then\n     show = n+ann\n     out:write(format(\"@@ %d @@\\n\", n))\n   end\n   if not show then goto next end\n      end\n      if v then\n   out:write(format(fmtv, v, line))\n      else\n   out:write(format(fmtn, line))\n      end\n    ::next::\n      n = n + 1\n    end\n    fp:close()\n  end\nend\n\n------------------------------------------------------------------------------\n\n-- Finish profiling and dump result.\nlocal function prof_finish()\n  if prof_ud then\n    profile.stop()\n    local samples = prof_samples\n    if samples == 0 then\n      if prof_raw ~= true then out:write(\"[No samples collected]\\n\") end\n      return\n    end\n    if prof_ann then\n      prof_annotate(prof_count1, samples)\n    else\n      prof_top(prof_count1, prof_count2, samples, \"\")\n    end\n    prof_count1 = nil\n    prof_count2 = nil\n    prof_ud = nil\n  end\nend\n\n-- Start profiling.\nlocal function prof_start(mode)\n  local interval = \"\"\n  mode = mode:gsub(\"i%d*\", function(s) interval = s; return \"\" end)\n  prof_min = 3\n  mode = mode:gsub(\"m(%d+)\", function(s) prof_min = tonumber(s); return \"\" end)\n  prof_depth = 1\n  mode = mode:gsub(\"%-?%d+\", function(s) prof_depth = tonumber(s); return \"\" end)\n  local m = {}\n  for c in mode:gmatch(\".\") do m[c] = c end\n  prof_states = m.z or m.v\n  if prof_states == \"z\" then zone = require(\"jit.zone\") end\n  local scope = m.l or m.f or m.F or (prof_states and \"\" or \"f\")\n  local flags = (m.p or \"\")\n  prof_raw = m.r\n  if m.s then\n    prof_split = 2\n    if prof_depth == -1 or m[\"-\"] then prof_depth = -2\n    elseif prof_depth == 1 then prof_depth = 2 end\n  elseif mode:find(\"[fF].*l\") then\n    scope = \"l\"\n    prof_split = 3\n  else\n    prof_split = (scope == \"\" or mode:find(\"[zv].*[lfF]\")) and 1 or 0\n  end\n  prof_ann = m.A and 0 or (m.a and 3)\n  if prof_ann then\n    scope = \"l\"\n    prof_fmt = \"pl\"\n    prof_split = 0\n    prof_depth = 1\n  elseif m.G and scope ~= \"\" then\n    prof_fmt = flags..scope..\"Z;\"\n    prof_depth = -100\n    prof_raw = true\n    prof_min = 0\n  elseif scope == \"\" then\n    prof_fmt = false\n  else\n    local sc = prof_split == 3 and m.f or m.F or scope\n    prof_fmt = flags..sc..(prof_depth >= 0 and \"Z < \" or \"Z > \")\n  end\n  prof_count1 = {}\n  prof_count2 = {}\n  prof_samples = 0\n  profile.start(scope:lower()..interval, prof_cb)\n  prof_ud = newproxy(true)\n  getmetatable(prof_ud).__gc = prof_finish\nend\n\n------------------------------------------------------------------------------\n\nlocal function start(mode, outfile)\n  if not outfile then outfile = os.getenv(\"LUAJIT_PROFILEFILE\") end\n  if outfile then\n    out = outfile == \"-\" and stdout or assert(io.open(outfile, \"w\"))\n  else\n    out = stdout\n  end\n  prof_start(mode or \"f\")\nend\n\n-- Public module functions.\nreturn {\n  start = start, -- For -j command line option.\n  stop = prof_finish\n}\n\n\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/rainbuf",
hash = "fc1271dd524d428126d5b21a26cb3aeef581b75531a240c85db8db815f6d41b7",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal lineGen = import(\"repr:repr\", \"lineGen\")\n\n\n\n\n\n\nlocal Rainbuf = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\nfunction Rainbuf.clearCaches(rainbuf)\n   clear(rainbuf.lines)\nend\n\n\n\n\n\n\n\n\nlocal lines = import(\"core/string\", \"lines\")\nfunction Rainbuf.initComposition(rainbuf, cols)\n   cols = cols or 80\n   if rainbuf.scrollable then\n      cols = cols - 3\n   end\n   -- If width is changing, we need a re-render\n   -- \"live\" means re-render every time\n   if cols ~= rainbuf.cols or rainbuf.live then\n      rainbuf:clearCaches()\n   end\n   rainbuf.cols = cols\n   rainbuf.more = true\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nfunction Rainbuf.composeOneLine(rainbuf)\n   local line = rainbuf:_composeOneLine()\n   if line then\n      insert(rainbuf.lines, line)\n      return true\n   else\n      rainbuf.more = false\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.composeUpTo(rainbuf, line_number)\n   while rainbuf.more and #rainbuf.lines <= line_number do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\nfunction Rainbuf.composeAll(rainbuf)\n   while rainbuf.more do\n      rainbuf:composeOneLine()\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.lineGen(rainbuf, rows, cols)\n   rainbuf:initComposition(cols)\n   -- state for iterator\n   local cursor = rainbuf.offset\n   local max_row = rainbuf.offset + rows\n   local function _nextLine()\n      -- Off the end\n      if cursor >= max_row then\n         return nil\n      end\n      cursor = cursor + 1\n      rainbuf:composeUpTo(cursor)\n      local prefix = \"\"\n      if rainbuf.scrollable then\n         -- If this is the last line requested, but more are available,\n         -- prepend a continuation marker, otherwise left padding\n         prefix = \"   \"\n         if cursor == max_row and rainbuf.more then\n            prefix = a.red \"...\"\n         end\n      end\n      return rainbuf.lines[cursor] and prefix .. rainbuf.lines[cursor]\n   end\n   return _nextLine\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Rainbuf.replace(rainbuf)\n   rainbuf:clearCaches()\nend\n\n\n\n\n\n\n\n\n\nfunction Rainbuf._init(rainbuf)\n   rainbuf.n = 0\n   rainbuf.offset = 0\n   rainbuf.lines = {}\nend\n\n\n\n\n\n\nfunction Rainbuf.__call(buf_class, res, cfg)\n   if type(res) == \"table\" then\n      if res.idEst == buf_class then\n         return res\n      elseif res.is_rainbuf then\n         error(\"Trying to make a Rainbuf from another type of Rainbuf\")\n      end\n   end\n   local buf_M = getmetatable(buf_class)\n   local rainbuf = setmetatable({}, buf_M)\n   rainbuf:_init()\n   rainbuf:replace(res)\n   if cfg then\n      for k, v in pairs(cfg) do\n         rainbuf[k] = v\n      end\n   end\n   return rainbuf\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\nfunction Rainbuf.inherit(buf_class, cfg)\n   local parent_M = getmetatable(buf_class)\n   local child_M = setmetatable({}, parent_M)\n   -- Copy metamethods because mmethod lookup does not respect =__index=es\n   for k,v in pairs(parent_M) do\n      if sub(k, 1, 2) == \"__\" then\n         child_M[k] = v\n      end\n   end\n   -- But, the new MT should have itself as __index, not the parent\n   child_M.__index = child_M\n   if cfg then\n      -- this can override the above metamethod assignment\n      for k,v in pairs(cfg) do\n         child_M[k] = v\n      end\n   end\n   return child_M\nend\n\n\n\n\n\n\n\n\nRainbuf.super = assert(require \"core:cluster\" . super)\n\n\n\n\n\n\n\n\n\nRainbuf.is_rainbuf = true\n\n\n\n\nlocal Rainbuf_class = setmetatable({}, Rainbuf)\nRainbuf.idEst = Rainbuf_class\n\nreturn Rainbuf_class\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/selection_list",
hash = "2b13c8a75c7380c7bf9ecdbeaa84409fa89433699a65fe7005ea8e75da185ef5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\nlocal clamp = assert(require \"core:math\" . clamp)\nfunction SelectionList.selectIndex(list, index)\n   index = clamp(index, 1, #list)\n   if index ~= list.selected_index then\n      list.selected_index = index\n      return true\n   else\n      return false\n   end\nend\n\nfunction SelectionList.selectFirst(list)\n   return list:selectIndex(1)\nend\n\nfunction SelectionList.selectNext(list)\n   return list:selectIndex(list.selected_index + 1)\nend\n\nfunction SelectionList.selectPrevious(list)\n   return list:selectIndex(list.selected_index - 1)\nend\n\n\n\n\n\n\n\n\n\nfunction SelectionList.selectNextWrap(list)\n   local new_idx = list.selected_index < #list\n      and list.selected_index + 1\n      or 1\n   return list:selectIndex(new_idx)\nend\n\nfunction SelectionList.selectPreviousWrap(list)\n   local new_idx = list.selected_index > 1\n      and list.selected_index - 1\n      or #list\n   return list:selectIndex(new_idx)\nend\n\n\n\n\n\n\n\nfunction SelectionList.selectedItem(list)\n   return list[list.selected_index]\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal concat = assert(table.concat)\n\nfunction SelectionList.highlight(list, line, max_disp, c)\n   local frag_index = 1\n   -- Collapse multiple spaces into one for display\n   line = line:gsub(\" +\",\" \")\n   local codes = Codepoints(line)\n   local disp = 0\n   local stop_at\n   for i, char in ipairs(codes) do\n      local char_disp = 1\n      if char == \"\\n\" then\n         char = c.stresc .. \"\\\\n\" .. c.base\n         codes[i] = char\n         char_disp =  2\n      end\n      -- Reserve one space for ellipsis unless this is the\n      -- last character on the line\n      local reserved_space = i < #codes and 1 or 0\n      if disp + char_disp + reserved_space > max_disp then\n         char = c.alert(\"…\")\n         codes[i] = char\n         disp = disp + 1\n         stop_at = i\n         break\n      end\n      disp = disp + char_disp\n      if frag_index <= #list.frag and char == list.frag:sub(frag_index, frag_index) then\n         local char_color\n         -- highlight the last two differently if this is a\n         -- \'second best\' search\n         if not list.best and #list.frag - frag_index < 2 then\n            char_color = c.alert\n         else\n            char_color = c.search_hl\n         end\n         char = char_color .. char .. c.base\n         codes[i] = char\n         frag_index = frag_index + 1\n      end\n   end\n   return c.base(concat(codes, \"\", 1, stop_at)), disp\nend\n\nfunction SelectionList.__repr(list, window, c)\n   assert(c, \"must provide a color table\")\n   if #list == 0 then\n      return c.alert \"No results found\"\n   end\n   local i = 1\n   return function()\n      local line = list[i]\n      local len\n      if line == nil then return nil end\n      line, len = list:highlight(line, window.remains - 4, c)\n      if list.show_shortcuts then\n         local alt_seq = \"    \"\n         if i < 10 then\n            alt_seq = c.bold(\"M-\" .. tostring(i) .. \" \")\n         end\n         line = alt_seq .. line\n         len = len + 4\n      end\n      if i == list.selected_index then\n         line = c.highlight(line)\n      end\n      i = i + 1\n      return line, len\n   end\nend\n\n\n\n\n\n\nnew = function()\n   local list = meta(SelectionList)\n   list.selected_index = 0\n   -- list.n = 0\n   return list\nend\n\n\n\nSelectionList.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/sessionbuf",
hash = "a0a4267c605ce588f480f0c1786c249a30b1308b8ce59e85df29badcbf70c89a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Rainbuf = require \"helm:rainbuf\"\nlocal Resbuf  = require \"helm:resbuf\"\nlocal Txtbuf  = require \"helm:txtbuf\"\n\nlocal Sessionbuf = Rainbuf:inherit()\n\n\n\n\n\n\n-- The (maximum) number of rows we will use for the \"line\" (command)\n-- (in case it is many lines long)\nSessionbuf.ROWS_PER_LINE = 4\n-- The (maximum) number of rows we will use for the result of the selected line\nSessionbuf.ROWS_PER_RESULT = 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clamp = assert(require \"core:math\" . clamp)\nfunction Sessionbuf.selectIndex(buf, index)\n   index = #buf.session == 0\n      and 0\n      or clamp(index, 1, #buf.session)\n   if index ~= buf.selected_index then\n      buf.selected_index = index\n      local premise = buf:selectedPremise()\n      local result\n      if premise then\n         -- #todo re-evaluate sessions on -s startup, and display an\n         -- indication of whether there are changes (and eventually a diff)\n         -- rather than just the newest available result\n         result = premise.new_result or premise.old_result\n      end\n      buf.resbuf:replace(result)\n      buf.resbuf.offset = 0\n      return true\n   end\n   return false\nend\n\n\n\n\n\n\n\n\n\nfunction Sessionbuf.selectNextWrap(buf)\n   local new_idx = buf.selected_index < #buf.session\n      and buf.selected_index + 1\n      or 1\n   return buf:selectIndex(new_idx)\nend\nfunction Sessionbuf.selectPreviousWrap(buf)\n   local new_idx = buf.selected_index > 1\n      and buf.selected_index - 1\n      or #buf.session\n   return buf:selectIndex(new_idx)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Sessionbuf.rowsForSelectedResult(buf)\n   buf.resbuf:initComposition(buf.cols - 3)\n   buf.resbuf:composeUpTo(buf.ROWS_PER_RESULT)\n   return clamp(#buf.resbuf.lines, 0, buf.ROWS_PER_RESULT)\nend\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\nfunction Sessionbuf.positionOf(buf, index)\n   local position = 1\n   for i = 1, index - 1 do\n      local num_lines = select(2, gsub(buf.session[i].line, \'\\n\', \'\\n\')) + 1\n      num_lines = clamp(num_lines, 1, buf.ROWS_PER_LINE)\n      position = position + num_lines + 1\n      if i == buf.selected_index then\n         position = position + buf:rowsForSelectedResult() + 1\n      end\n   end\n   return position\nend\n\nfunction Sessionbuf.positionOfSelected(buf)\n   return buf:positionOf(buf.selected_index)\nend\n\n\n\n\n\n\n\n\nfunction Sessionbuf.scrollResultsDown(buf)\n   -- #todo this should all be handled internally by Rainbuf--\n   -- we should just be calling buf.resbuf:scrollDown()\n   local offset = buf.resbuf.offset + 1\n   buf.resbuf:composeUpTo(offset + buf.ROWS_PER_RESULT)\n   local max_offset = clamp(#buf.resbuf.lines - buf.ROWS_PER_RESULT, 0)\n   offset = clamp(offset, 0, max_offset)\n   if offset ~= buf.resbuf.offset then\n      buf.resbuf.offset = offset\n      return true\n   end\n   return false\nend\n\nfunction Sessionbuf.scrollResultsUp(buf)\n   if buf.resbuf.offset > 0 then\n      buf.resbuf.offset = buf.resbuf.offset - 1\n      return true\n   end\n   return false\nend\n\n\n\n\n\n\nfunction Sessionbuf.selectedPremise(buf)\n   return buf.session[buf.selected_index]\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal status_cycle_map = {\n   ignore = \"accept\",\n   accept = \"reject\",\n   reject = \"skip\",\n   skip   = \"ignore\"\n}\n\nfunction Sessionbuf.toggleSelectedState(buf)\n   local premise = buf:selectedPremise()\n   premise.status = status_cycle_map[premise.status]\n   return true\nend\n\nlocal inverse = assert(require \"core:table\" . inverse)\nlocal status_reverse_map = inverse(status_cycle_map)\n\nfunction Sessionbuf.reverseToggleSelectedState(buf)\n   local premise = buf:selectedPremise()\n   premise.status = status_reverse_map[premise.status]\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _swapPremises(buf, index_a, index_b)\n   local premise_a = buf.session[index_a]\n   local premise_b = buf.session[index_b]\n   buf.session[index_a] = premise_b\n   buf.txtbufs[index_a]:replace(premise_b.line)\n   premise_b.ordinal = index_a\n   buf.session[index_b] = premise_a\n   buf.txtbufs[index_b]:replace(premise_a.line)\n   premise_a.ordinal = index_b\n   buf:clearCaches()\nend\n\nfunction Sessionbuf.movePremiseUp(buf)\n   if buf.selected_index == 1 then\n      return false\n   end\n   _swapPremises(buf, buf.selected_index, buf.selected_index - 1)\n   -- Maintain selection of the same premise after the move\n   -- Will never wrap because we disallowed moving the first premise up\n   buf:selectPreviousWrap()\n   return true\nend\n\nfunction Sessionbuf.movePremiseDown(buf)\n   if buf.selected_index == #buf.session then\n      return false\n   end\n   _swapPremises(buf, buf.selected_index, buf.selected_index + 1)\n   buf:selectNextWrap()\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sessionbuf.clearCaches(buf)\n   buf:super\"clearCaches\"()\n   buf._composeOneLine = nil\nend\n\n\n\n\n\n\nlocal wrap = assert(coroutine.wrap)\nfunction Sessionbuf.initComposition(buf, cols)\n   buf:super\"initComposition\"(cols)\n   buf._composeOneLine = wrap(function() buf:_composeAll() end)\nend\n\n\n\n\n\n\n\n\n\n\nlocal status_icons = {\n   ignore = \"🟡\",\n   accept = \"✅\",\n   reject = \"🚫\",\n   skip   = \"🗑 \"\n}\n\nlocal box_light = assert(require \"anterm:box\" . light)\nlocal yield = assert(coroutine.yield)\nlocal c = assert(require \"singletons:color\" . color)\nfunction Sessionbuf._composeAll(buf)\n   local inner_cols = buf.cols - 2 -- For the box borders\n   for i, premise in ipairs(buf.session) do\n      yield(i == 1\n         and box_light:topLine(inner_cols)\n         or box_light:spanningLine(inner_cols))\n      -- Render the line (which could actually be multiple physical lines)\n      -- Leave 4 columns on the left for the status icon,\n      -- and one on the right for padding\n      local line_prefix = box_light:contentLine(inner_cols) ..\n         status_icons[premise.status] .. \' \'\n      for line in buf.txtbufs[i]:lineGen(buf.ROWS_PER_LINE, inner_cols - 5) do\n         -- Selected premise gets a highlight\n         if i == buf.selected_index then\n            line = c.highlight(line)\n         end\n         yield(line_prefix .. line)\n         line_prefix = box_light:contentLine(inner_cols) .. \'   \'\n      end\n      -- Selected premise also displays results\n      if i == buf.selected_index then\n         yield(box_light:spanningLine(inner_cols))\n         -- Account for left and right padding inside the box\n         for line in buf.resbuf:lineGen(buf.ROWS_PER_RESULT, inner_cols - 2) do\n            yield(box_light:contentLine(inner_cols) .. line)\n         end\n      end\n   end\n   if #buf.session == 0 then\n      yield(box_light:topLine(inner_cols))\n      yield(box_light:contentLine(inner_cols) .. \"No premises to display\")\n   end\n   yield(box_light:bottomLine(inner_cols))\n   buf._composeOneLine = nil\nend\n\n\n\n\n\n\n\n\nfunction Sessionbuf._init(buf)\n   buf:super\"_init\"()\n   buf.live = true\n   buf.resbuf = Resbuf({ n = 0 }, { scrollable = true })\n   buf.txtbufs = {}\nend\n\n\n\n\n\n\nlocal lua_thor = assert(require \"helm:lex\" . lua_thor)\nfunction Sessionbuf.replace(buf, session)\n   buf:super\"replace\"(session)\n   buf.session = session\n   for i, premise in ipairs(session) do\n      if buf.txtbufs[i] then\n         buf.txtbufs[i]:replace(premise.line)\n      else\n         buf.txtbufs[i] = Txtbuf(premise.line, { lex = lua_thor })\n      end\n   end\n   for i = #session + 1, #buf.txtbufs do\n      buf.txtbufs[i] = nil\n   end\n   buf:selectIndex(1)\nend\n\n\n\nlocal Sessionbuf_class = setmetatable({}, Sessionbuf)\nSessionbuf.idEst = Sessionbuf_class\n\nreturn Sessionbuf_class\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm",
hash = "e08bb85b5c607e3272724433bd7e3a633cddd29798ffa057a38d23fdf326e2de",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n--[[\nprofile = require(\"jit.profile\")\nprofiled = {}\nprofile.start(\"li1\", function(th, samples, vmmode)\n   local d = profile.dumpstack(th, \"pF\", 1)\n   profiled[d] = (profiled[d] or 0) + samples\nend)\n--]]\n\n\n\nassert(true)\nif rawget(_G, \"_Bridge\") then\n   _Bridge.helm = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __G = setmetatable({}, {__index = _G})\n__G.__G = __G\n\n\n\n\n\n\n\n\n\nlocal function _helm(_ENV)\n\n\n\n\n\nsetfenv(0, __G)\n\nimport = assert(require \"core/module\" . import)\nmeta = import(\"core/meta\", \"meta\")\ncore = require \"core:core\"\nkit = require \"valiant:replkit\"\njit.vmdef = require \"helm:helm/vmdef\"\njit.p = require \"helm:helm/ljprof\"\nsql = assert(sql, \"sql must be in _G\")\n\n\n\n\n\n\n\nuv = require \"luv\"\nlocal usecolors\nstdout = \"\"\n\n\n\n\n\n\n\n\n\n\nif uv.guess_handle(1) == \'tty\' then\n   stdout = uv.new_tty(1, false)\n   usecolors = true\nelse\n   stdout = uv.new_pipe(false)\n   uv.pipe_open(utils.stdout, 1)\n   usecolors = false\nend\n\n\n\n\n\nlocal function write(...)\n   uv.write(stdout, {...})\nend\n\n\n\nlocal concat = assert(table.concat)\n\nfunction print(...)\n   local n = select(\'#\', ...)\n   local arguments = {...}\n   for i = 1, n do\n      arguments[i] = tostring(arguments[i])\n   end\n   uv.write(stdout, concat(arguments, \"\\t\") .. \"\\n\")\nend\n\n\n\n\n\n\nif uv.guess_handle(0) ~= \'tty\' or\n   uv.guess_handle(1) ~= \'tty\' then\n   -- Bail if we\'re in a pipe\n   error \"stdio must be a tty\"\nend\n\nlocal stdin = uv.new_tty(0, true)\n\n\n\n\n\na = require \"anterm:anterm\"\nlocal Point = require \"anterm:point\"\n--watch = require \"watcher\"\n\n\n\n\n\n\n\n-- Get window size and set up an idler to keep it refreshed\n\nlocal MOUSE_MAX = 223\n\nlocal function bind_pane(dim1, dim2)\n   dim1 = dim1 > MOUSE_MAX and MOUSE_MAX or dim1\n   dim2 = dim2 > MOUSE_MAX and MOUSE_MAX or dim2\n   return dim1, dim2\nend\n\nlocal max_col, max_row = bind_pane(uv.tty_get_winsize(stdin))\nlocal max_extent = Point(max_row, max_col)\n\n\n\nmodeS = require \"helm/modeselektor\" (max_extent, write)\nlocal insert = assert(table.insert)\nlocal function s_out(msg)\n   insert(modeS.status, msg)\nend\n\n-- make a new \'status\' instance\nlocal s = require \"status:status\" (s_out)\n\nlocal bounds_watch = uv.new_timer()\nuv.timer_start(bounds_watch, 500, 500, function()\n   max_col, max_row = uv.tty_get_winsize(stdin)\n   if Point(max_row, max_col) ~= modeS.max_extent then\n      modeS.max_extent = Point(bind_pane(max_row, max_col))\n      -- Mark all zones as touched since we don\'t know the state of the screen\n      -- (some terminals, iTerm for sure, will attempt to reflow the screen\n      -- themselves and fail miserably)\n      for _, zone in ipairs(modeS.zones) do\n         zone.touched = true\n      end\n      modeS:reflow()\n   end\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal restart_watch, lume = nil, nil\n\nif _Bridge.args.listen then\n   uv.new_timer():start(0, 0, function()\n      local orb = require \"orb:orb\"\n      lume = orb.lume(uv.cwd())\n      lume :run() :serve(true)\n      restart_watch = uv.new_timer()\n      uv.timer_start(restart_watch, 500, 500, function()\n         if lume.has_file_change then\n            modeS:restart()\n            lume.has_file_change = nil\n         end\n      end)\n   end)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal byte, sub, char = assert(string.byte),\n                        assert(string.sub),\n                        assert(string.char)\nlocal m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove\nlocal navigation = a.navigation\n\nlocal function process_escapes(seq)\n   if is_mouse(seq) then\n      return modeS(\"MOUSE\", m_parse(seq))\n   elseif #seq == 2 and byte(seq, 2) < 128 then\n      -- Meta\n      local key = \"M-\" .. sub(seq,2,2)\n      return modeS(\"ALT\", key)\n   elseif a.is_paste(seq) then\n      return modeS(\"PASTE\", a.parse_paste(seq))\n   else\n      return modeS(\"NYI\", seq)\n   end\nend\n\n-- uv, being an event loop, will sometimes keep reading after\n-- we expect it to stop.\n-- this prevents modeS from being reloaded in such circumstances.\n--\n-- maybe.\n\nlocal _ditch = false\n\nlocal function onseq(err,seq)\n   if _ditch then return nil end\n   if err then error(err) end\n\n   local head = byte(seq)\n   -- Special \"navigation\" sequences--this includes some escape sequences\n   if navigation[seq] then\n      modeS(\"NAV\", navigation[seq])\n   -- Other escape sequences\n   elseif head == 27 then\n      process_escapes(seq)\n   -- Control sequences\n   elseif head <= 31 then\n      local ctrl = \"^\" .. char(head + 64)\n      modeS(\"CTRL\", ctrl)\n   -- Printables--break into codepoints in case of multi-char input sequence\n   -- But first, optimize common case of single ascii printable\n   -- Note that bytes <= 31 and 127 (DEL) will have been taken care of earlier\n   elseif #seq == 1 and head < 128 then\n      modeS(\"ASCII\", seq)\n   else\n      local points = Codepoints(seq)\n      for i, pt in ipairs(points) do\n         -- #todo handle decode errors here--right now we\'ll just insert an\n         -- actual Unicode \"replacement character\"\n         modeS(byte(pt) < 128 and \"ASCII\" or \"UTF8\", pt)\n      end\n   end\n   -- Okay, if the action resulted in a quit, break out of the event loop\n   if modeS.has_quit then\n      _ditch = true\n      uv.read_stop(stdin)\n      uv.timer_stop(bounds_watch)\n      if restart_watch then\n         uv.timer_stop(restart_watch)\n         lume.server:stop()\n      end\n   end\nend\n\n\n\n\n\n-- Get names for as many values as possible\n-- into the colorizer\n-- Treat package names as existing in the global namespace\n-- rather than having a \"package.loaded.\" prefix\nlocal names = require \"repr:repr/names\"\nnames.loadNames(package.loaded)\nnames.loadNames(_G)\nnames.loadNames(__G)\n\n-- assuming we survived that, set up our repling environment:\n\n-- raw mode\nuv.tty_set_mode(stdin, 2)\n\n-- Enable mouse tracking, save the cursor, switch screens and wipe,\n-- then put the cursor at 1,1.\n-- #todo Cursor save/restore supposedly may not work on all terminals?\n-- Test this and, if necessary, explicitly read and store the cursor position\n-- and manually restore it at the end.\nwrite(a.cursor.stash(),\n      a.alternate_screen(true),\n      a.erase.all(),\n      a.jump(1, 1),\n      a.paste_bracketing(true),\n      a.mouse.track(true)\n)\nuv.read_start(stdin, onseq)\n\n-- initial layout and paint screen\nmodeS:reflow()\n\n-- main loop\nlocal retcode =  uv.run(\'default\')\n\n-- Shut down the database conn:\nlocal helm_db = require \"helm:helm/helm-db\"\nhelm_db.close()\n\nretcode = uv.run \'default\'\n\n-- Teardown: Mouse tracking off, restore main screen and cursor\nwrite(a.mouse.track(false),\n      a.paste_bracketing(false),\n      a.alternate_screen(false),\n      a.cursor.pop(),\n      a.cursor.show())\n\n-- Back to normal mode and finish tearing down uv\nuv.tty_reset_mode()\nuv.stop()\n\n-- Make sure the terminal processes all of the above,\n-- then remove any spurious mouse inputs or other stdin stuff\nio.stdout:flush()\nio.stdin:read \"*a\"\n\n-- Restore the global environment\nsetfenv(0, _G)\nend -- of _helm\n\n\n\n\n\nreturn setfenv(_helm, __G)\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/page",
hash = "32354de5b378e3929e0633fdf210a2f8714d37fb52517fc6dffe3000e2878f14",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal RagaBase = require \"helm:helm/raga/base\"\n\n\n\nlocal Page = clone(RagaBase, 2)\n\nPage.name = \"page\"\nPage.prompt_char = \"❓\"\n\nlocal alias = require \"helm/raga/aliaser\" (Page)\n\n\n\n\n\n\n\n\nlocal function toZone(fn)\n   return function(modeS, category, value)\n      return modeS.zones.popup[fn](modeS.zones.popup)\n   end\nend\n\n\n\n\n\nalias{ toZone \"scrollDown\",\n       NAV   = {\"DOWN\", \"SHIFT_DOWN\", \"RETURN\"},\n       ASCII = {\"e\", \"j\"},\n       CTRL  = {\"^N\", \"^E\", \"^J\"} }\n\nalias{ toZone \"scrollUp\",\n       NAV   = {\"UP\", \"SHIFT_UP\", \"SHIFT_RETURN\"},\n       ASCII = {\"y\", \"k\"},\n       CTRL  = {\"^Y\", \"^P\", \"^K\"} }\n\nalias{ toZone \"pageDown\",\n       NAV   = {\"PAGE_DOWN\"},\n       ASCII = {\" \", \"f\"},\n       CTRL  = {\"^V\", \"^F\"} }\nalias{ toZone \"pageUp\",\n       NAV   = {\"PAGE_UP\"},\n       ASCII = {\"b\"},\n       CTRL  = {\"^B\"} }\n\nalias{ toZone \"halfPageDown\",\n       ASCII = {\"d\"},\n       CTRL  = {\"^D\"} }\nalias{ toZone \"halfPageUp\",\n       ASCII = {\"u\"},\n       CTRL  = {\"^U\"} }\n\nalias{ toZone \"scrollToTop\",\n       NAV   = {\"HOME\"},\n       ASCII = {\"g\", \"<\"} }\nalias{ toZone \"scrollToBottom\",\n       NAV   = {\"END\"},\n       ASCII = {\"G\", \">\"} }\n\n\n\n\nlocal function _quit(modeS)\n   -- #todo should have a stack of ragas and switch back to the one\n   -- we entered from, but this will do for now\n   modeS.shift_to = \"nerf\"\nend\n\nalias{_quit, NAV = {\"ESC\"}, ASCII = {\"q\"} }\n\n\n\n\n\nfunction Page.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.zones.popup:scrollUp()\n      elseif value.button == \"MB1\" then\n         modeS.zones.popup:scrollDown()\n      end\n   end\nend\n\n\n\n\n\n\n\n\nfunction Page.onShift(modeS)\n   modeS.zones.popup:show()\nend\nfunction Page.onUnshift(modeS)\n   modeS.zones.popup:hide()\nend\n\n\n\nreturn Page\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/lua-parser",
hash = "73613e524bd891cb366ae3b3c4469ecc3daab3e98c2368045ce9fc634896004d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\n\n\n\n\nlocal lua_str = [[\nlua = shebang* _ chunk _ Error*\nshebang = \"#\" (!\"\\n\" 1)* \"\\n\"\nchunk = _ (statement _ \";\"?)* (_ laststatement _ \";\"?)?\n\nError = 1+\n\nstatement = \"do\" t chunk \"end\" t\n          / \"while\" t expr \"do\" t chunk \"end\" t\n          / \"repeat\" t chunk \"until\" t expr\n          / \"if\" t expr \"then\" t chunk\n            (\"elseif\" t expr \"then\" t chunk)*\n            (\"else\" t chunk)* \"end\" t\n          / \"for\" t _ symbol _ \"=\" expr _ \",\" _ expr _ (\",\" _ expr)?\n            _ \"do\" t chunk \"end\" t\n          / \"for\" t _ symbollist _ \"in\" t expr \"do\" t chunk \"end\" t\n          / \"function\" t _ funcname _ funcbody\n          / \"local\" t _ \"function\" t _ symbol _ funcbody\n          / \"local\" t _ symbollist _ (\"=\" _ explist)?\n          / varlist _ \"=\" _ explist\n          / \"goto\" t _ symbol\n          / \"::\" symbol \"::\"\n          / functioncall\n\nlaststatement = \"return\" t _ (explist)?\n              / \"break\" t\n\nfuncname = symbol _ (\".\" _ symbol)* (\":\" _ symbol)?\nvarlist  = var (_ \",\" _ var)*\n\n`expr`  = _ unop _ expr _\n      / _ value _ (binop _ expr)* _\nunop  = \"-\" / \"#\" / \"not\"\nbinop = \"and\" / \"or\" / \"..\" / \"<=\" / \">=\" / \"~=\" / \"==\"\n      / \"+\" / \"-\" / \"/\" / \"*\" / \"^\" / \"%\" / \"<\" / \">\"\n\n`value` = Nil / bool / vararg / number / string\n       / tableconstructor / Function\n       / functioncall / var\n       / \"(\" _ expr _ \")\"\nNil   = \"nil\" t\nbool  = \"true\" t / \"false\" t\nvararg = \"...\"\nfunctioncall = prefix (_ suffix &(_ suffix))* _ call\ntableconstructor = \"{\" _ fieldlist* _ \"}\"\nFunction = \"function\" t _ funcbody\n\nvar = prefix (_ suffix &(_ suffix))* index\n    / symbol\n\n\n`fieldlist` = field (_ (\",\" / \";\") _ field)*\nfield = key _ \"=\" _ val\n      / expr\nkey = \"[\" expr \"]\" / symbol\nval = expr\n\n`prefix`  = \"(\" expr \")\" / symbol\nindex   = \"[\" expr \"]\" / \".\" _ symbol\n`suffix`  = call / index\n`call`    = args / method\nmethod    = \":\" _ symbol _ args\n\nargs = \"(\" _ (explist _)? \")\"\n     / string\n     / tableconstructor\n`explist` = expr (\",\" expr)*\n\n`funcbody` = parameters _ chunk _ \"end\" t\nparameters = \"(\" _ (symbollist (_ \",\" _ vararg)*)* \")\"\n          / \"(\" _ vararg _ \")\"\n`symbollist` = (symbol (\",\" _ symbol)*)\n\n\nstring = singlestring / doublestring / longstring\n`singlestring` = \"\'\" (\"\\\\\" \"\'\" / (!\"\'\" !\"\\n\" 1))* \"\'\"\n`doublestring` = \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n`longstring`   = ls_open (!ls_close 1)* ls_close\n\n`ls_open` = \"[\" \"=\"*@eq \"[\"\n`ls_close` = \"]\" \"=\"*@(eq) \"]\"\n\nsymbol = reprsymbol\n       / !keyword ([A-Z] / [a-z] / \"_\") ([A-Z] / [a-z] / [0-9] /\"_\" )*\n\nreprsymbol = \"$\" ([1-9] [0-9]*)* (\".\" ([a-z]/[A-Z]))*\n\nnumber = real / hex / integer\n`integer` = [0-9]+\n`real` = integer \".\" integer* ((\"e\" / \"E\") \"-\"? integer)?\n`hex` = \"0\" (\"x\" / \"X\") higit+ (\".\" higit*)? ((\"p\" / \"P\") \"-\"? higit+)?\n`higit` = [0-9] / [a-f] / [A-F]\n\n`_` = comment+ / whitespace\ncomment = whitespace longcomment\n        / whitespace \"--\" (!\"\\n\" 1)* whitespace\n\n`longcomment` = \"--\" longstring\n`whitespace` = { \\t\\n\\r}*\n\nkeyword = (\"and\" / \"break\" / \"do\" / \"else\" / \"elseif\"\n        / \"end\" / \"false\" / \"for\" / \"function\" / \"goto\" / \"if\"\n        / \"in\" / \"local\" / \"nil\" / \"not\" / \"or\" / \"repeat\"\n        / \"return\" / \"then\" / \"true\" / \"until\" / \"while\")\n        t\n`t` = !([A-Z] / [a-z] / [0-9] / \"_\")\n]]\n\n\n\n\n\n\n\nlocal Lua = Node : inherit \"lua\"\n\nfunction Lua.__tostring(lua)\n   return lua:span()\nend\n\nlocal lua_metas = { lua = Lua }\n\n\n\nreturn Peg(lua_str) : toGrammar(lua_metas)\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/vmdef",
hash = "2df7b7cdb2055d2be37c9b762653387337458860f792e78249deb4046f783a40",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n-- This is a generated file. DO NOT EDIT!\n\nreturn {\n\nbcnames = \"ISLT  ISGE  ISLE  ISGT  ISEQV ISNEV ISEQS ISNES ISEQN ISNEN ISEQP ISNEP ISTC  ISFC  IST   ISF   ISTYPEISNUM MOV   NOT   UNM   LEN   ADDVN SUBVN MULVN DIVVN MODVN ADDNV SUBNV MULNV DIVNV MODNV ADDVV SUBVV MULVV DIVVV MODVV POW   CAT   KSTR  KCDATAKSHORTKNUM  KPRI  KNIL  UGET  USETV USETS USETN USETP UCLO  FNEW  TNEW  TDUP  GGET  GSET  TGETV TGETS TGETB TGETR TSETV TSETS TSETB TSETM TSETR CALLM CALL  CALLMTCALLT ITERC ITERN VARG  ISNEXTRETM  RET   RET0  RET1  FORI  JFORI FORL  IFORL JFORL ITERL IITERLJITERLLOOP  ILOOP JLOOP JMP   FUNCF IFUNCFJFUNCFFUNCV IFUNCVJFUNCVFUNCC FUNCCW\",\n\nirnames = \"LT    GE    LE    GT    ULT   UGE   ULE   UGT   EQ    NE    ABC   RETF  NOP   BASE  PVAL  GCSTEPHIOP  LOOP  USE   PHI   RENAMEPROF  KPRI  KINT  KGC   KPTR  KKPTR KNULL KNUM  KINT64KSLOT BNOT  BSWAP BAND  BOR   BXOR  BSHL  BSHR  BSAR  BROL  BROR  ADD   SUB   MUL   DIV   MOD   POW   NEG   ABS   ATAN2 LDEXP MIN   MAX   FPMATHADDOV SUBOV MULOV AREF  HREFK HREF  NEWREFUREFO UREFC FREF  STRREFLREF  ALOAD HLOAD ULOAD FLOAD XLOAD SLOAD VLOAD ASTOREHSTOREUSTOREFSTOREXSTORESNEW  XSNEW TNEW  TDUP  CNEW  CNEWI BUFHDRBUFPUTBUFSTRTBAR  OBAR  XBAR  CONV  TOBIT TOSTR STRTO CALLN CALLA CALLL CALLS CALLXSCARG  \",\n\nirfpm = { [0]=\"floor\", \"ceil\", \"trunc\", \"sqrt\", \"exp\", \"exp2\", \"log\", \"log2\", \"log10\", \"sin\", \"cos\", \"tan\", \"other\", },\n\nirfield = { [0]=\"str.len\", \"func.env\", \"func.pc\", \"func.ffid\", \"thread.env\", \"tab.meta\", \"tab.array\", \"tab.node\", \"tab.asize\", \"tab.hmask\", \"tab.nomm\", \"udata.meta\", \"udata.udtype\", \"udata.file\", \"cdata.ctypeid\", \"cdata.ptr\", \"cdata.int\", \"cdata.int64\", \"cdata.int64_4\", },\n\nircall = {\n[0]=\"lj_str_cmp\",\n\"lj_str_find\",\n\"lj_str_new\",\n\"lj_strscan_num\",\n\"lj_strfmt_int\",\n\"lj_strfmt_num\",\n\"lj_strfmt_char\",\n\"lj_strfmt_putint\",\n\"lj_strfmt_putnum\",\n\"lj_strfmt_putquoted\",\n\"lj_strfmt_putfxint\",\n\"lj_strfmt_putfnum_int\",\n\"lj_strfmt_putfnum_uint\",\n\"lj_strfmt_putfnum\",\n\"lj_strfmt_putfstr\",\n\"lj_strfmt_putfchar\",\n\"lj_buf_putmem\",\n\"lj_buf_putstr\",\n\"lj_buf_putchar\",\n\"lj_buf_putstr_reverse\",\n\"lj_buf_putstr_lower\",\n\"lj_buf_putstr_upper\",\n\"lj_buf_putstr_rep\",\n\"lj_buf_puttab\",\n\"lj_buf_tostr\",\n\"lj_tab_new_ah\",\n\"lj_tab_new1\",\n\"lj_tab_dup\",\n\"lj_tab_clear\",\n\"lj_tab_newkey\",\n\"lj_tab_len\",\n\"lj_gc_step_jit\",\n\"lj_gc_barrieruv\",\n\"lj_mem_newgco\",\n\"lj_math_random_step\",\n\"lj_vm_modi\",\n\"sinh\",\n\"cosh\",\n\"tanh\",\n\"fputc\",\n\"fwrite\",\n\"fflush\",\n\"lj_vm_floor\",\n\"lj_vm_ceil\",\n\"lj_vm_trunc\",\n\"sqrt\",\n\"exp\",\n\"lj_vm_exp2\",\n\"log\",\n\"lj_vm_log2\",\n\"log10\",\n\"sin\",\n\"cos\",\n\"tan\",\n\"lj_vm_powi\",\n\"pow\",\n\"atan2\",\n\"ldexp\",\n\"lj_vm_tobit\",\n\"softfp_add\",\n\"softfp_sub\",\n\"softfp_mul\",\n\"softfp_div\",\n\"softfp_cmp\",\n\"softfp_i2d\",\n\"softfp_d2i\",\n\"lj_vm_sfmin\",\n\"lj_vm_sfmax\",\n\"lj_vm_tointg\",\n\"softfp_ui2d\",\n\"softfp_f2d\",\n\"softfp_d2ui\",\n\"softfp_d2f\",\n\"softfp_i2f\",\n\"softfp_ui2f\",\n\"softfp_f2i\",\n\"softfp_f2ui\",\n\"fp64_l2d\",\n\"fp64_ul2d\",\n\"fp64_l2f\",\n\"fp64_ul2f\",\n\"fp64_d2l\",\n\"fp64_d2ul\",\n\"fp64_f2l\",\n\"fp64_f2ul\",\n\"lj_carith_divi64\",\n\"lj_carith_divu64\",\n\"lj_carith_modi64\",\n\"lj_carith_modu64\",\n\"lj_carith_powi64\",\n\"lj_carith_powu64\",\n\"lj_cdata_newv\",\n\"lj_cdata_setfin\",\n\"strlen\",\n\"memcpy\",\n\"memset\",\n\"lj_vm_errno\",\n\"lj_carith_mul64\",\n\"lj_carith_shl64\",\n\"lj_carith_shr64\",\n\"lj_carith_sar64\",\n\"lj_carith_rol64\",\n\"lj_carith_ror64\",\n},\n\ntraceerr = {\n[0]=\"error thrown or hook called during recording\",\n\"trace too short\",\n\"trace too long\",\n\"trace too deep\",\n\"too many snapshots\",\n\"blacklisted\",\n\"retry recording\",\n\"NYI: bytecode %d\",\n\"leaving loop in root trace\",\n\"inner loop in root trace\",\n\"loop unroll limit reached\",\n\"bad argument type\",\n\"JIT compilation disabled for function\",\n\"call unroll limit reached\",\n\"down-recursion, restarting\",\n\"NYI: unsupported variant of FastFunc %s\",\n\"NYI: return to lower frame\",\n\"store with nil or NaN key\",\n\"missing metamethod\",\n\"looping index lookup\",\n\"NYI: mixed sparse/dense table\",\n\"symbol not in cache\",\n\"NYI: unsupported C type conversion\",\n\"NYI: unsupported C function type\",\n\"guard would always fail\",\n\"too many PHIs\",\n\"persistent type instability\",\n\"failed to allocate mcode memory\",\n\"machine code too long\",\n\"hit mcode limit (retrying)\",\n\"too many spill slots\",\n\"inconsistent register allocation\",\n\"NYI: cannot assemble IR instruction %d\",\n\"NYI: PHI shuffling too complex\",\n\"NYI: register coalescing too complex\",\n},\n\nffnames = {\n[0]=\"Lua\",\n\"C\",\n\"assert\",\n\"type\",\n\"next\",\n\"pairs\",\n\"ipairs_aux\",\n\"ipairs\",\n\"getmetatable\",\n\"setmetatable\",\n\"getfenv\",\n\"setfenv\",\n\"rawget\",\n\"rawset\",\n\"rawequal\",\n\"unpack\",\n\"select\",\n\"tonumber\",\n\"tostring\",\n\"error\",\n\"pcall\",\n\"xpcall\",\n\"loadfile\",\n\"load\",\n\"loadstring\",\n\"dofile\",\n\"gcinfo\",\n\"collectgarbage\",\n\"newproxy\",\n\"print\",\n\"coroutine.status\",\n\"coroutine.running\",\n\"coroutine.isyieldable\",\n\"coroutine.create\",\n\"coroutine.yield\",\n\"coroutine.resume\",\n\"coroutine.wrap_aux\",\n\"coroutine.wrap\",\n\"math.abs\",\n\"math.floor\",\n\"math.ceil\",\n\"math.sqrt\",\n\"math.log10\",\n\"math.exp\",\n\"math.sin\",\n\"math.cos\",\n\"math.tan\",\n\"math.asin\",\n\"math.acos\",\n\"math.atan\",\n\"math.sinh\",\n\"math.cosh\",\n\"math.tanh\",\n\"math.frexp\",\n\"math.modf\",\n\"math.log\",\n\"math.atan2\",\n\"math.pow\",\n\"math.fmod\",\n\"math.ldexp\",\n\"math.min\",\n\"math.max\",\n\"math.random\",\n\"math.randomseed\",\n\"bit.tobit\",\n\"bit.bnot\",\n\"bit.bswap\",\n\"bit.lshift\",\n\"bit.rshift\",\n\"bit.arshift\",\n\"bit.rol\",\n\"bit.ror\",\n\"bit.band\",\n\"bit.bor\",\n\"bit.bxor\",\n\"bit.tohex\",\n\"string.byte\",\n\"string.char\",\n\"string.sub\",\n\"string.rep\",\n\"string.reverse\",\n\"string.lower\",\n\"string.upper\",\n\"string.dump\",\n\"string.find\",\n\"string.match\",\n\"string.gmatch_aux\",\n\"string.gmatch\",\n\"string.gsub\",\n\"string.format\",\n\"table.maxn\",\n\"table.insert\",\n\"table.concat\",\n\"table.sort\",\n\"table.new\",\n\"table.clear\",\n\"io.method.close\",\n\"io.method.read\",\n\"io.method.write\",\n\"io.method.flush\",\n\"io.method.seek\",\n\"io.method.setvbuf\",\n\"io.method.lines\",\n\"io.method.__gc\",\n\"io.method.__tostring\",\n\"io.open\",\n\"io.popen\",\n\"io.tmpfile\",\n\"io.close\",\n\"io.read\",\n\"io.write\",\n\"io.flush\",\n\"io.input\",\n\"io.output\",\n\"io.lines\",\n\"io.type\",\n\"os.execute\",\n\"os.remove\",\n\"os.rename\",\n\"os.tmpname\",\n\"os.getenv\",\n\"os.exit\",\n\"os.clock\",\n\"os.date\",\n\"os.time\",\n\"os.difftime\",\n\"os.setlocale\",\n\"debug.getregistry\",\n\"debug.getmetatable\",\n\"debug.setmetatable\",\n\"debug.getfenv\",\n\"debug.setfenv\",\n\"debug.getinfo\",\n\"debug.getlocal\",\n\"debug.setlocal\",\n\"debug.getupvalue\",\n\"debug.setupvalue\",\n\"debug.upvalueid\",\n\"debug.upvaluejoin\",\n\"debug.sethook\",\n\"debug.gethook\",\n\"debug.debug\",\n\"debug.traceback\",\n\"jit.on\",\n\"jit.off\",\n\"jit.flush\",\n\"jit.status\",\n\"jit.attach\",\n\"jit.util.funcinfo\",\n\"jit.util.funcbc\",\n\"jit.util.funck\",\n\"jit.util.funcuvname\",\n\"jit.util.traceinfo\",\n\"jit.util.traceir\",\n\"jit.util.tracek\",\n\"jit.util.tracesnap\",\n\"jit.util.tracemc\",\n\"jit.util.traceexitstub\",\n\"jit.util.ircalladdr\",\n\"jit.opt.start\",\n\"jit.profile.start\",\n\"jit.profile.stop\",\n\"jit.profile.dumpstack\",\n\"ffi.meta.__index\",\n\"ffi.meta.__newindex\",\n\"ffi.meta.__eq\",\n\"ffi.meta.__len\",\n\"ffi.meta.__lt\",\n\"ffi.meta.__le\",\n\"ffi.meta.__concat\",\n\"ffi.meta.__call\",\n\"ffi.meta.__add\",\n\"ffi.meta.__sub\",\n\"ffi.meta.__mul\",\n\"ffi.meta.__div\",\n\"ffi.meta.__mod\",\n\"ffi.meta.__pow\",\n\"ffi.meta.__unm\",\n\"ffi.meta.__tostring\",\n\"ffi.meta.__pairs\",\n\"ffi.meta.__ipairs\",\n\"ffi.clib.__index\",\n\"ffi.clib.__newindex\",\n\"ffi.clib.__gc\",\n\"ffi.callback.free\",\n\"ffi.callback.set\",\n\"ffi.cdef\",\n\"ffi.new\",\n\"ffi.cast\",\n\"ffi.typeof\",\n\"ffi.typeinfo\",\n\"ffi.istype\",\n\"ffi.sizeof\",\n\"ffi.alignof\",\n\"ffi.offsetof\",\n\"ffi.errno\",\n\"ffi.string\",\n\"ffi.copy\",\n\"ffi.fill\",\n\"ffi.abi\",\n\"ffi.metatype\",\n\"ffi.gc\",\n\"ffi.load\",\n},\n\n}\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/modal",
hash = "2a7a573ae5b8494d0506acbab5336abf30f052be1f314fa25f01c7aa04628946",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal clone = assert(require \'core:table\' . clone)\nlocal a = require \"anterm:anterm\"\nlocal RagaBase = require \"helm:raga/base\"\n\n\n\nlocal Modal = clone(RagaBase, 2)\nModal.name = \"modal\"\nModal.prompt_char = \" \"\n\n\n\nlocal function _getModel(modeS)\n   return modeS.zones.modal.contents[1]\nend\n\nfunction Modal.close(modeS, value)\n   _getModel(modeS).value = value\n   -- #todo shift back to the previous raga--modeS needs to maintain a stack\n   modeS.shift_to = modeS.raga_default\nend\n\n\n\n\n\nlocal function _shortcutFrom(button)\n   local shortcut_decl = button.text and button.text:match(\'&([^&])\')\n   return shortcut_decl and shortcut_decl:lower()\nend\n\nlocal function _buttonTextFrom(button)\n   local button_text = button.text\n      :gsub(\'&([^&])\', function(ch) return a.underline(ch) end, 1)\n      :gsub(\'&&\', \'&\')\n   button_text = \'[ \' .. button_text .. \' ]\'\n   if button.default then\n      return a.bold(button_text)\n   else\n      return button_text\n   end\nend\n\nlocal function _buttonWidthFrom(button)\n   -- Four chars for the leading \'[ \' and trailing \' ]\'\n   return 4 + #button.text:gsub(\'&(.)\', \'%1\')\nend\n\nfunction Modal.ASCII(modeS, category, value)\n   local model = _getModel(modeS)\n   local key = value:lower()\n   for _, button in ipairs(model.buttons) do\n      if _shortcutFrom(button) == key then\n         return Modal.close(modeS, button.value)\n      end\n   end\n   return RagaBase(modeS, category, value)\nend\n\nfunction Modal.NAV.ESC(modeS, category, value)\n   local model = _getModel(modeS)\n   for _, button in ipairs(model.buttons) do\n      if button.cancel then\n         return Modal.close(modeS, button.value)\n      end\n   end\nend\n\nfunction Modal.NAV.RETURN(modeS, category, value)\n   local model = _getModel(modeS)\n   for _, button in ipairs(model.buttons) do\n      if button.default then\n         return Modal.close(modeS, button.value)\n      end\n   end\nend\n\n\n\n\n\n\nfunction Modal.onShift(modeS)\n   modeS.zones.modal:show()\nend\n\nfunction Modal.onUnshift(modeS)\n   modeS.zones.modal:hide()\nend\n\n\n\n\n\n\n\n\nlocal DialogModel = meta {}\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal ceil = assert(math.ceil)\nlocal breakascii = assert(require \"core:string/print\" . breakascii)\n\nlocal function _buttonAndSpaceInfo(model)\n   local buttons_width, spaces_count = 0, 0\n   -- First, figure out how much space we need to fill\n   for i, button in ipairs(model.buttons) do\n      if button.text then\n         buttons_width = buttons_width + _buttonWidthFrom(button)\n         if i ~= 1 then\n            -- For space between buttons\n            buttons_width = buttons_width + 1\n         end\n      elseif button.space then\n         spaces_count = spaces_count + 1\n      end\n   end\n   return buttons_width, spaces_count\nend\n\nfunction DialogModel.__repr(model, window, c)\n   local phrase = {}\n   local wrapped_text = breakascii(model.text, 40)\n   insert(phrase, wrapped_text)\n   insert(phrase, \"\\n\\n\")\n   local buttons_width, spaces_count = _buttonAndSpaceInfo(model)\n   local space_remaining = window.width - buttons_width\n   for i, button in ipairs(model.buttons) do\n      if button.text then\n         if i ~= 1 then insert(phrase, \" \") end\n         insert(phrase, _buttonTextFrom(button))\n      elseif button.space then\n         local spaces = ceil(space_remaining / spaces_count)\n         insert(phrase, (\" \"):rep(spaces))\n         space_remaining = space_remaining - spaces\n         spaces_count = spaces_count - 1\n      end\n   end\n   return concat(phrase)\nend\n\n\n\n\n\n\n\n\nlocal max = assert(math.max)\nlocal Point = require \"anterm:point\"\n\nfunction DialogModel.requiredExtent(model)\n   local _, text_height, text_width = breakascii(model.text, 40)\n   local buttons_width, spaces_count = _buttonAndSpaceInfo(model)\n   -- Ensure that any flexible-space element is at least one space wide\n   local button_row_width = buttons_width + spaces_count\n   -- Add two lines for a blank line and the button row\n   return Point(text_height + 2, max(text_width, button_row_width))\nend\n\n\n\n\n\n\n\n\nlocal button_styles = {\n   yes_no_cancel = {\n      { value = \"cancel\", text = \"&Cancel\", cancel = true },\n      { space = true },\n      { value = \"no\", text = \"&No\" },\n      { value = \"yes\", text = \"&Yes\", default = true }\n   }\n}\n\nfunction Modal.newModel(text, button_style)\n   local model = meta(DialogModel)\n   model.text = text\n   if type(button_style) == \"string\" then\n      button_style = button_styles[button_style]\n   end\n   model.buttons = button_style\n   return model\nend\n\n\n\nreturn Modal\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/complete",
hash = "fb2d0ece1661002ea9fd85555ebf0d6942a5982e33ec635a87d73475861a7fd5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm/raga/edit\"\n\nlocal Complete = clone(EditBase, 2)\n\nComplete.name = \"complete\"\nComplete.prompt_char = \"💬\"\n\n\n\n\n\n\nlocal function _quit(modeS)\n   modeS.suggest:cancel(modeS)\n   -- #todo restore last-used raga instead of always returning to default\n   modeS.shift_to = modeS.raga_default\nend\n\nlocal function _accept(modeS)\n   if modeS.suggest.active_suggestions then\n      modeS.suggest:accept(modeS)\n   else\n      modeS.action_complete = false\n   end\n   _quit(modeS)\nend\n\nfunction Complete.PASTE(modeS, category, value)\n   _quit(modeS)\n   modeS.action_complete = false\nend\n\n\n\n\nlocal find = assert(string.find)\nlocal function _insert(modeS, category, value)\n   -- Non-symbol character accepts the completion\n   -- #todo should be consistent with lex.orb definition\n   if find(value, \"[^a-zA-Z0-9_]\") then\n      _accept(modeS, category, value)\n      modeS.action_complete = false\n   else\n      EditBase(modeS, category, value)\n   end\nend\n\nComplete.ASCII = _insert\nComplete.UTF8 = _insert\n\n\n\n\n\nlocal NAV = Complete.NAV\n\nlocal function _scrollAfter(modeS, func_name)\n   local suggestions = modeS.suggest.active_suggestions\n   local zone = modeS.zones.suggest\n   suggestions[func_name](suggestions)\n   zone:ensureVisible(suggestions.selected_index)\n   zone:beTouched()\n   -- Command zone needs re-render too\n   modeS.zones.command:beTouched()\nend\n\nfunction NAV.TAB(modeS, category, value)\n   _scrollAfter(modeS, \"selectNextWrap\")\nend\nNAV.DOWN = NAV.TAB\nNAV.SHIFT_DOWN = NAV.TAB\n\nfunction NAV.SHIFT_TAB(modeS, category, value)\n   _scrollAfter(modeS, \"selectPreviousWrap\")\nend\nNAV.UP = NAV.SHIFT_TAB\nNAV.SHIFT_UP = NAV.SHIFT_TAB\n\nNAV.ESC = _quit\nNAV.RETURN = _accept\n\nfunction NAV.LEFT(modeS, category, value)\n   _accept(modeS, category, value)\n   modeS.action_complete = false\nend\n\n\n\n\n\n\n\n\n\n\nfunction Complete.onTxtbufChanged(modeS)\n   modeS.suggest:update(modeS)\n   EditBase.onCursorChanged(modeS)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Complete.onCursorChanged(modeS)\n   _quit(modeS)\n   EditBase.onCursorChanged(modeS)\nend\n\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction Complete.getCursorPosition(modeS)\n   local point = EditBase.getCursorPosition(modeS)\n   local suggestion = modeS.suggest:selectedSuggestion()\n   if suggestion then\n      for _, tok in ipairs(modeS.txtbuf:tokens()) do\n         if tok.cursor_offset then\n            point = point + Point(0, #suggestion - tok.cursor_offset)\n            break\n         end\n      end\n   end\n   return point\nend\n\n\n\n\n\n\n\n\nfunction Complete.onShift(modeS)\n   _scrollAfter(modeS, \"selectFirst\")\nend\n\n\n\n\nreturn Complete\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/edit-title",
hash = "ccc5111e2e72e40f0eb2e0631762504abc414d2819639b54397399e714e71bef",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal clone    = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm:helm/raga/edit\"\n\nlocal EditTitle = clone(EditBase, 2)\nEditTitle.name = \"edit_title\"\nEditTitle.prompt_char = \"👉\"\n\n\n\n\n\n\n\n\nfunction EditTitle.ASCII(modeS, category, value)\n   modeS.txtbuf:insert(value)\nend\nEditTitle.UTF8 = EditTitle.ASCII\n\nfunction EditTitle.PASTE(modeS, category, value)\n   modeS.txtbuf:paste(value)\nend\n\n\n\n\n\n\n\n\n\nlocal function _getSelectedPremise(modeS)\n   return modeS.zones.results.contents:selectedPremise()\nend\n\n\n\n\n\n\nlocal function _accept(modeS)\n   local sessionbuf = modeS.zones.results.contents\n   sessionbuf:selectedPremise().title = tostring(modeS.txtbuf)\n   sessionbuf:selectNextWrap()\n   modeS.shift_to = \"review\"\nend\n\nEditTitle.NAV.RETURN = _accept\nEditTitle.NAV.TAB = _accept\n\nfunction EditTitle.NAV.ESC(modeS, category, value)\n   modeS.txtbuf:replace(_getSelectedPremise(modeS).title)\n   modeS.shift_to = \"review\"\nend\n\n\n\n\n\n\n\n\n\nEditTitle.CTRL[\"^Q\"] = function(modeS, category, value)\n   _accept(modeS)\n   modeS.action_complete = false\nend\n\n\n\n\n\n\nEditTitle.CTRL[\"^R\"] = nil\n\n\n\n\nreturn EditTitle\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/aliaser",
hash = "64b143536021b9e6d4e8ee092c26549a10e484cbb12d0e26a50dc9297a87acc4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function aliaser(raga)\n   local function alias(dict)\n      local fn = dict[1]\n      for category, values in pairs(dict) do\n         if category ~= 1 then\n            for _, value in ipairs(values) do\n               raga[category][value] = fn\n            end\n         end\n      end\n   end\n   return alias\nend\n\nreturn aliaser\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/helm-db",
hash = "7f8951287e3ef5a29123b8091e1133291f255390e4f3d45c0c4cbbd08506b579",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal uv  = require \"luv\"\nlocal sql = assert(sql, \"sql must be in bridge _G\")\n\n\n\n\n\n\nlocal helm_db = {}\n\n\n\n\n\n\nlocal helm_db_home =  os.getenv \'HELM_HOME\'\n                      or _Bridge.bridge_home .. \"/helm/helm.sqlite\"\nhelm_db.helm_db_home = helm_db_home\n\n\n\n\n\n\n\n\n\n\n\nlocal _conns = setmetatable({}, { __mode = \'v\' })\n\n\n\n\n\n\n\n\n\n\n\nlocal function _resolveConn(conn)\n   if conn then\n      if type(conn) == \'string\' then\n         return _conns[conn]\n      else\n         return conn\n      end\n   end\n   return nil\nend\n\n\n\n\n\n\n\n\n\nlocal function _openConn(conn_handle)\n   if not conn_handle then\n      conn_handle = helm_db_home\n   end\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn = helm_db.boot(conn_handle)\n   end\n   assert(conn, \"no conn! \" .. conn_handle)\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_project_table_3 = [[\nCREATE TABLE IF NOT EXISTS project_3 (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\'))\n);\n]]\n\n\n\n\nlocal create_repl_table_3 = [[\nCREATE TABLE IF NOT EXISTS repl_3 (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_result_table = [[\nCREATE TABLE IF NOT EXISTS result (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   line_id INTEGER,\n   repr text NOT NULL,\n   value blob,\n   FOREIGN KEY (line_id)\n      REFERENCES repl (line_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_session_table_4 = [[\nCREATE TABLE IF NOT EXISTS session (\n   session_id INTEGER PRIMARY KEY,\n   title TEXT,\n   project INTEGER,\n   accepted INTEGER NOT NULL DEFAULT 0 CHECK (accepted = 0 or accepted = 1),\n   vc_hash TEXT,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\nlocal create_premise_table = [[\nCREATE TABLE IF NOT EXISTS premise (\n   session INTEGER NOT NULL,\n   line INTEGER NOT NULL,\n   -- ordinal is 1-indexed for Lua compatibility\n   -- \"ordinal\" not \"order\" because SQL\n   ordinal INTEGER NOT NULL CHECK (ordinal > 0),\n   title TEXT,\n   status STRING NOT NULL CHECK (\n      status = \'accept\' or status = \'reject\' or status = \'ignore\' ),\n   PRIMARY KEY (session, ordinal) ON CONFLICT REPLACE\n   FOREIGN KEY (session)\n      REFERENCES session (session_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (line)\n      REFERENCES repl (line_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\nlocal create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   directory TEXT UNIQUE,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n]]\n\nlocal create_session_table = [[\nCREATE TABLE IF NOT EXISTS session (\nsession_id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT,\nproject INTEGER,\n-- These two are line_ids\nstart INTEGER NOT NULL,\nend INTEGER,\ntest BOOLEAN,\nsha TEXT,\nFOREIGN KEY (project)\n   REFERENCES project (project_id)\n   ON DELETE CASCADE );\n]]\n\nlocal create_repl_table = [[\nCREATE TABLE IF NOT EXISTS repl (\n   line_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   project INTEGER,\n   line TEXT,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhelm_db.HELM_DB_VERSION = 3\n\nlocal migrations = {function() return true end}\nhelm_db.migrations = migrations\n\n\n\n\n\n\nlocal insert = assert(table.insert)\n\nlocal migration_2 = {\n   create_project_table,\n   create_result_table,\n   create_repl_table,\n   create_session_table\n}\n\ninsert(migrations, migration_2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_3 = {}\n\n\nmigration_3[1] = [[\nUPDATE project\nSET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n]]\n\n\nmigration_3[2] = create_project_table_3\n\n\nmigration_3[3] = [[\nINSERT INTO project_3 (project_id, directory, time)\nSELECT project_id, directory, time\nFROM project;\n]]\n\nmigration_3[4] = [[\nDROP TABLE project;\n]]\n\nmigration_3[5] = [[\nALTER TABLE project_3\nRENAME TO project;\n]]\n\nmigration_3[6] = [[\nUPDATE repl\nSET time = strftime(\'%Y-%m-%dT%H:%M:%f\', time);\n]]\n\n\nmigration_3[7] = create_repl_table_3\n\n\nmigration_3[8] = [[\nINSERT INTO repl_3 (line_id, project, line, time)\nSELECT line_id, project, line, time\nFROM repl;\n]]\n\nmigration_3[8] = [[\nDROP TABLE repl;\n]]\n\nmigration_3[9] = [[\nALTER TABLE repl_3\nRENAME to repl;\n]]\n\n\ninsert(migrations, migration_3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_4 = {}\n\n\nmigration_4[1] = [[\nDROP TABLE session;\n]]\n\n\ninsert(migration_4, create_session_table_4)\ninsert(migration_4, create_premise_table)\n\ninsert(migrations, migration_4)\n\n\n\n\n\n\n\n\nlocal migration_5 = {}\ninsert(migrations, migration_5)\n\n\n\n\n\n\n\n\n\n\n\n\nmigration_5[1] = [[\nALTER TABLE repl RENAME TO input;\n]]\n\n\n\nmigration_5[2] = [[\nCREATE INDEX idx_input_time ON input (time);\n]]\n\n\n\n\n\n\n\nlocal create_session_table_5 = [[\nCREATE TABLE IF NOT EXISTS session_5 (\n   session_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   title TEXT,\n   project INTEGER,\n   accepted INTEGER NOT NULL DEFAULT 0 CHECK (accepted = 0 or accepted = 1),\n   vc_hash TEXT,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\nmigration_5[3] = create_session_table_5\n\n\nmigration_5[4] = [[\nINSERT INTO session_5(title, project, accepted, vc_hash)\nSELECT title, project, accepted, vc_hash FROM session\n;\n]]\n\nmigration_5[5] = [[\nDROP TABLE session;\n]]\n\nmigration_5[6] = [[\nALTER TABLE session_5 RENAME TO session;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_result_table_5 = [[\nCREATE TABLE IF NOT EXISTS result_5 (\n   result_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   line_id INTEGER,\n   hash text NOT NULL,\n   FOREIGN KEY (line_id)\n      REFERENCES input (line_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (hash)\n      REFERENCES repr (hash)\n);\n]]\n\n\n\n\n\n\n\n\n\n\nlocal create_repr_table = [[\nCREATE TABLE IF NOT EXISTS repr (\n   hash TEXT PRIMARY KEY ON CONFLICT IGNORE,\n   repr BLOB\n);\n]]\n\n\n\nlocal create_repr_hash_idx = [[\nCREATE INDEX repr_hash_idx ON repr (hash);\n]]\n\n\n\n\n\nmigration_5[7] = create_result_table_5\nmigration_5[8] = create_repr_table\nmigration_5[9] = create_repr_hash_idx\n\n\n\n\n\n\n\n\n\nlocal get_old_result_5 = [[\nSELECT result_id, line_id, repr\nFROM result\nORDER BY result_id\n;\n]]\n\n\n\nlocal insert_new_result_5 = [[\nINSERT INTO result_5 (result_id, line_id, hash) VALUES (?, ?, ?);\n]]\n\n\n\nlocal insert_repr_5 = [[\nINSERT INTO repr (hash, repr) VALUES (?, ?);\n]]\n\n\n\n\n\nlocal drop_result_5 = [[\nDROP TABLE result;\n]]\n\nlocal rename_result_5 = [[\nALTER TABLE result_5 RENAME TO result;\n]]\n\n\n\n\n\n\nlocal TRUNCATE_AT = 1048576 * 4 -- 4 MiB is long enough for one repr...\n\nlocal function _truncate_repr(repr)\n   local idx = TRUNCATE_AT\n   if repr:sub(1, 1) == \"\\x01\" then\n      -- If this is a tokenized-format repr, look for the start of\n      -- the next token after the 4MB mark, and stop just before it.\n      -- Theoretically there might not be any such, if the repr is just\n      -- barely over 4MB, in which case we keep the whole thing.\n      idx = repr:find(\"\\x01\", idx, true)\n      if idx then\n         idx = idx - 1\n      end\n   end\n   return repr:sub(1, idx)\nend\n\nmigration_5[10] = function (conn, s)\n   local sha = require \"util:sha\" . shorthash\n   local insert_result = conn:prepare(insert_new_result_5)\n   local insert_repr = conn:prepare(insert_repr_5)\n   s:chat \"Hashing results, this may take awhile...\"\n   local truncated = 0\n   for _, result_id, line_id, repr in conn:prepare(get_old_result_5):cols() do\n      ---[[\n      if #repr > TRUNCATE_AT then\n         s:verb(\"Found a %.2f MiB result!\", #repr / 1048576)\n         truncated = truncated + 1\n         repr = _truncate_repr(repr)\n      end\n      --]]\n      local hash = sha(repr)\n      insert_result :bind(result_id, line_id, hash)\n                    :step()\n      insert_result :clearbind() :reset()\n      insert_repr :bind(hash, repr) :step()\n      insert_repr :clearbind() :reset()\n   end\n   s:chat(\"Truncated %d results\", truncated)\n   s:verb(drop_result_5)\n   s:verb(rename_result_5)\n   conn:exec(drop_result_5)\n   conn:exec(rename_result_5)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal migration_6 = {}\n\ninsert(migrations, migration_6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_table = [[\nCREATE TABLE IF NOT EXISTS run (\n   run_id INTEGER PRIMARY KEY,\n   project INTEGER NOT NULL,\n   start_time DATETIME DEFAULT (strftime(\'%Y-%m-%dT%H:%M:%f\', \'now\')),\n   finish_time DATETIME,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE CASCADE\n);\n]]\n\nlocal create_run_attr_table = [[\nCREATE TABLE IF NOT EXISTS run_attr (\n   run_attr_id INTEGER PRIMARY KEY,\n   run INTEGER,\n   key TEXT,\n   value BLOB,\n   FOREIGN KEY (run)\n      REFERENCES run (run_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_run_action_table = [[\nCREATE TABLE IF NOT EXISTS run_action (\n   ordinal INTEGER,\n   class TEXT CHECK (length(class) <= 3),\n   input INTEGER,\n   run INTEGER,\n   PRIMARY KEY (run, ordinal) -- ON CONFLICT ABORT?\n   FOREIGN KEY (run)\n      REFERENCES run (run_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (input)\n      REFERENCES input (line_id)\n);\n]]\n\nlocal create_action_attr_table = [[\nCREATE TABLE IF NOT EXISTS action_attr (\n   action_attr_id PRIMARY KEY,\n   run_action INTEGER,\n   key TEXT,\n   value BLOB,\n   FOREIGN KEY (run_action)\n      REFERENCES run_action (run_action_id)\n      ON DELETE CASCADE\n);\n]]\n\n\n\n\n\n\n\n\n\nlocal create_error_string_table = [[\nCREATE TABLE IF NOT EXISTS error_string (\n   error_id INTEGER PRIMARY KEY,\n   string TEXT UNIQUE ON CONFLICT IGNORE\n);\n]]\n\n\n\nlocal create_error_string_idx = [[\nCREATE INDEX idx_error_string ON error_string (string);\n]]\n\n\n\n\ninsert(migration_6, create_run_table)\ninsert(migration_6, create_run_attr_table)\ninsert(migration_6, create_run_action_table)\ninsert(migration_6, create_action_attr_table)\ninsert(migration_6, create_error_string_table)\ninsert(migration_6, create_error_string_idx)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _prepareStatements(conn, stmts)\n   return function(_, key)\n      if stmts[key] then\n         return conn:prepare(stmts[key])\n      else\n         error(\"Don\'t have a statement \" .. key .. \" to prepare.\")\n      end\n   end\nend\n\nlocal function _readOnly(_, key, value)\n   error (\"can\'t assign to prepared statements table, key: \" .. key\n          .. \" value: \" .. value)\nend\n\nlocal lastRowId = assert(sql.lastRowId)\nfunction _makeProxy(conn, stmts)\n   return setmetatable({ lastRowId = function() return lastRowId(conn) end },\n                       { __index = _prepareStatements(conn, stmts),\n                         __newindex = _readOnly })\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal historian_sql = {}\nhelm_db.historian_sql = historian_sql\n\n\n\n\n\nhistorian_sql.insert_line = [[\nINSERT INTO input (project, line) VALUES (:project, :line);\n]]\n\nhistorian_sql.insert_result_hash = [[\nINSERT INTO result (line_id, hash) VALUES (:line_id, :hash);\n]]\n\nhistorian_sql.insert_repr = [[\nINSERT INTO repr (hash, repr) VALUES (:hash, :repr);\n]]\n\nhistorian_sql.insert_project = [[\nINSERT INTO project (directory) VALUES (?);\n]]\n\n\n\nhistorian_sql.get_recent = [[\nSELECT CAST (line_id AS REAL), line FROM input\n   WHERE project = :project\n   ORDER BY line_id DESC\n   LIMIT :num_lines;\n]]\n\nhistorian_sql.get_number_of_lines = [[\nSELECT CAST (count(line) AS REAL) from input\n   WHERE project = ?\n;\n]]\n\nhistorian_sql.get_project = [[\nSELECT project_id FROM project\n   WHERE directory = ?;\n]]\n\nhistorian_sql.get_results = [[\nSELECT repr\nFROM result\nINNER JOIN repr ON repr.hash == result.hash\nWHERE result.line_id = :line_id\nORDER BY result.result_id;\n]]\n\n\n\n\n\n\n\n\n\nfunction helm_db.historian(conn_handle)\n   local conn = _openConn(conn_handle)\n   local hist_proxy = _makeProxy(conn, historian_sql)\n   rawset(hist_proxy, \"savepoint_persist\",\n          function()\n            conn:exec \"SAVEPOINT save_persist\"\n          end)\n   rawset(hist_proxy, \"release_persist\",\n          function()\n             conn:exec \"RELEASE save_persist\"\n          end)\n   rawset(hist_proxy, \"savepoint_restart_session\",\n          function()\n             conn:exec \"SAVEPOINT restart_session\"\n          end)\n   rawset(hist_proxy, \"release_restart_session\",\n          function()\n             conn:exec \"RELEASE restart_session\"\n          end)\n   return hist_proxy\nend\n\n\n\n\n\n\n\n\n\nlocal session_sql = {}\n\n\n\n\n\n\n\n\nsession_sql.insert_session = [[\nINSERT INTO\n   session (title, project, accepted)\nVALUES\n   (:session_title, :project_id, :accepted)\n;\n]]\n\nsession_sql.insert_premise = [[\nINSERT INTO\n   premise (session, ordinal, line, title, status)\nVALUES\n   (:session_id, :ordinal, :line_id, :title, :status)\n;\n]]\n\nsession_sql.truncate_session = [[\nDELETE FROM premise WHERE session = :session_id AND ordinal > :n;\n]]\n\nsession_sql.delete_session_by_id = [[\nDELETE FROM session WHERE session_id = :session_id;\n]]\n\n\n\nsession_sql.insert_line = [[\nINSERT INTO input (project, line, time) VALUES (:project, :line, :time);\n]]\n\n\n\n\nsession_sql.insert_result_hash = historian_sql.insert_result_hash\nsession_sql.insert_repr        = historian_sql.insert_repr\n\n\n\n\n\n\n\n\nsession_sql.update_session = [[\nUPDATE session SET title = :session_title, accepted = :accepted\n   WHERE session_id = :session_id;\n]]\n\n\n\n\nsession_sql.delete_session_by_id = [[\nDELETE FROM session WHERE session_id = :session_id;\n]]\n\nsession_sql.update_accepted_session = [[\nUPDATE session SET accepted = :accepted WHERE session_id = :session_id;\n]]\n\nsession_sql.update_title_session = [[\nUPDATE session SET title = :title WHERE session_id = :session_id;\n]]\n\n\n\nsession_sql.get_session_by_id = [[\nSELECT\n   session.title AS session_title,\n   session.accepted AS session_accepted,\n   session.session_id,\n   session.project,\n   premise.status,\n   premise.title,\n   input.line,\n   input.time,\n   input.line_id\nFROM\n   session\nLEFT JOIN premise ON premise.session = session.session_id\nLEFT JOIN input ON input.line_id = premise.line\nWHERE session.session_id = ?\nORDER BY premise.ordinal\n;\n]]\n\n\n\n\nsession_sql.get_results = [[\nSELECT repr.repr\nFROM result\nINNER JOIN repr ON result.hash = repr.hash\nWHERE result.line_id = ?\nORDER BY result.result_id;\n]]\n\n\n\nsession_sql.get_sessions_for_project = [[\nSELECT title as session_title, accepted, project, vc_hash, session_id\nFROM session\nWHERE session.project = :project_id\nORDER BY session.session_id;\n]]\n\nsession_sql.get_project_by_dir = [[\nSELECT project_id FROM project WHERE directory = ?;\n]]\n\nsession_sql.get_accepted_by_dir = [[\nSELECT title FROM session\nINNER JOIN\n   project ON session.project = project.project_id\nWHERE\n   project.directory = ?\nAND\n   session.accepted = 1\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.get_session_list_by_dir = [[\nSELECT title, accepted, session_id FROM session\nINNER JOIN\n   project ON session.project = project.project_id\nWHERE\n   project.directory = ?\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.count_premises = [[\nSELECT CAST (count(premise.ordinal) AS REAL)\nFROM premise\nWHERE session = :session_id\n;\n]]\n\nsession_sql.get_sessions_from_project = [[\nSELECT\n   session_id,\n   CAST(accepted AS REAL) As accepted\nFROM\n   session\nWHERE\n   project = ?\nORDER BY\n   session.session_id\n;\n]]\n\nsession_sql.get_sessions_by_project = [[\nSELECT session_id FROM session\nWHERE project = ?\nORDER BY session_id\n;\n]]\n\nsession_sql.get_session_by_project_and_title = [[\nSELECT\n   CAST (session_id AS REAL) AS session_id,\n   CAST (accepted AS REAL) AS accepted\nFROM session\nWHERE project = ? AND title = ?\nORDER BY session_id\n;\n]]\n\nsession_sql.get_premises_for_export = [[\nSELECT\n   CAST (ordinal AS REAL) AS ordinal,\n   premise.title as title,\n   premise.status as status,\n   input.line as line,\n   input.time as time,\n   input.line_id as line_id\nFROM\n   premise\nLEFT JOIN\n   input\nON\n   input.line_id = premise.line\nWHERE\n   premise.session = :session_id\nORDER BY\n   premise.ordinal\n;\n]]\n\n\n\n\nlocal session_get_project_info = [[\nSELECT project_id, directory from project;\n]]\n\nsession_sql.update_premise_line = [[\nUPDATE premise\nSET line = :line\nWHERE\n   session = :session\nAND\n   ordinal = :ordinal\n;\n]]\n\n\nfunction helm_db.session(conn_handle)\n   local conn = _openConn(conn_handle)\n   local stmts =  _makeProxy(conn, session_sql)\n   rawset(stmts, \"get_project_info\",\n          function()\n             return conn:exec(session_get_project_info)\n          end)\n   rawset(stmts, \"beginTransaction\",\n          function()\n             return conn:exec \"BEGIN TRANSACTION;\"\n          end)\n   rawset(stmts, \"commit\",\n          function()\n             return conn:exec \"COMMIT;\"\n          end)\n   return stmts\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal assertfmt = require \"core:core/string\" . assertfmt\nlocal format = assert(string.format)\nlocal boot = assert(sql.boot)\n\n\nfunction helm_db.boot(conn_handle)\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn_handle = helm_db_home\n      conn = boot(conn_handle, migrations)\n      _conns[conn_handle] = conn\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\nfunction helm_db.close(conn_handle)\n   local conn = _resolveConn(conn_handle)\n   if not conn then\n      conn = _conns[helm_db_home]\n      conn_handle = helm_db_home\n   end\n   if not conn then return end\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   -- set up an idler to close the conn, so that e.g. busy\n   -- exceptions don\'t blow up the hook\n   local close_idler = uv.new_idle()\n   close_idler:start(function()\n      local success = pcall(conn.close, conn)\n      if not success then\n         return nil\n      else\n         -- we don\'t want to rely on GC to prevent closing a conn twice\n         _conns[conn_handle] = nil\n         close_idler:stop()\n      end\n   end)\nend\n\n\n\n\n\n\n\n\n\n\nfunction helm_db.conn(conn_handle)\n   conn_handle = conn_handle or helm_db_home\n   return _conns[conn_handle]\nend\n\n\n\n\n\n\n\n\nsetmetatable(helm_db, { __newindex = function()\n                                        error \"cannnot assign to helm_db\"\n                                     end })\n\n\n\n\nreturn helm_db\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/reflect",
hash = "8bb0ab8aced18bf16c311c7a9bc8cce93bf6bf6cdc9b7bade4b2ca4ecf6962b1",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ffi = require \"ffi\"\nlocal bit = require \"bit\"\nlocal reflect = {}\n\nlocal CTState, init_CTState\nlocal miscmap, init_miscmap\n\nlocal function gc_str(gcref) -- Convert a GCref (to a GCstr) into a string\n  if gcref ~= 0 then\n    local ts = ffi.cast(\"uint32_t*\", gcref)\n    return ffi.string(ts + 4, ts[3])\n  end\nend\n\nlocal typeinfo = rawget(ffi, \"typeinfo\")\n\ntypeinfo = typeinfo or function(id)\n  -- ffi.typeof is present in LuaJIT v2.1 since 8th Oct 2014 (d6ff3afc)\n  -- this is an emulation layer for older versions of LuaJIT\n  local ctype = (CTState or init_CTState()).tab[id]\n  return {\n    info = ctype.info,\n    size = bit.bnot(ctype.size) ~= 0 and ctype.size,\n    sib = ctype.sib ~= 0 and ctype.sib,\n    name = gc_str(ctype.name),\n  }\nend\n\nlocal function memptr(gcobj)\n  return tonumber(tostring(gcobj):match\"%x*$\", 16)\nend\n\ninit_CTState = function()\n  -- Relevant minimal definitions from lj_ctype.h\n  ffi.cdef [[\n    typedef struct CType {\n      uint32_t info;\n      uint32_t size;\n      uint16_t sib;\n      uint16_t next;\n      uint32_t name;\n    } CType;\n\n    typedef struct CTState {\n      CType *tab;\n      uint32_t top;\n      uint32_t sizetab;\n      void *L;\n      void *g;\n      void *finalizer;\n      void *miscmap;\n    } CTState;\n  ]]\n\n  -- Acquire a pointer to this Lua universe\'s CTState\n  local co = coroutine.create(function()end) -- Any live coroutine will do.\n  local uint32_ptr = ffi.typeof(\"uint32_t*\")\n  local G = ffi.cast(uint32_ptr, ffi.cast(uint32_ptr, memptr(co))[2])\n  -- In global_State, `MRef ctype_state` is immediately before `GCRef gcroot[GCROOT_MAX]`.\n  -- We first find (an entry in) gcroot by looking for a metamethod name string.\n  local anchor = ffi.cast(\"uint32_t\", ffi.cast(\"const char*\", \"__index\"))\n  local i = 0\n  while math.abs(tonumber(G[i] - anchor)) > 64 do\n    i = i + 1\n  end\n  -- We then work backwards looking for something resembling ctype_state.\n  repeat\n    i = i - 1\n    CTState = ffi.cast(\"CTState*\", G[i])\n  until ffi.cast(uint32_ptr, CTState.g) == G\n\n  return CTState\nend\n\ninit_miscmap = function()\n  -- Acquire the CTState\'s miscmap table as a Lua variable\n  local t = {}; t[0] = t\n  local tvalue = ffi.cast(\"uint32_t*\", memptr(t))[2]\n  ffi.cast(\"uint32_t*\", tvalue)[ffi.abi\"le\" and 0 or 1] = ffi.cast(\"uint32_t\", ffi.cast(\"uintptr_t\", (CTState or init_CTState()).miscmap))\n  miscmap = t[0]\n  return miscmap\nend\n\n-- Information for unpacking a `struct CType`.\n-- One table per CT_* constant, containing:\n-- * A name for that CT_\n-- * Roles of the cid and size fields.\n-- * Whether the sib field is meaningful.\n-- * Zero or more applicable boolean flags.\nlocal CTs = {[0] =\n  {\"int\",\n    \"\", \"size\", false,\n    {0x08000000, \"bool\"},\n    {0x04000000, \"float\", \"subwhat\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n    {0x00400000, \"long\"},\n  },\n  {\"struct\",\n    \"\", \"size\", true,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"union\", \"subwhat\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"ptr\",\n    \"element_type\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"ref\", \"subwhat\"},\n  },\n  {\"array\",\n    \"element_type\", \"size\", false,\n    {0x08000000, \"vector\"},\n    {0x04000000, \"complex\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00100000, \"vla\"},\n  },\n  {\"void\",\n    \"\", \"size\", false,\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n  },\n  {\"enum\",\n    \"type\", \"size\", true,\n  },\n  {\"func\",\n    \"return_type\", \"nargs\", true,\n    {0x00800000, \"vararg\"},\n    {0x00400000, \"sse_reg_params\"},\n  },\n  {\"typedef\", -- Not seen\n    \"element_type\", \"\", false,\n  },\n  {\"attrib\", -- Only seen internally\n    \"type\", \"value\", true,\n  },\n  {\"field\",\n    \"type\", \"offset\", true,\n  },\n  {\"bitfield\",\n    \"\", \"offset\", true,\n    {0x08000000, \"bool\"},\n    {0x02000000, \"const\"},\n    {0x01000000, \"volatile\"},\n    {0x00800000, \"unsigned\"},\n  },\n  {\"constant\",\n    \"type\", \"value\", true,\n    {0x02000000, \"const\"},\n  },\n  {\"extern\", -- Not seen\n    \"CID\", \"\", true,\n  },\n  {\"kw\", -- Not seen\n    \"TOK\", \"size\",\n  },\n}\n\n-- Set of CType::cid roles which are a CTypeID.\nlocal type_keys = {\n  element_type = true,\n  return_type = true,\n  value_type = true,\n  type = true,\n}\n\n-- Create a metatable for each CT.\nlocal metatables = {\n}\nfor _, CT in ipairs(CTs) do\n  local what = CT[1]\n  local mt = {__index = {}}\n  metatables[what] = mt\nend\n\n-- Logic for merging an attribute CType onto the annotated CType.\nlocal CTAs = {[0] =\n  function(a, refct) error(\"TODO: CTA_NONE\") end,\n  function(a, refct) error(\"TODO: CTA_QUAL\") end,\n  function(a, refct)\n    a = 2^a.value\n    refct.alignment = a\n    refct.attributes.align = a\n  end,\n  function(a, refct)\n    refct.transparent = true\n    refct.attributes.subtype = refct.typeid\n  end,\n  function(a, refct) refct.sym_name = a.name end,\n  function(a, refct) error(\"TODO: CTA_BAD\") end,\n}\n\n-- C function calling conventions (CTCC_* constants in lj_refct.h)\nlocal CTCCs = {[0] =\n  \"cdecl\",\n  \"thiscall\",\n  \"fastcall\",\n  \"stdcall\",\n}\n\nlocal function refct_from_id(id) -- refct = refct_from_id(CTypeID)\n  local ctype = typeinfo(id)\n  local CT_code = bit.rshift(ctype.info, 28)\n  local CT = CTs[CT_code]\n  local what = CT[1]\n  local refct = setmetatable({\n    what = what,\n    typeid = id,\n    name = ctype.name,\n  }, metatables[what])\n\n  -- Interpret (most of) the CType::info field\n  for i = 5, #CT do\n    if bit.band(ctype.info, CT[i][1]) ~= 0 then\n      if CT[i][3] == \"subwhat\" then\n        refct.what = CT[i][2]\n      else\n        refct[CT[i][2]] = true\n      end\n    end\n  end\n  if CT_code <= 5 then\n    refct.alignment = bit.lshift(1, bit.band(bit.rshift(ctype.info, 16), 15))\n  elseif what == \"func\" then\n    refct.convention = CTCCs[bit.band(bit.rshift(ctype.info, 16), 3)]\n  end\n\n  if CT[2] ~= \"\" then -- Interpret the CType::cid field\n    local k = CT[2]\n    local cid = bit.band(ctype.info, 0xffff)\n    if type_keys[k] then\n      if cid == 0 then\n        cid = nil\n      else\n        cid = refct_from_id(cid)\n      end\n    end\n    refct[k] = cid\n  end\n\n  if CT[3] ~= \"\" then -- Interpret the CType::size field\n    local k = CT[3]\n    refct[k] = ctype.size or (k == \"size\" and \"none\")\n  end\n\n  if what == \"attrib\" then\n    -- Merge leading attributes onto the type being decorated.\n    local CTA = CTAs[bit.band(bit.rshift(ctype.info, 16), 0xff)]\n    if refct.type then\n      local ct = refct.type\n      ct.attributes = {}\n      CTA(refct, ct)\n      ct.typeid = refct.typeid\n      refct = ct\n    else\n      refct.CTA = CTA\n    end\n  elseif what == \"bitfield\" then\n    -- Decode extra bitfield fields, and make it look like a normal field.\n    refct.offset = refct.offset + bit.band(ctype.info, 127) / 8\n    refct.size = bit.band(bit.rshift(ctype.info, 8), 127) / 8\n    refct.type = {\n      what = \"int\",\n      bool = refct.bool,\n      const = refct.const,\n      volatile = refct.volatile,\n      unsigned = refct.unsigned,\n      size = bit.band(bit.rshift(ctype.info, 16), 127),\n    }\n    refct.bool, refct.const, refct.volatile, refct.unsigned = nil\n  end\n\n  if CT[4] then -- Merge sibling attributes onto this type.\n    while ctype.sib do\n      local entry = typeinfo(ctype.sib)\n      if CTs[bit.rshift(entry.info, 28)][1] ~= \"attrib\" then break end\n      if bit.band(entry.info, 0xffff) ~= 0 then break end\n      local sib = refct_from_id(ctype.sib)\n      sib:CTA(refct)\n      ctype = entry\n    end\n  end\n\n  return refct\nend\n\nlocal function sib_iter(s, refct)\n  repeat\n    local ctype = typeinfo(refct.typeid)\n    if not ctype.sib then return end\n    refct = refct_from_id(ctype.sib)\n  until refct.what ~= \"attrib\" -- Pure attribs are skipped.\n  return refct\nend\n\nlocal function siblings(refct)\n  -- Follow to the end of the attrib chain, if any.\n  while refct.attributes do\n    refct = refct_from_id(refct.attributes.subtype or typeinfo(refct.typeid).sib)\n  end\n\n  return sib_iter, nil, refct\nend\n\nmetatables.struct.__index.members = siblings\nmetatables.func.__index.arguments = siblings\nmetatables.enum.__index.values = siblings\n\nlocal function find_sibling(refct, name)\n  local num = tonumber(name)\n  if num then\n    for sib in siblings(refct) do\n      if num == 1 then\n        return sib\n      end\n      num = num - 1\n    end\n  else\n    for sib in siblings(refct) do\n      if sib.name == name then\n        return sib\n      end\n    end\n  end\nend\n\nmetatables.struct.__index.member = find_sibling\nmetatables.func.__index.argument = find_sibling\nmetatables.enum.__index.value = find_sibling\n\nfunction reflect.typeof(x) -- refct = reflect.typeof(ct)\n  return refct_from_id(tonumber(ffi.typeof(x)))\nend\n\nfunction reflect.getmetatable(x) -- mt = reflect.getmetatable(ct)\n  return (miscmap or init_miscmap())[-tonumber(ffi.typeof(x))]\nend\n\nreturn reflect\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/search",
hash = "cc3fc0422166fb5bad84c9bc6e47aeb987a679ae1a3b829a925aa2feed51c546",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal clone = import(\"core/table\", \"clone\")\nlocal EditBase = require \"helm/raga/edit\"\nlocal Rainbuf = require \"helm/rainbuf\"\nlocal Txtbuf = require \"helm/txtbuf\"\n\nlocal Search = clone(EditBase, 2)\n\nSearch.name = \"search\"\nSearch.prompt_char = \"⁉️\"\n\n\n\n\n\n\n\n\nfunction Search.onTxtbufChanged(modeS)\n   local searchResult = modeS.hist:search(tostring(modeS.txtbuf))\n   modeS.txtbuf.active_suggestions = searchResult[1]\n   modeS:setResults(searchResult)\nend\n\n\n\n\n\n\nlocal NAV = Search.NAV\n\nfunction NAV.SHIFT_DOWN(modeS, category, value)\n   local search_buf = modeS.hist.last_collection\n   if not search_buf then return end\n   local search_result = search_buf[1]\n   if search_result:selectNext() then\n      if search_result.selected_index >= search_buf.offset + modeS.zones.results:height() then\n        search_buf:scrollDown()\n      end\n      modeS.zones.command:beTouched()\n      modeS.zones.results:beTouched()\n   end\nend\n\n\n\nfunction NAV.SHIFT_UP(modeS, category, value)\n   local search_buf = modeS.hist.last_collection\n   if not search_buf then return end\n   local search_result = search_buf[1]\n   if search_result:selectPrevious() then\n      if search_result.selected_index < search_buf.offset then\n         search_buf:scrollUp()\n      end\n      modeS.zones.command:beTouched()\n      modeS.zones.results:beTouched()\n   end\nend\n\n\n\nfunction NAV.ESC(modeS, category, value)\n   local search_buf = modeS.hist.last_collection\n   local search_result = search_buf and search_buf[1]\n   -- No results or nothing is selected, exit search mode\n   if not search_result or search_result.selected_index == 0 then\n      modeS.shift_to = modeS.raga_default\n      modeS:setResults(\"\")\n   -- If something *is* selected, deselect it first\n   else\n      search_result.selected_index = 0\n      modeS.zones.command:beTouched()\n      modeS.zones.results:beTouched()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nNAV.DOWN      = NAV.SHIFT_DOWN\nNAV.TAB       = NAV.SHIFT_DOWN\nNAV.UP        = NAV.SHIFT_UP\nNAV.SHIFT_TAB = NAV.SHIFT_UP\n\nlocal function _modeShiftOnDeleteWhenEmpty(modeS, category, value)\n   if tostring(modeS.txtbuf) == \"\" then\n      modeS.shift_to = modeS.raga_default\n      modeS:setResults(\"\")\n   else\n      EditBase(modeS, category, value)\n   end\nend\n\nNAV.BACKSPACE = _modeShiftOnDeleteWhenEmpty\nNAV.DELETE    = _modeShiftOnDeleteWhenEmpty\n\n\n\n\n\n\n\nlocal function _acceptAtIndex(modeS, selected_index)\n   local search_result = modeS.hist.last_collection[1]\n   local line, result\n   if #search_result > 0 then\n      selected_index = selected_index or search_result.selected_index\n      if selected_index == 0 then selected_index = 1 end\n      line, result = modeS.hist:index(search_result.cursors[selected_index])\n   end\n   modeS.shift_to = modeS.raga_default\n   modeS:setTxtbuf(Txtbuf(line), result)\n   modeS:setResults(result)\nend\n\nfunction NAV.RETURN(modeS, category, value)\n   _acceptAtIndex(modeS)\nend\n\nlocal function _makeControl(num)\n   return function(modeS, category, value)\n      _acceptAtIndex(modeS, num)\n   end\nend\n\nfor i = 1, 9 do\n   Search.ALT[\"M-\" ..tostring(i)] = _makeControl(i)\nend\n\n\n\n\n\n\nfunction Search.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         modeS.raga.NAV.SHIFT_DOWN(modeS, category, value)\n      elseif value.button == \"MB1\" then\n         modeS.raga.NAV.SHIFT_UP(modeS, category, value)\n      end\n   end\nend\n\n\n\nreturn Search\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/base",
hash = "97ef0af467964d0b5955da67782b15c274545a4c506e02ad84234c150118a68d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal a         = require \"anterm:anterm\"\n\nlocal concat         = assert(table.concat)\nlocal sub, gsub, rep = assert(string.sub),\n                       assert(string.gsub),\n                       assert(string.rep)\n\n\n\n\n\n\n\n\nlocal RagaBase_meta = {}\nlocal RagaBase = setmetatable({}, RagaBase_meta)\n\nfor _, cat in ipairs{\"NAV\", \"CTRL\", \"ALT\", \"ASCII\",\n                     \"UTF8\", \"PASTE\", \"MOUSE\", \"NYI\"} do\n   RagaBase[cat] = {}\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRagaBase.CTRL[\"^Q\"] = function(modeS, category, value)\n   -- #todo it\'s obviously terrible to have code specific to a particular\n   -- piece of functionality in an abstract class like this.\n   -- To do this right, we probably need a proper raga stack. Then -n could\n   -- push the Review raga onto the bottom of the stack, then Nerf. Quit\n   -- at this point would be the result of the raga stack being empty,\n   -- rather than an explicitly-invoked command, and Ctrl-Q would just pop\n   -- the current raga. Though, a Ctrl-Q from e.g. Search would still want\n   -- to actually quit, so it\'s not quite that simple...\n   -- Anyway. Also, don\'t bother saving the session if it has no premises...\n   if _Bridge.args.new_session and #modeS.hist.session > 0 then\n      -- #todo Add the ability to change accepted status of\n      -- the whole session to the review interface\n      modeS.hist.session.accepted = true\n      -- Also, it\'s horribly hacky to change the \"default\" raga, but it\'s\n      -- the only way to make Modal work properly. A proper raga stack\n      -- would *definitely* fix this\n      modeS.raga_default = \"review\"\n      modeS.shift_to = \"review\"\n      modeS:setStatusLine(\"review\", modeS.hist.session.session_title)\n   else\n      modeS:quit()\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasfield, iscallable = import(\"core/table\", \"hasfield\", \"iscallable\")\n\nfunction RagaBase_meta.__call(raga, modeS, category, value)\n   -- Dispatch on value if possible\n   if hasfield(raga[category], value) then\n      raga[category][value](modeS, category, value)\n   -- Or on category if the whole category is callable\n   elseif iscallable(raga[category]) then\n      raga[category](modeS, category, value)\n   -- Otherwise indicate that we didn\'t know what to do with the input\n   else\n      return false\n   end\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.getCursorPosition(modeS)\n   return nil\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onTxtbufChanged(modeS)\n   return\nend\n\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onCursorChanged(modeS)\n   return\nend\n\n\n\n\n\n\n\n\n\nfunction RagaBase.onShift(modeS)\n   return\nend\n\n\n\n\n\n\n\n\nfunction RagaBase.onUnshift(modeS)\n   return\nend\n\n\n\n\nreturn RagaBase\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/raga/review",
hash = "2fa7375366f075d394a016f25478fbbfd7c63f042f7f1683950d0f795b5bf893",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal clone = assert(require \"core:table\" . clone)\nlocal RagaBase = require \"helm:raga/base\"\nlocal Txtbuf = require \"helm:txtbuf\"\nlocal Sessionbuf = require \"helm:sessionbuf\"\n\n\n\nlocal Review = clone(RagaBase, 2)\nReview.name = \"review\"\nReview.prompt_char = \"💬\"\n\n\n\n\n\n\n\n\n\nlocal function _toSessionbuf(fn)\n   return function(modeS, category, value)\n      local buf = modeS.zones.results.contents\n      local answer = buf[fn](buf)\n      modeS.zones.results:beTouched()\n      return answer\n   end\nend\n\nlocal function _onSelectionChanged(modeS)\n   local zone = modeS.zones.results\n   local buf = zone.contents\n   modeS.txtbuf:replace(buf:selectedPremise().title)\n   local start_index = buf:positionOfSelected()\n   local end_index = start_index + buf:rowsForSelectedResult() + 3\n   modeS.zones.results:ensureVisible(start_index, end_index)\n   modeS.zones.results:beTouched()\nend\n\nlocal function _selectUsing(fn)\n   return function(modeS, category, value)\n      local buf = modeS.zones.results.contents\n      local answer = buf[fn](buf)\n      _onSelectionChanged(modeS)\n      return answer\n   end\nend\n\n\n\n\n\n\nlocal NAV = Review.NAV\n\nNAV.UP   = _selectUsing \"selectPreviousWrap\"\nNAV.DOWN = _selectUsing \"selectNextWrap\"\n\nNAV.SHIFT_UP   = _toSessionbuf \"scrollResultsUp\"\nNAV.SHIFT_DOWN = _toSessionbuf \"scrollResultsDown\"\n\nNAV.TAB = _toSessionbuf \"toggleSelectedState\"\nNAV.SHIFT_TAB = _toSessionbuf \"toggleSelectedState\"\n\nfunction NAV.RETURN(modeS, category, value)\n   if modeS.zones.results.contents.selected_index ~= 0 then\n      modeS.shift_to = \"edit_title\"\n   end\nend\n\nNAV.ALT_UP   = _toSessionbuf \"movePremiseUp\"\nNAV.ALT_DOWN = _toSessionbuf \"movePremiseDown\"\n\n\n\n\n\n\n\n\nReview.CTRL[\"^Q\"] = function(modeS, category, value)\n   modeS:showModal(\'Save changes to the session \"\'\n      .. modeS.hist.session.session_title .. \'\"?\',\n      \"yes_no_cancel\")\nend\n\n\n\n\n\n\n\n\n\n\nfunction Review.MOUSE(modeS, category, value)\n   if value.scrolling then\n      if value.button == \"MB0\" then\n         NAV.SHIFT_UP(modeS, category, value)\n      elseif value.button == \"MB1\" then\n         NAV.SHIFT_DOWN(modeS, category, value)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Review.onShift(modeS)\n   -- Hide the suggestion column so the review interface can occupy\n   -- the full width of the terminal.\n   -- #todo once we are able to switch between REPLing and review\n   -- on the fly, we\'ll need to put this back as appropriate, but I\n   -- think that\'ll come naturally once we have a raga stack.\n   modeS.zones.suggest:hide()\n\n   local modal_answer = modeS:modalAnswer()\n   if modal_answer then\n      if modal_answer == \"yes\" then\n         modeS.hist.session:save()\n         modeS:quit()\n      elseif modal_answer == \"no\" then\n         modeS:quit()\n      end -- Do nothing on cancel\n      return\n   end\n\n   local contents = modeS.zones.results.contents\n   if not contents or contents.idEst ~= Sessionbuf then\n      local buf = Sessionbuf(modeS.hist.session, { scrollable = true })\n      modeS.zones.results:replace(buf)\n      local premise = buf:selectedPremise()\n      modeS.txtbuf:replace(premise and premise.title or \"\")\n   else\n      _onSelectionChanged(modeS)\n   end\nend\n\n\n\nreturn Review\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/fuzz_patt",
hash = "56ec93fdd6235c4fc1c3889202067af9434e6dd48e52b950358241886bf72194",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L        = require \"lpeg\"\nlocal P, match = L.P, L.match\nlocal Codepoints = require \"singletons/codepoints\"\n\nlocal function fuzz_patt(frag)\n   frag = type(frag) == \"string\" and Codepoints(frag) or frag\n   local patt = P(true)\n   for i = 1 , #frag do\n      local v = frag[i]\n      patt = patt * (P(1) - P(v))^0 * P(v)\n   end\n   return patt\nend\n\nreturn fuzz_patt\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/lex",
hash = "60e155a33391a727382bde55482b0b30c6fbcfb6710cb5385db664bcc78fc48b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, R, S, match = L.P, L.R, L.S, L.match\nlocal Lex = meta {}\nlocal sub, gsub = assert(string.sub), assert(string.gsub)\nlocal concat, insert = assert(table.concat), assert(table.insert)\n\n\n\n\n\n\nlocal WS = (P\" \")^1\n\nlocal NL = P\"\\n\"\n\nlocal terminal = S\" \\\"\'+-*^~%#;,<>={}[]().:\\n\" + -P(1)\n\nlocal keyword = (P\"function\" + \"local\" + \"for\" + \"in\" + \"do\"\n           + \"and\" + \"or\" + \"not\" + \"true\" + \"false\"\n           + \"while\" + \"break\" + \"if\" + \"then\" + \"else\" + \"elseif\"\n           + \"goto\" + \"repeat\" + \"until\" + \"return\" + \"nil\"\n           + \"end\") * #terminal\n\nlocal operator = P\"+\" + \"-\" + \"*\" + \"/\" + \"%\" + \"^\" + \"#\"\n           + \"==\" + \"~=\" + \"<=\" + \">=\" + \"<\" + \">\"\n           + \"=\" + \"(\" + \")\" + \"{\" + \"}\" + \"[\" + \"]\"\n           + \";\" + \":\" + \"...\" + \"..\" + \".\" + \",\"\n\nlocal digit = R\"09\"\n\nlocal _decimal = P\"-\"^0 * ((digit^1 * P\".\"^-1 * digit^0\n                           * ((P\"e\" + P\"E\")^-1 * P\"-\"^-1 * digit^1)^-1\n                        + digit^1)^1 + digit^1)\n\nlocal higit = R\"09\" + R\"af\" + R\"AF\"\n\n-- hexadecimal floats. are a thing. that exists. in luajit.\nlocal _hexadecimal = P\"-\"^0 * P\"0\" * (P\"x\" + P\"X\")\n                        * ((higit^1 * P\".\"^-1 * higit^0\n                           * ((P\"p\" + P\"P\")^-1 * P\"-\"^-1 * higit^1)^-1\n                        + higit^1)^1 + higit^1)\n\n-- long strings, straight from the LPEG docs\nlocal _equals = P\"=\"^0\nlocal _open = \"[\" * L.Cg(_equals, \"init\") * \"[\" * P\"\\n\"^-1\nlocal _close = \"]\" * L.C(_equals) * \"]\"\nlocal _closeeq = L.Cmt(_close * L.Cb(\"init\"),\n                          function (s, i, a, b) return a == b end)\n\nlocal long_str = (_open * L.C((P(1) - _closeeq)^0) * _close) / 0 * L.Cp()\n\nlocal str_esc = P\"\\\\\" * (S\"abfnrtvz\\\\\'\\\"[]\\n\"\n                         + (R\"09\" * R\"09\"^-2)\n                         + (P\"x\" + P\"X\") * higit * higit)\n\nlocal double_str = P\"\\\"\" * (P(1) - (P\"\\\"\" + P\"\\\\\") + str_esc)^0 * P\"\\\"\"\nlocal single_str = P\"\\\'\" * (P(1) - (P\"\\\'\" + P\"\\\\\") + str_esc)^0 * P\"\\\'\"\n\nlocal string_short = double_str + single_str\n\nlocal string_long = long_str\n\nlocal letter = R\"az\" + R\"AZ\"\n\nlocal symbol =   (-digit * -terminal * P(1))^1\n               * (-terminal * P(1))^0\n               * #terminal\n\nlocal number = _hexadecimal + _decimal\n\nlocal comment = P\"--\" * long_str\n              + P\"--\" * (P(1) - NL)^0 * (NL + - P(1))\n\nlocal ERR = P(1)^1\n\nlocal lua_toks = {comment, keyword, string_long, string_short, number, operator, symbol,\n                  WS, NL, ERR}\n\nlocal color_map = {\n   [keyword] = \"keyword\",\n   [operator] = \"operator\",\n   [number] = \"number\",\n   [symbol] = \"field\",\n   [string_short] = \"string\",\n   [string_long] = \"string\",\n   [comment] = \"comment\",\n   [ERR] = \"error\",\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function chomp_token(lb, start_pos)\n   for _,v in ipairs(lua_toks) do\n      local end_pos = match(v, lb, start_pos)\n      if end_pos ~= nil then\n         return sub(lb, start_pos, end_pos - 1), end_pos, v\n      end\n   end\n   return nil\nend\n\nlocal Token = require \"repr:token\"\nlocal inbounds = assert(require \"core:math\" . inbounds)\nlocal instanceof = assert(require \"core:meta\" . instanceof)\nlocal Txtbuf = require \"helm:txtbuf\"\n\nfunction Lex.lua_thor(code, cursor_index)\n   local toks = {}\n   cursor_index = cursor_index or 0\n   local fixup_cursor = false\n   local pos = 1\n   while pos <= #code do\n      local bite, new_pos, tok_t = chomp_token(code, pos)\n      assert(bite and #bite > 0, \"lua-thor has failed you\")\n      local cfg = { color = color_map[tok_t] or \"no_color\" }\n      if inbounds(cursor_index, pos + 1, new_pos) then\n         -- The cursor should not be considered to be \"within\" a punctuation\n         -- or whitespace token, but rather should be part of the subsequent\n         -- identifier if any, or if not, we will create an empty one\n         if bite:find(\"^[.:]$\")\n            or (bite:find(\"^ +$\") and tostring(toks[#toks]):find(\"^[.:]$\")) then\n            fixup_cursor = true\n         else\n            cfg.cursor_offset = cursor_index - pos\n         end\n      elseif fixup_cursor then\n         fixup_cursor = false\n         if cfg.color ~= \"field\" then\n            insert(toks, Token(\"\", { color = \"field\", cursor_offset = 0 }))\n         else\n            cfg.cursor_offset = 0\n         end\n      end\n      -- Would love to highlight escape sequences in strings,\n      -- but this turns out to be rather difficult...\n      insert(toks, Token(bite, cfg))\n      pos = new_pos\n   end\n   if fixup_cursor then\n      insert(toks, Token(\"\", { color = \"field\", cursor_offset = 0 }))\n   end\n   return toks\nend\n\n\n\n\n\n\n\nfunction Lex.null(code, cursor_index)\n   return { Token(code, { color = \"no_color\", cursor_offset = cursor_index - 1 }) }\nend\n\n\n\nreturn Lex\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/historian",
hash = "9a247a9a44eaf5c5eabb1c81a526cedf0d80631ee18aa7e09e659ca5a6101208",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv      = require \"luv\"\nlocal sql     = assert(sql, \"sql must be in bridge _G\")\n\nlocal Resbuf  = require \"helm:resbuf\"\nlocal Session = require \"helm:session\"\nlocal persist_tabulate = require \"repr:persist-tabulate\"\nlocal helm_db = require \"helm:helm-db\"\n\nlocal concat, insert = assert(table.concat), assert(table.insert)\nlocal reverse = require \"core/table\" . reverse\nlocal meta = require \"core/meta\" . meta\nlocal sha = assert(require \"util:sha\" . shorthash)\n\nlocal Set = require \"set:set\"\n\n\n\n\n\n\nlocal Historian = meta {}\nHistorian.HISTORY_LIMIT = 2000\nHistorian.helm_db_home = helm_db.helm_db_home\nHistorian.project = uv.cwd()\n\n\n\n\n\nfunction Historian.createPreparedStatements(historian, helm_db_home)\n   if helm_db_home then\n      historian.helm_db_home = helm_db_home\n   end\n   local stmts = helm_db.historian(historian.helm_db_home)\n   historian.stmts = stmts\n   historian.insert_line = stmts.insert_line\n   historian.insert_repr = stmts.insert_repr\n   historian.insert_result_hash = stmts.insert_result_hash\n   historian.get_results = stmts.get_results\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal clamp, inbounds = import(\"core:core/math\", \"clamp\", \"inbounds\")\nlocal assertfmt = import(\"core:core/string\", \"assertfmt\")\nlocal format = assert(string.format)\n\nfunction Historian.load(historian)\n   local stmts = historian.stmts\n   -- Retrieve project id\n   local proj_val, proj_row = stmts.get_project\n                                      : bind(historian.project)\n                                      : resultset \'i\'\n   if not proj_val then\n      proj_val, proj_row = stmts.insert_project\n                             : bind(historian.project)\n                             : step()\n      -- retry\n      proj_val, proj_row = stmts.get_project\n                                      : bind(historian.project)\n                                      : resultset \'i\'\n      if not proj_val then\n         error \"Could not create project in .bridge\"\n      end\n   end\n   local project_id = proj_val[1][1]\n   historian.project_id = project_id\n   -- Retrieve history\n   local number_of_lines = stmts.get_number_of_lines\n                             :bind(project_id):step()[1]\n   if number_of_lines == 0 then\n      return nil\n   end\n   number_of_lines = clamp(number_of_lines, nil, historian.HISTORY_LIMIT)\n   local pop_stmt = stmts.get_recent\n                      : bindkv { project = project_id,\n                                 num_lines = number_of_lines }\n   historian.cursor = number_of_lines + 1\n   historian.cursor_start = number_of_lines + 1\n   historian.n = number_of_lines\n   local counter = number_of_lines\n   local idler\n   local function load_one()\n      local res = pop_stmt:step()\n      if not res then\n         if idler then idler:stop() end\n         return nil\n      end\n      historian[counter] = res[2]\n      historian.line_ids[counter] = res[1]\n      -- Results are loaded backwards because that\'s how they\'re accessed\n      counter = counter - 1\n   end\n   -- add one line to ensure we have history on startup\n   load_one()\n   -- idle to populate the rest of the history\n   idler = uv.new_idle()\n   idler:start(load_one)\nend\n\n\n\n\n\n\n\n\nlocal tabulate = require \"repr:tabulate\"\nlocal tabulate_some = assert(persist_tabulate.tabulate_some)\nlocal no_color = assert(require \"singletons:color\" . no_color)\nfunction Historian.persist(historian, line, results)\n   if type(results) ~= \"table\" or results.n == 0 then\n      results = nil\n   end\n   if line == \"\" then\n      -- A blank line can have no results and is uninteresting.\n      return false\n   end\n   historian.stmts.savepoint_persist()\n   historian.insert_line:bindkv { project = historian.project_id,\n                                       line    = sql.blob(line) }\n   local err = historian.insert_line:step()\n   if not err then\n      historian.insert_line:clearbind():reset()\n   else\n      error(err)\n   end\n   local line_id = historian.stmts.lastRowId()\n   insert(historian.line_ids, line_id)\n   -- If there\'s nothing to persist, release our savepoint\n   -- and don\'t bother starting the idler\n   if not results then\n      historian.stmts.release_persist()\n      return line_id\n   end\n\n   local persist_cb = tabulate_some(results)\n   local persist_idler = uv.new_idle()\n   historian.idlers:insert(persist_idler)\n   persist_idler:start(function()\n      local done, results_tostring = persist_cb()\n      if not done then return nil end\n      -- inform the Session that persisted results are available\n      historian.session:resultsAvailable(line_id, results_tostring)\n      -- now persist\n      for i = 1, results.n do\n         local hash = sha(results_tostring[i])\n         historian.insert_repr:bind(hash, results_tostring[i])\n         err = historian.insert_repr:step()\n         if not err then\n            historian.insert_repr :clearbind() :reset()\n         else\n            error(err)\n         end\n         historian.insert_result_hash:bind(line_id, hash)\n         err = historian.insert_result_hash:step()\n         if not err then\n            historian.insert_result_hash :clearbind() :reset()\n         else\n            error(err)\n         end\n      end\n      historian.stmts.release_persist()\n      persist_idler:stop()\n      assert(historian.idlers:remove(persist_idler) == true)\n   end)\n   return line_id\nend\n\n\n\n\n\n\n\n\n\n\nfunction Historian.append(historian, line, results, success)\n   if line == \"\" or line == historian[historian.n] then\n      -- don\'t bother\n      return false\n   end\n   historian.n = historian.n + 1\n   historian[historian.n] = line\n   if not success then results = nil end\n   historian.result_buffer[historian.n] = results\n   local line_id = historian:persist(line, results)\n   historian.session:append(line_id, line, results)\n   return true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal SelectionList = require \"helm/selection_list\"\nlocal fuzz_patt = require \"helm:helm/fuzz_patt\"\n\nfunction Historian.search(historian, frag)\n   if historian.last_collection\n      and historian.last_collection[1].lit_frag == frag then\n      -- don\'t repeat a search\n      return historian.last_collection\n   end\n   if frag == \"\" then\n      return \"\"\n   end\n   local result = SelectionList()\n   result.cursors = {}\n   result.frag = frag\n   result.lit_frag = frag\n   result.best = true\n   result.show_shortcuts = true\n   local function try_search()\n      local patt = fuzz_patt(result.frag)\n      local dup = {}\n      for i = historian.n, 1, -1 do\n         local item_str = tostring(historian[i])\n         if not dup[item_str] and patt:match(item_str) then\n            dup[item_str] = true\n            insert(result, item_str)\n            insert(result.cursors, i)\n         end\n      end\n   end\n   try_search()\n   if #result == 0 then\n      result.best = false\n      result.frag = frag:sub(1, -3) .. frag:sub(-1, -1) .. frag:sub(-2, -2)\n      try_search()\n   end\n   historian.last_collection = Resbuf({ result, n = 1 }, { live = true })\n   historian.last_collection.made_in = \"historian.search\"\n   return historian.last_collection\nend\n\n\n\nlocal db_result_M = assert(persist_tabulate.db_result_M)\n\nlocal function _resultsFrom(historian, cursor)\n   if historian.result_buffer[cursor] then\n      return historian.result_buffer[cursor]\n   end\n   local line_id = historian.line_ids[cursor]\n   local stmt = historian.get_results\n   stmt:bindkv {line_id = line_id}\n   local results = stmt :resultset \'i\'\n   if results then\n      results = results[1]\n      results.n = #results\n      for i = 1, results.n do\n         -- stick the result in a table to enable repr-ing\n         results[i] = {results[i]}\n         setmetatable(results[i], db_result_M)\n      end\n   end\n   stmt:reset()\n   -- may as well memoize the database call, while we\'re here\n   historian.result_buffer[line_id] = results\n   return results\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.delta(historian, delta)\n   historian.cursor = clamp(historian.cursor + delta, 1, historian.n + 1)\n   local line = historian[historian.cursor]\n   if line then\n      local result = _resultsFrom(historian, historian.cursor)\n      return line, result\n   else\n      return nil, nil\n   end\nend\n\nfunction Historian.prev(historian)\n   return historian:delta(-1)\nend\nfunction Historian.next(historian)\n   return historian:delta(1)\nend\n\n\n\n\n\n\n\n\n\nfunction Historian.index(historian, cursor)\n   assert(inbounds(cursor, 1, historian.n))\n   historian.cursor = cursor\n   local line = historian[cursor]\n   local result = _resultsFrom(historian, cursor)\n   return line, result\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal __result_buffer_M = meta {}\nfunction __result_buffer_M.__repr(buf, window, c)\n   return c.alert \"cowardly refusing to print result_buffer to avoid infinite appending\"\nend\n\nlocal function new(helm_db)\n   local historian = meta(Historian)\n   historian.line_ids = {}\n   historian.cursor = 0\n   historian.cursor_start = 0\n   historian.n = 0\n   historian:createPreparedStatements(helm_db)\n   historian:load()\n   local session_cfg = {}\n   local session_title = _Bridge.args.macro or\n                         _Bridge.args.new_session or\n                         _Bridge.args.session\n   if _Bridge.args.macro then\n      session_cfg.accepted = true\n      session_cfg.mode = \"macro\"\n   end\n   local sesh = Session(helm_db,\n                        historian.project_id,\n                        session_title,\n                        session_cfg)\n   -- Asked to create a session that already exists\n   if (_Bridge.args.new_session or _Bridge.args.macro) and sesh.session_id then\n      error(\'A session named \"\' .. session_title ..\n            \'\" already exists. You can review it with br helm -s.\')\n   end\n   if _Bridge.args.session then\n      if sesh.session_id then\n         sesh:loadPremises()\n      else\n         -- Asked to review a session that doesn\'t exist\n         error(\'No session named \"\' .. session_title ..\n               \'\" found. Use br helm -n to create a new session.\')\n      end\n   end\n   historian.session = sesh\n   historian.result_buffer = setmetatable({}, __result_buffer_M)\n   historian.idlers = Set()\n   return historian\nend\n\nHistorian.idEst = new\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "fa5a31a3f9b0ab64ab29a2b11331e8f95b46a726",
name = "helm/modeselektor",
hash = "047be60b515546f72261e99aa550a873b20b254fb2c712a6b95b118eae356a5e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nassert(meta, \"must have meta in _G\")\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal Valiant = require \"valiant:valiant\"\n\nlocal Txtbuf     = require \"helm:txtbuf\"\nlocal Resbuf     = require \"helm:resbuf\"\nlocal Historian  = require \"helm:historian\"\nlocal Lex        = require \"helm:lex\"\nlocal Zoneherd   = require \"helm:zone\"\nlocal Suggest    = require \"helm:suggest\"\nlocal repr       = require \"repr:repr\"\nlocal lua_parser = require \"helm:lua-parser\"\n\nlocal concat               = assert(table.concat)\nlocal sub, gsub, rep, find = assert(string.sub),\n                             assert(string.gsub),\n                             assert(string.rep),\n                             assert(string.find)\n\nlocal ts = repr.ts_color\n\n\n\n\nlocal ModeS = meta()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeS.REPL_LINE = 2\nModeS.PROMPT_WIDTH = 3\n\n\n\n\n\n\n\nfunction ModeS.errPrint(modeS, log_stmt)\n   modeS.zones.suggest:replace(log_stmt)\n   modeS:paint()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c = import(\"singletons:color\", \"color\")\n\nlocal STAT_ICON = \"◉ \"\n\nlocal function tf(bool)\n   return bool and c[\"true\"](\"t\") or c[\"false\"](\"f\")\nend\n\nlocal function mouse_paint(m)\n   return c.userdata(STAT_ICON)\n      .. a.magenta(m.button) .. \": \"\n      .. tf(m.shift) .. \" \"\n      .. tf(m.meta) .. \" \"\n      .. tf(m.ctrl) .. \" \"\n      .. tf(m.moving) .. \" \"\n      .. tf(m.scrolling) .. \" \"\n      .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)\nend\n\nlocal function mk_paint(fragment, shade)\n   return function(action)\n      return shade(fragment .. action)\n   end\nend\n\nlocal function paste_paint(frag)\n   local result\n   -- #todo handle escaping of special characters in pasted data\n   if #frag < 20 then\n      result = \"PASTE: \" .. frag\n   else\n      result = (\"PASTE(%d): %s...\"):format(#frag, frag:sub(1, 17))\n   end\n   return a.green(STAT_ICON .. result)\nend\n\nlocal icon_map = { MOUSE = mouse_paint,\n                   NAV   = mk_paint(STAT_ICON, a.magenta),\n                   CTRL  = mk_paint(STAT_ICON, a.blue),\n                   ALT   = mk_paint(STAT_ICON, c[\"function\"]),\n                   ASCII = mk_paint(STAT_ICON, a.green),\n                   UTF8  = mk_paint(STAT_ICON, a.green),\n                   PASTE = paste_paint,\n                   NYI   = mk_paint(STAT_ICON .. \"! \", a.red) }\n\nlocal function _make_icon(category, value)\n   return icon_map[category](value)\nend\n\n\n\n\n\n\n\n\nlocal Point = require \"anterm:point\"\nfunction ModeS.placeCursor(modeS)\n   local point = modeS.raga.getCursorPosition(modeS)\n   if point then\n      modeS.write(a.jump(point), a.cursor.show())\n   end\n   return modeS\nend\n\n\n\n\n\n\n\n\nfunction ModeS.paint(modeS)\n   modeS.zones:paint(modeS)\n   modeS:placeCursor(modeS)\n   return modeS\nend\n\n\n\n\n\n\nfunction ModeS.reflow(modeS)\n   modeS.zones:reflow(modeS)\n   modeS:paint()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\nModeS.raga_default = \"nerf\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.continuationLines(modeS)\n   return modeS.txtbuf and #modeS.txtbuf - 1 or 0\nend\n\n\n\n\n\n\n\nfunction ModeS.updatePrompt(modeS)\n   local prompt = modeS.raga.prompt_char .. \" \" .. (\"\\n...\"):rep(modeS:continuationLines())\n   modeS.zones.prompt:replace(prompt)\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Nerf      = require \"helm:raga/nerf\"\nlocal Search    = require \"helm:raga/search\"\nlocal Complete  = require \"helm:raga/complete\"\nlocal Page      = require \"helm:raga/page\"\nlocal Modal     = require \"helm:raga/modal\"\nlocal Review    = require \"helm:raga/review\"\nlocal EditTitle = require \"helm:raga/edit-title\"\n\nModeS.closet = { nerf =       { raga = Nerf,\n                                lex  = Lex.lua_thor },\n                 search =     { raga = Search,\n                                lex  = Lex.null },\n                 complete =   { raga = Complete,\n                                lex  = Lex.lua_thor },\n                 page =       { raga = Page,\n                                lex  = Lex.null },\n                 review =     { raga = Review,\n                                lex  = Lex.null },\n                 edit_title = { raga = EditTitle,\n                                lex = Lex.null },\n                 modal =      { raga = Modal,\n                                lex  = Lex.null } }\n\nfunction ModeS.shiftMode(modeS, raga_name)\n   -- Stash the current lexer associated with the current raga\n   -- Currently we never change the lexer separate from the raga,\n   -- but this will change when we start supporting multiple languages\n   -- Guard against nil raga or lexer during startup\n   if modeS.raga then\n      modeS.raga.onUnshift(modeS)\n      modeS.closet[modeS.raga.name].lex = modeS.txtbuf.lex\n   end\n   -- Switch in the new raga and associated lexer\n   modeS.raga = modeS.closet[raga_name].raga\n   modeS.txtbuf.lex = modeS.closet[raga_name].lex\n   modeS.raga.onShift(modeS)\n   modeS:updatePrompt()\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.actOnce(modeS, category, value)\n   local handled = modeS.raga(modeS, category, value)\n   if modeS.shift_to then\n      modeS:shiftMode(modeS.shift_to)\n      modeS.shift_to = nil\n   end\n   if modeS.txtbuf.contents_changed then\n      modeS.zones.command:beTouched()\n      modeS.raga.onTxtbufChanged(modeS)\n    -- Treat contents_changed as implying cursor_changed\n    -- only ever fire one of the two events\n   elseif modeS.txtbuf.cursor_changed then\n      modeS.raga.onCursorChanged(modeS)\n   end\n    modeS.txtbuf.contents_changed = false\n    modeS.txtbuf.cursor_changed = false\n   -- Check shift_to again in case one of the cursor handlers set it\n   if modeS.shift_to then\n      modeS:shiftMode(modeS.shift_to)\n      modeS.shift_to = nil\n   end\n   return handled\nend\n\n\n\nfunction ModeS.act(modeS, category, value)\n   local icon = _make_icon(category, value)\n   local handled = false\n   repeat\n      modeS.action_complete = true\n      -- The raga may set action_complete to false to cause the command\n      -- to be re-processed, most likely after a mode-switch\n      local handledThisTime = modeS:actOnce(category, value)\n      handled = handled or handledThisTime\n   until modeS.action_complete == true\n   if not handled then\n      local val_rep = string.format(\"%q\",value):sub(2,-2)\n      icon = _make_icon(\"NYI\", category .. \": \" .. val_rep)\n   end\n\n   -- Replace zones\n   modeS.zones.stat_col:replace(icon)\n   modeS:updatePrompt()\n   -- Reflow in case command height has changed. Includes a paint.\n   -- Don\'t allow errors encountered here to break this entire\n   -- event-loop iteration, otherwise we become unable to quit if\n   -- there\'s a paint error.\n   local success, err = xpcall(modeS.reflow, debug.traceback, modeS)\n   if not success then\n      io.stderr:write(err, \"\\n\")\n      io.stderr:flush()\n   end\n   collectgarbage()\n   return modeS\nend\n\n\n\n\n\nfunction ModeS.__call(modeS, category, value)\n   return modeS:act(category, value)\nend\n\n\n\n\n\n\n\n\n\nlocal instanceof = import(\"core:meta\", \"instanceof\")\n\nfunction ModeS.setResults(modeS, results)\n   results = results or \"\"\n   if results == \"\" then\n      modeS.zones.results:replace(results)\n      return modeS\n   end\n   local cfg = { scrollable = true }\n   if type(results) == \"string\" then\n      cfg.frozen = true\n      results = { results, n = 1 }\n   end\n   modeS.zones.results:replace(Resbuf(results, cfg))\n   return modeS\nend\n\n\n\n\n\n\n\n\n\n\nModeS.status_lines = { default = \"an repl, plz reply uwu 👀\",\n                       quit    = \"exiting repl, owo... 🐲\",\n                       restart = \"restarting an repl ↩️\",\n                       review  = \'reviewing session \"%s\"\' }\nModeS.status_lines.macro = ModeS.status_lines.default .. \' (macro-recording \"%s\")\'\nModeS.status_lines.new_session = ModeS.status_lines.default .. \' (recording \"%s\")\'\n\nfunction ModeS.setStatusLine(modeS, status_name, ...)\n   local status_line = modeS.status_lines[status_name]:format(...)\n   modeS.zones.status:replace(status_line)\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS.setTxtbuf(modeS, txtbuf)\n   -- Copy the lexer and suggestions over to the new Txtbuf\n   -- #todo keep the same Txtbuf around (updating it using :replace())\n   -- rather than swapping it out\n   txtbuf.lex = modeS.txtbuf.lex\n   txtbuf.active_suggestions = modeS.txtbuf.active_suggestions\n   modeS.txtbuf = txtbuf\n   modeS.txtbuf.cursor_changed = true\n   modeS.txtbuf.contents_changed = true\n   modeS.zones.command:replace(modeS.txtbuf)\n   return modeS\nend\n\n\n\n\n\n\nlocal eval = Valiant(_G, __G)\n\n\n\nlocal insert = assert(table.insert)\nlocal keys = assert(core.keys)\n\nfunction ModeS.eval(modeS)\n   -- Getting ready to eval, cancel any active autocompletion\n   modeS.suggest:cancel(modeS)\n   local line = tostring(modeS.txtbuf)\n   local success, results = eval(line)\n   if not success and results == \'advance\' then\n      modeS.txtbuf:endOfText()\n      modeS.txtbuf:nl()\n   else\n      modeS.hist:append(line, results, success)\n      modeS.hist.cursor = modeS.hist.n + 1\n      modeS:setResults(results)\n      modeS:setTxtbuf(Txtbuf())\n   end\n\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS.evalFromCursor(modeS)\n   local top = modeS.hist.n\n   local cursor = modeS.hist.cursor\n   for i = cursor, top do\n      -- Discard the second return value from :index\n      -- or it will confuse the Txtbuf constructor rather badly\n      local line = modeS.hist:index(i)\n      modeS:setTxtbuf(Txtbuf(line))\n      modeS:eval()\n   end\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS.quit(modeS)\n   -- #todo handle this better--as an event of sorts, maybe?\n   local session = modeS.hist.session\n   if session.mode == \"macro\" and #session > 0 then\n      session:save()\n   end\n   modeS:setStatusLine(\"quit\")\n   modeS.has_quit = true\nend\n\n\n\n\n\n\n\n\nfunction ModeS.restart(modeS)\n   modeS :setStatusLine \'restart\'\n   -- remove existing result\n   modeS :setResults \"\" :paint()\n   -- perform rerun\n   -- Replace results:\n   local hist = modeS.hist\n   local top = hist.n\n   hist.n = hist.cursor_start - 1\n   -- put instrumented require in restart mode\n   eval:restart()\n   hist.stmts.savepoint_restart_session()\n   for i = hist.cursor_start, top do\n      local success, results = eval(tostring(hist[i]))\n      assert(results ~= \"advance\", \"Incomplete line when restarting session\")\n      hist:append(hist[i], results, success, modeS.session)\n   end\n   eval:reset()\n   assert(hist.n == #hist, \"History length mismatch after restart: n = \"\n         .. tostring(hist.n) .. \", # = \" , tostring(#hist))\n   modeS :setResults(hist.result_buffer[hist.cursor]) :paint()\n   uv.timer_start(uv.new_timer(), 1500, 0,\n                  function()\n                     modeS :setStatusLine \'default\' :paint()\n                  end)\n   local restart_idle = uv.new_idle()\n   restart_idle:start(function()\n      if #hist.idlers > 0 then\n         return nil\n      end\n      hist.stmts.release_restart_session()\n      restart_idle:stop()\n   end)\n   return modeS\nend\n\n\n\n\n\n\n\nfunction ModeS.openHelp(modeS)\n  -- #todo this should be a generic Rainbuf\n   local rb = Resbuf{ (\"abcde \"):rep(1000), n = 1 }\n   modeS.zones.popup:replace(rb)\n   modeS.shift_to = \"page\"\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction ModeS.showModal(modeS, text, button_style)\n   local modal_info = Modal.newModel(text, button_style)\n   -- #todo make DialogModel a kind of Rainbuf? Or use a generic one?\n   modeS.zones.modal:replace(Resbuf{ modal_info, n = 1 })\n   modeS.shift_to = \"modal\"\n   return modeS\nend\n\n\n\n\n\n\n\n\n\nfunction ModeS.modalAnswer(modeS)\n   local contents = modeS.zones.modal.contents\n   return (contents and contents.is_rainbuf) and contents[1].value or nil\nend\n\n\n\n\n\n\n\nlocal function _status__repr(status_table)\n   return concat(status_table)\nend\n\nlocal _stat_M = meta {}\n_stat_M.__repr = _status__repr\n\nfunction _stat_M.clear(status_table)\n   return setmetatable({}, getmetatable(status_table))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal deepclone = assert(core.deepclone)\nlocal function new(max_extent, writer, db)\n   local modeS = meta(ModeS)\n\n   modeS.txtbuf = Txtbuf()\n   modeS.hist  = Historian(db)\n   modeS.suggest = Suggest()\n   modeS.status = setmetatable({}, _stat_M)\n   rawset(__G, \"stat\", modeS.status)\n   modeS.max_extent = max_extent\n   modeS.write = writer\n   modeS.repl_top = ModeS.REPL_LINE\n   modeS.zones = Zoneherd(modeS, writer)\n   modeS.zones.command:replace(modeS.txtbuf)\n   -- If we are loading an existing session, start in review mode\n   local session = modeS.hist.session\n   if session.session_id then\n      modeS.raga_default = \"review\"\n      modeS:setStatusLine(\"review\", session.session_title)\n   elseif session.session_title then\n      modeS:setStatusLine(\n         session.mode == \"macro\" and \"macro\" or \"new_session\",\n         session.session_title)\n   else\n      modeS:setStatusLine(\"default\")\n   end\n   -- initial state\n   modeS:shiftMode(modeS.raga_default)\n   modeS.action_complete = true\n   modeS.shift_to = nil\n   return modeS\nend\n\nModeS.idEst = new\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/lash.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/lash.git",
    home = "",
    website = "",
    name = "lash",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "e1ecc0c8802ce66ad9f70bf068a9a333758b2871",
name = "lash",
hash = "09210eddf39cf67221e03ef4960c4f98dff5ad573f53a7ce8c5102d2aa84aa51",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Sh = {}\n\n\n\n\n-- make a safe-escaped, POSIX-compliant literal string,\n-- with the \'quote marks\'\nlocal function sh_str(str)\n    return table.concat {\"\'\", str:gsub(\"\'\", \"\'\\\\\'\'\"), \"\'\"}\nend\n-- borrowed with gratitude from:\n-- https://github.com/zserge/luash/blob/master/sh.lua\n\n-- converts key and it\'s argument to \"-k\" or \"-k=v\" or just \"\"\nlocal function arg(k, a)\n    if not a then return k end\n    if type(a) == \'string\' and #a > 0 then return k .. \'=\' .. sh_str(a) end\n    if type(a) == \'number\' then return k..\'=\'..tostring(a) end\n    if type(a) == \'boolean\' and a == true then return k end\n    error(\'invalid argument type \' .. type(a) .. \" \" .. tostring(a))\nend\n\n-- converts nested tables into a flat list of arguments and concatenated input\nlocal function flatten(t)\n    local result = {args = {}}\n\n    local function f(t)\n        local keys = {}\n        for k = 1, #t do\n            keys[k] = true\n            local v = t[k]\n            if type(v) == \'table\' then\n                f(v)\n            else\n                table.insert(result.args, v)\n            end\n        end\n        for k, v in pairs(t) do\n            if k == \'__input\' then\n                result.input = result.input or \'\'\n                result.input = result.input .. v\n            elseif not keys[k] and k:sub(1, 1) ~= \'_\' then\n                local key = \'-\'..k\n                if #k > 1 then key = \'-\' ..key end\n                table.insert(result.args, arg(key, v))\n            end\n        end\n    end\n\n    f(t)\n    return result\nend\n\n-- returns a function that executes the command with given args and returns its\n-- output, exit status etc\nlocal function command(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n        local p = io.popen(s, \'r\')\n        local output = p:read(\'*a\')\n        local _, exit, status = p:close()\n\n        local t = {\n            __input = output,\n            __exitcode = exit == \'exit\' and status or 127,\n            __signal = exit == \'signal\' and status or 0,\n        }\n        local mt = {\n            __index = function(self, k)\n                return command(k)\n            end,\n            __tostring = function(self)\n                -- return trimmed command output as a string\n                return self.__input:match(\'^%s*(.-)%s*$\')\n            end,\n            __repr = function(self)\n                return string.gmatch(self.__input, \"[^\\n]+\")\n            end\n        }\n        return setmetatable(t, mt)\n    end\nend\n\n-- export command() function\nSh.command = command\n\n\n\n\n\n\n\n\n\nlocal function preview(cmd, ...)\n    local prearg = {...}\n    return function(...)\n        local args = flatten({...})\n        local s = cmd\n        for _, v in ipairs(prearg) do\n            s = s .. \' \' .. v\n        end\n        for k, v in pairs(args.args) do\n            s = s .. \' \' .. v\n        end\n\n        if args.input then\n            s = \"echo \" .. sh_str(args.input) .. \" | \" .. s\n        end\n       return s\n    end\nend\n\nSh.preview = preview\n\n\n\n\n\n-- allow to call sh to run shell commands\nlocal Sh_M = {\n    __call = function(_, cmd, ...)\n        return command(cmd, ...)()\n    end,\n    __index = function(_, field)\n        return command(field)\n    end\n}\nsetmetatable(Sh, Sh_M)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.install(_Global)\n    local Global\n    local VER = string.sub( assert( _VERSION ), -4 )\n    if _Global and _Global ~= Sh then\n        Global = _Global\n    elseif VER == \" 5.1\" then\n        Global = getfenv()\n    else\n        Global = _ENV\n    end\n    local G_mt, G_index = nil, nil\n    local at_top = false\n    local our_mt = false\n    while not at_top do\n        local maybe_mt = getmetatable(Global)\n        if not maybe_mt then\n            at_top = true\n        else\n            -- we have a metatable\n            G_mt = maybe_mt\n            -- but is it the ultimate?\n            if G_mt.__index then\n                if type(G_mt.__index) == \"function\" then\n                    at_top = true\n                    G_index = G_mt.__index\n                elseif getmetatable(G_mt.__index) then\n                    at_top = false\n                    Global = G_mt.__index\n                else\n                    at_top = true\n                    G_index = G_mt.__index\n                end\n            else\n                at_top = true\n            end\n        end\n    end\n    -- if _ENV has no metatable, let\'s make one:\n    if not G_mt then\n        our_mt = true\n        G_mt = {}\n    end\n    -- *now* we can monkey-patch the global environment\n    local __index_fn\n    -- three flavors:\n    if not G_index then\n        __index_fn = function(_, cmd)\n                        return command(cmd)\n                     end\n    elseif type(G_index) == \"table\" then\n        __index_fn = function(_, key)\n                        local v = rawget(G_index, key)\n                        if v ~= nil then return v end\n                        return command(key)\n                     end\n    elseif type(G_index) == \"function\" then\n        __index_fn = function(_, key)\n                        local ok, v = pcall(G_index, _, key)\n                        if ok and (v ~= nil) then return v end\n                        return command(key)\n                     end\n    end\n    --- now set the metatable:\n    G_mt.__index = __index_fn\n    setmetatable(Global, G_mt)\n    -- stash the components for later removal\n    -- put them on the lash metatable to avoid polluting the\n    -- command space or global environment\n    Sh_M.__cache = { Global = Global,\n                     our_mt = our_mt,\n                     G_index = G_index,\n                     index_fn = __index_fn }\n    -- return Sh for convenience\n    return Sh\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Sh.remove()\n    if not Sh_M.__cache then\n        -- didn\'t patch the namespace,\n        -- or already removed it\n        return false\n    end\n    local cache = Sh_M.__cache\n    if cache.our_mt then\n        -- we made the metatable, let\'s remove the whole thing\n        setmetatable(cache.Global, nil)\n    else\n        -- if there was no G_index this will set it to nil\n        -- but only if our index function is still present.\n        local G_mt = getmetatable(cache.Global)\n        if G_mt.__index == cache.index_fn then\n            G_mt.__index = cache.G_index\n        end\n    end\n    -- remove cache\n    Sh_M.__cache = nil\n    return true\nend\n\n\n\nreturn Sh\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/lon.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/lon.git",
    home = "",
    website = "",
    name = "lon",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "df41f0fb6bf691cc11f9fd50a61cf40d5565fd20",
name = "loml",
hash = "36af7759ec9098e07959f77e64b742ca6c78eb3130c76a4cf16bea82326781d6",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal Node = require \"espalier:espalier/node\"\n\nlocal s = require \"status:status\" ()\n\n\nlocal loml_str = [=[\n\n;; Overall Structure\n\n   loml    <-  expression (nl expression)* (wschar / nl)* Error?\n\n`expression` <-  ws keyval ws comment?\n             /  ws table  ws comment?\n             /  ws comment\n             /  ws &nl\n\n;; Whitespace\n\n        `ws`  <-  {\\t }*\n    `wschar`  <-  {\\t }+\n\n;; Newline\n\n        `nl`  <- \"\\n\" / \"\\r\\n\"\n\n;; Comment\n\n     comment  <- \"#\" (!nl 1)*\n\n;; Key-Value pairs\n\n      keyval  <-  key ws \"=\" ws val\n               /  key ws \"=\" ws Error\n\n         key  <-  dotted-key / simple-key\n\n`simple-key`  <-  quoted-key / unquoted-key\n\nunquoted-key  <-  ([A-Z] / [a-z] / [0-9] / \"-\" / \"_\")+\n\n  quoted-key  <-  basic-string / literal-string\n\n  dotted-key  <-  simple-key (ws \".\" ws simple-key)+\n\n         val  <-  string / boolean / array / inline-table\n                  / date-time / float / integer\n\n;; String\n\n        `string`  <-  ml-basic-string   / basic-string\n                  /   ml-literal-string / literal-string\n\n;; Note: this isn\'t technically TOML, because we\'ll use Lua string\n;; conventions. I have no interest in implementing \\u.\n\n    basic-string  <-  \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* \'\"\'\n                  /   \'\"\' (\'\\\\\' \'\"\' / (!\'\"\' !\"\\n\" 1))* &\"\\n\" Error\n\n ml-basic-string  <- \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' 1) / &\'\"\"\"\"\' \'\"\')* \'\"\"\"\'\n                  /  \'\"\"\"\' (\'\\\\\' \'\"\' / (!\'\"\"\"\' !-2 1))* Error\n\n  literal-string  <-  \"\'\"  (!\"\'\" !\"\\n\" 1)* \"\'\"\n                  /   \"\'\"  (!\"\'\" !\"\\n\" 1)* &\"\\n\" Error\n\nml-literal-string <- \"\'\'\'\" (!\"\'\'\'\" 1 / (&\"\'\'\'\'\" !\"\'\'\'\'\'\'\") \"\'\")* \"\'\'\'\"\n                  /  \"\'\'\'\" (!\"\'\'\'\" !-2 1)* Error\n\n;; Integer\n\n    integer  <-  hexadecimal / octal / binary / decimal\n\n    decimal  <-  sign? dec-int\n\n       sign  <-  \"+\" / \"-\"\n\n  `dec-int`  <-  [1-9] ([0-9] / \"_\" [0-9])+ / [0-9]\n\nhexadecimal  <-  \"0x\" higit (higit / \"_\" higit)*\n\n    `higit`  <- [A-F] / [a-f] / [0-9]\n\n      octal  <- \"0o\" [0-7] ([0-7] / \"_\" [0-7])*\n\n     binary  <- \"0b\" [0-1] ([0-1] / \"_\" [0-1])*\n\n;; Float\n\nfloat <- decimal \".\" decimal* ((\"e\" / \"E\") \"-\"? decimal)?\n      /  special-float\n\nspecial-float = sign? (\"inf\" / \"nan\")\n\n;; Boolean\n\nboolean = \"true\" / \"false\"\n\n;;; Not in the mood to port dates from \'ortho8600\'\n;; Date and Time (as defined in RFC 3339)\n\ndate-time <- \"placeholder@#$%@$#%\"\n\n;; Offset Date-Time\n\noffset-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date-Time\n\nlocal-date-time <- \"placeholder@#$%@$#%\"\n\n;; Local Date\n\nlocal-date <- \"placeholder@#$%@$#%\"\n\n;; Local Time\n\nlocal-time <- \"placeholder@#$%@$#%\"\n\n;; Array\n\n        array  <-  \"[\" array-values? opt-comment \"]\"\n\n`opt-comment`  <-  (ws comment? nl ws)+ / ws\n\n array-values  <-  opt-comment val (opt-comment \",\" opt-comment val)* \",\"*\n\n;; Table\n\ntable  <-  std-table / array-table\n\n;; Standard Table\n\nstd-table  <-  \"[\" ws key ws \"]\"\n\n;; Inline Table\n\ninline-table <-  \"{\" ws (keyval (ws \",\" ws keyval)*)* ws \"}\"\n\n;; Array Table\n\narray-table <- \"[[\" ws key ws \"]]\"\n\n;; Error\n\nError  <-  1+\n]=]\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub, gsub, byte, format = assert(string.sub),\n                                assert(string.gsub),\n                                assert(string.byte),\n                                assert(string.format)\n\n\n\n\nlocal Twig = Node:inherit()\n\n\n\n\n\n\nfunction Twig.value(twig)\n   return twig:span()\nend\n\n\n\n\nlocal Loml = Twig :inherit \'loml\'\n\nfunction Loml.toTable(loml)\n   local tab = {}\n   local work = tab\n   for _, twig in ipairs(loml) do\n      work = twig:toTable(tab, work)\n   end\n   return tab\nend\n\n\n\nlocal Keyval = Twig: inherit \'keyval\'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _noredefine(tab, field, node)\n   if tab[field] ~= nil then\n      local line, col = node:linePos()\n      local errmsg = format(\"attempt to redefine field \'%s\'\"\n                             ..\" at line %d, column %d\", field, line, col)\n      error(errmsg, 2)\n   end\nend\n\nlocal function _lvalue(tab, keynode)\n   if keynode[1].id ~= \'dotted_key\' then\n      local val = keynode:value()\n      _noredefine(tab, val, keynode)\n      return tab, val\n   else\n      local to_assign = tab\n      keynode = keynode[1]\n      for i = 1, #keynode - 1 do\n         local val = keynode[i]:value()\n         to_assign[val] = to_assign[val] or {}\n         to_assign = to_assign[val]\n      end\n      local val = keynode[#keynode]:value()\n      _noredefine(to_assign, val, keynode[#keynode])\n      return to_assign, val\n   end\nend\n\n\nfunction Keyval.toTable(keyval, tab, work)\n   if keyval[2].id == \'Error\' then\n      s:halt(\"erroneous value at line %d, col %d\", keyval[2]:linePos())\n   end\n   -- this part is actually a bit tricky, since we need to assign to the\n   -- correct field in a table with potentially unbounded subtables, e.g.\n   -- table.subtable.\"deep subtable\" etc.\n   local lval, lfield = _lvalue(work, keyval[1])\n   lval[lfield] = keyval[2]:value()\n   return work\nend\n\n\n\nlocal Val = Twig :inherit \'val\'\n\nfunction Val.value(val)\n   return val[1]:value()\nend\n\n\n\n\nlocal QuotedKey = Twig :inherit \'quoted_key\'\n\nfunction QuotedKey.value(quote)\n   return quote[1]:value()\nend\n\n\n\n\n\n\nlocal Table = Twig :inherit \'table\'\n\nfunction Table.toTable(tabnode, tab, work)\n   return tabnode[1]:toTable(tab, work)\nend\n\n\n\nlocal StdTable = Twig :inherit \'std_table\'\n\nfunction StdTable.toTable(std_tab, tab, work)\n   local lval, field = _lvalue(tab, std_tab[1])\n   lval[field] = lval[field] or {}\n   return lval[field]\nend\n\n\n\nlocal ArrayTable = Twig :inherit \'array_table\'\n\nfunction ArrayTable.toTable(array, tab, work)\n   local lval, field = _lvalue(tab, array[1])\n   -- get or create table\n   lval[field] = lval[field] or {}\n   -- create subtable\n   lval[field][#lval[field] + 1] = {}\n   return lval[field][#lval[field]]\nend\n\n\n\nlocal InlineTable = Twig :inherit \'inline_table\'\n\nfunction InlineTable.value(inline)\n   local work = {}\n   for keyval in inline :select \'keyval\' do\n      keyval:toTable(nil, work)\n   end\n   return work\nend\n\n\n\n\n\n\n\n\nlocal Array = Twig :inherit \'array\'\n\nfunction Array.value(arraynode)\n   local array = {}\n   local vals = arraynode :select \'array_values\' ()\n   if not vals then return array end\n   for _, val in ipairs(vals) do\n      array[#array + 1] = val:value()\n   end\n   return array\nend\n\n\n\n\n\n\n\nlocal LiteralString = Twig :inherit \'literal_string\'\n\nfunction LiteralString.value(litstr)\n   return sub(litstr.str, litstr.first + 1, litstr.last - 1)\nend\n\n\n\n\nlocal BasicString = Twig :inherit \'basic_string\'\n\nfunction BasicString.value(str)\n   return setfenv(load(\"return \".. str:span()), {})()\nend\n\n\n\nlocal MLLiteralString = Twig :inherit \'ml_literal_string\'\n\n\n\nfunction MLLiteralString.value(litstr)\n   -- have to skip a leading newline\n   local front = byte(litstr.str, litstr.first + 3) == 10 and 4 or 3\n   return sub(litstr.str, litstr.first + front, litstr.last - 3)\nend\n\n\n\nlocal MLBasicString = Twig :inherit \'ml_basic_string\'\n\nfunction MLBasicString.value(mlstr)\n   local span = mlstr:span()\n   local front = byte(span, 4) == 10 and 5 or 4\n   -- clip front and back\n   -- do \\ substitution\n   -- replace newlines with \\n\n   -- unescape any \\\" to \"\n   -- escape \" (which happens to undo any effect of the above!)\n   -- replace \\\\\" with \\\\\\\" (yeah. we have to. I know. but we do.)\n   -- now we have a string, load it prepended with \'return \' and\n   -- in a clean fenv for good measure!\n   return setfenv(load(\'return \"\' .. sub(span, front, -4)\n                        :gsub(\'\\\\%s+\', \"\")\n                        :gsub(\'\\n\', \"\\\\n\")\n                        :gsub(\'\\\\\"\', \'\"\')\n                        :gsub(\'\"\', \'\\\\\"\')\n                        :gsub(\'\\\\\\\\\"\', \'\\\\\\\\\\\\\"\') .. \'\"\'), {})()\n   --]]\nend\n\n\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nlocal function tonum(num)\n   return tonumber((gsub(num, \"_\", \"\")))\nend\n\n\n\nlocal Integer = Twig :inherit \'integer\'\n\nfunction Integer.value(int)\n   return int[1]:value()\nend\n\n\n\nlocal Float = Twig :inherit \'float\'\n\nfunction Float.value(float)\n   return tonum(float:span())\nend\n\n\n\n\nlocal Decimal = Twig :inherit \'decimal\'\n\nDecimal.value = Float.value\n\n\n\nlocal Hex = Twig :inherit \'hexadecimal\'\n\nHex.value = Float.value\n\n\n\nlocal Octal = Twig :inherit \'octal\'\n\nfunction Octal.value(octal)\n   return tonum(octal.str:sub(octal.first + 2, octal.last), 8)\nend\n\n\n\nlocal Binary = Twig :inherit \'binary\'\n\nfunction Binary.value(binary)\n   return tonum(binary.str:sub(binary.first + 2, binary.last), 2)\nend\n\n\n\n\n\n\nlocal Boolean = Twig :inherit \'boolean\'\n\nfunction Boolean.value(boolean)\n   -- we just check if the first letter is \'t\'\n   return byte(boolean.str, boolean.first) == 116 and true or false\nend\n\n\n\n\n\n\nlocal Comment = Twig :inherit \'comment\'\n\nfunction Comment.toTable(tab)\n   return\nend\n\n-- this would probably cause problems, but also shouldn\'t happen\nComment.value = Comment.toTable\n\n\n\n\n\nlocal Loml_M = { Twig,\n                 loml = Loml,\n                 keyval = Keyval,\n                 val = Val,\n                 quoted_key = QuotedKey,\n                 table = Table,\n                 std_table = StdTable,\n                 array_table = ArrayTable,\n                 array = Array,\n                 inline_table = InlineTable,\n                 literal_string = LiteralString,\n                 ml_literal_string = MLLiteralString,\n                 ml_basic_string = MLBasicString,\n                 basic_string = BasicString,\n                 integer = Integer,\n                 float  = Float,\n                 hexadecimal = Hex,\n                 octal = Octal,\n                 decimal = Decimal,\n                 binary = Binary,\n                 boolean = Boolean,\n                 comment = Comment,\n\n }\n\n\n\nreturn Peg(loml_str, Loml_M)\n\n",
},
} },
{
  project = {
    repo = "https://github.com/mnemnion/orb.git",
    repo_alternates = "https://gitlab.com/special-circumstance/orb.git\nhttps://gitlab.com/atman/orb.git\nhttps://gitlab.special-circumstanc.es/bridge-tools/orb.git",
    home = "",
    website = "",
    name = "orb",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/metas/docmetas",
hash = "a837dc8d3abc8c1b1233d573c31839c122e0275d55289b4f471e694db8d88e9a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal DocMetas = {}\n\n\n\n\n\n\n\nlocal Doc_M = Twig:inherit \"doc\"\nDocMetas.doc = Doc_M\n\n\n\nfunction Doc_M.toMarkdown(doc, scroll)\n   for _, block in ipairs(doc) do\n      block:toMarkdown(scroll)\n   end\nend\n\n\n\n\n\n\n\n\nlocal Skein;\nfunction Doc_M.toSkein(doc)\n   Skein = Skein or require \"orb:orb/skein\"\nend\n\n\n\nlocal Section_M = Twig:inherit \"section\"\nDocMetas.section = Section_M\n\n\n\nfunction Section_M.toMarkdown(section, scroll)\n   for _, block in ipairs(section) do\n      block:toMarkdown(scroll)\n   end\nend\n\n\n\nreturn DocMetas\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "compile/commit",
hash = "fa5c10b6713868f818779dff0dbb003e3b9b2d1bd256d9833c77ae38e25e05b9",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.verbose = false\nlocal sql = assert(sql, \"must have sql in bridge _G\")\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal uv  = require \"luv\"\nlocal sha = require \"compile/sha2\" . sha3_512\nlocal database = require \"orb:compile/database\"\n\n\n\nlocal commit = {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\nlocal function commitModule(stmt, bytecode, project_id, bundle_id,\n                            version_id, git_info, now)\n   -- get code_id from the hash\n   local code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmt.new_code:bindkv(bytecode):step()\n      stmt.code_id:reset()\n      code_id = unwrapKey(stmt.code_id:bindkv(bytecode):resultset(\"i\"))\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmt.add_module:bindkv(mod):step()\n   for _, st in pairs(stmt) do\n      st:reset()\n   end\nend\n\ncommit.commitModule = commitModule\n\n\n\n\n\n\nlocal sh = require \"orb:util/sh\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction commit.commitCodex(codex)\n   local conn = database.open()\n   local now = tostring(date())\n   -- begin transaction\n   conn:exec \"BEGIN TRANSACTION;\"\n   -- select project_id\n   local project_id = database.project(conn, codex:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, codex:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmt = { code_id = conn:prepare(get_code_id_by_hash),\n                  new_code = conn:prepare(new_code),\n                  add_module = conn:prepare(add_module) }\n   for _, bytecode in pairs(codex.bytecodes) do\n      commitModule(stmt,\n                   bytecode,\n                   project_id,\n                   bundle_id,\n                   version_id,\n                   codex.git_info,\n                   now)\n   end\n   -- commit transaction\n   conn:exec \"COMMIT;\"\n   -- use a pcall because we get a (harmless) error if the table is locked\n   -- by another process:\n   pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n   -- set up an idler to close the conn, so that e.g. busy\n   -- exceptions don\'t blow up the hook\n   local close_idler = uv.new_idle()\n   close_idler:start(function()\n      local success = pcall(conn.close, conn)\n      if not success then\n        return nil\n      else\n        close_idler:stop()\n        uv.stop()\n      end\n   end)\n   if not uv.loop_alive() then\n      uv.run \"default\"\n   end\nend\n\n\n\n\nreturn commit\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "manifest/manifest",
hash = "9b96b60f663ae44b2110ff57b79c2bb97d071f434385018c7c1dc4c192f1bb3b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core:core/cluster\" . Meta\nlocal Toml = require \"lon:loml\"\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\nlocal Manifest = meta {}\n\n\n\n\nlocal function _addBlock(manifest, block)\n   -- quick sanity check\n   assert(block and block.isNode, \"manifest() must receive a Node\")\n   local codebody = block :select \"code_body\" ()\n   local contents = Toml(codebody) :toTable()\n   if contents then\n      for k,v in pairs(contents) do\n         manifest[k] = v\n      end\n   else\n       s:halt(\"no contents generated from #manifest block, line %d\",\n              block:linePos())\n   end\nend\n\n\n\n\nfunction Manifest.__call(manifest, msg)\n   if msg == true then\n      -- we make and return a new Manifest instance\n      return meta(manifest)\n   end\n   -- otherwise this should be a codeblock\n   local block = msg\n   _addBlock(manifest, block)\nend\n\n\n\n\n\nlocal function new(block)\n   local manifest = meta(Manifest)\n   if block then\n      _addBlock(manifest, block)\n   end\n   return manifest\nend\n\nManifest.idEst = new\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "knit/predicator",
hash = "4e791c5318b3f460bd5fc89d3fb8caca60c194212b003dde56391745256e197b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nreturn function(hashtag)\n   return function(codeblock, skein)\n      local tags = skein.tags[codeblock]\n      if tags and tags(hashtag) then\n         return true\n      else\n         return false\n      end\n   end\nend\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/doc",
hash = "019d53cee98cc1f01499f419e1fdd51919a9bb05939a20f57c04cb0d7a963319",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg   = require \"espalier:peg\"\nlocal table = require \"core:core/table\"\n\n\n\nlocal Twig      = require \"orb:orb/metas/twig\"\nlocal Header    = require \"orb:orb/header\"\nlocal Codeblock = require \"orb:orb/codeblock\"\nlocal Table     = require \"orb:orb/table\"\nlocal Prose     = require \"orb:orb/prose\"\nlocal List      = require \"orb:orb/list\"\nlocal Listline  = require \"orb:orb/list-line\"\nlocal fragments = require \"orb:orb/fragments\"\n\n\n\n\n\n\n\n\nlocal Doc_str = [[\n            doc  ←  (first-section / section) section*\n`first-section`  ←  blocks / block-sep\n\n        section  ←  header line-end blocks*\n         header  ←  \" \"* \"*\"+ \" \" (!\"\\n\" 1)*\n                 /   \" \"* \"*\"+ &\"\\n\"\n\n       `blocks`  ←  block (block-sep* block)* block-sep*\n        `block`  ←  structure\n                 /  paragraph\n    `structure`  ←  codeblock\n                 /  blockquote\n                 /  table\n                 /  list\n                 /  handle-line\n                 /  hashtag-line\n                 /  note\n                 /  link-line\n                 /  drawer\n      block-sep  ←  \"\\n\\n\" \"\\n\"*\n\n      codeblock  ←  code-start (!code-end 1)* code-end\n   `code-start`  ←  \"#\" (\"!\"+)@codelevel code-type@code_c (!\"\\n\" 1)* \"\\n\"\n     `code-end`  ←  \"\\n\" \"#\" (\"/\"+)@(#codelevel) code-type@(code_c)\n                     (!\"\\n\" 1)* line-end\n                 /  -1\n    `code-type`  ←  symbol?\n\n     blockquote  ←  block-line+ line-end\n     block-line  ←  \" \"* \"> \" (!\"\\n\" 1)* (!\"\\n\\n\" \"\\n\")?\n\n          table  ←  table-head table-line*\n   `table-head`  ←  (\" \"* handle_h* \" \"*)@table_c\n                    \"|\" (!\"\\n\" 1)* line-end\n   `table-line`  ←  (\" \"*)@(#table_c) \"|\" (!line-end 1)* line-end\n\n           list  ←  (list-line / numlist-line)+\n      list-line  ←  (\"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>list_c) !\"- \"\n                    (!line-end 1)* line-end)*\n                 /  (\" \"+ \"- \")@list_c (!line-end 1)* line-end\n                    (!(\" \"* list-num)\n                    (\" \"+)@(>=list_c) !\"- \" (!line-end 1)* line-end)*\n   numlist-line  ←  list-num@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n                 /  (\" \"+ list-num)@numlist_c (!line-end 1)* line-end\n                    (!(\" \"* \"- \")\n                    (\" \"+)@(>=numlist_c)\n                    !list-num (!line-end 1)* line-end)*\n     `list-num`  ←  [0-9]+ \". \"\n\n    handle-line  ←  handle (!line-end 1)* line-end\n\n   hashtag-line  ←  hashtag (!line-end 1)* line-end\n\n           note  ←  note-slug note-body line-end\n      note-slug  ←  \"{\" (!\" \" !\"\\n\" !\"}\" 1)+ \"}: \"\n      note-body  ←  note-lines\n   `note-lines`  ←  (note-line note-line-end)* note-line\n    `note-line`  ←  (!\"\\n\" 1)+\n`note-line-end`  ←  \"\\n\"+ \"   \" &note-line\n\n      link-line  ←  link-open obelus link-close link line-end\n      link-open  ←  \"[\"\n         obelus  ←  !(\"[\" / \"{\" / \"#\") 1 (!\"]\" 1)*\n     link-close  ←  \"]: \"\n           link  ←  (!line-end 1)*\n\n         drawer  ←  drawer-top line-end\n                    ((structure \"\\n\"* / (!drawer-bottom prose-line)+)+\n                    / &drawer-bottom)\n                    drawer-bottom\n   `drawer-top`  ←  \" \"* \":[\" (!\"\\n\" !\"]:\" 1)*@drawer_c \"]:\" &\"\\n\"\n`drawer-bottom`  ←  \" \"* \":/[\" (!\"\\n\" !\"]:\" 1)*@(drawer_c) \"]:\" line-end\n\n      paragraph  ←  (!header !structure par-line (!\"\\n\\n\" \"\\n\")?)+\n     `par-line`  ←  (!\"\\n\" 1)+\n     prose-line  ←  (!\"\\n\" 1)* \"\\n\"\n       line-end  ←  (block-sep / \"\\n\" / -1)\n]]\n\n\n\n\n\nDoc_str = Doc_str .. fragments.symbol .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\n\n\n\n\nlocal compact = assert(table.compact)\n\nlocal function _parent(levels, section)\n   local top = #levels\n   if top == 0 then\n      return section\n   end\n   local level = section :select \"level\"() :len()\n   for i = top, 1, -1 do\n      local p_level = levels[i] :select \"level\"() :len()\n      if p_level < level then\n         return levels[i]\n      end\n   end\n   return section\nend\n\nlocal function post(doc)\n   local levels = {}\n   local top = #doc\n   for i = 1, top do\n      local section = doc[i]\n      if section:select \"section\" () then\n         local parent = _parent(levels, section)\n         if parent ~= section then\n            -- add to section\n            section.parent = parent\n            parent[#parent + 1] = section\n            -- remove from doc\n            doc[i] = nil\n            -- adjust .last fields\n            parent.last = section.last\n            local under\n            repeat\n               under = parent\n               parent = _parent(levels, under)\n               parent.last = section.last\n            until parent == under\n         end\n         levels[#levels + 1] = section\n      end\n   end\n   compact(doc, top)\n   return doc\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Linkline = Twig:inherit \"link_line\"\n\nLinkline.toMarkdown = Twig.nullstring\n\n\n\n\nlocal DocMetas = { Twig,\n                   header       = Header,\n                   codeblock    = Codeblock,\n                   table        = Table,\n                   paragraph    = Prose,\n                   list         = List,\n                   list_line    = Listline,\n                   numlist_line = Listline,\n                   note_body    = Prose,\n                   link_line    = Linkline, }\n\n\n\nlocal addall = assert(table.addall)\n\naddall(DocMetas, require \"orb:orb/metas/docmetas\")\n\n\n\nreturn Peg(Doc_str, DocMetas, nil, post)\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/metas/headermetas",
hash = "b8fd572adc8005d241f9ea2c9a5230fe32e8ac787867ad2bcba2cee8df6237a3",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal Header_M = {}\n\n\n\nlocal Header = Twig:inherit \"header\"\nHeader_M.header = Header\n\n\n\n\n\nfunction Header.toMarkdown(header, scroll)\n   local phrase = (\"#\"):rep(header:select(\"level\")():len())\n   scroll:add(phrase)\n   for i = 2, #header do\n      header[i]:toMarkdown(scroll)\n   end\nend\n\n\n\nreturn Header_M\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/list",
hash = "ec207be79bef458620308a90a3f8c5d36cc85de21bda6edaffdf4ab569648d0a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal table = require \"core:core/table\"\nlocal anterm = require \"anterm:anterm\"\nlocal c = require \"singletons/color\" . color -- #todo remove\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\nlocal List = Twig :inherit \'list\'\n\nlocal super_strExtra = Twig . strExtra\n\nfunction List.strExtra(list)\n   local phrase = super_strExtra(list)\n   return phrase .. anterm.magenta(tostring(list.indent))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal DEPTH = 512\nlocal function _parent(list, dent, list_line)\n   local parent = list\n   local count = 1\n   repeat\n      parent = parent.parent\n      count = count + 1\n   until parent.indent <= dent or count == DEPTH\n   if count >= DEPTH then\n      s:warn(anterm.red(\"infinite loop or absurdly deep list folding!\"))\n      s:warn(debug.traceback())\n   end\n   return parent\nend\n\n\n\nlocal function _makesublist(parent, line)\n   if not line then\n      s:verb(\"no line! \\n %s\", debug.traceback())\n   end\n   local sublist = { first = line.first,\n                     last = line.last,\n                     parent = parent,\n                     str = line.str }\n   local lead = { first = line.first,\n                  last = line.last,\n                  parent = sublist,\n                  str = line.str,\n                  id = \'lead\' }\n   setmetatable(lead, Twig)\n   sublist[1] = lead\n   lead[1] =  line\n   line.parent = lead\n   return setmetatable(sublist, List)\nend\n\n\n\nlocal insert, compact = assert(table.insert), assert(table.compact)\n\nlocal function _insert(list, list_line)\n   insert(list, list_line)\n   list_line.parent = list\n   list.last = list_line.last\n   -- the base list won\'t have a parent yet\n   if not list.parent then return end\n   local parent = list.parent\n   while parent.parent and parent.id == \'list\' do\n      parent.last = list_line.last\n      local newparent = parent.parent\n      parent = newparent\n   end\n   --]]\nend\n\nlocal function post(list)\n   local linum = list:linePos()\n   local top = #list\n   local base = list[1].indent\n   -- add an indent to the list itself\n   list.indent = base\n   -- tracking variables:\n   local dent = base\n   local work_list = list\n   for i = 1, top do\n      -- is it an indent line?\n      if not list[i].indent then\n         local id, line, col = list[i].id, list[i]:linePos()\n         s:verb(\"no indent on %s at line %d, col %d\", id, line, col)\n      end\n      if list[i].indent > dent then\n         -- handle base list a bit differently\n         if work_list == list then\n            -- make a list from the previous line\n            local sublist = _makesublist(work_list, list[i - 1])\n            dent = list[i].indent\n            sublist.indent = dent\n            -- insert working line\n            _insert(sublist, list[i])\n            -- replace prior line with list\n            list[i - 1] = sublist\n            -- nil out working line\n            list[i] = nil\n            -- replace the work list\n            work_list = sublist\n         else\n            local sublist = _makesublist(work_list, work_list[#work_list])\n            -- this moves the tip of the work list to the lead of the sub list\n            -- so we need to remove it from the work list\n            work_list[#work_list] = nil\n            dent = list[i].indent\n            sublist.indent = dent\n            _insert(work_list, sublist)\n            _insert(sublist, list[i])\n            list[i] = nil\n            work_list = sublist\n         end\n      elseif dent > base and dent == list[i].indent then\n         -- put it in the worklist\n         _insert(work_list, list[i])\n         list[i] = nil\n      elseif list[i].indent < dent then\n         -- get a new work_list\n         work_list = _parent(work_list, list[i].indent, list[i])\n         if work_list ~= list then\n            _insert(work_list, list[i])\n            dent = list[i].indent\n            list[i] = nil\n         else -- otherwise, we leave the line in-place\n            dent = list[i].indent\n         end\n      else -- otherwise we have a list_line we can leave in place\n         local linstart = list[i]:linePos()\n      end\n   end\n   compact(list, top)\n   return list\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function List_fn(list, offset)\n   setmetatable(list, List)\n   return post(list)\nend\n\n\n\nreturn List_fn\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/link",
hash = "d56d2f618335eedb0daf54622cc7d6d98f3954b7f2e32963a445278db08b1d8c",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal fragments = require \"orb:orb/fragments\"\nlocal WS  = require \"orb:orb/metas/ws\"\nlocal s = require \"status:status\" ()\ns.grumpy = true\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\nlocal link_str = [[\n   link         ←  link-head link-text link-close WS*\n                   (link-open anchor link-close)?\n                   (WS* hashtag WS*)* link-close\n                /  link-head link-text link-close obelus link-close\n\n   link-head    ←  \"[[\"\n   link-close   ←  \"]\"\n   link-open    ←  \"[\"\n   link-text    ←  (!\"]\" 1)*\n\n   anchor       ←  h-ref / url / bad-form\n   `h-ref`      ←  pat ref\n   ref          ←  (h-full / h-local / h-other)\n   `h-full`     ←  project col doc (hax fragment)?\n   `h-local`    ←  doc (hax fragment)?\n   `h-other`    ←  (!\"]\" 1)+  ; this might not be reachable?\n   project      ←  (!(\":\" / \"#\" / \"]\") 1)*\n   doc          ←  (!(\"#\" / \"]\") 1)+\n   fragment     ←  (!\"]\" 1)+\n   pat          ←  \"@\"\n   col          ←  \":\"\n   hax          ←  \"#\"\n\n   ;; urls probably belong in their own parser.\n   ;; this might prove to be true of refs as well.\n   url          ←  \"http://example.com\"\n   bad-form     ←  (!\"]\" 1)*\n   obelus       ←  (!\"]\" 1)+\n   WS           ←  { \\n}+\n]]\n\n\nlink_str = link_str .. fragments.hashtag\n\nlocal link_M = Twig :inherit \"link\"\n\n\n\nlocal function obelusPred(ob_mark)\n   return function(twig)\n      local obelus = twig:select \"obelus\" ()\n      if obelus and obelus:span() == ob_mark then\n         return true\n      end\n      return false\n   end\nend\n\nfunction link_M.toMarkdown(link, scroll)\n   local link_text = link:select(\"link_text\")()\n   link_text = link_text and link_text:span() or \"\"\n   local phrase = \"[\"\n   phrase = phrase ..  link_text .. \"]\"\n   local link_anchor = link:select(\"anchor\")()\n   if link_anchor then\n      link_anchor = link_anchor:span()\n   else\n      -- look for an obelus\n      local obelus = link:select(\"obelus\")()\n      if obelus then\n         -- find the link_line\n         local ob_pred = obelusPred(obelus:span())\n         local link_line = link\n                             :root()\n                             :selectFrom(ob_pred, link.last + 1) ()\n         if link_line then\n            link_anchor = link_line :select \"link\" () :span()\n         else\n            local line_pos = obelus:linePos()\n            local link_err = \"link line not found for obelus: \"\n                             .. obelus:span() .. \" on line \" .. line_pos\n            scroll:addError(link_err)\n            link_anchor = link_err\n         end\n      else\n         link_anchor = \"\"\n      end\n   end\n   phrase = phrase .. \"(\" ..  link_anchor .. \")\"\n   scroll:add(phrase)\nend\n\n\n\nlocal Link_Metas = { Twig,\n                     link = link_M,\n                     WS   = WS, }\nlocal link_grammar = Peg(link_str, Link_Metas)\n\n\n\nreturn subGrammar(link_grammar.parse, \"link-nomatch\")\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb",
hash = "ae6948496eff18b0849261ce3bebdb0a5c6313ba147e8ccd43393805660ed32d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\ncore = require \"core:core\"\n\n\n\n\n\n\nlocal Orb = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrb.lume = require \"orb:lume/lume\"\n\n\n\ncore = nil\n\nreturn Orb\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "tag/tagger",
hash = "368cb039c2ef08b950ee3b4e1f0098625954ecc987e8a0a651e7fd85386e5dbc",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\n\n\n\nlocal s = require \"status:status\" ()\n\n\n\n\n\n\n\n\nlocal taggable = Set {\n   \'header\',\n   \'list_line\',\n   \'section\',\n   \'numlist_line\',\n   \'codeblock\',\n   \'blockquote\',\n   \'paragraph\',\n   \'handle_line\',\n   \'hashtag_line\',\n   \'table\',\n   \'drawer\',\n}\n\n\n\n\n\n\n\n\nlocal sub, lower = assert(string.sub), assert(string.lower)\nlocal insert = assert(table.insert)\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _taggableParent(node, doc, note)\n-- note(\"finding parent of %s\", node.id)\n   local parent = node.parent\n   while parent ~= doc do\n      -- note(\"checking parent %s\", parent.id)\n      if taggable :∈ (parent.id) then\n         break\n      end\n      parent = parent.parent\n   end\n   return parent\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _capitalTag(tag)\n   local first = sub(tag, 1, 1)\n   if lower(first) == first then\n      return false, tag\n   else\n      return true, lower(first) .. sub(tag, 2)\n   end\nend\n\n\n\n\n\n\n\nlocal function _tagUp(tags, node, tag, note)\n   note(\"tagging a %s on line %d with %s\", node.id, (node:linePos()), tag)\n   tags[tag] = tags[tag] or {}\n   insert(tags[tag], node)\n   tags[node] = tags[node] or Set {}\n   tags[node][tag] = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _endPred(node)\n   if node.id == \"line_end\" or node.id == \"block_sep\" then\n      return true\n   else\n      return false\n   end\nend\n\nlocal function _clingsDown(cling_line, note)\n   local back, front = cling_line :selectBack(_endPred)(),\n                       cling_line :selectFrom(_endPred, cling_line.first)()\n   local backlen = back and back:len() or 0\n   local frontlen = front and front:len() or 0\n\n   note(\"back length %d front length %d\", backlen, frontlen)\n   --[[\n   if back then\n      note(\"back token %s\", back:strLine())\n   end\n   if front then\n      note(\"front token %s\", front:strLine())\n   end\n   --]]\n\n   return backlen >= frontlen\nend\n\n\n\n\n\n\n\n\n\n-- a set of whitespace-esque possible block values, which we don\'t want\n-- to tag during the cling rule\nlocal skippable = Set {\'block_sep\', \'line_end\'}\n-- I don\'t know that line_end will ever come up but we may as well exclude it\n\nlocal _capTagResolve = {\n   list_line = function(tags, list_line, tag, note)\n      if list_line.parent.id ~= \'lead\' then\n         -- no children on a list line, just apply the tag\n         _tagUp(tags, list_line, tag, note)\n         return\n      end\n      local list = list_line.parent.parent\n      local function _tagChildren(l)\n         note(\"tagging children of list on line %d\", list_line:linePos())\n         for _, child in ipairs(l) do\n            if child.id == \'lead\' then\n               -- tag the list_line\n               _tagUp(tags, child[1], tag, note)\n            elseif child.id == \'list_line\' or child.id == \'numlist_line\' then\n               _tagUp(tags, child, tag, note)\n            elseif child.id == \'list\' then\n               _tagChildren(child)\n            else\n               note(\"encountered a strange child: %s\", child.id)\n            end\n         end\n      end\n      _tagChildren(list)\n   end,\n   header = function(tags, header, tag, note)\n      local section = header.parent\n      note(\"tagging %s and subsections with %s on line %d\",\n           section.id, tag, section:linePos())\n      _tagUp(tags, section, tag, note)\n      local function _tagChildren(sec)\n         for _, child in ipairs(sec) do\n            if child.id == \'section\' then\n               note(\"tagging subsection on line %d\", child:linePos())\n               _tagUp(tags, child, tag, note)\n               _tagChildren(child)\n            end\n         end\n      end\n      _tagChildren(section)\n   end,\n   hashtag_line = function(tags, hashtag_line, tag, note)\n      local clingsDown = _clingsDown(hashtag_line, note)\n      local section = hashtag_line.parent\n      assert(section.id == \'section\' or section.id == \'doc\',\n             \"found tagline parent with id \" .. section.id)\n      local cD = clingsDown and \"clings down\" or \"clings up\"\n      note(\"tagline parent is %s, %s\", section.id, cD)\n      local index;\n      for i = 1, #section do\n         if section[i] == hashtag_line then\n            index = i\n         end\n      end\n      -- rummage around for valid blocks to tag before and after the index\n      local prior, after;\n      local cursor = index - 1\n      while not prior do\n         if section[cursor] and (not skippable(section[cursor].id)) then\n            prior = section[cursor]\n         elseif cursor == 0 then\n            -- leave prior nil\n            break\n         else\n            cursor = cursor - 1\n         end\n      end\n      cursor = index + 1\n      while not after do\n         if section[cursor] and (not skippable(section[cursor].id)) then\n            after = section[cursor]\n         elseif cursor == #section + 1 then\n            break\n         else\n            cursor = cursor + 1\n         end\n      end\n      if not after then\n         note(\"no after\")\n      end\n      if not prior then\n         note(\"no prior\")\n      end\n\n      if clingsDown then\n         -- can\'t tag down if we\'re at the end of the Doc\n         if not after then\n            note(\"forcing cling up at end of Doc\")\n            if not prior then\n               -- this can happen if a Doc is just a hashtag line\n               note(\"didn\'t find a valid taggable before or after, weird\")\n            else\n               _tagUp(tags, prior, tag, note)\n            end\n         else\n            _tagUp(tags, after, tag, note)\n         end\n      else\n         -- can\'t tag up if we\'re in the first block of a Doc\n         if prior then\n            _tagUp(tags, prior, tag, note)\n         elseif not after then\n            note(\"didn\'t find a valid taggable before or after, weird\")\n         else\n            _tagUp(tags, after, tag, note)\n         end\n      end\n   end,\n   -- some are as simple as just tagging the parent\n   codeblock  = _tagUp,\n   blockquote = _tagUp,\n   paragraph  = _tagUp,\n   table      = _tagUp,\n   drawer     = _tagUp,\n   handle_line = _tagUp,\n}\n\n-- numlist_lines use the list_line logic\n_capTagResolve.numlist_line = _capTagResolve.list_line\n\n-- miniscule tags are mostly just _tagUp\nlocal _minTagResolve = {}\n\nfor field in pairs(taggable) do\n   _minTagResolve[field] = _tagUp\nend\n\n_minTagResolve.hashtag_line = _capTagResolve.hashtag_line\n\n\n\nlocal function hashtagAction(hashtag, skein)\n   local line = hashtag:linePos()\n   -- this is where all the gnarly stuff happens\n   -- for now, add the hashtag itself to the tag collection\n   local tagspan = sub(hashtag.str, hashtag.first + 1, hashtag.last)\n   local tag_parent = _taggableParent(hashtag, skein.source.doc, skein.note)\n   local iscap, tag = _capitalTag(tagspan)\n   if iscap then\n      skein.note(\"line %d: capital tag %s on %s, made into %s\",\n            line, tagspan, tag_parent.id, tag)\n      local resolver = _capTagResolve[tag_parent.id]\n      if resolver then\n         resolver(skein.tags, tag_parent, tag, skein.note)\n      else\n         s:halt(\"no resolver function for %s\", tag_parent.id)\n      end\n   else\n      skein.note(\"line %d: miniscule tag %s on %s\", line, tag, tag_parent.id)\n      local resolver = _minTagResolve[tag_parent.id]\n      if resolver then\n         resolver(skein.tags, tag_parent, tag, skein.note)\n      else\n         s:halt(\"no resolver function for %s\", tag_parent.id)\n      end\n   end\nend\n\nlocal function Tagger(skein)\n   local doc = assert(skein.source.doc, \"No doc found on Skein\")\n   local tags = {}\n   skein.tags = tags\n   for node in doc:walk() do\n      if node.id == \'hashtag\' then\n         hashtagAction(node, skein)\n      end\n   end\n\n   return skein\nend\n\n\n\nreturn function(skein)\n   local ok, res = xpcall(function() return Tagger(skein) end, debug.traceback)\n   if ok then return skein end\n   skein.note(\"error: %s\", res)\n   s:warn(res)\n   return skein\nend\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "lume/deck",
hash = "c36b3895880ed54cd94489a6bd79a963df3f3ea2b50ef0fe208b337b095eae5f",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal s   = require \"status:status\" ()\ns.verbose = false\ns.chatty  = true\n\nlocal Dir = require \"fs:fs/directory\"\n\n\n\nlocal new;\n\nlocal Deck = {}\nDeck.__index = Deck\nlocal __Decks = setmetatable({}, { __mode = \"kv\" })\n\n\n\n-- ignore a few critters that can show up\nlocal decIgnore = {\".DS_Store\", \".git\"}\n\nlocal function ignore(file)\n   local willIgnore = false\n   local basename = file:basename()\n   for _, str in ipairs(decIgnore) do\n      willIgnore = willIgnore or basename == str\n   end\n   -- Goddammit Dropbox\n   willIgnore = willIgnore or (string.find(tostring(file), \"%.%_\") ~= nil)\n   return willIgnore\nend\n\n\n\n\n\n\n\n\n\nlocal new\n\nlocal function case(deck)\n   s:verb(\"dir: \" .. tostring(deck.dir))\n   local dir = deck.dir\n   local lume = deck.lume\n   local basename = dir:basename()\n   assert(dir.idEst == Dir, \"dir not a directory\")\n   local lumeRoot = lume.root:basename()\n   s:verb(\"root: \" .. tostring(lume.root) .. \" base: \" ..tostring(lumeRoot))\n   local subdirs = dir:getsubdirs()\n   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)\n   for i, sub in ipairs(subdirs) do\n      s:verb(\"  - \" .. sub.path.str)\n      deck[i] = new(lume, sub)\n   end\n   local files = dir:getfiles()\n   s:verb(\"  \" .. \"# files: \" .. #files)\n   for i, file in ipairs(files) do\n      if not ignore(file) then\n         lume.shuttle:push(file)\n         --[[not using eponyms, if it doesn\'t come up, delete this\n         local name = file:basename()\n         if #file:extension() > 1 then\n            name = string.sub(name, 1, - #file:extension() - 1)\n         end\n         if name == basename then\n            s:verb(\"  ~ \" .. name)\n            deck.eponym = file\n         end\n         --]]\n      end\n   end\n\n   s:verb(\"#deck is : \" .. #deck)\n   return lume\nend\n\nDeck.case = case\n\n\n\nnew = function (lume, dir)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   s:verb(\"directory: %s\", tostring(dir))\n   if __Decks[dir] then\n      return __Decks[dir]\n   end\n   local deck = setmetatable({}, Deck)\n   deck.dir = dir\n   deck.lume = lume\n   deck.files  = {}\n   case(deck)\n   return deck\nend\n\n\n\n\nDeck.idEst = new\nreturn new\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "util/gitinfo",
hash = "df6e235f6bc13bca2db225d433c6a10434c76424cf369be0a6fec7428ad3916e",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal sh = require \"orb:util/sh\"\nlocal pl = require \"orb:util/plmini\"\nlocal isdir = assert(pl.path.isdir)\nlocal lines = assert(require \"core:core/string\" . lines)\nlocal insert = assert(table.insert)\n\nlocal function gitInfo(path)\n   local git_info = {}\n   if isdir(path..\"/.git\") then\n      local git = sh.command (\"cd \" .. path .. \" && git\")\n      git_info.is_repo = true\n      local branches = tostring(git \"branch\")\n      for branch in lines(branches) do\n         if branch:sub(1,1) == \"*\" then\n            git_info.branch = branch:sub(3)\n         end\n      end\n      local remotes = tostring(git \"remote\")\n      if remotes then\n         git_info.remotes = {}\n         for remote in lines(remotes) do\n            local url = tostring(git(\"remote\", \"get-url\", remote))\n            if remote == \"origin\" then\n               git_info.url = url\n            end\n            insert(git_info.remotes, {remote, url})\n         end\n         if not git_info.url then\n            git_info.url = git_info.remotes[1] and git_info.remotes[1][2]\n         end\n      end\n      git_info.commit_hash = tostring(git(\"rev-parse\", \"HEAD\"))\n   else\n      git_info.is_repo = false\n   end\n   return git_info\nend\n\nreturn gitInfo\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "knit/c",
hash = "48d6dc66eb6bf5ae7af7fdf0288aa5ed802e16d720e0a07ead9277e35844d0d0",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal c_noknit = require \"orb:knit/predicator\" \"#asLua\"\n\n\n\n\n\n\nlocal c_knit = {}\n\n\n\n\n\n\nc_knit.code_type = \"c\"\n\n\n\n\n\n\n\n\n\n\n\nc_knit.pred = function() return false end\n\nc_knit.knit_pred = function() return end\n\n\n\n\n\n\n\nfunction c_knit.knit(codeblock, scroll, skein)\n   if c_noknit(codeblock) then return end\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 1 do\n      scroll:add \"\\n\"\n   end\n   scroll:add(codebody)\n   -- add an extra line and skip 2, to get a newline at EOF\n   scroll:add \"\\n\"\n   scroll.line_count = line_end + 2\nend\n\n\n\nreturn c_knit\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "lume/lume",
hash = "b10beca8535cc17bcf295393ac33c10a33d7b9d86b5e214f5d2e8554660a945d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\nlocal sql = assert(sql)\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal git_info = require \"orb:util/gitinfo\"\nlocal Skein = require \"orb:skein/skein\"\nlocal Deck = require \"orb:lume/deck\"\nlocal Watcher = require \"orb:lume/watcher\"\nlocal database = require \"orb:compile/database\"\n\nlocal Dir  = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal Path = require \"fs:fs/path\"\nlocal Deque = require \"deque:deque\"\nlocal Set = require \"set:set\"\n\n\n\n\n\n\nlocal Lume = {}\nLume.__index = Lume\n\n\n\n\n\n\nlocal _Lumes = setmetatable({}, { __mode = \"kv\" })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Net = {}\n\n\n\nfunction Net.__index(net, ref)\n   -- resolve reference\n   -- make Skein\n   -- net carries a reference to parent lume:\n   s:verb(\"initial load of \" .. tostring(ref))\n   local skein = Skein(ref, net.lume)\n   -- cache result\n   rawset(net, ref, skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.run(lume)\n   -- determine if we need to start the loop\n   local loop_alive = uv.loop_alive()\n   local launcher = uv.new_idle()\n   local launch_running = true\n   launcher:start(function()\n      lume:bundle()\n      launcher:stop()\n      launch_running = false\n   end)\n\n   if not loop_alive then\n      s:chat \"running loop\"\n      uv.run \'default\'\n   end\n\n   loop_alive = uv.loop_alive()\n   -- if there are remaining (hence broken) coroutines, run the skein again,\n   -- to try and catch the error:\n   local retrier = uv.new_idle()\n   retrier :start(function()\n      if launch_running or lume.transacting or lume.persisting then\n         return\n      end\n\n      for _, skein in pairs(lume.ondeck) do\n         s:verb(\"retry on %s\", tostring(skein.source.file))\n         local ok, err = xpcall(skein:transform(), debug.traceback)\n         if not ok then\n            s:warn(err)\n         end\n      end\n      retrier:stop()\n      s:verb(\"end run\")\n   end)\n   if not loop_alive then\n      uv.run \'default\'\n   end\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\nlocal function changer(lume)\n   return function (watcher, fname)\n      local full_name = tostring(lume.orb) .. \"/\" .. fname\n      s:chat (\"altered or new file %s\", full_name)\n      -- refresh git info\n      lume:gitInfo()\n      local skein = lume.net[File(full_name)]\n      skein:transform()\n      lume.has_file_change = true\n      s:chat(\"processed %s\", full_name)\n   end\nend\n\nfunction Lume.serve(lume)\n   s:chat(\"listening for file changes in orb/\")\n   s:chat(\"^C to exit\")\n   local loop_alive = uv.loop_alive()\n   lume.server = Watcher { onchange = changer(lume),\n                            onrename = changer(lume) }\n   lume.server(tostring(lume.orb))\n   if not loop_alive then\n      uv.run \'default\'\n   end\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create, resume, running, yield = assert(coroutine.create),\n                                       assert(coroutine.resume),\n                                       assert(coroutine.running),\n                                       assert(coroutine.yield)\n\nlocal function _loader(skein, lume, path)\n   s:verb(\"begin read of %s\", path)\n   local co = running()\n   lume.ondeck[co] = skein\n   skein :load() :spin() :knit() :weave() :compile()\n   s:verb(\"processed: %s\", path)\n   lume.count = lume.count - 1\n   lume.ondeck[co] = nil\n   lume.rack:insert(co)\n   local stmts, ids, git_info, now = yield()\n   skein:commit(stmts, ids, git_info, now)\n   yield()\n   skein:persist()\nend\n\nfunction Lume.bundle(lume)\n   lume.count = 0\n   -- #todo this is, ideally, temporary; we need it while things can still\n   -- break.\n   lume.ondeck = {}\n   -- bail early if there\'s nothing on the shuttle\n   if lume.shuttle:is_empty() then return lume end\n   repeat\n      local skein = lume.net[lume.shuttle:pop()]\n      local path = tostring(skein.source.file)\n      s:verb(\"loaded skein: %s\", path)\n      lume.count = lume.count + 1\n      resume(create(_loader), skein, lume, path)\n   until lume.shuttle:is_empty()\n   s:verb(\"cleared shuttle\")\n   lume:persist()\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal commitBundle, commitSkein = assert(database.commitBundle),\n                                  assert(database.commitSkein)\n\nfunction Lume.persist(lume)\n   local transactor, persistor = uv.new_idle(), uv.new_idle()\n   lume.transacting, lume.persisting = true, true\n   local check, report = 0, 1\n\n   transactor:start(function()\n      -- watch for next phase\n      check = check + 1\n      if check == report then\n         s:verb(\"lume.count: %d\", lume.count)\n         report = report * 2\n      end\n      if check > 512 then\n         s:warn(\"bailing. lume.count: %d\", lume.count)\n         lume.count = 0\n      end\n      if lume.count > 0 then return end\n      -- report failed coroutines\n      for _, skein in pairs(lume.ondeck) do\n         s:verb(\"failed to process: %s\", tostring(skein.source.file))\n      end\n      -- set up transaction\n      local conn = lume.conn\n      local stmts, ids, now = commitBundle(lume)\n      local git_info = lume:gitInfo()\n      -- cache db info for later commits\n      lume.db = { stmts    = stmts,\n                  ids      = ids,\n                  git_info = git_info,\n                  now      = now }\n      -- make closures for transaction so we can reuse them\n      lume.db.begin = function() conn:exec [[BEGIN TRANSACTION;]] end\n      lume.db.commit = function() conn:exec [[COMMIT;]] end\n      s:chat(\"writing artifacts to database\")\n      lume.db.begin()\n      for co in pairs(lume.rack) do\n         if coroutine.status(co) ~= \'dead\' then\n            local ok, err = resume(co, stmts, ids, git_info, now)\n            if not ok then\n               error (\"coroutine broke during commit: \" .. err\n                        .. \"\\n\" .. debug.traceback(co))\n               conn:exec \"ROLLBACK;\"\n               transacting = false\n               persistor:stop()\n               transactor:stop()\n            end\n         end\n      end\n      -- commit transaction\n      lume.db.commit()\n      -- checkpoint\n      -- use a pcall because we get a (harmless) error if the table is locked\n      -- by another process:\n      pcall(conn.pragma.wal_checkpoint, \"0\") -- 0 == SQLITE_CHECKPOINT_PASSIVE\n      -- clean up db cache\n      lume.db.ids.bundle_id = nil\n      lume.db.now = nil\n      -- end transactor, signal persistor to act\n      lume.transacting = false\n      transactor:stop()\n   end)\n   -- persist changed files to disk\n   persistor:start(function()\n      if lume.transacting then return end\n      for co in pairs(lume.rack) do\n         local ok, err = resume(co)\n         if not ok then\n            error (\"coroutine broke during file write: \" .. err\n                     .. \"\\n\" .. debug.traceback(co))\n            persistor:stop()\n         end\n      end\n      -- GC the coroutines, now that we\'re done with them\n      lume.rack:clear()\n      lume.persisting = false\n      persistor:stop()\n   end)\n\n   return lume\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sh = require \"lash:lash\"\nlocal date = sh.command(\"date\", \"-u\", \'+\"%Y-%m-%d %H:%M:%S\"\')\n\nfunction Lume.now(lume)\n   return tostring(date())\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.gitInfo(lume)\n   lume.git_info = git_info(tostring(lume.root))\n   return lume.git_info\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.projectInfo(lume)\n   local proj = {}\n   proj.name = _Bridge.args.project or lume.project\n   if lume.git_info.is_repo then\n      proj.repo_type = \"git\"\n      proj.repo = lume.git_info.url\n      proj.home = lume.home or \"\"\n      proj.website = lume.website or \"\"\n      local alts = {}\n      for _, repo in ipairs(lume.git_info.remotes) do\n         alts[#alts + 1] = repo[2] ~= proj.repo and repo[2] or nil\n      end\n      proj.repo_alternates = table.concat(alts, \"\\n\")\n   end\n   return proj\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Lume.versionInfo(lume)\n   if not _Bridge.args.version then\n      return { is_versioned = false }\n   end\n   local version = { is_versioned = true }\n   for k,v in pairs(_Bridge.args.version) do\n      version[k] = v\n   end\n   version.edition = _Bridge.args.edition or \"\"\n   version.stage   = _Bridge.args.stage or \"SNAPSHOT\"\n   return version\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _findSubdirs(lume, dir)\n   local isCo = false\n   local orbDir, srcDir, libDir = nil, nil, nil\n   local docDir, docMdDir, docDotDir, docSvgDir = nil, nil, nil, nil\n   lume.root = dir\n   local subdirs = dir:getsubdirs()\n\n   for i, sub in ipairs(subdirs) do\n      local name = sub:basename()\n      if name == \"orb\" then\n         s:verb(\"orb: \" .. tostring(sub))\n         orbDir = sub\n         lume.orb = sub\n      elseif name == \"src\" then\n         s:verb(\"src: \" .. tostring(sub))\n         srcDir = Dir(sub)\n         lume.src = sub\n      elseif name == \"doc\" then\n         s:verb(\"doc: \" .. tostring(sub))\n         docDir = sub\n         lume.doc = sub\n         local subsubdirs = docDir:getsubdirs()\n         for j, subsub in ipairs(subsubdirs) do\n            local subname = subsub:basename()\n            if subname == \"md\" then\n               s:verb(\"doc/md: \" .. tostring(subsub))\n               docMdDir = subsub\n               lume.docMd = subsub\n            elseif subname == \"dot\" then\n               s:verb(\"doc/dot: \" .. tostring(subsub))\n               docDotDir = subsub\n               lume.docDot = subsub\n            elseif subname == \"svg\" then\n               s:verb(\"doc/svg: \" .. tostring(subsub))\n               docSvgDir = subsub\n               lume.docSvg = subsub\n            end\n         end\n      end\n   end\n\n   return (orbDir and srcDir and docDir)\nend\n\n\n\n\nlocal function new(dir, db_conn, no_write)\n   if type(dir) == \"string\" then\n      dir = Dir(dir)\n   end\n   if _Lumes[dir] then\n      return _Lumes[dir]\n   end\n   local lume = setmetatable({}, Lume)\n   lume.conn = db_conn and _Bridge.new_modules_db(db_conn)\n                       or _Bridge.modules_conn\n                       or error \"no database\"\n   lume.no_write = no_write\n   lume.shuttle = Deque()\n   lume.rack = Set()\n   lume.pedantic = _Bridge.args.pedantic and true or false\n   lume.well_formed = _findSubdirs(lume, dir)\n   if lume.well_formed then\n      lume.deck = Deck(lume, lume.orb)\n   else\n      -- this will probably break currently, but the end goal of\n      -- this architecture is to try and do something more sensible\n      -- than that.\n      s:warn(\"%s is not a well formed codex\", uv.cwd())\n   end\n   lume.project = dir.path[#dir.path]\n   lume.git_info = git_info(tostring(dir))\n   lume.net = setmetatable({}, Net)\n   lume.net.lume = lume\n   _Lumes[dir] = lume\n   return lume\nend\n\nLume.idEst = new\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "compile/database",
hash = "b5b0888d49c0d812618bd1ebe4063e605fa55e2f1fea47dbbf0674cf53e7c729",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Dir = require \"fs:fs/directory\"\nlocal File = require \"fs:fs/file\"\nlocal s = require \"status:status\" ()\ns.verbose = false\n\nlocal unwrapKey, toRow = assert(sql.unwrapKey), assert(sql.toRow)\n\n\n\n\n\n\nlocal database = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project = [[\nSELECT * FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal latest_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = ?\nORDER BY major DESC, minor DESC, patch DESC\nLIMIT 1\n;\n]]\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE version.project = :project\nAND version.major = :major\nAND version.minor = :minor\nAND version.patch = :patch\nAND version.edition = :edition\nAND version.stage = :stage\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, stage, project, major, minor, patch)\nVALUES (:edition, :stage, :project, :major, :minor, :patch)\n;\n]]\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version, time)\nVALUES (?, ?, ?)\n;\n]]\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\nlocal get_bundle_id = [[\nSELECT CAST (bundle.bundle_id AS REAL) FROM bundle\nWHERE bundle.project = ?\nORDER BY time desc limit 1;\n]]\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = :hash;\n]]\n\nlocal get_bytecode = [[\nSELECT code.binary FROM code\nWHERE code.code_id = %d ;\n]]\n\n\n\n\n\nlocal insert, concat = assert(table.insert), assert(table.concat)\n\nlocal function _updateProjectInfo(conn, db_project, codex_project)\n   -- determine if we need to do an update\n   local update = false\n   for k, v in pairs(codex_project) do\n      if db_project[k] ~= v then\n         update = true\n      end\n   end\n   if update then\n      local stmt = conn:prepare(update_project)\n      stmt:bindkv(codex_project):step()\n   end\nend\n\n\n\nfunction database.project(conn, codex_info)\n   local db_info = conn:prepare(get_project):bind(codex_info.name):resultset()\n   db_info = toRow(db_info) or {}\n   local project_id = db_info.project_id\n   if project_id then\n      s:verb(\"project_id is \" .. project_id)\n      -- update information if there are any changes\n      _updateProjectInfo(conn, db_info, codex_info)\n   else\n      conn:prepare(new_project):bindkv(codex_info):step()\n      project_id = conn:prepare(get_project):bind(codex_info.name):step()\n      if not project_id then\n         error (\"failed to create project \" .. codex.project)\n      else\n         project_id = project_id[1]\n      end\n   end\n   return project_id\nend\n\n\n\n\n\n\nfunction database.version(conn, version_info, project_id)\n   local version_id\n   if not version_info.is_versioned then\n      version_id = conn:prepare(latest_version):bind(project_id):step()\n      if not version_id then\n         conn : prepare(new_version_snapshot) : bindkv\n              { edition = \"\",\n                project = project_id }\n              : step()\n         version_id = conn:prepare(latest_version):bind(project_id):step()\n         if not version_id then\n            error \"didn\'t make a SNAPSHOT\"\n         else\n            version_id = version_id[1]\n         end\n      else\n         version_id = version_id[1]\n      end\n   else\n      version_info.project = project_id\n      conn:prepare(new_version):bindkv(version_info):step()\n      version_id = conn:prepare(get_version):bindkv(version_info):step()\n      if not version_id then\n         error \"failed to create version\"\n      end\n      version_id = version_id[1]\n   end\n   s:verb(\"version_id is \" .. version_id)\n   return version_id\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal unwrapKey, toRow, blob = sql.unwrapKey, sql.toRow, sql.blob\n\nfunction database.commitSkein(skein, stmts, ids, git_info, now)\n   local bytecode = skein.compiled and skein.compiled.lua\n   if not bytecode or bytecode.err then\n      local err = bytecode and bytecode.err\n      if err then\n        s:complain(\"attempt to commit erroneous bytecode data: %s, %s\",\n               tostring(skein.source.file), err)\n        return nil, err\n      end\n      -- missing bytecode means the Doc didn\'t create a knitted.lua, which\n      -- is normal\n      return nil\n   end\n   local project_id, version_id, bundle_id = ids.project_id,\n                                             ids.version_id,\n                                             ids.bundle_id\n   -- get code_id from the hash\n   local code_id = stmts.code_id :bindkv(bytecode) :value()\n   if not code_id then\n      bytecode.binary = blob(bytecode.binary)\n      stmts.new_code :bindkv(bytecode) :value()\n      code_id = stmts.code_id :bindkv(bytecode) :value()\n   end\n   s:verb(\"code ID is \" .. code_id)\n   s:verb(\"module name is \" .. bytecode.name)\n   if not code_id then\n      error(\"code_id not found for \" .. bytecode.name)\n   end\n   local mod = { name    = bytecode.name,\n                 project = project_id,\n                 bundle  = bundle_id,\n                 code    = code_id,\n                 version = version_id,\n                 time    = now }\n   if git_info.is_repo then\n      mod.vc_hash = git_info.commit_hash\n      mod.branch  = git_info.branch\n   end\n   stmts.add_module:bindkv(mod) :value()\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction database.commitBundle(lume)\n   local conn = lume.conn or s:halt(\"no database conn on the Lume\")\n   local now = lume:now()\n   -- select project_id\n   local project_id = database.project(conn, lume:projectInfo())\n   -- select or create version_id\n   local version_id = database.version(conn, lume:versionInfo(), project_id)\n   -- make a bundle\n   conn:prepare(new_bundle):bind(project_id, version_id, now):step()\n   -- get bundle_id\n   local bundle_id = conn:prepare(get_bundle_id):bind(project_id):step()\n   if bundle_id then\n      bundle_id = bundle_id[1]\n   else\n      error \"didn\'t retrieve bundle_id\"\n   end\n\n   -- prepare statements for module insertion\n   local stmts = { code_id = conn:prepare(get_code_id_by_hash),\n                   new_code = conn:prepare(new_code),\n                   add_module = conn:prepare(add_module) }\n   -- wrap ids\n   local ids = { project_id = project_id,\n                 version_id = version_id,\n                 bundle_id  = bundle_id }\n   return stmts, ids, now\nend\n\n\n\n\nreturn database\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/codeblock",
hash = "7bbf69425a868342cb9152bab3564b501b00dabcd628e7feb05567e49c0a7596",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\nlocal code_str = [[\n    codeblock  ←  code-start code-body  code-end\n   code-start  ←  start-mark code-type? (WS name)* rest* NL\n   start-mark  ←  \"#\" \"!\"+\n           NL  ←  \"\\n\"\n           WS  ←  \" \"+\n    code-body  ←  (!code-end 1)+\n     code-end  ←  end-mark code-type? execute* rest* line-end\n               /  -1\n     end-mark  ←  \"#\" \"/\"+\n    code-type  ←  symbol\n     line-end  ←  (\"\\n\\n\" \"\\n\"* / \"\\n\")* (-1)\n         name  ←  handle\n      execute  ←  \"(\" \" \"* \")\"\n       `rest`  ←  (handle / hashtag / raw)+\n          raw  ←  (!handle !hashtag !\"\\n\" 1)+\n]]\n\n\ncode_str = code_str\n           .. fragments.symbol\n           .. fragments.handle\n           .. fragments.hashtag\n\n\n\nlocal Code_M = Twig :inherit \"codeblock\"\n\n\n\nfunction Code_M.toMarkdown(codeblock, scroll)\n   local phrase = \"```\"\n   -- #Todo code_type is optional, change this\n   phrase = phrase .. codeblock :select \"code_type\"() :span() .. \"\\n\"\n   phrase = phrase .. codeblock :select \"code_body\"() :span()\n   local code_end = codeblock :select \"code_end\"()\n   local line_end\n   if not code_end[1] then\n      line_end = \"\\n\"\n      -- might be a missing newline\n      if not tostring(phrase):sub(-1) == \"\\n\" then\n         phrase = phrase .. \"\\n\"\n      end\n   else\n      line_end = code_end :select \"line_end\"() :span()\n   end\n   phrase = phrase .. \"```\" .. line_end\n   scroll:add(phrase)\nend\n\n\n\nlocal code_peg = Peg(code_str, { Twig, codeblock = Code_M })\n\n\n\n\n\nreturn subGrammar(code_peg.parse, nil, \"code-nomatch\")\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "knit/knit",
hash = "454dab65695e94ea55724ead7c6c052234f580bee4f740f4705c10e1e178c506",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Scroll = require \"scroll:scroll\"\nlocal Set = require \"set:set\"\n\nlocal knitters = require \"orb:knit/knitters\"\n\nlocal core = require \"core:core\"\n\n\n\nlocal Knitter = {}\nKnitter.__index = Knitter\n\n\n\nlocal insert = assert(table.insert)\n\nfunction Knitter.knit(knitter, skein)\n   local doc = skein.source.doc\n   local knitted\n   if skein.knitted then\n      knitted = skein.knitted\n   else\n      knitted = {}\n      skein.knitted = knitted\n   end\n   -- specialize the knitter collection and create scrolls for each type\n   local knit_set = Set()\n   for codeblock in doc :select \'codeblock\' do\n      local code_type = codeblock :select \'code_type\'()\n      knit_set:insert(knitters[code_type and code_type:span()])\n   end\n   for knitter, _ in pairs(knit_set) do\n      local scroll = Scroll()\n      knitted[knitter.code_type] = scroll\n      -- #todo this bakes in assumptions we wish to relax\n      scroll.line_count = 1\n      scroll.path = skein.source.file.path\n                       :subFor(skein.source_base,\n                               skein.knit_base,\n                               knitter.code_type)\n   end\n   for codeblock in doc :select \'codeblock\' do\n      local code_type = codeblock :select \'code_type\'() :span()\n      local tagset = skein.tags[codeblock]\n      if (not tagset) or (not skein.tags[codeblock] \'noKnit\') then\n         for knitter in pairs(knit_set) do\n            if knitter.code_type == code_type then\n               knitter.knit(codeblock, knitted[code_type], skein)\n            end\n            if knitter.pred(codeblock, skein) then\n               knitter.pred_knit(codeblock, knitted[knitter.code_type], skein)\n            end\n         end\n      end\n   end\n   -- clean up unused scrolls\n   for code_type, scroll in pairs(knitted) do\n      if #scroll == 0 then\n         knitted[code_type] = nil\n      end\n   end\nend\n\n\n\nlocal function new()\n   local knitter = setmetatable({}, Knitter)\n\n   return knitter\nend\n\nKnitter.idEst = new\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "concordance/concordance",
hash = "79e5c65deda8e1f0f2acf102efb4838e4ec115c96b04ec0e6c58351328f635fa",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint (\n   codepoint_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   codevalue NOT NULL,\n   utf INTEGER default 1,\n   category STRING NOT NULL DEFAULT \'utf\',\n   version STRING NOT NULL DEFAULT \'official\',\n   destription STRING NOT NULL,\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_codepoint = [[\nCREATE TABLE IF NOT EXISTS codepoint_in (\n   codepoint_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   document UNIQUE, NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   codepoint INTEGER NOT NULL,\n   doc INTEGER NOT NULL,\n   document INTEGER NOT NULL,\n   FOREIGN KEY codepoint\n      REFERENCES codepoint (codepoint_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word (\n   word_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word STRING UNIQUE NOT NULL ON CONFLICT DO NOTHING,\n   -- JSON array of codepoint_ids\n   spelling BLOB NOT NULL ON CONFLICT DO NOTHING,\n   thesaurus INTEGER,\n   FOREIGN KEY thesaurus\n      REFERENCES thesaurus (thesaurus_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal create_word = [[\nCREATE TABLE IF NOT EXISTS word_in (\n   word_in_id INTEGER PRIMARY KEY AUTOINCREMENT,\n   word_repr STRING NOT NULL,\n   disp INTEGER NOT NULL,\n   wid INTEGER NOT NULL DEFAULT 1,\n   line_num INTEGER NOT NULL,\n   col_num INTEGER NOT NULL,\n   word INTEGER,\n   doc INTEGER,\n   document INTEGER,\n   FOREIGN KEY word\n      REFERENCES word (word_id),\n   FOREIGN KEY doc\n      REFERENCE doc (doc_id)\n   FOREIGN KEY document\n      REFERENCES document (document_id),\n]]\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "compile/compiler",
hash = "8aa82272eb203d692973dfcfef8e58859ba56ee14323f8aab723ca472117b409",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal compiler, compilers = {}, {}\ncompiler.compilers = compilers\n\n\n\n\n\n\nlocal sha = require \"util:sha\" . shorthash\n\nlocal s = require \"status:status\" ()\ns.verbose = false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _moduleName(path, project)\n   local mod = {}\n   local inMod = false\n   for i, v in ipairs(path) do\n      if v == project then\n         inMod = true\n      end\n      if inMod then\n         if i ~= #path then\n            table.insert(mod, v)\n          else\n             table.insert(mod, path:barename())\n         end\n      end\n   end\n   -- drop the bits of the path we won\'t need\n   --- awful kludge fix\n   local weird_path = table.concat(mod)\n   local good_path = string.gsub(weird_path, \"%.%_\", \"\")\n   local _, cutpoint = string.find(good_path, \"/src/\")\n   local good_path = string.sub(good_path, cutpoint + 1)\n   return good_path\nend\n\n\n\n\n\n\n\n\nfunction compilers.lua(skein)\n   local project = skein.lume.project\n   skein.compiled = skein.compiled or {}\n   local compiled = skein.compiled\n   local path = skein.knitted.lua.path\n   local src = skein.knitted.lua\n   local mod_name = _moduleName(path, project)\n   local bytecode, err = load (tostring(src), \"@\" .. mod_name)\n   if bytecode then\n      -- add to srcs\n      local byte_str = tostring(src) -- #todo: parse and strip\n      local byte_table = {binary = byte_str}\n      byte_table.hash = sha(byte_str)\n      byte_table.name = mod_name\n      byte_table.err = false\n      compiled.lua = byte_table\n      s:verb(\"compiled: \" .. project .. \":\" .. byte_table.name)\n   else\n      s:chat \"error:\"\n      s:chat(err)\n      compiled.lua = { err = err }\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction compiler.compile(compiler, skein)\n   for extension, scroll in pairs(skein.knitted) do\n      if compiler.compilers[extension] then\n         compiler.compilers[extension](skein)\n      end\n   end\nend\n\n\n\nreturn compiler\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/metas/ws",
hash = "62740b54addf9bb357f7b8cb0e31d711c99e6abee2f3a46ca6511e0bba3afa8b",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\n\n\nlocal WS = Twig:inherit \"WS\"\n\n\n\nWS.strLine = Twig.nullstring\n\n\n\nreturn WS\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "knit/knitters",
hash = "e59daebe26ff2e8e2bcd99c2fc03390d7fc8f5fe1670ea0ed2229eedb63e0d43",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn { lua = require \"orb:knit/lua\",\n           c = require \"orb:knit/c\" }\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/metas/prosemetas",
hash = "69d2ab4927c6b844a653310fb75246657abbffc9bb9dce95ac980aa6731104dc",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal Twig = require \"orb:orb/metas/twig\"\n\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\nlocal function bookmaker(icon)\n   return function(bookended, scroll)\n      scroll:add(icon)\n      for i = 2, #bookended - 1 do\n         bookended[i]:toMarkdown(scroll)\n      end\n      scroll:add(icon)\n   end\nend\n\n\n\nlocal bold_M = Twig:inherit \"bold\"\nbold_M.toMarkdown = bookmaker \"**\"\n\n\n\nlocal italic_M = Twig:inherit \"italic\"\nitalic_M.toMarkdown = bookmaker \"*\"\n\n\n\n\n\n\n\nlocal literal_M = Twig:inherit \"literal\"\n\nlocal find, rep = assert(string.find), assert(string.rep)\n\nfunction literal_M.toMarkdown(literal, scroll)\n   local span = literal :select \"body\"() :span()\n   local ends = \"`\"\n   local head, tail = find(span, \"%`+\")\n   if head then\n      ends = rep(\"`\", tail + 2 - head)\n   end\n   scroll:add(ends .. span .. ends)\nend\n\n\n\nlocal strike_M = Twig:inherit \"strike\"\nstrike_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal underline_M = Twig:inherit \"underline\"\nunderline_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal verbatim_M = Twig:inherit \"verbatim\"\nverbatim_M.toMarkdown = bookmaker \"\"\n\n\n\nlocal Prose_M = { bold = bold_M,\n                  italic = italic_M,\n                  literal = literal_M,\n                  strike = strike_M,\n                  underline = underline_M,\n                  verbatim = verbatim_M, }\n\n\n\n\nreturn Prose_M\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/header",
hash = "1a5d4cec60cc230871ed399354fbd2b750d58327583d016ef0396656979e9319",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\nlocal Peg = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal Header_M = require \"orb:orb/metas/headermetas\"\nlocal fragments = require \"orb:orb/fragments\"\n\n\nlocal header_str = [[\n        header  ←  WS? level head-line* -1\n         WS     ←  \" \"+\n         level  ←  \"*\"+\n   `head-line`  ←  handle / hashtag / raw\n         raw    ←  (!handle !hashtag 1)+\n]]\n\n\nheader_str = header_str .. fragments.handle .. fragments.hashtag\n\nlocal addall = assert(require \"core:core/table\" . addall)\nlocal head_M = {Twig}\naddall(head_M, Header_M)\nlocal header_grammar = Peg(header_str, head_M)\n\n\n\n\nreturn subGrammar(header_grammar.parse, \"header-nomatch\")\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/metas/twig",
hash = "71255bb54152213f0f9768b34bb5b9fe1080bc06d0c0cc08f445090832af86d0",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Node = require \"espalier:espalier/node\"\nlocal a = require \"anterm:anterm\"\nlocal Set = require \"set:set\"\nlocal Codepoints = require \"singletons:singletons/codepoints\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\n\n\n\n\n\n\nlocal Twig = {}\n\nfor k,v in next, Node do\n   Twig[k] = v\nend\n\nTwig.__index = Twig\nTwig.id = \"twig\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal md_special = Set {\"\\\\\", \"`\", \"*\", \"_\", \"{\", \"}\", \"[\", \"]\", \"(\", \")\",\n                        \"#\", \"+\", \"-\", \".\", \"!\"}\n\nfunction Twig.toMarkdown(twig, scroll)\n   if #twig == 0 then\n      local points = Codepoints(twig:span())\n      for i , point in ipairs(points) do\n         if md_special(point) then\n            points[i] = \"\\\\\" .. point\n         end\n      end\n      scroll:add(tostring(points))\n   else\n      for _, sub_twig in ipairs(twig) do\n         sub_twig:toMarkdown(scroll)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function _escapeHtml(span)\n   -- stub\n   return span\nend\n\nfunction Twig.toHtml(twig, skein)\n   local phrase = \'<span class=\"\' .. twig.id .. Phrase \'\">\'\n   if #twig == 0 then\n      phrase = phrase .. _escapeHtml(twig:span())\n   else\n      for _, sub_twig in ipairs(twig) do\n         phrase = phrase .. sub_twig:toHtml(skein)\n      end\n   end\n   return phrase .. \"</span>\"\nend\n\n\n\n\n\n\n\n\n\n\nfunction Twig.nullstring()\n   return \"\"\nend\n\n\n\nreturn Twig\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/fragments",
hash = "3665b90213df73e5a55c97b523a6493f399fa32179861e76392b28726f678fbd",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal fragments = {}\n\n\n\n\n\n\n\n\n\n\nlocal gap_str = [[\n    `gap`  <-  { \\n([)]} / \"{\" / \"}\" / -1\n]]\nfragments.gap = gap_str\n\n\n\n\n\n\nlocal hashtag_h_str = [[\n   `hashtag_h`  ←  \"#\" ends_h+ (middle_h+ ends_h+)*\n        `ends_h`  ←  [A-Z] / [a-z] / [0-9] / \"-\" / \"_\"\n       `middle_h` ←  \".\" / \"/\" / \":\"\n]]\n\n\nlocal hashtag_str = [[\n\n   hashtag  ←  hashtag_h\n]] .. hashtag_h_str\n\n\nfragments.hashtag = hashtag_str\nfragments.hashtag_h = hashtag_h_str\n\n\n\n\n\n\nlocal handle_h_str = [[\n\n  `handle_h`  ← \"@\" (!gap 1 / \"[\" (!gap ! \"]\" 1)+ \"]\")+\n]] .. gap_str\n\nlocal handle_str = [[\n\n   handle  ←  handle_h\n]] .. handle_h_str\n\nfragments.handle = handle_str\nfragments.handle_h = handle_h_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal symbol_str = [[\n\n   `symbol`  <-  (([a-z]/[A-Z]) ([a-z]/[A-Z]/[0-9]/\"-\"/\"_\")*)\n]]\nfragments.symbol = symbol_str\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal term_str = [[\n\n   `t` = { \\n.,:;?!)(][\\\"} / -1\n]]\nfragments.t = term_str\n\n\n\n\n\n\n\n\n\n\n\nlocal utf8_str = [[\n   `utf8`  ←  [\\x00-\\x7f]\n           /  [\\xc2-\\xdf] [\\x80-\\xbf]\n           /  [\\xe0-\\xef] [\\x80-\\xbf] [\\x80-\\xbf]\n           /  [\\xf0-\\xf4] [\\x80-\\xbf] [\\x80-\\xbf] [\\x80-\\xbf]\n]]\nfragments.utf8 = utf8_str\n\n\n\nreturn fragments\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/list-line",
hash = "61d2c9c69af24f5cbe820aac9e2469830a3025ea33af5848108ef34cec5e9585",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\nlocal Peg = require \"espalier:espalier/peg\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal prose = require \"orb:orb/prose\"\nlocal fragments = require \"orb:orb/fragments\"\nlocal anterm = require \"anterm:anterm\"\n\n\nlocal listline_str = [[\n     list-line  ←  depth number* sep WS\n                   (cookie / radio)*\n                   (key colon text / text) cookie* list-end\n         depth  ←  \" \"*\n        number  ←  [0-9]+\n           sep  ←  \"-\" / \".\"\n        cookie  ←  \"[\" (!\"]\" 1)+ \"]\"\n         radio  ←  \"(\" 1 \")\" ; this should be one utf-8 character\n           key  ←  \" \"* (handle / hashtag / (!\":\" !gap 1)+) \" \"*\n         colon  ←  \":\" &(ws (!ws 1))\n          text  ←  (!(cookie list-end / list-end) 1)+\n            WS  ←  ws\n          `ws`  ←  { \\n}+\n      list-end  ←  \"\\n\"* -1\n]]\n\n\nlistline_str = listline_str .. fragments.gap\n               .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\nlocal Sep = Twig:inherit \'sep\'\n\nfunction Sep.toMarkdown(sep, scroll)\n   scroll:add(sep:span())\nend\n\n\n\n\n\n\nlocal Cookie = Twig:inherit \'cookie\'\nCookie.toMarkdown = Sep.toMarkdown\n\n\n\n\n\n\nlocal listline_Meta = { Twig,\n                        text = prose,\n                        sep = Sep,\n                        cookie = Cookie }\nlocal listline_grammar = Peg(listline_str, listline_Meta).parse\n\n\n\n\n\n\n\n\nlocal Listline = Twig:inherit \"list_line\"\n\n\nlocal super_strExtra = Twig . strExtra\n\nfunction Listline.strExtra(list_line)\n   local phrase = super_strExtra(list_line)\n   return phrase .. anterm.magenta(tostring(list_line.indent))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal gsub = assert(string.gsub)\n\nlocal function makeAdjustment(level_space)\n   return function(str)\n      return gsub(str, \'\\n[ ]+\', level_space)\n   end\nend\n\nfunction Listline.toMarkdown(list_line, scroll)\n   local phrase = \"\"\n   local level_space = \"\\n\" .. (\" \"):rep(list_line.indent + 2)\n   local defer = makeAdjustment(level_space)\n   local close_mark = scroll:deferStart(defer)\n   for _, node in ipairs(list_line) do\n      node:toMarkdown(scroll)\n   end\n   scroll:deferFinish(close_mark)\nend\n\n\n\n\nlocal function listline_fn(t)\n   local match = listline_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t.last then\n         -- label the match according to the rule\n         match.id = t.id or \"list_line\"\n         match.indent = match:select\"sep\"().last - match.first + 2\n         return setmetatable(match, Listline)\n       else\n         match.id = t.id .. \"_INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   -- we need to fix the list line grammar to recognize more lists, but for\n   -- now, we know it makes mistakes. So we\'re just going to post-process\n   -- it in a sort of ugly way\n   setmetatable(t, Listline)\n   t.id = \'list_line_nomatch\'\n   local _, sep_end = t:span():find(\'%s+- \')\n   t.indent = sep_end\n   return setmetatable(t, Twig)\nend\n\n\n\n\n\nreturn listline_fn\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "lume/watcher",
hash = "6c0b2bb6dd3f6caa6974a406faeba7b84da0d11d4a9f352d7c993c94c9ea82ed",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal uv = require \"luv\"\n\nlocal function watch(watcher, dir, recur)\n    watcher.dir = dir\n    -- default to a recursive watch\n    if recur == nil then\n        recur = true\n    end\n    local fse = uv.new_fs_event()\n    watcher.fse = fse\n    uv.fs_event_start(fse, dir, {recursive = recur},\n       function (err,fname,status)\n          if (err) then\n             print(\"Error \"..err)\n          else\n             local ev = nil\n             for k,v in pairs(status) do\n                ev = k\n             end\n             if ev == \"change\" then\n                watcher:onchange(fname)\n             elseif ev == \"rename\" then\n                watcher:onrename(fname)\n             else\n                print(\"Unrecognized event in watch(\" .. dir .. \"): \" ..ev)\n             end\n          end\n       end)\nend\n\n\n\nlocal function stop(watcher)\n   uv.fs_event_stop(watcher.fse)\nend\n\n\n\nlocal _W = {__call = watch}\n_W.__index = _W\n\nfunction _W.run(watcher)\n   uv.run()\nend\n\nlocal function Watcher(handlers)\n   handlers = handlers or {}\n   local watcher = {}\n   watcher.onchange = handlers.onchange or function() end\n   watcher.onrename = handlers.onrename or function() end\n   watcher.stop = stop\n   return setmetatable(watcher, _W)\nend\n\n_W.idEst = _W\n\n\n\nreturn Watcher\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/table",
hash = "90bfab22cc9fbd96690af044863bcfeff5c765ba66fbb486ba1fc213ef7566c2",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Peg  = require \"espalier:espalier/peg\"\nlocal subGrammar = require \"espalier:espalier/subgrammar\"\n\nlocal fragments = require \"orb:orb/fragments\"\nlocal Twig      = require \"orb:orb/metas/twig\"\n\n\nlocal table_str = [[\n      table  ←  WS* handle* WS* row+\n        row  ←  WS* pipe cell (!table-end pipe cell)* table-end\n       cell  ←  (!table-end !pipe 1)+\n       pipe  ←  \"|\"\n`table-end`  ←  (pipe / hline / double-row)* line-end\n      hline  ←  \"~\"\n double-row  ←  \"\\\\\"\n         WS  ←  \" \"+\n   line-end  ←  (block-sep / \"\\n\" / -1)\n  block-sep  ←  \"\\n\\n\" \"\\n\"*\n]]\n\n\ntable_str = table_str .. fragments.handle .. fragments.symbol\n\n\n\nlocal table_grammar = Peg(table_str, {Twig})\n\n\n\nreturn subGrammar(table_grammar, nil, \"table-nomatch\")\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "knit/lua",
hash = "1db90d7a3962b62131221d566fe6cb2eac2d126ec4e8479fbce6c7018a760449",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal predicator = require \"orb:knit/predicator\"\nlocal s = require \"status:status\" ()\n\n\n\nlocal lua_knit = {}\n\n\n\n\n\n\n\n\n\nlua_knit.code_type = \"lua\"\n\n\n\n\n\n\n\n\n\nlua_knit.pred = predicator \"asLua\"\n\n\n\n\n\n\n\n\n\n\nfunction lua_knit.knit(codeblock, scroll, skein)\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 1 do\n      scroll:add \"\\n\"\n   end\n   scroll:add(codebody)\n   -- add an extra line and skip 2, to get a newline at EOF\n   scroll:add \"\\n\"\n   scroll.line_count = line_end + 2\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, gsub = assert(string.format),\n                           assert(string.find),\n                           assert(string.gsub)\nlocal L = require \"lpeg\"\n\nlocal end_str_P = L.P \"]\" * L.P \"=\"^0 * L.P \"]\"\n\nlocal function _disp(first, last)\n   return last - first - 2\nend\n\n-- capture an array containing the number of equals signs in each matching\n-- long-string close, e.g. \"aa]]bbb]=]ccc]==]\" returns {0, 1, 2}\n\nlocal find_str = L.Ct(((-end_str_P * 1)^0\n                      * (L.Cp() * end_str_P * L.Cp()) / _disp)^1)\n\nfunction lua_knit.pred_knit(codeblock, scroll, skein)\n   local name = codeblock:select \"name\"()\n   local codetype = codeblock:select(\"code_type\")():span()\n   local header, str_start = \"\", \" = [\"\n   if name then\n      -- stringify and drop \"@\"\n      name = name:select \"handle\"() :span() :sub(2)\n      -- normalize - to _\n      name = gsub(name, \"%-\", \"_\")\n      -- two forms: =local name= or (=name.field=, name[field])\n      if not (find(name, \"%.\") or find(name, \"%[\")) then\n         header = \"local \"\n      end\n   elseif codetype ~= \"c\" then\n      local linum = codeblock :select \"code_start\"() :linePos()\n      s:warn(\"an #asLua block must have a name, line: %d\", linum)\n      return\n   end\n   -- special-case #asLua C blocks as ffi.cdef\n   -- this allows for a named C code block; the name isn\'t used here but\n   -- can be used to reference the block elsewhere.\n   if codetype == \"c\" then\n      header = \"ffi.cdef \"\n      name = \"\"\n      str_start = \" [\"\n   end\n   local codebody = codeblock :select \"code_body\" ()\n   local line_start, _ , line_end, _ = codebody:linePos()\n   for i = scroll.line_count, line_start - 2 do\n      scroll:add \"\\n\"\n   end\n   -- search for ==\"]\" \"=\"* \"]\"== in code_body span and add more = if\n   -- needful\n   local eqs = \"\"\n   local caps = L.match(find_str, codebody:span())\n   if caps then\n      table.sort(caps)\n      eqs = (\"=\"):rep(caps[#caps] + 1)\n   end\n   header = header .. name .. str_start .. eqs .. \"[\\n\"\n   scroll:add(header)\n   scroll:add(codebody)\n   scroll:add(\"]\" .. eqs .. \"]\\n\")\n   scroll.line_count = line_end + 2\nend\n\n\n\nreturn lua_knit\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "orb/prose",
hash = "aac92c64260304186b3b972731e207cf6ef6e80b2ee62c468c6b1ee2f391f27d",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\nlocal Peg = require \"espalier:peg\"\nlocal Set = require \"set:set\"\nlocal core = require \"core:core\"\nlocal Twig = require \"orb:orb/metas/twig\"\nlocal fragments = require \"orb:orb/fragments\"\n\nlocal ProseMetas = require \"orb:orb/metas/prosemetas\"\n\n\n\n\n\n\n\n\n\n\nlocal prose_str = [[\n            prose  ←  ( escape\n                       / link\n                       / note-link\n                       / italic\n                       / bold\n                       / strike\n                       / literal\n                       / verbatim\n                       / underline\n                       / raw )+\n\n           escape  ←  \"\\\\\" {*/~_=`][}\n             link  ←  \"[[\" (!\"]\" 1)+ \"]\" WS*     ; link phrase\n                       (\"[\" (!\"]\" 1)+ \"]\")*      ; link body\n                       (WS* hashtag WS*)* \"]\"    ; optional hashtag\n                      ; obelus link\n                   /  \"[[\" (!\"]\" 1)+ \"]\" !(\"#\" / \"{\" / \"[\" / \"]\") 1\n                      (!(WS / \"]\") 1)* \"]\"\n\n        note-link  ←  note-open note-prose note-slug note-close\n                   /  note-slug\n       note-prose  ←  (!note-slug 1)+\n        note-slug  ←  \"[{\" (!WS !\"}\" 1)+ \"}]\"\n        note-open  ←  \"[\"\n       note-close  ←  \"]\"\n\n\n             bold  ←   bold-start bold-body bold-end\n     `bold-start`  ←  \"*\"+@bold-c !WS\n       `bold-end`  ←  \"*\"+@(bold-c)\n      `bold-body`  ←  ( WS+ (!non-bold !bold-end fill)+\n                       / WS* non-bold\n                       / (!non-bold !bold-end fill)+ )+\n       `non-bold`  ←  italic / strike / underline / literal / verbatim\n\n           italic  ←  italic-start italic-body italic-end\n   `italic-start`  ←  \"/\"+@italic-c !WS\n     `italic-end`  ←  \"/\"+@(italic-c)\n    `italic-body`  ←  ( WS+ (!non-italic !italic-end fill)+\n                       / WS* non-italic\n                       / (!non-italic !italic-end fill)+ )+\n     `non-italic`  ←  bold / strike / underline / literal / verbatim\n\n           strike  ←  strike-start strike-body strike-end\n   `strike-start`  ←  \"~\"+@strike-c !WS\n     `strike-end`  ←  \"~\"+@(strike-c)\n    `strike-body`  ←  ( WS+ (!non-strike !strike-end fill)+\n                             / WS* non-strike\n                             / (!non-strike !strike-end fill)+ )+\n     `non-strike`  ←  bold / italic / underline / literal / verbatim\n\n        underline  ←  underline-start underline-body underline-end\n`underline-start`  ←  \"_\"+@underline-c !WS\n  `underline-end`  ←  \"_\"+@(underline-c)\n `underline-body`  ←  ( WS+ (!non-underline !underline-end fill)+\n                          / WS* non-underline\n                          / (!non-underline !underline-end fill)+ )+\n  `non-underline`  ←  bold / italic / strike / literal / verbatim\n\n          literal  ←  literal-start literal-body literal-end\n  `literal-start`  ←  \"=\"+@literal-c\n    `literal-end`  ←  \"=\"+@(literal-c)\n   `literal-body`  ←  (!literal-end 1)+\n\n         verbatim  ←  verbatim-start verbatim-body verbatim-end\n `verbatim-start`  ←  (\"`\" \"`\"+)@verbatim-c\n   `verbatim-end`  ←  (\"`\" \"`\"+)@(verbatim-c)\n  `verbatim-body`  ←  (!verbatim-end 1)+\n\n           `fill`  ←  link / note-link / hashtag / handle / !WS 1\n               WS  ←  (\" \" / \"\\n\")\n            `raw`  ←  ( !bold\n                        !italic\n                        !strike\n                        !literal\n                        !verbatim\n                        !underline\n                        !escape\n                        !note-link\n                        !link (hashtag / handle / word / punct / WS) )+\n             word  ←  (!t 1)+\n            punct  ←  ({\\n.,:;?!)(]\\\"} / (!\"[[\" \"[\"))+\n]]\n\n\nprose_str = prose_str .. fragments.t .. fragments.handle .. fragments.hashtag\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal bounds = { bold      = \"*\",\n                 italic    = \"/\",\n                 literal   = \"=\",\n                 verbatim  = \"`\",\n                 underline = \"_\",\n                 strike    = \"~\" }\nlocal bookends = Set(core.keys(bounds))\n\n\n\nlocal byte = assert(string.byte)\nlocal insert = assert(table.insert)\n\nlocal function _makeBooks(bound, bookended)\n   local first, last, str = bookended.first, bookended.last, bookended.str\n   local count = 0\n   while true do\n      if byte(str, first + count + 1) ~= bound then\n         break\n      end\n      -- may as well prevent infinite work on malformed input...\n      if first + count + 1 > last then break end\n      count = count + 1\n   end\n   local head = setmetatable({ first  = first,\n                               last   = first + count,\n                               str    = str,\n                               parent = bookended,\n                               id     = \"bound\" }, Twig)\n   local tail = setmetatable({ first  = last - count,\n                               last   = last,\n                               str    = str,\n                               parent = bookended,\n                               id    = \"bound\" }, Twig)\n   return head, tail, count\nend\n\n\nlocal function _fillGen(bookended)\n   local bound = byte(bounds[bookended.id])\n   local str, first, last = bookended.str, bookended.first, bookended.last\n   if #bookended == 0 then\n      local head, tail, count = _makeBooks(bound, bookended)\n      local body = setmetatable({ first = first + count + 1,\n                                  last  = last - count - 1,\n                                  str   = str,\n                                  parent = bookended,\n                                  id    = \"body\" }, Twig)\n      insert(bookended, head)\n      insert(bookended, body)\n      insert(bookended, tail)\n   else\n      local head, tail, count = _makeBooks(bound, bookended)\n      -- temporary array to hold the new collection\n      local new_order = {head}\n      local next_first = head.last + 1\n      -- test and capture first text\n      if next_first ~= bookended[1].first then\n      insert(new_order, setmetatable({ first  = next_first,\n                                       last   = bookended[1].first - 1,\n                                       str    = str,\n                                       parent = bookended,\n                                       id     = \"word\" }, Twig))\n      end\n      -- test and capture interspersed text\n      for i = 2, #bookended do\n         insert(new_order, bookended[i - 1])\n         if not (bookended[i - 1].last + 1 == bookended[i].first) then\n            local inter = setmetatable({ first  = bookended[i - 1].last + 1,\n                                         last   = bookended[i].first - 1,\n                                         str    = str,\n                                         parent = bookended,\n                                         id     = \"word\" }, Twig)\n            insert(new_order, inter)\n         end\n      end\n      insert(new_order, bookended[#bookended])\n      -- test and capture end text\n      if bookended[#bookended].last ~= bookended.last then\n         local hip = setmetatable({ first  = bookended[#bookended].last + 1,\n                                    last   = bookended.last - count - 1,\n                                    str    = str,\n                                    parent = bookended,\n                                    id     = \"word\" }, Twig)\n         insert(new_order, hip)\n      end\n      for i, node in ipairs(new_order) do\n         bookended[i] = node\n      end\n      insert(bookended, tail)\n   end\nend\n\n\n\nlocal prose_fn;\n\nlocal function _prosePost(prose)\n   -- walk manually to replace note-bodies\n   for i, node in ipairs(prose) do\n     if bookends(node.id) then\n        _fillGen(node)\n     elseif node.id == \'note_prose\' then\n        prose[i] = prose_fn(node)\n     end\n     _prosePost(node)\n   end\n   return prose\nend\n\nlocal function _prosePost(prose)\n   for node in prose:walk() do\n     if bookends(node.id) then\n        _fillGen(node)\n     end\n   end\n   return prose\nend\n\n\n\n\n\nlocal proseMetas = { Twig,\n                     WS   =  require \"orb:orb/metas/ws\",\n                     link =  require \"orb:orb/link\" }\n\ncore.addall(proseMetas, require \"orb:orb/metas/prosemetas\")\n\nprose_grammar = Peg(prose_str, proseMetas, nil, _prosePost).parse\n\n\n\n\n\n\n\n\n\nprose_fn = function(t)\n   local match = prose_grammar(t.str, t.first, t.last)\n   if match then\n       if match.last == t. last then\n         -- label the match according to the rule\n         match.id = t.id or \"prose\"\n         return match\n       else\n         match.id = t.id .. \"-INCOMPLETE\"\n         return match\n       end\n   end\n   -- if error:\n   t.id = \"prose-nomatch\"\n   return setmetatable(t, Twig)\nend\n\n\n\nreturn prose_fn\n\n",
},
  { 
vc_hash = "c62cee57aa01298394b5b8cbc83561662b03391e",
name = "skein/skein",
hash = "bb3e71302df5a74e8b15358b120882a197a11e49dfe01c42a5cc2ae25861ec72",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\nlocal a = require \"anterm:anterm\"\ns.chatty = true\ns.angry = false\n\n\n\nlocal Doc      = require \"orb:orb/doc\"\nlocal knitter  = require \"orb:knit/knit\" ()\nlocal compiler = require \"orb:compile/compiler\"\nlocal database = require \"orb:compile/database\"\n\nlocal File   = require \"fs:fs/file\"\nlocal Path   = require \"fs:fs/path\"\nlocal Scroll = require \"scroll:scroll\"\nlocal Notary = require \"status:annotate\"\n\n\n\nlocal Skein = {}\nSkein.__index = Skein\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.load(skein)\n   local ok, text = pcall(skein.source.file.read, skein.source.file)\n   if ok then\n      skein.source.text = text\n   else\n      s:complain(\"fail on load %s: %s\", tostring(skein.source.file), text)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.filter(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.spin(skein)\n   local ok, doc = pcall(Doc, skein.source.text)\n   if not ok then\n       s:complain(\"couldn\'t make doc: %s, %s\", doc, tostring(skein.source.file))\n   end\n   skein.source.doc = doc\n   skein:tag()\n   return skein\nend\n\n\n\n\n\n\n\n\nfunction Skein.format(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\nSkein.tag = require \"orb:tag/tagger\"\n\n\n\n\n\n\n\n\n\n\nfunction Skein.knit(skein)\n   local ok, err = pcall(knitter.knit, knitter, skein)\n   if not ok then\n      s:complain(\"failure to knit %s: %s\", tostring(skein.source.file), err)\n   end\n   if not skein.knitted.lua then\n      s:warn(\"no knit document produced from %s\", tostring(skein.source.file))\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.weave(skein)\n   if not skein.woven then\n      skein.woven = {}\n   end\n   local woven = skein.woven\n   woven.md = {}\n   local ok, err = pcall(function()\n      local scroll = Scroll()\n      skein.source.doc:toMarkdown(scroll)\n      local ok = scroll:deferResolve()\n      if not ok then\n         scroll.not_resolved = true\n      end\n      woven.md.text = tostring(scroll)\n      woven.md.scroll = scroll\n      -- report errors, if any\n      for _, err in ipairs(scroll.errors) do\n         s:warn(tostring(skein.source.file) .. \": \" .. err)\n      end\n      -- again, this bakes in the assumption of \'codex normal form\', which we\n      -- need to relax, eventually.\n      woven.md.path = skein.source.file.path\n                          :subFor(skein.source_base,\n                                  skein.weave_base .. \"/md\",\n                                  \"md\")\n   end)\n   if not ok then\n      s:complain(\"couldn\'t weave %s: %s\", tostring(skein.source.file), err)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.compile(skein)\n   compiler:compile(skein)\n   return skein\nend\n\n\n\n\n\n\n\n\n\nlocal commitSkein = assert(database.commitSkein)\n\nfunction Skein.commit(skein, stmts, ids, git_info, now)\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n   assert(now)\n   commitSkein(skein, stmts, ids, git_info, now)\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transact(skein, stmts, ids, git_info, now)\n   assert(stmts)\n   assert(ids)\n   assert(git_info)\n   skein.lume.db.begin()\n   commitSkein(skein, stmts, ids, git_info, now)\n   skein.lume.db.commit()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function writeOnChange(scroll, path, dont_write)\n   -- if we don\'t have a path, there\'s nothing to be done\n   -- #todo we should probably take some note of this situation\n   if not path then return end\n   local current = File(path):read()\n   local newest = tostring(scroll)\n   if newest ~= current then\n      s:chat(a.green(\"    - \" .. tostring(path)))\n      if not dont_write then\n         File(path):write(newest)\n      end\n      return true\n   else\n   -- Otherwise do nothing\n      return nil\n   end\nend\n\n\n\nfunction Skein.persist(skein)\n   for _, scroll in pairs(skein.knitted) do\n      writeOnChange(scroll, scroll.path, skein.no_write)\n   end\n   local md = skein.woven.md\n   if md then\n      writeOnChange(md.text, md.path, skein.no_write)\n   end\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Skein.transform(skein)\n   local db = skein.lume.db\n   skein\n     : load()\n     : filter()\n     : spin()\n     : knit()\n     : weave()\n     : compile()\n     : transact(db.stmts, db.ids, db.git_info, skein.lume:now())\n     : persist()\n   return skein\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(path, lume)\n   local skein = setmetatable({}, Skein)\n   skein.note = Notary()\n   skein.source = {}\n   if not path then\n      error \"Skein must be constructed with a path\"\n   end\n   -- handles: string, Path, or File objects\n   if path.idEst ~= File then\n      path = File(Path(path):absPath())\n   end\n   if lume then\n      skein.lume = lume\n      -- lift info off the lume here\n      skein.project     = lume.project\n      skein.source_base = lume.orb\n      skein.knit_base   = lume.src\n      skein.weave_base  = lume.doc\n      if lume.no_write then\n         skein.no_write = true\n      end\n   end\n   skein.source.file = path\n   return skein\nend\n\nSkein.idEst = new\n\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "https://gitlab.com/special-circumstance/pylon",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/pylon",
    home = "",
    website = "",
    name = "pylon",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "sql",
hash = "94610a0e88337154c9cc418a5328eee3b6db5043f550af955847e4c57afbc3b7",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sqlayer = {}\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\n\njit.off(true, true)\n\n\n\n\n\n\nlocal ffi  = require \"ffi\"\nlocal bit  = require \"bit\"\nlocal uv   = require \"luv\"\n\n\n\n\n\n\nlocal insert = table.insert\n\n-- CREDIT: Steve Dovan snippet.\nlocal function split(s, re)\n local i1, ls = 1, { }\n if not re then re = \'%s+\' end\n if re == \'\' then return { s } end\n while true do\n   local i2, i3 = s:find(re, i1)\n   if not i2 then\n     local last = s:sub(i1)\n     if last ~= \'\' then insert(ls, last) end\n     if #ls == 1 and ls[1] == \'\' then\n       return  { }\n     else\n       return ls\n     end\n   end\n   insert(ls, s:sub(i1, i2 - 1))\n   i1 = i3 + 1\n end\nend\n\nlocal function trim(s)\n return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\nend\n\nlocal function err(code, msg)\n error(\"ljsqlite3[\"..code..\"] \"..msg .. \"\\n\" .. debug.traceback())\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Codes --------------------------------------------------------------------\nlocal sqlconstants = {} -- SQLITE_* and OPEN_* declarations.\nlocal codes = {\n   [0] = \"OK\", \"ERROR\", \"INTERNAL\", \"PERM\", \"ABORT\", \"BUSY\", \"LOCKED\", \"NOMEM\",\n   \"READONLY\", \"INTERRUPT\", \"IOERR\", \"CORRUPT\", \"NOTFOUND\", \"FULL\", \"CANTOPEN\",\n   \"PROTOCOL\", \"EMPTY\", \"SCHEMA\", \"TOOBIG\", \"CONSTRAINT\", \"MISMATCH\", \"MISUSE\",\n   \"NOLFS\", \"AUTH\", \"FORMAT\", \"RANGE\", \"NOTADB\", [100] = \"ROW\", [101] = \"DONE\"\n} -- From 0 to 26.\n\ndo\n   local types = { \"INTEGER\", \"FLOAT\", \"TEXT\", \"BLOB\", \"NULL\" } -- From 1 to 5.\n\n   local opens = {\n     READONLY =        0x00000001;\n     READWRITE =       0x00000002;\n     CREATE =          0x00000004;\n     DELETEONCLOSE =   0x00000008;\n     EXCLUSIVE =       0x00000010;\n     AUTOPROXY =       0x00000020;\n     URI =             0x00000040;\n     MAIN_DB =         0x00000100;\n     TEMP_DB =         0x00000200;\n     TRANSIENT_DB =    0x00000400;\n     MAIN_JOURNAL =    0x00000800;\n     TEMP_JOURNAL =    0x00001000;\n     SUBJOURNAL =      0x00002000;\n     MASTER_JOURNAL =  0x00004000;\n     NOMUTEX =         0x00008000;\n     FULLMUTEX =       0x00010000;\n     SHAREDCACHE =     0x00020000;\n     PRIVATECACHE =    0x00040000;\n     WAL =             0x00080000;\n   }\n\n   local t = sqlconstants\n   local pre = \"static const int32_t SQLITE_\"\n   for i=0,26    do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n   for i=100,101 do t[#t+1] = pre..codes[i]..\"=\"..i..\";\\n\" end\n   for i=1,5     do t[#t+1] = pre..types[i]..\"=\"..i..\";\\n\" end\n   pre = pre..\"OPEN_\"\n   for k,v in pairs(opens) do\n      t[#t+1] = pre..k..\"=\"..bit.tobit(v)..\";\\n\"\n   end\nend\n\n-- Cdef ---------------------------------------------------------------------\n-- SQLITE_*, OPEN_*\n\nffi.cdef(table.concat(sqlconstants))\n\n\n\n\n\n\n\nffi.cdef  [[\n// Typedefs.\ntypedef struct sqlite3 sqlite3;\ntypedef struct sqlite3_stmt sqlite3_stmt;\ntypedef void (*sqlite3_destructor_type)(void*);\ntypedef struct sqlite3_context sqlite3_context;\ntypedef struct Mem sqlite3_value;\n\n// Get informative error message.\nconst char *sqlite3_errmsg(sqlite3*);\n\n// Connection.\nint sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags,\n const char *zVfs);\nint sqlite3_close(sqlite3*);\nint sqlite3_busy_timeout(sqlite3*, int ms);\n\n// Statement.\nint sqlite3_prepare_v2(sqlite3 *conn, const char *zSql, int nByte,\n                       sqlite3_stmt **ppStmt, const char **pzTail);\nint sqlite3_step(sqlite3_stmt*);\nint sqlite3_reset(sqlite3_stmt *pStmt);\nint sqlite3_finalize(sqlite3_stmt *pStmt);\n\n// Extra functions for SELECT.\nint sqlite3_column_count(sqlite3_stmt *pStmt);\nconst char *sqlite3_column_name(sqlite3_stmt*, int N);\nint sqlite3_column_type(sqlite3_stmt*, int iCol);\n\n// Get value from SELECT.\nint64_t sqlite3_column_int64(sqlite3_stmt*, int iCol);\ndouble sqlite3_column_double(sqlite3_stmt*, int iCol);\nint sqlite3_column_bytes(sqlite3_stmt*, int iCol);\nconst unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\nconst void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\n\n// Set value in bind.\nint sqlite3_bind_int64(sqlite3_stmt*, int, int64_t);\nint sqlite3_bind_double(sqlite3_stmt*, int, double);\nint sqlite3_bind_null(sqlite3_stmt*, int);\nint sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));\nint sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\n\nint sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *name);\nconst char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\nint sqlite3_bind_parameter_count(sqlite3_stmt*);\n\n// Clear bindings.\nint sqlite3_clear_bindings(sqlite3_stmt*);\n\n// Get value in callbacks.\nint sqlite3_value_type(sqlite3_value*);\nint64_t sqlite3_value_int64(sqlite3_value*);\ndouble sqlite3_value_double(sqlite3_value*);\nint sqlite3_value_bytes(sqlite3_value*);\nconst unsigned char *sqlite3_value_text(sqlite3_value*); //Not used.\nconst void *sqlite3_value_blob(sqlite3_value*);\n\n// Set value in callbacks.\nvoid sqlite3_result_error(sqlite3_context*, const char*, int);\nvoid sqlite3_result_int64(sqlite3_context*, int64_t);\nvoid sqlite3_result_double(sqlite3_context*, double);\nvoid sqlite3_result_null(sqlite3_context*);\nvoid sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\nvoid sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\n\n// Persistency of data in callbacks (here just a pointer for tagging).\nvoid *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\n\n// Typedefs for callbacks.\ntypedef void (*ljsqlite3_cbstep)(sqlite3_context*,int,sqlite3_value**);\ntypedef void (*ljsqlite3_cbfinal)(sqlite3_context*);\n\n// Posix/libc sleep function, for non-blocking waits outside of event loops\nunsigned int sleep(unsigned int seconds);\n\nint usleep(int useconds); //pass in microseconds\n\n// Register callbacks.\nint sqlite3_create_function(\n    sqlite3 *conn,\n    const char *zFunctionName,\n    int nArg,\n    int eTextRep,\n    void *pApp,\n    void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n    void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n    void (*xFinal)(sqlite3_context*)\n);\n]]\n\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\n\nlocal transient = ffi.cast(\"sqlite3_destructor_type\", -1)\nlocal int64_ct = ffi.typeof(\"int64_t\")\n\nlocal blob_mt = {} -- For tagging only.\n\nlocal function blob(str)\n return setmetatable({ str }, blob_mt)\nend\n\nlocal connstmt = {} -- Statements for a conn.\nlocal conncb = {} -- Callbacks for a conn.\nlocal aggregatestate = {} -- Aggregate states.\n\nlocal stmt_step\n\nlocal stmt_mt, stmt_ct = {}\nstmt_mt.__index = stmt_mt\n\nlocal conn_mt, conn_ct = {}\nconn_mt.__index = conn_mt\n\n-- Checks ----------------------------------------------------------------------\n\n-- Helper function to get error msg and code from sqlite.\nlocal function codemsg(pconn, code)\n   return codes[code]:lower(), ffi.string(ffi.C.sqlite3_errmsg(pconn))\nend\n\n-- Throw error for a given connection.\nlocal function E_conn(pconn, code)\n   local code, msg = codemsg(pconn, code)\n   err(code, msg)\nend\n\n-- Test code is OK or throw error for a given connection.\nlocal function T_okcode(pconn, code)\n   if code ~= ffi.C.SQLITE_OK then\n      E_conn(pconn, code)\n   end\nend\n\nlocal function T_open(x)\n   if x._closed then\n      err(\"misuse\", \"object is closed\")\n   end\nend\n\n-- Getters / Setters to minimize code duplication ------------------------------\nlocal sql_get_code = [=[\nreturn function(stmt_or_value <opt_i>)\n local t = ffi.C.sqlite3_<variant>_type(stmt_or_value <opt_i>)\n if t == ffi.C.SQLITE_INTEGER then\n   return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>)\n elseif t == ffi.C.SQLITE_FLOAT then\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>)\n elseif t == ffi.C.SQLITE_TEXT then\n   local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n   return ffi.string(ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>), nb)\n elseif t == ffi.C.SQLITE_BLOB then\n   local nb = ffi.C.sqlite3_<variant>_bytes(stmt_or_value <opt_i>)\n   return ffi.string(ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>), nb)\n elseif t == ffi.C.SQLITE_NULL then\n   return nil\n else\n   err(\"constraint\", \"unexpected SQLite3 type\")\n end\nend\n]=]\n\nlocal sql_set_code = [=[\nreturn function(stmt_or_value, v <opt_i>)\n local t = type(v)\n if t == \"table\" then\n    --  Convert on a __todb metamethod\n    local t_M = getmetatable(v)\n    local method = t_M and t_M.__todb\n    if method then\n       v = method(v)\n       t = \"string\"\n    end\n end\n if ffi.istype(int64_ct, v) then\n   return ffi.C.sqlite3_<variant>_int64(stmt_or_value <opt_i>, v)\n elseif t == \"number\" then\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, v)\n elseif t == \"string\" then\n   return ffi.C.sqlite3_<variant>_text(stmt_or_value <opt_i>, v, #v,\n     transient)\n elseif t == \"table\" and getmetatable(v) == blob_mt then\n   v = v[1]\n   return ffi.C.sqlite3_<variant>_blob(stmt_or_value <opt_i>, v, #v,\n     transient)\n elseif t == \"boolean\" then\n   local bool_num = v and 1 or 0\n   return ffi.C.sqlite3_<variant>_double(stmt_or_value <opt_i>, bool_num)\n elseif t == \"nil\" then\n   return ffi.C.sqlite3_<variant>_null(stmt_or_value <opt_i>)\n else\n   err(\"constraint\", \"unexpected Lua type \" .. t)\n end\nend\n]=]\n\n-- Environment for setters/getters.\nlocal sql_env = {\n   sql          = sql,\n   transient    = transient,\n   ffi          = ffi,\n   int64_ct     = int64_ct,\n   blob_mt      = blob_mt,\n   getmetatable = getmetatable,\n   err          = err,\n   type         = type,\n   tostring     = tostring\n}\n\nlocal function sql_format(s, variant, index)\n   return s:gsub(\"<variant>\", variant):gsub(\"<opt_i>\", index)\nend\n\nlocal function loadcode(s, env)\n   local ret = assert(loadstring(s))\n   if env then setfenv(ret, env) end\n   return ret()\nend\n\n-- Must always be called from *:_* function due to error level 4.\nlocal get_column = loadcode(sql_format(sql_get_code, \"column\", \",i\"),   sql_env)\nlocal get_value  = loadcode(sql_format(sql_get_code, \"value\" , \"  \"),   sql_env)\nlocal set_column = loadcode(sql_format(sql_set_code, \"bind\"  , \",i\"),   sql_env)\nlocal set_value  = loadcode(sql_format(sql_set_code, \"result\", \"  \"),   sql_env)\n\n-- Connection ------------------------------------------------------------------\nlocal open_modes = {\n   ro = ffi.C.SQLITE_OPEN_READONLY,\n   rw = ffi.C.SQLITE_OPEN_READWRITE,\n   rwc = bit.bor(ffi.C.SQLITE_OPEN_READWRITE, ffi.C.SQLITE_OPEN_CREATE)\n}\n\nlocal conn_map = setmetatable({}, { __mode = \'kv\' })\n\nlocal function open(str, mode)\n   mode = mode or \"rwc\"\n   mode = open_modes[mode]\n   if not mode then\n      err(\"constraint\", \"argument #2 to open must be ro, rw, or rwc\")\n   end\n   local aptr = ffi.new(\"sqlite3*[1]\")\n   -- Usually aptr is set even if error code, so conn always needs to be closed.\n   local code = ffi.C.sqlite3_open_v2(str, aptr, mode, nil)\n   local conn = conn_ct(aptr[0], false)\n   -- Must create this anyway due to conn:close() function.\n   connstmt[conn] = setmetatable({}, { __mode = \"k\" })\n   conncb[conn] = { scalar = {}, step = {}, final = {} }\n   if code ~= ffi.C.SQLITE_OK then\n      local code, msg = codemsg(conn._ptr, code) -- Before closing!\n      conn:close() -- Free resources, should not fail here in this case!\n      err(code, msg)\n   end\n   conn_map[conn] = str\n   return conn\nend\n\nfunction conn_mt:close() T_open(self)\n  -- Close all stmt linked to conn.\n   for k,_ in pairs(connstmt[self]) do if not k._closed then k:close() end end\n    -- Close all callbacks linked to conn.\n   for _,v in pairs(conncb[self].scalar) do v:free() end\n   for _,v in pairs(conncb[self].step)   do v:free() end\n   for _,v in pairs(conncb[self].final)  do v:free() end\n   local code = ffi.C.sqlite3_close(self._ptr)\n   T_okcode(self._ptr, code)\n   connstmt[self] = nil -- Table connstmt is not weak, need to clear manually.\n   conncb[self] = nil\n   self._closed = true -- Set only if close succeded.\nend\n\nfunction conn_mt:__gc()\n   if not self._closed then self:close() end\nend\n\nfunction conn_mt:prepare(stmtstr)\n   local aptr = ffi.new(\"sqlite3_stmt*[1]\")\n   -- If error code aptr NULL, so no need to close anything.\n   local code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n   if (code == ffi.C.SQLITE_BUSY or code == ffi.C.SQLITE_LOCKED) then\n      -- are we in a coro loop?\n      local thread, main = coroutine.running()\n      local async = (not main) and uv.loop_alive()\n      if not async then\n         local retrying = true\n         local count = 1\n         while retrying do\n             -- sleep 0.2 seconds (200000) microseconds\n             ffi.C.usleep(200000)\n             code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n             if code == ffi.C.SQLITE_OK or count >= 100 then\n               retrying = false\n             end\n             count = count + 1\n         end\n      else\n         -- async retry\n         local idle = uv.new_idle()\n         idle:start(function()\n            code = ffi.C.sqlite3_prepare_v2(self._ptr, stmtstr, #stmtstr, aptr, nil)\n            if code == ffi.C.SQLITE_OK then\n               -- resume the thread\n               local stmt = stmt_ct(aptr[0], false, self._ptr, code)\n               connstmt[self][stmt] = true\n               idle:stop()\n               coroutine.resume(thread, stmt)\n            elseif not (code == ffi.C.SQLITE_BUSY\n                        or code == ffi.C.SQLITE_LOCKED) then\n               idle:stop()\n               T_okcode(self._ptr, code)\n            end\n            return nil\n         end)\n         return coroutine.yield()\n      end\n   end\n   T_okcode(self._ptr, code)\n   local stmt = stmt_ct(aptr[0], false, self._ptr, code)\n   connstmt[self][stmt] = true\n   return stmt\nend\n\n-- Connection exec, __call, rowexec --------------------------------------------\nfunction conn_mt:exec(commands, get) T_open(self)\n   get = get or \'ihk\'\n   local cmd1 = split(commands, \";\")\n   local res, n\n   for i=1,#cmd1 do\n      local cmd = trim(cmd1[i])\n      if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         res, n = stmt:resultset(get)\n         stmt:close()\n      end\n   end\n   return res, n -- Only last record is returned.\nend\n\nfunction conn_mt:rowexec(command) T_open(self)\n   local stmt = self:prepare(command)\n   local res = stmt:_step()\n   if stmt:_step() then\n      err(\"misuse\", \"multiple records returned, 1 expected\")\n   end\n   stmt:close()\n   if res then\n      return unpack(res)\n   else\n      return nil\n   end\nend\n\nfunction conn_mt:__call(commands, out) T_open(self)\n   out = out or print\n   local cmd1 = split(commands, \";\")\n   for c=1,#cmd1 do\n      local cmd = trim(cmd1[c])\n      if #cmd > 0 then\n         local stmt = self:prepare(cmd)\n         local ret, n = stmt:resultset(\'hik\')\n         if ret then -- All the results get handled, not only last one.\n            out(unpack(ret[0])) -- Headers are printed.\n            for i=1,n do\n               local o = {}\n               for j=1,#ret[0] do\n                  local v = ret[j][i]\n                  -- Empty strings for NULLs\n                  if type(v) == \"nil\" then v = \"\" end\n                  o[#o+1] = tostring(v)\n               end\n               out(unpack(o))\n            end\n         end\n         stmt:close()\n      end\n   end\nend\n\n-- Callbacks -------------------------------------------------------------------\n-- Update (one of) callbacks registry for sqlite functions.\nlocal function updatecb(self, where, name, f)\n   local cbs = conncb[self][where]\n   if cbs[name] then -- Callback already present, free old one.\n      cbs[name]:free()\n   end\n   cbs[name] = f -- Could be nil and that\'s fine.\nend\n\n-- Return manually casted callback that sqlite expects, scalar.\nlocal function scalarcb(name, f)\n   local values = {} -- Conversion buffer.\n   local function sqlf(context, nvalues, pvalues)\n      -- Indexing 0,N-1.\n      for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n      -- Throw error via sqlite function if necessary.\n      local ok, result = pcall(f, unpack(values, 1, nvalues))\n      if not ok then\n         local msg = \"Lua registered scalar function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      else\n         set_value(context, result)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\nend\n\n-- Return the state for aggregate case (created via initstate()). We use the ptr\n-- returned from aggregate_context() for tagging only, all the state data is\n-- handled from Lua side.\nlocal function getstate(context, initstate, size)\n   -- Only pointer address relevant for indexing, size irrelevant.\n   local ptr = ffi.C.sqlite3_aggregate_context(context, size)\n   local pid = tonumber(ffi.cast(\"intptr_t\",ptr))\n   local state = aggregatestate[pid]\n   if type(state) == \"nil\" then\n      state = initstate()\n      aggregatestate[pid] = state\n   end\n   return state, pid\nend\n\n-- Return manually casted callback that sqlite expects, stepper for aggregate.\nlocal function stepcb(name, f, initstate)\n   local values = {} -- Conversion buffer.\n   local function sqlf(context, nvalues, pvalues)\n      -- Indexing 0,N-1.\n      for i=1,nvalues do values[i] = get_value(pvalues[i - 1]) end\n      local state = getstate(context, initstate, 1)\n      -- Throw error via sqlite function if necessary.\n      local ok, result = pcall(f, state, unpack(values, 1, nvalues))\n      if not ok then\n         local msg = \"Lua registered step function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbstep\", sqlf)\nend\n\n-- Return manually casted callback that sqlite expects, finalizer for aggregate.\nlocal function finalcb(name, f, initstate)\n   local function sqlf(context)\n      local state, pid = getstate(context, initstate, 0)\n      aggregatestate[pid] = nil -- Clear the state.\n      local ok, result = pcall(f, state)\n      -- Throw error via sqlite function if necessary.\n      if not ok then\n         local msg = \"Lua registered final function \"..name..\" error: \"..result\n         ffi.C.sqlite3_result_error(context, msg, #msg)\n      else\n         set_value(context, result)\n      end\n   end\n   return ffi.cast(\"ljsqlite3_cbfinal\", sqlf)\nend\n\nfunction conn_mt:setscalar(name, f) T_open(self)\n   jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n   local cbf = f and scalarcb(name, f) or nil\n   local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n      cbf, nil, nil) -- If cbf nil this clears the function is sqlite.\n   T_okcode(self._ptr, code)\n   updatecb(self, \"scalar\", name, cbf) -- Update and clear old.\nend\n\nfunction conn_mt:setaggregate(name, initstate, step, final) T_open(self)\n   jit.off(stmt_step) -- Necessary to avoid bad calloc in some use cases.\n   local cbs = step  and stepcb (name, step,  initstate) or nil\n   local cbf = final and finalcb(name, final, initstate) or nil\n   local code = ffi.C.sqlite3_create_function(self._ptr, name, -1, 5, nil,\n      nil, cbs, cbf) -- If cbs, cbf nil this clears the function is sqlite.\n   T_okcode(self._ptr, code)\n   updatecb(self, \"step\", name, cbs) -- Update and clear old.\n   updatecb(self, \"final\", name, cbf) -- Update and clear old.\nend\n\nconn_ct = ffi.metatype(\"struct { sqlite3* _ptr; bool _closed; }\", conn_mt)\n\n-- Statement -------------------------------------------------------------------\nfunction stmt_mt:reset() T_open(self)\n   -- Ignore possible error code, it would be repetition of error raised during\n   -- most recent evaluation of statement which would have been raised already.\n   ffi.C.sqlite3_reset(self._ptr)\n   self._code = ffi.C.SQLITE_OK -- Always succeds.\n   return self\nend\n\nfunction stmt_mt:close() T_open(self)\n   -- Ignore possible error code, it would be repetition of error raised during\n   -- most recent evaluation of statement which would have been raised already.\n   ffi.C.sqlite3_finalize(self._ptr)\n   self._code = ffi.C.SQLITE_OK -- Always succeds.\n   self._closed = true -- Must be called exaclty once.\nend\n\nfunction stmt_mt:__gc()\n   if not self._closed then self:close() end\nend\n\n-- Statement step, resultset ---------------------------------------------------\nfunction stmt_mt:_ncol()\n   return ffi.C.sqlite3_column_count(self._ptr)\nend\n\nfunction stmt_mt:_header(h)\n   for i=1,self:_ncol() do -- Here indexing 0,N-1.\n      h[i] = ffi.string(ffi.C.sqlite3_column_name(self._ptr, i - 1))\n   end\nend\n\nlocal function _retry(action, self, row, header)\n   -- blocking first\n   local retrying = true\n   local count = 1\n   while retrying do\n      -- 0.2 seconds\n      ffi.C.usleep(200000)\n      local row, header = action(self, row, header)\n      if row ~= false then\n         return row, header\n      end\n      count = count + 1\n      if not (self._code == ffi.C.SQLITE_BUSY\n              or self._code == ffi.C.SQLITE_LOCKED) then\n         E_conn(self._conn, self._code)\n      end\n      if count >= 100 then\n         retrying = false\n      end\n   end\n   E_conn(self._conn, self._code)\nend\n\nlocal function _stepGen(action)\n   return function(self, row, header)\n      local row, header = action(self, row, header)\n      if row ~= false then\n         return row, header\n      end\n      if self._code == ffi.C.SQLITE_BUSY\n         or self._code == ffi.C.SQLITE_LOCKED then\n         -- retries are stubbed out because untested\n         E_conn(self._conn, self._code)\n         -- _retry(action, self, row, header)\n      else  -- Other codes are errors we can\'t recover from.\n         E_conn(self._conn, self._code)\n      end\n   end\nend\n\nlocal function step_action(self, row, header)\n   -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n   if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n   self._code = ffi.C.sqlite3_step(self._ptr)\n   if self._code == ffi.C.SQLITE_ROW then\n      -- All the sql.* functions called never errors here.\n      row = row or {}\n      for i=1,self:_ncol() do\n         row[i] = get_column(self._ptr, i - 1)\n      end\n      if header then self:_header(header) end\n      return row, header\n   elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now.\n      return nil\n   else\n      return false\n   end\nend\n\nstmt_step = _stepGen(step_action)\n\nstmt_mt._step = stmt_step\n\nlocal function stepkv_action(self, row, header)\n   -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n   if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n   self._code = ffi.C.sqlite3_step(self._ptr)\n   if self._code == ffi.C.SQLITE_ROW then\n      row = row or {}\n      for i = 0, self:_ncol() - 1 do\n         local col = ffi.string(ffi.C.sqlite3_column_name(self._ptr, i))\n         row[col] = get_column(self._ptr, i)\n      end\n      if header then self:_header(header) end\n      return row, header\n   elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now.\n      return nil\n   else\n      return false\n   end\nend\n\nstmt_mt.stepkv = _stepGen(stepkv_action)\n\nfunction stmt_mt:step(row, header) T_open(self)\n   return self:_step(row, header)\nend\n\n\n-- iterator for rows\nfunction stmt_mt:irows(maxrecords) T_open(self)\n   maxrecords = maxrecords or math.huge\n   if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n       err(\"constraint\", \"argument #2 to resultset must be >= 1\")\n   end\n   local n = 1\n   return function()\n       if n > maxrecords then return nil end\n       local row = self:step()\n       if row then\n         return row\n       else\n         self:clearbind():reset()\n         return nil\n       end\n   end\nend\n\nfunction stmt_mt:resultset(get, maxrecords) T_open(self)\n   get = get or \"k\"\n   maxrecords = maxrecords or math.huge\n   if maxrecords < 1 then\n      err(\"constraint\", \"argument #2 to resultset must be >= 1\")\n   end\n   local hash, hasi, hask = get:find(\"h\"), get:find(\"i\"), get:find(\"k\")\n   local r, h = self:_step({}, {})\n   if not r then return nil, 0 end -- No records case.\n   -- First record, o is a temporary table used to get records.\n   local o = hash and { [0] = h } or {}\n   for i=1,#h do o[i] = { r[i] } end\n   -- Other records.\n   local n = 1\n   while n < maxrecords and self:_step(r) do\n      n = n + 1\n      for i=1,#h do o[i][n] = r[i] end\n   end\n\n   local out = { [0] = o[0] } -- Eventually copy colnames.\n   if hasi then -- Use numeric indexes.\n      for i=1,#h do out[i] = o[i] end\n   end\n   if hask then -- Use colnames indexes.\n      for i=1,#h do out[h[i]] = o[i] end\n   end\n   return out, n\nend\n\n   function stmt_mt:rows(maxrecords) T_open(self)\n      maxrecords = maxrecords or math.huge\n      if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n         err(\"constraint\", \"argument to rows must be >= 1\")\n      end\n      local n = 1\n      return function()\n         if n > maxrecords then return nil end\n         local r = self:stepkv()\n         if r then\n            n = n + 1\n            return r\n         else\n            self:clearbind():reset()\n            return nil\n         end\n      end\n   end\n\n   function stmt_mt:cols(maxrecords) T_open(self)\n      maxrecords = maxrecords or math.huge\n      if maxrecords < 1 or type(maxrecords) ~= \'number\' then\n         err(\"constraint\", \"argument to cols must be >= 1\")\n      end\n      local row, ncol, n = {}, self:_ncol(), 0\n      return function()\n         if n >= maxrecords then return nil end\n         -- Must check code ~= SQL_DONE or sqlite3_step --> undefined result.\n         if self._code == ffi.C.SQLITE_DONE then return nil end -- Already finished.\n         -- reset container\n         for i = 1, ncol do\n            row[i] = nil\n         end\n         self._code = ffi.C.sqlite3_step(self._ptr)\n         if self._code == ffi.C.SQLITE_ROW then\n            n = n + 1\n            for i = 1, ncol do\n               row[i] = get_column(self._ptr, i - 1)\n            end\n            return n, unpack(row, 1, ncol)\n         elseif self._code == ffi.C.SQLITE_DONE then -- Have finished now\n            self:clearbind():reset()\n            return nil\n         else -- If code not DONE or ROW then it\'s error.\n            E_conn(self._conn, self._code)\n         end\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction stmt_mt:value() T_open(self)\n   local result, val = self:_step(), nil\n   if result then\n      val = result[1]\n   end\n   self:clearbind():reset()\n   return val\nend\n\n\n\n\n   -- Statement bind --------------------------------------------------------------\n   function stmt_mt:_bind1(i, v)\n     local code = set_column(self._ptr, v, i) -- Here indexing 1,N.\n     T_okcode(self._conn, code)\n     return self\n   end\n\n   function stmt_mt:bind1(i, v) T_open(self)\n     return self:_bind1(i, v)\n   end\n\n   function stmt_mt:bind(...) T_open(self)\n     for i=1,select(\"#\", ...) do self:_bind1(i, select(i, ...)) end\n     return self\n   end\n\n   function stmt_mt:bindkv(t) T_open(self)\n      local ncol = ffi.C.sqlite3_bind_parameter_count(self._ptr)\n      for i = 1, ncol do\n         local param = ffi.C.sqlite3_bind_parameter_name(self._ptr, i)\n         -- params of form :NNN eg :123 can have holes, so we check for NULL:\n         if param ~= nil then\n            param = ffi.string(param):sub(2)\n            if t[param] then\n               self:_bind1(i, t[param])\n            end\n         end\n      end\n      return self\n   end\n\n   function stmt_mt:clearbind() T_open(self)\n     local code = ffi.C.sqlite3_clear_bindings(self._ptr)\n     T_okcode(self._conn, code)\n     return self\n   end\n\n   stmt_ct = ffi.metatype([[struct {\n     sqlite3_stmt* _ptr;\n     bool          _closed;\n     sqlite3*      _conn;\n     int32_t       _code;\n   }]], stmt_mt)\n\n\n\n   sqlayer.open = open\n   sqlayer.blob = blob\n\n\n\n\n\n\n\n\n\n\n   local pcall = assert (pcall)\n   local gsub = assert(string.gsub)\n   local format = assert(string.format)\n\n\n\n\n\n\n\n\n  function sqlayer.conn_path(conn)\n     return conn_map[conn]\n  end\n\n\n\n\n\n\n\n\n   local function san(str)\n      return gsub(str, \"\'\", \"\'\'\")\n   end\n\n   sqlayer.san = san\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.format(str, ...)\n      local argv = {...}\n      str = gsub(str, \"%%s\", \"\'%%s\'\"):gsub(\"\'\'%%s\'\'\", \"\'%%s\'\")\n      for i, v in ipairs(argv) do\n         if type(v) == \"string\" then\n            argv[i] = san(v)\n         elseif type(v) == \"cdata\" then\n            -- assume this is a number of some kind\n            argv[i] = tonumber(v)\n         else\n            argv[i] = v\n         end\n      end\n      local success, ret = pcall(format, str, unpack(argv))\n      if success then\n         return ret\n      else\n         return success, ret\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.pexec(conn, stmt, col_str)\n      -- conn:exec(stmt)\n      col_str = col_str or \"hik\"\n      local success, result, nrow = pcall(conn.exec, conn, stmt, col_str)\n      if success then\n         return result, nrow\n      else\n         return false, result\n      end\n   end\n\n\n\n\n\n\n\n\n\n\n   function sqlayer.lastRowId(conn)\n      local result = conn:rowexec \"SELECT CAST(last_insert_rowid() AS REAL)\"\n      return result\n   end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.unwrapKey(result_set)\n   if result_set and result_set[1] and result_set[1][1] then\n      local id = result_set[1][1]\n      if type(id) == \"cdata\" then\n         return tonumber(id)\n      else\n         return id\n      end\n   else\n      return nil\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction sqlayer.toRow(sql_result, num)\n   if not sql_result then return nil end\n   local one_result = false\n   local result_tab = {}\n   if not num then\n      num = 1\n      one_result = true\n   end\n   assert(type(num) == \"number\")\n   for key, column in pairs(sql_result) do\n      if type(key) == \"string\" then\n         for i = 1, num do\n            local v = type(column[i]) == \"cdata\"\n                      and tonumber(column[i])\n                      or column[i]\n            result_tab[i] = result_tab[i] or {}\n            result_tab[i][key] = v\n         end\n      end\n   end\n   if one_result then\n      return result_tab[1]\n   else\n      return result_tab\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function migrate(conn, migration, s, ...)\n   if type(migration) == \'function\' then\n      migration(conn, s, ...)\n   elseif type(migration) == \'table\' then\n      for i, step in ipairs(migration) do\n         if type(step) == \'string\' then\n            s:verb(step)\n            conn:exec(step)\n         elseif type(step) == \'function\' then\n            step(conn, s, ...)\n         else\n            error(\"invalid step #\" .. i .. \" of type \" .. type(step))\n         end\n      end\n   else\n      error(\"cannot perform migration of type \" .. type(migration))\n   end\nend\n\n\n\nlocal format = assert(string.format)\nlocal open = assert(open)\n\nfunction sqlayer.boot(conn, migrations, ...)\n   conn = type(conn) == \'string\' and open(conn, \'rwc\') or conn\n   -- bail early with no migrations\n   if not migrations then return conn end\n   local version = #migrations\n   conn.pragma.foreign_keys(true)\n   conn.pragma.journal_mode \'wal\'\n   -- check the user_version and perform migrations if necessary.\n   local user_version = tonumber(conn.pragma.user_version())\n   if not user_version then\n      user_version = 1\n   end\n   if user_version < version then\n      local s = require \"status:status\" (io.stdout, io.stderr)\n      s.verbose = true -- probably not the correct default\n      conn.pragma.foreign_keys(false)\n      conn:exec \"BEGIN TRANSACTION;\"\n      for i = user_version + 1, version do\n         s:chat(\"Performing migration %d\", i)\n         migrate(conn, migrations[i], s, ...)\n      end\n      conn:exec \"COMMIT;\"\n      s:chat \"Cleaning up...\"\n      conn:exec \"VACUUM;\"\n      conn.pragma.foreign_keys(true)\n      conn.pragma.user_version(version)\n      s:chat(\"Migrations completed, your version is %d\", version)\n   elseif user_version > version then\n      error(format(\"Error: database version is %d, expected %d\",\n                   user_version, version))\n      os.exit(1)\n   end\n\n   return conn\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   local pragma_pre = \"PRAGMA \"\n\n   -- Builds and returns a pragma string\n   local function __pragma(prag, value)\n      local val\n      if value == nil then\n         return pragma_pre .. prag .. \";\"\n      end\n      if type(value) == \"boolean\" then\n         val = value and \" = 1\" or \" = 0\"\n      elseif type(value) == \"string\" then\n         val = \"(\'\" .. san(value) .. \"\')\"\n      elseif type(value) == \"number\" then\n         val = \" = \" .. tostring(value)\n      else\n         error(\"illegal value of type \"\n               .. type(value) .. \", \"\n               .. tostring(value))\n      end\n      return pragma_pre .. prag .. val .. \";\"\n   end\n\n   -- Sets a pragma and checks its new value\n   local function _prag_set(conn, prag)\n      return function(value)\n         local prag_str = __pragma(prag, value)\n         conn:exec(prag_str)\n         -- cast booleans results to Lua booleans,\n         -- otherwise return the (string) result\n         local answer = conn:exec(pragma_pre .. prag .. \";\", \"i\")\n         if answer[1] and answer[1][1] then\n            if answer[1][1] == 1 then\n               return true\n            elseif answer[1][1] == 0 then\n               return false\n            else\n               return answer[1][1]\n            end\n         end\n      end\n   end\n\n\n\n\n\n\n   local function new_conn_index(conn, key)\n      local function _prag_index(_, prag)\n         return _prag_set(conn, prag)\n      end\n      if key == \"pragma\" then\n         return setmetatable({}, {__index = _prag_index})\n      else\n         return conn_mt[key]\n      end\n   end\n\n   conn_mt.__index = new_conn_index\n\n\n\n\n\n\n\n\n\n  local close = conn_mt.close\n\n  function conn_mt.pclose(conn)\n     local uv = require \"luv\"\n     local loop_alive = uv.loop_alive()\n     local close_idler = uv.new_idle()\n     close_idler:start(function()\n       local success = pcall(close, conn)\n       if not success then\n         return nil\n       else\n         close_idler:stop()\n       end\n     end)\n     if not loop_alive then\n        uv.run \'default\'\n     end\n  end\n\n\n\n\n\n\njit.on()\nend\nsql = sqlayer\nsqlayer = nil\n\n",
},
  { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "argparse",
hash = "89b37e4e1714334792343dc40f7edf190f5bcaa553ac2028062dd93d65301091",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage.preload.argparse = (function ()\n-- The MIT License (MIT)\n\n-- Copyright (c) 2013 - 2018 Peter Melnichenko\n--                      2019 Paul Ouellette\n\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n-- the Software, and to permit persons to whom the Software is furnished to do so,\n-- subject to the following conditions:\n\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nlocal function deep_update(t1, t2)\n   for k, v in pairs(t2) do\n      if type(v) == \"table\" then\n         v = deep_update({}, v)\n      end\n\n      t1[k] = v\n   end\n\n   return t1\nend\n\n-- A property is a tuple {name, callback}.\n-- properties.args is number of properties that can be set as arguments\n-- when calling an object.\nlocal function class(prototype, properties, parent)\n   -- Class is the metatable of its instances.\n   local cl = {}\n   cl.__index = cl\n\n   if parent then\n      cl.__prototype = deep_update(deep_update({}, parent.__prototype), prototype)\n   else\n      cl.__prototype = prototype\n   end\n\n   if properties then\n      local names = {}\n\n      -- Create setter methods and fill set of property names.\n      for _, property in ipairs(properties) do\n         local name, callback = property[1], property[2]\n\n         cl[name] = function(self, value)\n            if not callback(self, value) then\n               self[\"_\" .. name] = value\n            end\n\n            return self\n         end\n\n         names[name] = true\n      end\n\n      function cl.__call(self, ...)\n         -- When calling an object, if the first argument is a table,\n         -- interpret keys as property names, else delegate arguments\n         -- to corresponding setters in order.\n         if type((...)) == \"table\" then\n            for name, value in pairs((...)) do\n               if names[name] then\n                  self[name](self, value)\n               end\n            end\n         else\n            local nargs = select(\"#\", ...)\n\n            for i, property in ipairs(properties) do\n               if i > nargs or i > properties.args then\n                  break\n               end\n\n               local arg = select(i, ...)\n\n               if arg ~= nil then\n                  self[property[1]](self, arg)\n               end\n            end\n         end\n\n         return self\n      end\n   end\n\n   -- If indexing class fails, fallback to its parent.\n   local class_metatable = {}\n   class_metatable.__index = parent\n\n   function class_metatable.__call(self, ...)\n      -- Calling a class returns its instance.\n      -- Arguments are delegated to the instance.\n      local object = deep_update({}, self.__prototype)\n      setmetatable(object, self)\n      return object(...)\n   end\n\n   return setmetatable(cl, class_metatable)\nend\n\nlocal function typecheck(name, types, value)\n   for _, type_ in ipairs(types) do\n      if type(value) == type_ then\n         return true\n      end\n   end\n\n   error((\"bad property \'%s\' (%s expected, got %s)\"):format(name, table.concat(types, \" or \"), type(value)))\nend\n\nlocal function typechecked(name, ...)\n   local types = {...}\n   return {name, function(_, value) typecheck(name, types, value) end}\nend\n\nlocal multiname = {\"name\", function(self, value)\n   typecheck(\"name\", {\"string\"}, value)\n\n   for alias in value:gmatch(\"%S+\") do\n      self._name = self._name or alias\n      table.insert(self._aliases, alias)\n   end\n\n   -- Do not set _name as with other properties.\n   return true\nend}\n\nlocal function parse_boundaries(str)\n   if tonumber(str) then\n      return tonumber(str), tonumber(str)\n   end\n\n   if str == \"*\" then\n      return 0, math.huge\n   end\n\n   if str == \"+\" then\n      return 1, math.huge\n   end\n\n   if str == \"?\" then\n      return 0, 1\n   end\n\n   if str:match \"^%d+%-%d+$\" then\n      local min, max = str:match \"^(%d+)%-(%d+)$\"\n      return tonumber(min), tonumber(max)\n   end\n\n   if str:match \"^%d+%+$\" then\n      local min = str:match \"^(%d+)%+$\"\n      return tonumber(min), math.huge\n   end\nend\n\nlocal function boundaries(name)\n   return {name, function(self, value)\n      typecheck(name, {\"number\", \"string\"}, value)\n\n      local min, max = parse_boundaries(value)\n\n      if not min then\n         error((\"bad property \'%s\'\"):format(name))\n      end\n\n      self[\"_min\" .. name], self[\"_max\" .. name] = min, max\n   end}\nend\n\nlocal actions = {}\n\nlocal option_action = {\"action\", function(_, value)\n   typecheck(\"action\", {\"function\", \"string\"}, value)\n\n   if type(value) == \"string\" and not actions[value] then\n      error((\"unknown action \'%s\'\"):format(value))\n   end\nend}\n\nlocal option_init = {\"init\", function(self)\n   self._has_init = true\nend}\n\nlocal option_default = {\"default\", function(self, value)\n   if type(value) ~= \"string\" then\n      self._init = value\n      self._has_init = true\n      return true\n   end\nend}\n\nlocal add_help = {\"add_help\", function(self, value)\n   typecheck(\"add_help\", {\"boolean\", \"string\", \"table\"}, value)\n\n   if self._help_option_idx then\n      table.remove(self._options, self._help_option_idx)\n      self._help_option_idx = nil\n   end\n\n   if value then\n      local help = self:flag()\n         :description \"Show this help message and exit.\"\n         :action(function()\n            print(self:get_help())\n            os.exit(0)\n         end)\n\n      if value ~= true then\n         help = help(value)\n      end\n\n      if not help._name then\n         help \"-h\" \"--help\"\n      end\n\n      self._help_option_idx = #self._options\n   end\nend}\n\nlocal Parser = class({\n   _arguments = {},\n   _options = {},\n   _commands = {},\n   _mutexes = {},\n   _groups = {},\n   _require_command = true,\n   _handle_options = true\n}, {\n   args = 3,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   add_help\n})\n\nlocal Command = class({\n   _aliases = {}\n}, {\n   args = 3,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   typechecked(\"epilog\", \"string\"),\n   typechecked(\"summary\", \"string\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"usage\", \"string\"),\n   typechecked(\"help\", \"string\"),\n   typechecked(\"require_command\", \"boolean\"),\n   typechecked(\"handle_options\", \"boolean\"),\n   typechecked(\"action\", \"function\"),\n   typechecked(\"command_target\", \"string\"),\n   typechecked(\"help_vertical_space\", \"number\"),\n   typechecked(\"usage_margin\", \"number\"),\n   typechecked(\"usage_max_width\", \"number\"),\n   typechecked(\"help_usage_margin\", \"number\"),\n   typechecked(\"help_description_margin\", \"number\"),\n   typechecked(\"help_max_width\", \"number\"),\n   typechecked(\"hidden\", \"boolean\"),\n   add_help\n}, Parser)\n\nlocal Argument = class({\n   _minargs = 1,\n   _maxargs = 1,\n   _mincount = 1,\n   _maxcount = 1,\n   _defmode = \"unused\",\n   _show_default = true\n}, {\n   args = 5,\n   typechecked(\"name\", \"string\"),\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n})\n\nlocal Option = class({\n   _aliases = {},\n   _mincount = 0,\n   _overwrite = true\n}, {\n   args = 6,\n   multiname,\n   typechecked(\"description\", \"string\"),\n   option_default,\n   typechecked(\"convert\", \"function\", \"table\"),\n   boundaries(\"args\"),\n   boundaries(\"count\"),\n   typechecked(\"target\", \"string\"),\n   typechecked(\"defmode\", \"string\"),\n   typechecked(\"show_default\", \"boolean\"),\n   typechecked(\"overwrite\", \"boolean\"),\n   typechecked(\"argname\", \"string\", \"table\"),\n   typechecked(\"choices\", \"table\"),\n   typechecked(\"hidden\", \"boolean\"),\n   option_action,\n   option_init\n}, Argument)\n\nfunction Parser:_inherit_property(name, default)\n   local element = self\n\n   while true do\n      local value = element[\"_\" .. name]\n\n      if value ~= nil then\n         return value\n      end\n\n      if not element._parent then\n         return default\n      end\n\n      element = element._parent\n   end\nend\n\nfunction Argument:_get_argument_list()\n   local buf = {}\n   local i = 1\n\n   while i <= math.min(self._minargs, 3) do\n      local argname = self:_get_argname(i)\n\n      if self._default and self._defmode:find \"a\" then\n         argname = \"[\" .. argname .. \"]\"\n      end\n\n      table.insert(buf, argname)\n      i = i+1\n   end\n\n   while i <= math.min(self._maxargs, 3) do\n      table.insert(buf, \"[\" .. self:_get_argname(i) .. \"]\")\n      i = i+1\n\n      if self._maxargs == math.huge then\n         break\n      end\n   end\n\n   if i < self._maxargs then\n      table.insert(buf, \"...\")\n   end\n\n   return buf\nend\n\nfunction Argument:_get_usage()\n   local usage = table.concat(self:_get_argument_list(), \" \")\n\n   if self._default and self._defmode:find \"u\" then\n      if self._maxargs > 1 or (self._minargs == 1 and not self._defmode:find \"a\") then\n         usage = \"[\" .. usage .. \"]\"\n      end\n   end\n\n   return usage\nend\n\nfunction actions.store_true(result, target)\n   result[target] = true\nend\n\nfunction actions.store_false(result, target)\n   result[target] = false\nend\n\nfunction actions.store(result, target, argument)\n   result[target] = argument\nend\n\nfunction actions.count(result, target, _, overwrite)\n   if not overwrite then\n      result[target] = result[target] + 1\n   end\nend\n\nfunction actions.append(result, target, argument, overwrite)\n   result[target] = result[target] or {}\n   table.insert(result[target], argument)\n\n   if overwrite then\n      table.remove(result[target], 1)\n   end\nend\n\nfunction actions.concat(result, target, arguments, overwrite)\n   if overwrite then\n      error(\"\'concat\' action can\'t handle too many invocations\")\n   end\n\n   result[target] = result[target] or {}\n\n   for _, argument in ipairs(arguments) do\n      table.insert(result[target], argument)\n   end\nend\n\nfunction Argument:_get_action()\n   local action, init\n\n   if self._maxcount == 1 then\n      if self._maxargs == 0 then\n         action, init = \"store_true\", nil\n      else\n         action, init = \"store\", nil\n      end\n   else\n      if self._maxargs == 0 then\n         action, init = \"count\", 0\n      else\n         action, init = \"append\", {}\n      end\n   end\n\n   if self._action then\n      action = self._action\n   end\n\n   if self._has_init then\n      init = self._init\n   end\n\n   if type(action) == \"string\" then\n      action = actions[action]\n   end\n\n   return action, init\nend\n\n-- Returns placeholder for `narg`-th argument.\nfunction Argument:_get_argname(narg)\n   local argname = self._argname or self:_get_default_argname()\n\n   if type(argname) == \"table\" then\n      return argname[narg]\n   else\n      return argname\n   end\nend\n\nfunction Argument:_get_choices_list()\n   return \"{\" .. table.concat(self._choices, \",\") .. \"}\"\nend\n\nfunction Argument:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self._name .. \">\"\n   end\nend\n\nfunction Option:_get_default_argname()\n   if self._choices then\n      return self:_get_choices_list()\n   else\n      return \"<\" .. self:_get_default_target() .. \">\"\n   end\nend\n\n-- Returns labels to be shown in the help message.\nfunction Argument:_get_label_lines()\n   if self._choices then\n      return {self:_get_choices_list()}\n   else\n      return {self._name}\n   end\nend\n\nfunction Option:_get_label_lines()\n   local argument_list = self:_get_argument_list()\n\n   if #argument_list == 0 then\n      -- Don\'t put aliases for simple flags like `-h` on different lines.\n      return {table.concat(self._aliases, \", \")}\n   end\n\n   local longest_alias_length = -1\n\n   for _, alias in ipairs(self._aliases) do\n      longest_alias_length = math.max(longest_alias_length, #alias)\n   end\n\n   local argument_list_repr = table.concat(argument_list, \" \")\n   local lines = {}\n\n   for i, alias in ipairs(self._aliases) do\n      local line = (\" \"):rep(longest_alias_length - #alias) .. alias .. \" \" .. argument_list_repr\n\n      if i ~= #self._aliases then\n         line = line .. \",\"\n      end\n\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nfunction Command:_get_label_lines()\n   return {table.concat(self._aliases, \", \")}\nend\n\nfunction Argument:_get_description()\n   if self._default and self._show_default then\n      if self._description then\n         return (\"%s (default: %s)\"):format(self._description, self._default)\n      else\n         return (\"default: %s\"):format(self._default)\n      end\n   else\n      return self._description or \"\"\n   end\nend\n\nfunction Command:_get_description()\n   return self._summary or self._description or \"\"\nend\n\nfunction Option:_get_usage()\n   local usage = self:_get_argument_list()\n   table.insert(usage, 1, self._name)\n   usage = table.concat(usage, \" \")\n\n   if self._mincount == 0 or self._default then\n      usage = \"[\" .. usage .. \"]\"\n   end\n\n   return usage\nend\n\nfunction Argument:_get_default_target()\n   return self._name\nend\n\nfunction Option:_get_default_target()\n   local res\n\n   for _, alias in ipairs(self._aliases) do\n      if alias:sub(1, 1) == alias:sub(2, 2) then\n         res = alias:sub(3)\n         break\n      end\n   end\n\n   res = res or self._name:sub(2)\n   return (res:gsub(\"-\", \"_\"))\nend\n\nfunction Option:_is_vararg()\n   return self._maxargs ~= self._minargs\nend\n\nfunction Parser:_get_fullname(exclude_root)\n   local parent = self._parent\n   if exclude_root and not parent then\n      return \"\"\n   end\n   local buf = {self._name}\n\n   while parent do\n      if not exclude_root or parent._parent then\n         table.insert(buf, 1, parent._name)\n      end\n      parent = parent._parent\n   end\n\n   return table.concat(buf, \" \")\nend\n\nfunction Parser:_update_charset(charset)\n   charset = charset or {}\n\n   for _, command in ipairs(self._commands) do\n      command:_update_charset(charset)\n   end\n\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         charset[alias:sub(1, 1)] = true\n      end\n   end\n\n   return charset\nend\n\nfunction Parser:argument(...)\n   local argument = Argument(...)\n   table.insert(self._arguments, argument)\n   return argument\nend\n\nfunction Parser:option(...)\n   local option = Option(...)\n   table.insert(self._options, option)\n   return option\nend\n\nfunction Parser:flag(...)\n   return self:option():args(0)(...)\nend\n\nfunction Parser:command(...)\n   local command = Command():add_help(true)(...)\n   command._parent = self\n   table.insert(self._commands, command)\n   return command\nend\n\nfunction Parser:mutex(...)\n   local elements = {...}\n\n   for i, element in ipairs(elements) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument, (\"bad argument #%d to \'mutex\' (Option or Argument expected)\"):format(i))\n   end\n\n   table.insert(self._mutexes, elements)\n   return self\nend\n\nfunction Parser:group(name, ...)\n   assert(type(name) == \"string\", (\"bad argument #1 to \'group\' (string expected, got %s)\"):format(type(name)))\n\n   local group = {name = name, ...}\n\n   for i, element in ipairs(group) do\n      local mt = getmetatable(element)\n      assert(mt == Option or mt == Argument or mt == Command,\n         (\"bad argument #%d to \'group\' (Option or Argument or Command expected)\"):format(i + 1))\n   end\n\n   table.insert(self._groups, group)\n   return self\nend\n\nlocal usage_welcome = \"Usage: \"\n\nfunction Parser:get_usage()\n   if self._usage then\n      return self._usage\n   end\n\n   local usage_margin = self:_inherit_property(\"usage_margin\", #usage_welcome)\n   local max_usage_width = self:_inherit_property(\"usage_max_width\", 70)\n   local lines = {usage_welcome .. self:_get_fullname()}\n\n   local function add(s)\n      if #lines[#lines]+1+#s <= max_usage_width then\n         lines[#lines] = lines[#lines] .. \" \" .. s\n      else\n         lines[#lines+1] = (\" \"):rep(usage_margin) .. s\n      end\n   end\n\n   -- Normally options are before positional arguments in usage messages.\n   -- However, vararg options should be after, because they can\'t be reliable used\n   -- before a positional argument.\n   -- Mutexes come into play, too, and are shown as soon as possible.\n   -- Overall, output usages in the following order:\n   -- 1. Mutexes that don\'t have positional arguments or vararg options.\n   -- 2. Options that are not in any mutexes and are not vararg.\n   -- 3. Positional arguments - on their own or as a part of a mutex.\n   -- 4. Remaining mutexes.\n   -- 5. Remaining options.\n\n   local elements_in_mutexes = {}\n   local added_elements = {}\n   local added_mutexes = {}\n   local argument_to_mutexes = {}\n\n   local function add_mutex(mutex, main_argument)\n      if added_mutexes[mutex] then\n         return\n      end\n\n      added_mutexes[mutex] = true\n      local buf = {}\n\n      for _, element in ipairs(mutex) do\n         if not element._hidden and not added_elements[element] then\n            if getmetatable(element) == Option or element == main_argument then\n               table.insert(buf, element:_get_usage())\n               added_elements[element] = true\n            end\n         end\n      end\n\n      if #buf == 1 then\n         add(buf[1])\n      elseif #buf > 1 then\n         add(\"(\" .. table.concat(buf, \" | \") .. \")\")\n      end\n   end\n\n   local function add_element(element)\n      if not element._hidden and not added_elements[element] then\n         add(element:_get_usage())\n         added_elements[element] = true\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      local is_vararg = false\n      local has_argument = false\n\n      for _, element in ipairs(mutex) do\n         if getmetatable(element) == Option then\n            if element:_is_vararg() then\n               is_vararg = true\n            end\n         else\n            has_argument = true\n            argument_to_mutexes[element] = argument_to_mutexes[element] or {}\n            table.insert(argument_to_mutexes[element], mutex)\n         end\n\n         elements_in_mutexes[element] = true\n      end\n\n      if not is_vararg and not has_argument then\n         add_mutex(mutex)\n      end\n   end\n\n   for _, option in ipairs(self._options) do\n      if not elements_in_mutexes[option] and not option:_is_vararg() then\n         add_element(option)\n      end\n   end\n\n   -- Add usages for positional arguments, together with one mutex containing them, if they are in a mutex.\n   for _, argument in ipairs(self._arguments) do\n      -- Pick a mutex as a part of which to show this argument, take the first one that\'s still available.\n      local mutex\n\n      if elements_in_mutexes[argument] then\n         for _, argument_mutex in ipairs(argument_to_mutexes[argument]) do\n            if not added_mutexes[argument_mutex] then\n               mutex = argument_mutex\n            end\n         end\n      end\n\n      if mutex then\n         add_mutex(mutex, argument)\n      else\n         add_element(argument)\n      end\n   end\n\n   for _, mutex in ipairs(self._mutexes) do\n      add_mutex(mutex)\n   end\n\n   for _, option in ipairs(self._options) do\n      add_element(option)\n   end\n\n   if #self._commands > 0 then\n      if self._require_command then\n         add(\"<command>\")\n      else\n         add(\"[<command>]\")\n      end\n\n      add(\"...\")\n   end\n\n   return table.concat(lines, \"\\n\")\nend\n\nlocal function split_lines(s)\n   if s == \"\" then\n      return {}\n   end\n\n   local lines = {}\n\n   if s:sub(-1) ~= \"\\n\" then\n      s = s .. \"\\n\"\n   end\n\n   for line in s:gmatch(\"([^\\n]*)\\n\") do\n      table.insert(lines, line)\n   end\n\n   return lines\nend\n\nlocal function autowrap_line(line, max_length)\n   -- Algorithm for splitting lines is simple and greedy.\n   local result_lines = {}\n\n   -- Preserve original indentation of the line, put this at the beginning of each result line.\n   -- If the first word looks like a list marker (\'*\', \'+\', or \'-\'), add spaces so that starts\n   -- of the second and the following lines vertically align with the start of the second word.\n   local indentation = line:match(\"^ *\")\n\n   if line:find(\"^ *[%*%+%-]\") then\n      indentation = indentation .. \" \" .. line:match(\"^ *[%*%+%-]( *)\")\n   end\n\n   -- Parts of the last line being assembled.\n   local line_parts = {}\n\n   -- Length of the current line.\n   local line_length = 0\n\n   -- Index of the next character to consider.\n   local index = 1\n\n   while true do\n      local word_start, word_finish, word = line:find(\"([^ ]+)\", index)\n\n      if not word_start then\n         -- Ignore trailing spaces, if any.\n         break\n      end\n\n      local preceding_spaces = line:sub(index, word_start - 1)\n      index = word_finish + 1\n\n      if (#line_parts == 0) or (line_length + #preceding_spaces + #word <= max_length) then\n         -- Either this is the very first word or it fits as an addition to the current line, add it.\n         table.insert(line_parts, preceding_spaces) -- For the very first word this adds the indentation.\n         table.insert(line_parts, word)\n         line_length = line_length + #preceding_spaces + #word\n      else\n         -- Does not fit, finish current line and put the word into a new one.\n         table.insert(result_lines, table.concat(line_parts))\n         line_parts = {indentation, word}\n         line_length = #indentation + #word\n      end\n   end\n\n   if #line_parts > 0 then\n      table.insert(result_lines, table.concat(line_parts))\n   end\n\n   if #result_lines == 0 then\n      -- Preserve empty lines.\n      result_lines[1] = \"\"\n   end\n\n   return result_lines\nend\n\n-- Automatically wraps lines within given array,\n-- attempting to limit line length to `max_length`.\n-- Existing line splits are preserved.\nlocal function autowrap(lines, max_length)\n   local result_lines = {}\n\n   for _, line in ipairs(lines) do\n      local autowrapped_lines = autowrap_line(line, max_length)\n\n      for _, autowrapped_line in ipairs(autowrapped_lines) do\n         table.insert(result_lines, autowrapped_line)\n      end\n   end\n\n   return result_lines\nend\n\nfunction Parser:_get_element_help(element)\n   local label_lines = element:_get_label_lines()\n   local description_lines = split_lines(element:_get_description())\n\n   local result_lines = {}\n\n   -- All label lines should have the same length (except the last one, it has no comma).\n   -- If too long, start description after all the label lines.\n   -- Otherwise, combine label and description lines.\n\n   local usage_margin_len = self:_inherit_property(\"help_usage_margin\", 3)\n   local usage_margin = (\" \"):rep(usage_margin_len)\n   local description_margin_len = self:_inherit_property(\"help_description_margin\", 25)\n   local description_margin = (\" \"):rep(description_margin_len)\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if help_max_width then\n      local description_max_width = math.max(help_max_width - description_margin_len, 10)\n      description_lines = autowrap(description_lines, description_max_width)\n   end\n\n   if #label_lines[1] >= (description_margin_len - usage_margin_len) then\n      for _, label_line in ipairs(label_lines) do\n         table.insert(result_lines, usage_margin .. label_line)\n      end\n\n      for _, description_line in ipairs(description_lines) do\n         table.insert(result_lines, description_margin .. description_line)\n      end\n   else\n      for i = 1, math.max(#label_lines, #description_lines) do\n         local label_line = label_lines[i]\n         local description_line = description_lines[i]\n\n         local line = \"\"\n\n         if label_line then\n            line = usage_margin .. label_line\n         end\n\n         if description_line and description_line ~= \"\" then\n            line = line .. (\" \"):rep(description_margin_len - #line) .. description_line\n         end\n\n         table.insert(result_lines, line)\n      end\n   end\n\n   return table.concat(result_lines, \"\\n\")\nend\n\nlocal function get_group_types(group)\n   local types = {}\n\n   for _, element in ipairs(group) do\n      types[getmetatable(element)] = true\n   end\n\n   return types\nend\n\nfunction Parser:_add_group_help(blocks, added_elements, label, elements)\n   local buf = {label}\n\n   for _, element in ipairs(elements) do\n      if not element._hidden and not added_elements[element] then\n         added_elements[element] = true\n         table.insert(buf, self:_get_element_help(element))\n      end\n   end\n\n   if #buf > 1 then\n      table.insert(blocks, table.concat(buf, (\"\\n\"):rep(self:_inherit_property(\"help_vertical_space\", 0) + 1)))\n   end\nend\n\nfunction Parser:get_help()\n   if self._help then\n      return self._help\n   end\n\n   local blocks = {self:get_usage()}\n\n   local help_max_width = self:_inherit_property(\"help_max_width\")\n\n   if self._description then\n      local description = self._description\n\n      if help_max_width then\n         description = table.concat(autowrap(split_lines(description), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, description)\n   end\n\n   -- 1. Put groups containing arguments first, then other arguments.\n   -- 2. Put remaining groups containing options, then other options.\n   -- 3. Put remaining groups containing commands, then other commands.\n   -- Assume that an element can\'t be in several groups.\n   local groups_by_type = {\n      [Argument] = {},\n      [Option] = {},\n      [Command] = {}\n   }\n\n   for _, group in ipairs(self._groups) do\n      local group_types = get_group_types(group)\n\n      for _, mt in ipairs({Argument, Option, Command}) do\n         if group_types[mt] then\n            table.insert(groups_by_type[mt], group)\n            break\n         end\n      end\n   end\n\n   local default_groups = {\n      {name = \"Arguments\", type = Argument, elements = self._arguments},\n      {name = \"Options\", type = Option, elements = self._options},\n      {name = \"Commands\", type = Command, elements = self._commands}\n   }\n\n   local added_elements = {}\n\n   for _, default_group in ipairs(default_groups) do\n      local type_groups = groups_by_type[default_group.type]\n\n      for _, group in ipairs(type_groups) do\n         self:_add_group_help(blocks, added_elements, group.name .. \":\", group)\n      end\n\n      local default_label = default_group.name .. \":\"\n\n      if #type_groups > 0 then\n         default_label = \"Other \" .. default_label:gsub(\"^.\", string.lower)\n      end\n\n      self:_add_group_help(blocks, added_elements, default_label, default_group.elements)\n   end\n\n   if self._epilog then\n      local epilog = self._epilog\n\n      if help_max_width then\n         epilog = table.concat(autowrap(split_lines(epilog), help_max_width), \"\\n\")\n      end\n\n      table.insert(blocks, epilog)\n   end\n\n   return table.concat(blocks, \"\\n\\n\")\nend\n\nfunction Parser:add_help_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_help_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local help = self:command()\n      :description \"Show help for commands.\"\n   help:argument \"command\"\n      :description \"The command to show help for.\"\n      :args \"?\"\n      :action(function(_, _, cmd)\n         if not cmd then\n            print(self:get_help())\n            os.exit(0)\n         else\n            for _, command in ipairs(self._commands) do\n               for _, alias in ipairs(command._aliases) do\n                  if alias == cmd then\n                     print(command:get_help())\n                     os.exit(0)\n                  end\n               end\n            end\n         end\n         help:error((\"unknown command \'%s\'\"):format(cmd))\n      end)\n\n   if value then\n      help = help(value)\n   end\n\n   if not help._name then\n      help \"help\"\n   end\n\n   help._is_help_command = true\n   return self\nend\n\nfunction Parser:_is_shell_safe()\n   if self._basename then\n      if self._basename:find(\"[^%w_%-%+%.]\") then\n         return false\n      end\n   else\n      for _, alias in ipairs(self._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n   end\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         if alias:find(\"[^%w_%-%+%.]\") then\n            return false\n         end\n      end\n      if option._choices then\n         for _, choice in ipairs(option._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, argument in ipairs(self._arguments) do\n      if argument._choices then\n         for _, choice in ipairs(argument._choices) do\n            if choice:find(\"[%s\'\\\"]\") then\n               return false\n            end\n         end\n      end\n   end\n   for _, command in ipairs(self._commands) do\n      if not command:_is_shell_safe() then\n         return false\n      end\n   end\n   return true\nend\n\nfunction Parser:add_complete(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:option()\n      :description \"Output a shell completion script for the specified shell.\"\n      :args(1)\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"--completion\"\n   end\n\n   return self\nend\n\nfunction Parser:add_complete_command(value)\n   if value then\n      assert(type(value) == \"string\" or type(value) == \"table\",\n         (\"bad argument #1 to \'add_complete_command\' (string or table expected, got %s)\"):format(type(value)))\n   end\n\n   local complete = self:command()\n      :description \"Output a shell completion script.\"\n   complete:argument \"shell\"\n      :description \"The shell to output a completion script for.\"\n      :choices {\"bash\", \"zsh\", \"fish\"}\n      :action(function(_, _, shell)\n         io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n         os.exit(0)\n      end)\n\n   if value then\n      complete = complete(value)\n   end\n\n   if not complete._name then\n      complete \"completion\"\n   end\n\n   return self\nend\n\nlocal function base_name(pathname)\n   return pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\") or pathname\nend\n\nlocal function get_short_description(element)\n   local short = element:_get_description():match(\"^(.-)%.%s\")\n   return short or element:_get_description():match(\"^(.-)%.?$\")\nend\n\nfunction Parser:_get_options()\n   local options = {}\n   for _, option in ipairs(self._options) do\n      for _, alias in ipairs(option._aliases) do\n         table.insert(options, alias)\n      end\n   end\n   return table.concat(options, \" \")\nend\n\nfunction Parser:_get_commands()\n   local commands = {}\n   for _, command in ipairs(self._commands) do\n      for _, alias in ipairs(command._aliases) do\n         table.insert(commands, alias)\n      end\n   end\n   return table.concat(commands, \" \")\nend\n\nfunction Parser:_bash_option_args(buf, indent)\n   local opts = {}\n   for _, option in ipairs(self._options) do\n      if option._choices or option._minargs > 0 then\n         local compreply\n         if option._choices then\n            compreply = \'COMPREPLY=($(compgen -W \"\' .. table.concat(option._choices, \" \") .. \'\" -- \"$cur\"))\'\n         else\n            compreply = \'COMPREPLY=($(compgen -f -- \"$cur\"))\'\n         end\n         table.insert(opts, (\" \"):rep(indent + 4) .. table.concat(option._aliases, \"|\") .. \")\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. compreply)\n         table.insert(opts, (\" \"):rep(indent + 8) .. \"return 0\")\n         table.insert(opts, (\" \"):rep(indent + 8) .. \";;\")\n      end\n   end\n\n   if #opts > 0 then\n      table.insert(buf, (\" \"):rep(indent) .. \'case \"$prev\" in\')\n      table.insert(buf, table.concat(opts, \"\\n\"))\n      table.insert(buf, (\" \"):rep(indent) .. \"esac\\n\")\n   end\nend\n\nfunction Parser:_bash_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \'args=(\"${args[@]:1}\")\')\n   table.insert(buf, (\" \"):rep(indent) .. \'for arg in \"${args[@]}\"; do\')\n   table.insert(buf, (\" \"):rep(indent + 4) .. \'case \"$arg\" in\')\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. table.concat(command._aliases, \"|\") .. \")\")\n      if self._parent then\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"$cmd \' .. command._name .. \'\"\')\n      else\n         table.insert(buf, (\" \"):rep(indent + 12) .. \'cmd=\"\' .. command._name .. \'\"\')\n      end\n      table.insert(buf, (\" \"):rep(indent + 12) .. \'opts=\"$opts \' .. command:_get_options() .. \'\"\')\n      command:_bash_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n      table.insert(buf, (\" \"):rep(indent + 12) .. \";;\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"esac\")\n   table.insert(buf, (\" \"):rep(indent) .. \"done\")\nend\n\nfunction Parser:_bash_cmd_completions(buf)\n   local cmd_buf = {}\n   if self._parent then\n      self:_bash_option_args(cmd_buf, 12)\n   end\n   if #self._commands > 0 then\n      table.insert(cmd_buf, (\" \"):rep(12) .. \'COMPREPLY=($(compgen -W \"\' .. self:_get_commands() .. \'\" -- \"$cur\"))\')\n   elseif self._is_help_command then\n      table.insert(cmd_buf, (\" \"):rep(12)\n         .. \'COMPREPLY=($(compgen -W \"\'\n         .. self._parent:_get_commands()\n         .. \'\" -- \"$cur\"))\')\n   end\n   if #cmd_buf > 0 then\n      table.insert(buf, (\" \"):rep(8) .. \"\'\" .. self:_get_fullname(true) .. \"\')\")\n      table.insert(buf, table.concat(cmd_buf, \"\\n\"))\n      table.insert(buf, (\" \"):rep(12) .. \";;\")\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_bash_cmd_completions(buf)\n   end\nend\n\nfunction Parser:get_bash_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {([[\n_%s() {\n    local IFS=$\' \\t\\n\'\n    local args cur prev cmd opts arg\n    args=(\"${COMP_WORDS[@]}\")\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    opts=\"%s\"\n]]):format(self._basename, self:_get_options())}\n\n   self:_bash_option_args(buf, 4)\n   self:_bash_get_cmd(buf, 4)\n   if #self._commands > 0 then\n      table.insert(buf, \"\")\n      table.insert(buf, (\" \"):rep(4) .. \'case \"$cmd\" in\')\n      self:_bash_cmd_completions(buf)\n      table.insert(buf, (\" \"):rep(4) .. \"esac\\n\")\n   end\n\n   table.insert(buf, ([=[\n    if [[ \"$cur\" = -* ]]; then\n        COMPREPLY=($(compgen -W \"$opts\" -- \"$cur\"))\n    fi\n}\n\ncomplete -F _%s -o bashdefault -o default %s\n]=]):format(self._basename, self._basename))\n\n   return table.concat(buf, \"\\n\")\nend\n\nfunction Parser:_zsh_arguments(buf, cmd_name, indent)\n   if self._parent then\n      table.insert(buf, (\" \"):rep(indent) .. \"options=(\")\n      table.insert(buf, (\" \"):rep(indent + 2) .. \"$options\")\n   else\n      table.insert(buf, (\" \"):rep(indent) .. \"local -a options=(\")\n   end\n\n   for _, option in ipairs(self._options) do\n      local line = {}\n      if #option._aliases > 1 then\n         if option._maxcount > 1 then\n            table.insert(line, \'\"*\"\')\n         end\n         table.insert(line, \"{\" .. table.concat(option._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\')\n         if option._maxcount > 1 then\n            table.insert(line, \"*\")\n         end\n         table.insert(line, option._name)\n      end\n      if option._description then\n         local description = get_short_description(option):gsub(\'[\"%]:`$]\', \"\\\\%0\")\n         table.insert(line, \"[\" .. description .. \"]\")\n      end\n      if option._maxargs == math.huge then\n         table.insert(line, \":*\")\n      end\n      if option._choices then\n         table.insert(line, \": :(\" .. table.concat(option._choices, \" \") .. \")\")\n      elseif option._maxargs > 0 then\n         table.insert(line, \": :_files\")\n      end\n      table.insert(line, \'\"\')\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(line))\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \")\")\n   table.insert(buf, (\" \"):rep(indent) .. \"_arguments -s -S \\\\\")\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"$options \\\\\")\n\n   if self._is_help_command then\n      table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :(\' .. self._parent:_get_commands() .. \')\" \\\\\')\n   else\n      for _, argument in ipairs(self._arguments) do\n         local spec\n         if argument._choices then\n            spec = \": :(\" .. table.concat(argument._choices, \" \") .. \")\"\n         else\n            spec = \": :_files\"\n         end\n         if argument._maxargs == math.huge then\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*\' .. spec .. \'\" \\\\\')\n            break\n         end\n         for _ = 1, argument._maxargs do\n            table.insert(buf, (\" \"):rep(indent + 2) .. \'\"\' .. spec .. \'\" \\\\\')\n         end\n      end\n\n      if #self._commands > 0 then\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\": :_\' .. cmd_name .. \'_cmds\" \\\\\')\n         table.insert(buf, (\" \"):rep(indent + 2) .. \'\"*:: :->args\" \\\\\')\n      end\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 2) .. \"&& return 0\")\nend\n\nfunction Parser:_zsh_cmds(buf, cmd_name)\n   table.insert(buf, \"\\n_\" .. cmd_name .. \"_cmds() {\")\n   table.insert(buf, \"  local -a commands=(\")\n\n   for _, command in ipairs(self._commands) do\n      local line = {}\n      if #command._aliases > 1 then\n         table.insert(line, \"{\" .. table.concat(command._aliases, \",\") .. \'}\"\')\n      else\n         table.insert(line, \'\"\' .. command._name)\n      end\n      if command._description then\n         table.insert(line, \":\" .. get_short_description(command):gsub(\'[\"`$]\', \"\\\\%0\"))\n      end\n      table.insert(buf, \"    \" .. table.concat(line) .. \'\"\')\n   end\n\n   table.insert(buf, \'  )\\n  _describe \"command\" commands\\n}\')\nend\n\nfunction Parser:_zsh_complete_help(buf, cmds_buf, cmd_name, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   self:_zsh_cmds(cmds_buf, cmd_name)\n   table.insert(buf, \"\\n\" .. (\" \"):rep(indent) .. \"case $words[1] in\")\n\n   for _, command in ipairs(self._commands) do\n      local name = cmd_name .. \"_\" .. command._name\n      table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(command._aliases, \"|\") .. \")\")\n      command:_zsh_arguments(buf, name, indent + 4)\n      command:_zsh_complete_help(buf, cmds_buf, name, indent + 4)\n      table.insert(buf, (\" \"):rep(indent + 4) .. \";;\\n\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"esac\")\nend\n\nfunction Parser:get_zsh_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {(\"#compdef %s\\n\"):format(self._basename)}\n   local cmds_buf = {}\n   table.insert(buf, \"_\" .. self._basename .. \"() {\")\n   if #self._commands > 0 then\n      table.insert(buf, \"  local context state state_descr line\")\n      table.insert(buf, \"  typeset -A opt_args\\n\")\n   end\n   self:_zsh_arguments(buf, self._basename, 2)\n   self:_zsh_complete_help(buf, cmds_buf, self._basename, 2)\n   table.insert(buf, \"\\n  return 1\")\n   table.insert(buf, \"}\")\n\n   local result = table.concat(buf, \"\\n\")\n   if #cmds_buf > 0 then\n      result = result .. \"\\n\" .. table.concat(cmds_buf, \"\\n\")\n   end\n   return result .. \"\\n\\n_\" .. self._basename .. \"\\n\"\nend\n\nlocal function fish_escape(string)\n   return string:gsub(\"[\\\\\']\", \"\\\\%0\")\nend\n\nfunction Parser:_fish_get_cmd(buf, indent)\n   if #self._commands == 0 then\n      return\n   end\n\n   table.insert(buf, (\" \"):rep(indent) .. \"set -e cmdline[1]\")\n   table.insert(buf, (\" \"):rep(indent) .. \"for arg in $cmdline\")\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"switch $arg\")\n\n   for _, command in ipairs(self._commands) do\n      table.insert(buf, (\" \"):rep(indent + 8) .. \"case \" .. table.concat(command._aliases, \" \"))\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"set cmd $cmd \" .. command._name)\n      command:_fish_get_cmd(buf, indent + 12)\n      table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n   end\n\n   table.insert(buf, (\" \"):rep(indent + 4) .. \"end\")\n   table.insert(buf, (\" \"):rep(indent) .. \"end\")\nend\n\nfunction Parser:_fish_complete_help(buf, basename)\n   local prefix = \"complete -c \" .. basename\n   table.insert(buf, \"\")\n\n   for _, command in ipairs(self._commands) do\n      local aliases = table.concat(command._aliases, \" \")\n      local line\n      if self._parent then\n         line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n            :format(prefix, basename, self:_get_fullname(true), aliases)\n      else\n         line = (\"%s -n \'__fish_%s_using_command\' -xa \'%s\'\"):format(prefix, basename, aliases)\n      end\n      if command._description then\n         line = (\"%s -d \'%s\'\"):format(line, fish_escape(get_short_description(command)))\n      end\n      table.insert(buf, line)\n   end\n\n   if self._is_help_command then\n      local line = (\"%s -n \'__fish_%s_using_command %s\' -xa \'%s\'\")\n         :format(prefix, basename, self:_get_fullname(true), self._parent:_get_commands())\n      table.insert(buf, line)\n   end\n\n   for _, option in ipairs(self._options) do\n      local parts = {prefix}\n\n      if self._parent then\n         table.insert(parts, \"-n \'__fish_\" .. basename .. \"_seen_command \" .. self:_get_fullname(true) .. \"\'\")\n      end\n\n      for _, alias in ipairs(option._aliases) do\n         if alias:match(\"^%-.$\") then\n            table.insert(parts, \"-s \" .. alias:sub(2))\n         elseif alias:match(\"^%-%-.+\") then\n            table.insert(parts, \"-l \" .. alias:sub(3))\n         end\n      end\n\n      if option._choices then\n         table.insert(parts, \"-xa \'\" .. table.concat(option._choices, \" \") .. \"\'\")\n      elseif option._minargs > 0 then\n         table.insert(parts, \"-r\")\n      end\n\n      if option._description then\n         table.insert(parts, \"-d \'\" .. fish_escape(get_short_description(option)) .. \"\'\")\n      end\n\n      table.insert(buf, table.concat(parts, \" \"))\n   end\n\n   for _, command in ipairs(self._commands) do\n      command:_fish_complete_help(buf, basename)\n   end\nend\n\nfunction Parser:get_fish_complete()\n   self._basename = base_name(self._name)\n   assert(self:_is_shell_safe())\n   local buf = {}\n\n   if #self._commands > 0 then\n      table.insert(buf, ([[\nfunction __fish_%s_print_command\n    set -l cmdline (commandline -poc)\n    set -l cmd]]):format(self._basename))\n      self:_fish_get_cmd(buf, 4)\n      table.insert(buf, ([[\n    echo \"$cmd\"\nend\n\nfunction __fish_%s_using_command\n    test (__fish_%s_print_command) = \"$argv\"\n    and return 0\n    or return 1\nend\n\nfunction __fish_%s_seen_command\n    string match -q \"$argv*\" (__fish_%s_print_command)\n    and return 0\n    or return 1\nend]]):format(self._basename, self._basename, self._basename, self._basename))\n   end\n\n   self:_fish_complete_help(buf, self._basename)\n   return table.concat(buf, \"\\n\") .. \"\\n\"\nend\n\nlocal function get_tip(context, wrong_name)\n   local context_pool = {}\n   local possible_name\n   local possible_names = {}\n\n   for name in pairs(context) do\n      if type(name) == \"string\" then\n         for i = 1, #name do\n            possible_name = name:sub(1, i - 1) .. name:sub(i + 1)\n\n            if not context_pool[possible_name] then\n               context_pool[possible_name] = {}\n            end\n\n            table.insert(context_pool[possible_name], name)\n         end\n      end\n   end\n\n   for i = 1, #wrong_name + 1 do\n      possible_name = wrong_name:sub(1, i - 1) .. wrong_name:sub(i + 1)\n\n      if context[possible_name] then\n         possible_names[possible_name] = true\n      elseif context_pool[possible_name] then\n         for _, name in ipairs(context_pool[possible_name]) do\n            possible_names[name] = true\n         end\n      end\n   end\n\n   local first = next(possible_names)\n\n   if first then\n      if next(possible_names, first) then\n         local possible_names_arr = {}\n\n         for name in pairs(possible_names) do\n            table.insert(possible_names_arr, \"\'\" .. name .. \"\'\")\n         end\n\n         table.sort(possible_names_arr)\n         return \"\\nDid you mean one of these: \" .. table.concat(possible_names_arr, \" \") .. \"?\"\n      else\n         return \"\\nDid you mean \'\" .. first .. \"\'?\"\n      end\n   else\n      return \"\"\n   end\nend\n\nlocal ElementState = class({\n   invocations = 0\n})\n\nfunction ElementState:__call(state, element)\n   self.state = state\n   self.result = state.result\n   self.element = element\n   self.target = element._target or element:_get_default_target()\n   self.action, self.result[self.target] = element:_get_action()\n   return self\nend\n\nfunction ElementState:error(fmt, ...)\n   self.state:error(fmt, ...)\nend\n\nfunction ElementState:convert(argument, index)\n   local converter = self.element._convert\n\n   if converter then\n      local ok, err\n\n      if type(converter) == \"function\" then\n         ok, err = converter(argument)\n      elseif type(converter[index]) == \"function\" then\n         ok, err = converter[index](argument)\n      else\n         ok = converter[argument]\n      end\n\n      if ok == nil then\n         self:error(err and \"%s\" or \"malformed argument \'%s\'\", err or argument)\n      end\n\n      argument = ok\n   end\n\n   return argument\nend\n\nfunction ElementState:default(mode)\n   return self.element._defmode:find(mode) and self.element._default\nend\n\nlocal function bound(noun, min, max, is_max)\n   local res = \"\"\n\n   if min ~= max then\n      res = \"at \" .. (is_max and \"most\" or \"least\") .. \" \"\n   end\n\n   local number = is_max and max or min\n   return res .. tostring(number) .. \" \" .. noun ..  (number == 1 and \"\" or \"s\")\nend\n\nfunction ElementState:set_name(alias)\n   self.name = (\"%s \'%s\'\"):format(alias and \"option\" or \"argument\", alias or self.element._name)\nend\n\nfunction ElementState:invoke()\n   self.open = true\n   self.overwrite = false\n\n   if self.invocations >= self.element._maxcount then\n      if self.element._overwrite then\n         self.overwrite = true\n      else\n         local num_times_repr = bound(\"time\", self.element._mincount, self.element._maxcount, true)\n         self:error(\"%s must be used %s\", self.name, num_times_repr)\n      end\n   else\n      self.invocations = self.invocations + 1\n   end\n\n   self.args = {}\n\n   if self.element._maxargs <= 0 then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:check_choices(argument)\n   if self.element._choices then\n      for _, choice in ipairs(self.element._choices) do\n         if argument == choice then\n            return\n         end\n      end\n      local choices_list = \"\'\" .. table.concat(self.element._choices, \"\', \'\") .. \"\'\"\n      local is_option = getmetatable(self.element) == Option\n      self:error(\"%s%s must be one of %s\", is_option and \"argument for \" or \"\", self.name, choices_list)\n   end\nend\n\nfunction ElementState:pass(argument)\n   self:check_choices(argument)\n   argument = self:convert(argument, #self.args + 1)\n   table.insert(self.args, argument)\n\n   if #self.args >= self.element._maxargs then\n      self:close()\n   end\n\n   return self.open\nend\n\nfunction ElementState:complete_invocation()\n   while #self.args < self.element._minargs do\n      self:pass(self.element._default)\n   end\nend\n\nfunction ElementState:close()\n   if self.open then\n      self.open = false\n\n      if #self.args < self.element._minargs then\n         if self:default(\"a\") then\n            self:complete_invocation()\n         else\n            if #self.args == 0 then\n               if getmetatable(self.element) == Argument then\n                  self:error(\"missing %s\", self.name)\n               elseif self.element._maxargs == 1 then\n                  self:error(\"%s requires an argument\", self.name)\n               end\n            end\n\n            self:error(\"%s requires %s\", self.name, bound(\"argument\", self.element._minargs, self.element._maxargs))\n         end\n      end\n\n      local args\n\n      if self.element._maxargs == 0 then\n         args = self.args[1]\n      elseif self.element._maxargs == 1 then\n         if self.element._minargs == 0 and self.element._mincount ~= self.element._maxcount then\n            args = self.args\n         else\n            args = self.args[1]\n         end\n      else\n         args = self.args\n      end\n\n      self.action(self.result, self.target, args, self.overwrite)\n   end\nend\n\nlocal ParseState = class({\n   result = {},\n   options = {},\n   arguments = {},\n   argument_i = 1,\n   element_to_mutexes = {},\n   mutex_to_element_state = {},\n   command_actions = {}\n})\n\nfunction ParseState:__call(parser, error_handler)\n   self.parser = parser\n   self.error_handler = error_handler\n   self.charset = parser:_update_charset()\n   self:switch(parser)\n   return self\nend\n\nfunction ParseState:error(fmt, ...)\n   self.error_handler(self.parser, fmt:format(...))\nend\n\nfunction ParseState:switch(parser)\n   self.parser = parser\n\n   if parser._action then\n      table.insert(self.command_actions, {action = parser._action, name = parser._name})\n   end\n\n   for _, option in ipairs(parser._options) do\n      option = ElementState(self, option)\n      table.insert(self.options, option)\n\n      for _, alias in ipairs(option.element._aliases) do\n         self.options[alias] = option\n      end\n   end\n\n   for _, mutex in ipairs(parser._mutexes) do\n      for _, element in ipairs(mutex) do\n         if not self.element_to_mutexes[element] then\n            self.element_to_mutexes[element] = {}\n         end\n\n         table.insert(self.element_to_mutexes[element], mutex)\n      end\n   end\n\n   for _, argument in ipairs(parser._arguments) do\n      argument = ElementState(self, argument)\n      table.insert(self.arguments, argument)\n      argument:set_name()\n      argument:invoke()\n   end\n\n   self.handle_options = parser._handle_options\n   self.argument = self.arguments[self.argument_i]\n   self.commands = parser._commands\n\n   for _, command in ipairs(self.commands) do\n      for _, alias in ipairs(command._aliases) do\n         self.commands[alias] = command\n      end\n   end\nend\n\nfunction ParseState:get_option(name)\n   local option = self.options[name]\n\n   if not option then\n      self:error(\"unknown option \'%s\'%s\", name, get_tip(self.options, name))\n   else\n      return option\n   end\nend\n\nfunction ParseState:get_command(name)\n   local command = self.commands[name]\n\n   if not command then\n      if #self.commands > 0 then\n         self:error(\"unknown command \'%s\'%s\", name, get_tip(self.commands, name))\n      else\n         self:error(\"too many arguments\")\n      end\n   else\n      return command\n   end\nend\n\nfunction ParseState:check_mutexes(element_state)\n   if self.element_to_mutexes[element_state.element] then\n      for _, mutex in ipairs(self.element_to_mutexes[element_state.element]) do\n         local used_element_state = self.mutex_to_element_state[mutex]\n\n         if used_element_state and used_element_state ~= element_state then\n            self:error(\"%s can not be used together with %s\", element_state.name, used_element_state.name)\n         else\n            self.mutex_to_element_state[mutex] = element_state\n         end\n      end\n   end\nend\n\nfunction ParseState:invoke(option, name)\n   self:close()\n   option:set_name(name)\n   self:check_mutexes(option, name)\n\n   if option:invoke() then\n      self.option = option\n   end\nend\n\nfunction ParseState:pass(arg)\n   if self.option then\n      if not self.option:pass(arg) then\n         self.option = nil\n      end\n   elseif self.argument then\n      self:check_mutexes(self.argument)\n\n      if not self.argument:pass(arg) then\n         self.argument_i = self.argument_i + 1\n         self.argument = self.arguments[self.argument_i]\n      end\n   else\n      local command = self:get_command(arg)\n      self.result[command._target or command._name] = true\n\n      if self.parser._command_target then\n         self.result[self.parser._command_target] = command._name\n      end\n\n      self:switch(command)\n   end\nend\n\nfunction ParseState:close()\n   if self.option then\n      self.option:close()\n      self.option = nil\n   end\nend\n\nfunction ParseState:finalize()\n   self:close()\n\n   for i = self.argument_i, #self.arguments do\n      local argument = self.arguments[i]\n      if #argument.args == 0 and argument:default(\"u\") then\n         argument:complete_invocation()\n      else\n         argument:close()\n      end\n   end\n\n   if self.parser._require_command and #self.commands > 0 then\n      self:error(\"a command is required\")\n   end\n\n   for _, option in ipairs(self.options) do\n      option.name = option.name or (\"option \'%s\'\"):format(option.element._name)\n\n      if option.invocations == 0 then\n         if option:default(\"u\") then\n            option:invoke()\n            option:complete_invocation()\n            option:close()\n         end\n      end\n\n      local mincount = option.element._mincount\n\n      if option.invocations < mincount then\n         if option:default(\"a\") then\n            while option.invocations < mincount do\n               option:invoke()\n               option:close()\n            end\n         elseif option.invocations == 0 then\n            self:error(\"missing %s\", option.name)\n         else\n            self:error(\"%s must be used %s\", option.name, bound(\"time\", mincount, option.element._maxcount))\n         end\n      end\n   end\n\n   for i = #self.command_actions, 1, -1 do\n      self.command_actions[i].action(self.result, self.command_actions[i].name)\n   end\nend\n\nfunction ParseState:parse(args)\n   for _, arg in ipairs(args) do\n      local plain = true\n\n      if self.handle_options then\n         local first = arg:sub(1, 1)\n\n         if self.charset[first] then\n            if #arg > 1 then\n               plain = false\n\n               if arg:sub(2, 2) == first then\n                  if #arg == 2 then\n                     if self.options[arg] then\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     else\n                        self:close()\n                     end\n\n                     self.handle_options = false\n                  else\n                     local equals = arg:find \"=\"\n                     if equals then\n                        local name = arg:sub(1, equals - 1)\n                        local option = self:get_option(name)\n\n                        if option.element._maxargs <= 0 then\n                           self:error(\"option \'%s\' does not take arguments\", name)\n                        end\n\n                        self:invoke(option, name)\n                        self:pass(arg:sub(equals + 1))\n                     else\n                        local option = self:get_option(arg)\n                        self:invoke(option, arg)\n                     end\n                  end\n               else\n                  for i = 2, #arg do\n                     local name = first .. arg:sub(i, i)\n                     local option = self:get_option(name)\n                     self:invoke(option, name)\n\n                     if i ~= #arg and option.element._maxargs > 0 then\n                        self:pass(arg:sub(i + 1))\n                        break\n                     end\n                  end\n               end\n            end\n         end\n      end\n\n      if plain then\n         self:pass(arg)\n      end\n   end\n\n   self:finalize()\n   return self.result\nend\n\nfunction Parser:error(msg)\n   io.stderr:write((\"%s\\n\\nError: %s\\n\"):format(self:get_usage(), msg))\n   os.exit(1)\nend\n\n-- Compatibility with strict.lua and other checkers:\nlocal default_cmdline = rawget(_G, \"arg\") or {}\n\nfunction Parser:_parse(args, error_handler)\n   return ParseState(self, error_handler):parse(args or default_cmdline)\nend\n\nfunction Parser:parse(args)\n   return self:_parse(args, self.error)\nend\n\nlocal function xpcall_error_handler(err)\n   return tostring(err) .. \"\\noriginal \" .. debug.traceback(\"\", 2):sub(2)\nend\n\nfunction Parser:pparse(args)\n   local parse_error\n\n   local ok, result = xpcall(function()\n      return self:_parse(args, function(_, err)\n         parse_error = err\n         error(err, 0)\n      end)\n   end, xpcall_error_handler)\n\n   if ok then\n      return true, result\n   elseif not parse_error then\n      error(result, 0)\n   else\n      return false, parse_error\n   end\nend\n\nlocal argparse = {}\n\nargparse.version = \"0.7.0\"\n\nsetmetatable(argparse, {__call = function(_, ...)\n   return Parser(default_cmdline[0]):add_help(true)(...)\nend})\n\nreturn argparse\n\nend)\n\n",
},
  { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "preamble",
hash = "d61ec5b3957bcf1afc7fb045d393f090f9174d2d2cd5602dbdd4791d03aa527c",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_Bridge = {}\n\n\n\n\n\n\n\n\n\n\n\n\npack = table.pack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"table.clear\"\nrequire \"table.new\"\nrequire \"table.isempty\"\nrequire \"table.isarray\"\nrequire \"table.nkeys\"\n-- require \"table.clone\" -- we provide a more general, but slower, version\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n_Bridge.bridge_modules = { }\n_Bridge.loaded = { }\n_Bridge.load_hashes = { }\n\n\n\n\n\n\n\n\n\nlocal bytecode_by_module = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nWHERE module.name = :name\nORDER BY module.time desc limit 1\n;\n]]\n\nlocal bytecode_by_module_and_project = [[\nSELECT code.binary, code.hash\nFROM code\nINNER JOIN module\nON module.code = code.code_id\nINNER JOIN project\nON project.project_id = module.project\nWHERE project.name = :project_name\nAND module.name = :module_name\nORDER BY module.time desc limit 1\n;\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal home_dir = os.getenv \"HOME\"\nlocal bridge_modules = os.getenv \"BRIDGE_MODULES\"\nlocal bridge_home = os.getenv \"BRIDGE_HOME\"\n\n   -- use BRIDGE_HOME if we have it\nif not bridge_home then\n   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"\n   if xdg_data_home then\n      bridge_home = xdg_data_home .. \"/bridge\"\n   else\n      bridge_home = home_dir .. \"/.local/share/bridge\"\n   end\nend\n\nif not bridge_modules then\n   bridge_modules = bridge_home.. \"/bridge.modules\"\nend\n\n_Bridge.bridge_home = bridge_home\n_Bridge.bridge_modules_home = bridge_modules\n\n\n\n\n\nlocal ok, bridge_conn = pcall(sql.open, bridge_modules, \"rw\")\nif ok then\n   _Bridge.modules_conn = bridge_conn\nelse\n   print \"no bridge.modules\"\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal bridge_strap = home_dir .. \"/.local/share/bridge/~bridge.modules\"\nlocal ok, strap_conn = pcall(sql.open, bridge_strap, \"rw\")\nif ok then\n   _Bridge.bootstrap_conn = strap_conn\nend\n\n\n\n\n\n\n\n\nlocal toRow = assert(sql.toRow)\n\nlocal function resultMap(result)\n   if result == nil then return nil end\n   return toRow(result)\nend\n\nlocal function loaderGen(conn)\n   -- check that we have a database conn\n   if not conn then error(\"sql connection failed\") end\n   -- make prepared statements\n   local module_stmt = conn:prepare(bytecode_by_module)\n   local project_stmt = conn:prepare(bytecode_by_module_and_project)\n   -- return loader\n\n   return function (mod_name)\n      package.bridge_loaded = package.bridge_loaded or {}\n      -- split the module into project and modname\n      local bytecode = nil\n      local project, mod = string.match(mod_name, \"(.*):(.*)\")\n      if not mod then\n         mod = mod_name\n      end\n      local proj_name = project or \"\"\n      -- might be \"module/module\":\n      local mod_double = mod .. \"/\" .. mod\n      -- might be \"project:module\" -> \"project/module\"\n      local proj_double = \"\"\n      if project then\n         proj_double = project .. \"/\" .. mod\n      end\n      if project then\n         -- retrieve bytecode by project and module\n         bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                            module_name  = mod })\n                      : resultset())\n         if not bytecode then\n            -- try mod_double\n            project_stmt:reset()\n            bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                            module_name  = mod_double })\n                      : resultset())\n         end\n         if not bytecode then\n            -- try proj_double\n            project_stmt:reset()\n            bytecode = resultMap(\n                      project_stmt:bindkv ({ project_name = project,\n                                             module_name  = proj_double })\n                      : resultset())\n         end\n         project_stmt:reset()\n      else\n         -- retrieve by bare module name\n         bytecode = resultMap(\n                      module_stmt:bindkv ({ name  = mod })\n                      : resultset())\n         if not bytecode then\n            module_stmt:reset()\n            bytecode =resultMap(\n                      module_stmt:bindkv ({ name  = mod_double })\n\n                      : resultset())\n         end\n         module_stmt:reset()\n      end\n      if bytecode then\n         local binary, hash = bytecode.binary, bytecode.hash\n         -- return a module-loading closure if already in scope\n         if _Bridge.loaded[hash] then\n            return function()\n               return package.loaded[_Bridge.loaded[hash]]\n            end\n         end\n         _Bridge.bridge_modules[\"@\" .. mod_name] = true\n         local loadFn, errmsg = load(binary, \"@\" .. mod_name)\n         if loadFn then\n            _Bridge.loaded[hash] = mod_name\n            _Bridge.load_hashes[mod_name] = hash\n            return loadFn\n         else\n             error(errmsg)\n         end\n      else\n         return nil, (\"unable to load: \" .. mod_name)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nif _Bridge.bootstrap_conn then\n   table.insert(package.loaders, 2, loaderGen(_Bridge.bootstrap_conn))\nend\nif _Bridge.modules_conn then\n   table.insert(package.loaders, 2, loaderGen(_Bridge.modules_conn))\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n   local getinfo, error, rawset, rawget = debug.getinfo, error, rawset, rawget\n   local strict = {}\n\n   local function what ()\n      local d = getinfo(3, \"S\")\n      return d and d.what or \"C\"\n   end\n\n   --- make an existing table strict.\n   -- @string name name of table (optional)\n   -- @tab[opt] mod table - if `nil` then we\'ll return a new table\n   -- @tab[opt] predeclared - table of variables that are to be considered predeclared.\n   -- @return the given table, or a new table\n   stricture = function (name,mod,predeclared)\n      local mt, old_newindex, old_index, old_index_type, global, closed\n      if predeclared then\n         global = predeclared.__global\n         closed = predeclared.__closed\n      end\n      if type(mod) == \'table\' then\n         mt = getmetatable(mod)\n         if mt and rawget(mt,\'__declared\') then return end -- already patched...\n      else\n         mod = {}\n      end\n      if mt == nil then\n         mt = {}\n         setmetatable(mod, mt)\n      else\n         old_newindex = mt.__newindex\n         old_index = mt.__index\n         old_index_type = type(old_index)\n      end\n      mt.__declared = predeclared or {}\n      mt.__newindex = function(t, n, v)\n         if old_newindex then\n            old_newindex(t, n, v)\n            if rawget(t,n)~=nil then return end\n         end\n         if not mt.__declared[n] then\n            if global then\n               local w = what()\n               if w ~= \"main\" and w ~= \"C\" then\n                  error(\"assign to undeclared global \'\"..n..\"\'\", 2)\n               end\n            end\n            mt.__declared[n] = true\n         end\n         rawset(t, n, v)\n      end\n      mt.__index = function(t,n)\n         if not mt.__declared[n] and what() ~= \"C\" then\n            if old_index then\n               if old_index_type == \"table\" then\n                  local fallback = old_index[n]\n                  if fallback ~= nil then\n                     return fallback\n                  end\n               else\n                  local res = old_index(t, n)\n                     if res ~= nil then\n                        return res\n                     end\n                  end\n               end\n               local msg = \"variable \'\"..n..\"\' is not declared\"\n               if name then\n                  msg = msg .. \" in \'\"..name..\"\'\"\n               end\n               error(msg, 2)\n            end\n         return rawget(t, n)\n      end\n\n      return mod\n   end\nend\n\n",
},
  { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "modules",
hash = "1aa92f289184a392e7bf1bfb030308635141d932bf4682c4ff777ebd72208be3",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\nlocal new_modules = false\n\n\n\n\n\n\n\n\n\n\n\n\nlocal stmts = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nstmts.create_project_table = [[\nCREATE TABLE IF NOT EXISTS project (\n   project_id INTEGER PRIMARY KEY,\n   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,\n   repo STRING,\n   repo_type STRING DEFAULT \'git\',\n   repo_alternates STRING,\n   home STRING,\n   website STRING\n);\n]]\n\n\n\n\nstmts.create_version_table = [[\nCREATE TABLE IF NOT EXISTS version (\n   version_id INTEGER PRIMARY KEY,\n   stage STRING DEFAULT \'SNAPSHOT\' COLLATE NOCASE,\n   edition STRING default \'\',\n   special STRING DEFAULT \'no\' COLLATE NOCASE,\n   major INTEGER DEFAULT 0,\n   minor INTEGER DEFAULT 0,\n   patch INTEGER DEFAULT 0,\n   project INTEGER NOT NULL,\n   UNIQUE (project, stage, edition, special, major, minor, patch)\n      ON CONFLICT IGNORE,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n);\n]]\n\n\n\n\nstmts.create_bundle_table = [[\nCREATE TABLE IF NOT EXISTS bundle (\n   bundle_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n);\n]]\n\n\n\n\nstmts.create_code_table = [[\nCREATE TABLE IF NOT EXISTS code (\n   code_id INTEGER PRIMARY KEY,\n   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,\n   binary BLOB NOT NULL\n);\n]]\n\n\n\n\nstmts.create_module_table = [[\nCREATE TABLE IF NOT EXISTS module (\n   module_id INTEGER PRIMARY KEY,\n   time DATETIME DEFAULT CURRENT_TIMESTAMP,\n   name STRING NOT NULL,\n   type STRING DEFAULT \'luaJIT-2.1-bytecode\',\n   branch STRING,\n   vc_hash STRING,\n   project INTEGER NOT NULL,\n   version INTEGER NOT NULL,\n   bundle INTEGER,\n   code INTEGER NOT NULL,\n   FOREIGN KEY (project)\n      REFERENCES project (project_id)\n      ON DELETE RESTRICT\n   FOREIGN KEY (version)\n      REFERENCES version (version_id)\n   FOREIGN KEY (bundle)\n      REFERENCES bundle (bundle_id)\n      ON DELETE CASCADE\n   FOREIGN KEY (code)\n      REFERENCES code (code_id)\n);\n]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function new_modules_db(conn_home)\n   local yes, conn;\n   if type(conn_home) == \'string\' then\n      yes, conn = pcall(sql.open, conn_home, \'rwc\')\n      if not yes then\n         error(\"Could not create \" .. conn_home\n               .. \", consider creating the directory or setting\"\n               .. \" $BRIDGE_MODULES.\")\n      end\n   end\n   if conn then\n      conn:exec(stmts.create_project_table)\n      conn:exec(stmts.create_version_table)\n      conn:exec(stmts.create_bundle_table)\n      conn:exec(stmts.create_code_table)\n      conn:exec(stmts.create_module_table)\n   end\n\n   return conn\nend\n\n_Bridge.new_modules_db = new_modules_db\n\nif not _Bridge.modules_conn then\n   _Bridge.modules_conn = new_modules_db(_Bridge.bridge_modules_home)\n   new_modules = true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal new_project = [[\nINSERT INTO project (name, repo, repo_alternates, home, website)\nVALUES (:name, :repo, :repo_alternates, :home, :website)\n;\n]]\n\n\n\n\nlocal get_project_id = [[\nSELECT project_id FROM project\nWHERE project.name = ?\n;\n]]\n\n\n\n\nlocal update_project = [[\nUPDATE project\nSET\n   repo = :repo,\n   repo_alternates = :repo_alternates,\n   home = :home,\n   website = :website\nWHERE\n   name = :name\n;\n]]\n\n\n\n\n\n\n\nlocal get_version = [[\nSELECT CAST (version.version_id AS REAL) FROM version\nWHERE edition = :edition\nAND stage = :stage\nAND major = :major\nAND minor = :minor\nAND patch = :patch\nAND special = :special\nAND project = :project\n;\n]]\n\n\n\n\nlocal new_version_snapshot = [[\nINSERT INTO version (edition, project)\nVALUES (:edition, :project)\n;\n]]\n\n\n\n\nlocal new_version = [[\nINSERT INTO version (edition, project, major, minor, patch)\nVALUES (:edition, :project, :major, :minor, :patch)\n;\n]]\n\n\n\n\n\n\n\nlocal get_code_id_by_hash = [[\nSELECT CAST (code.code_id AS REAL) FROM code\nWHERE code.hash = ?;\n]]\n\n\n\n\nlocal new_code = [[\nINSERT INTO code (hash, binary)\nVALUES (:hash, :binary)\n;\n]]\n\n\n\n\n\n\n\nlocal new_bundle = [[\nINSERT INTO bundle (project, version)\nVALUES (?, ?)\n;\n]]\n\n\n\nlocal get_latest_bundle = [[\nSELECT CAST (bundle.bundle_id AS REAL), time FROM bundle\nWHERE bundle.project = ?\nAND bundle.version = ?\nORDER BY\n   time DESC,\n   bundle_id DESC\nLIMIT 1\n;\n]]\n\n\n\n\n\n\n\nlocal add_module = [[\nINSERT INTO module (version, name, bundle,\n                    branch, vc_hash, project, code, time)\nVALUES (:version, :name, :bundle,\n        :branch, :vc_hash, :project, :code, :time)\n;\n]]\n\n\nlocal function _commitBundle(conn, bundle)\n   -- #todo verify byecode hashes, load bytecodes (but don\'t execute)\n   -- #todo verify bundle hash, and signature if possible/present\n   --\n   -- upsert project\n   local project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   if not project_id then\n      conn:prepare(new_project):bindkv(bundle.project):step()\n      project_id = conn:prepare(get_project_id)\n                          :bind(bundle.project.name):step()\n   end\n   project_id = project_id[1]\n   conn:prepare(update_project):bindkv(bundle.project):step()\n   -- upsert version (what to do if version exists?)\n   bundle.version.project = project_id\n   conn:prepare(new_version):bindkv(bundle.version):step()\n   local version_id = conn:prepare(get_version)\n                          :bindkv(bundle.version):step()\n   if not version_id then\n      error \"failed to create version\"\n   end\n   version_id = version_id[1]\n   -- make bundle, get bundle id\n   conn:prepare(new_bundle):bind(project_id, version_id):step()\n   local bundle_info = conn:prepare(get_latest_bundle)\n                         :bind(project_id, version_id):step()\n   if not bundle_info then\n      error \"failed to create bundle\"\n   end\n   local bundle_id, now = bundle_info[1], bundle_info[2]\n   local mod_stmt = conn:prepare(add_module)\n   for _, mod in ipairs(bundle.modules) do\n      -- commit code\n      local code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n      if not code_id then\n         conn:prepare(new_code):bindkv(mod):step()\n         code_id = conn:prepare(get_code_id_by_hash)\n                         :bind(mod.hash):step()\n         if not code_id then\n            error (\"failed to commit code for\" .. mod.name)\n         end\n      end\n      code_id = code_id[1]\n      -- add module info\n      mod.code = code_id\n      mod.project = project_id\n      mod.version = version_id\n      mod.bundle = bundle_id\n      mod.time = now\n      mod_stmt:bindkv(mod):step()\n      mod_stmt:reset()\n   end\nend\n\n\n\nlocal function import(file_name)\n   local file = io.open(file_name, \"r\")\n   if not file then\n      error(\"can\'t open \" .. file_name)\n   end\n   -- load() the file\n   local bundles, err = load(file:read(\"a\"))\n   file:close()\n   if not bundles then\n      error(err)\n   end\n   setfenv(bundles, {})\n   local bundles = bundles()\n\n   local conn = _Bridge.modules_conn\n   conn:exec \"BEGIN TRANSACTION;\"\n   if bundles.project then\n      -- single-bundled project\n      _commitBundle(conn, bundles)\n   else\n      for _, bundle in ipairs(bundles) do\n         _commitBundle(conn, bundle)\n      end\n   end\n   conn:exec \"COMMIT;\"\nend\n\n_Bridge.import = import\n\n\n\n\n\n\n\n\nif new_modules then\n   print \"importing modules bundle\"\n   import(\"all_modules.bundle\")\nend\n\n\n\n\n\n\nend\n\n",
},
  { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "afterward",
hash = "ab273bacd3f630691a90f9deab7b079a837dea9f290c15f6d58fbd441461faa4",
branch = "trunk",
binary = "\n\n\n\n\n\n\nif _Bridge.modules_conn then\n   _Bridge.modules_conn:pclose()\nend\n\nif _Bridge.bootstrap_conn then\n   _Bridge.bootstrap_conn:pclose()\nend\n\n\n\n\n\n\n\n\n\n\nif _Bridge.status_on then\n   require \"status:status\" :close()\nend\n\n",
},
  { 
vc_hash = "14ef45d6816e1637933639759b5541442de5bd8f",
name = "load",
hash = "9fea58ae3cac0172da0976e8f0226125bb149c281342badd030a26b66a0bbee0",
branch = "trunk",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\n\n\n\n\n\n\n\nstricture(nil,_G,{_PROMPT=true,__global=true})\nstricture = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal L = require \"lpeg\"\nlocal P, C, Cg, Ct, R, match = L.P, L.C, L.Cg, L.Ct, L.R, L.match\nlocal format = assert(string.format)\nlocal MAX_INT = 9007199254740991\n\nlocal function cast_to_int(str_val)\n   local num = tonumber(str_val)\n   if num > MAX_INT then\n      return nil, \"Version numbers cannot exceed 2^53 - 1, \"\n             .. str_val .. \" is invalid\"\n   end\n   return num\nend\n\nlocal function parse_version(str)\n   local major  = Cg(R\"09\"^1, \"major\")\n   local minor  = Cg(R\"09\"^1, \"minor\")\n   local patch  = Cg(R\"09\"^1, \"patch\")\n   local kelvin = P\"[\" * Cg(R\"09\"^1, \"kelvin\") * P\"]\"\n   local knuth  = Cg(R\"09\"^1, \"knuth\") * P\"..\"\n   local patt = Ct( major\n                  * (P\".\" * minor)\n                  * (P\".\" * (kelvin + knuth + patch) + P(-1)) )\n                  * P(-1)\n   local ver = match(patt, str)\n   if not ver then\n      if match(R\"09\"^1 * P\".\"^-1 * P(-1), str) then\n         return nil, \"Must provide at least major and minor version numbers\"\n      else\n         return nil, \"Invalid --version format: \" .. str\n      end\n   end\n   -- Cast to number\n   for k,v in pairs(ver) do\n      ver[k] = cast_to_int(v)\n   end\n   -- make alternate patch forms into flags\n   if ver.kelvin then\n      ver.patch = ver.kelvin\n      ver.kelvin = true\n   elseif ver.knuth then\n      ver.patch = ver.knuth\n      ver.knuth = true\n   end\n\n   return ver\nend\n\n_Bridge.parse_version = parse_version\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function open_range_fn(open)\n   return { tonumber(open:sub(1, -3)), \"#\" }\nend\n\nlocal num = C(R\"09\"^1) / tonumber\nlocal range = Ct((num * \"..\" * num))\nlocal open_range = C(num * \"..\") / open_range_fn\nlocal entry = range + num\n\nlocal list_p = Ct(P\"[\" * (P\" \"^0 * (range + num) * P\" \"^0 * P\",\")^0\n               * (P\" \"^0 * (range + open_range + num) * P\" \"^0)^-1 * P\"]\")\n\nlocal function parse_list(str)\n   local list = match(list_p, str)\n   if not list then\n      list = tonumber(str)\n      if list then return list end\n      return str\n   end\n\n   return list\nend\n\n_Bridge.parse_list = parse_list\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function parse_session_identifier(name)\n   return name:find(\"^%s*%d+%s*$\") and tonumber(name) or name\nend\n\nlocal function validate_session_name(name)\n   -- check if the string is only integers with possible whitespace padding\n   if name:find(\"^%s*%d+%s*$\") then\n      return nil, \"Can\'t give a session an integer name such as \" .. name .. \".\"\n   end\n   return name\nend\n\n\n\n\nlocal brParse = require \"argparse\" ()\n\n_Bridge.brParse = brParse\n\nbrParse\n   : require_command (false)\n   : name \"br\"\n   : description (\"The bridge tools suite for repl-driven \"\n                  .. \"literate programming.\\n\\n\"\n                  .. \"To view help for each command, type br <command> -h.\")\n   : epilog (\"To run user-installed projects, type br <project> with \"\n             .. \"any arguments.\\n\\n\"\n             .. \"For more info, see https://special-circumstanc.es\")\n   : command_target \"verb\"\n   : help_description_margin(25)\n   : help_max_width(80)\n   : option \"-f\" \"--file\"\n      : description \"Run a file. Lua only, for now.\"\n      : args(1)\n\nbrParse\n   : flag \"--show-arguments\"\n      : description \"display the args table. For development purposes.\"\n\nlocal orb_c = brParse : command \"orb o\"\n                         : description \"Literate compiler for Orb format.\"\n\norb_c\n   : require_command (false)\n\norb_c\n  : flag \"-P --pedantic\"\n    : description \"Perform all filters, linting, crash on errors, etc.\"\n\norb_c\n   : command \"serve\"\n      : description \"Launch the Orb server.\"\n\norb_c\n   : command \"knit\"\n      : description \"Knit the codex.\"\n\norb_c\n   : command \"weave\"\n      : description \"Weave the codex.\"\n\norb_c\n   : command \"revert\"\n   : description \"Revert the latest compiled changes in project.\"\n   : option \"-p --project\"\n      : description \"Project to revert.\"\n      : args(1)\n\n\nlocal orb_command_c = orb_c\n   : command \"compile\"\n      : description \"Knits the codex and compiles the resulting sorcery files.\"\n      : help_vertical_space(1)\n\norb_command_c\n  : option \"-v --version\"\n     : description \"A (semantic) version string.\"\n     : convert(parse_version)\n     : args(1)\n\norb_command_c\n  : option \"-e --edition\"\n     : description ( \"A named edition:\\n  special meaning applies to \"\n                    .. \"SESSION, CANDIDATE, and RELEASE.\")\n     : args(1)\n\norb_command_c\n  : option \"-H --home\"\n     : description (\"URL to fetch versions of the project.\")\n     : args(1)\n\norb_command_c\n  : option \"-R --repo\"\n     : description ( \"URL for the project\'s source repository.\\n\"\n                  .. \"  Defaults to git remote \'origin\'.\")\n     : args(1)\n\norb_command_c\n  : option \"-W --website\"\n     : description (\"URL for the project\'s user-facing website:\\n\"\n                 .. \"  documentation, tutorials, examples, etc.\")\n     : args(1)\n\norb_command_c\n  : option \"-p --project\"\n     : description \"Name of project.  Defaults to name of home directory.\"\n\n\nlocal helm_c = brParse\n                  : command \"helm i\"\n                     : description \"Launch helm, the \'i\'nteractive REPL.\"\n                     : help_description_margin(35)\n\nhelm_c\n   : option \"-s --session\"\n      : description \"Start the repl with a given, named session.\"\n      : convert(parse_session_identifier)\n      : args(1)\n\nhelm_c\n   : option \"-M --macro\"\n     : description ( \"Macro-record a session of the given name. \"\n                  .. \"Results of all lines will be accepted as correct.\" )\n      : convert(validate_session_name)\n      : args(1)\n\nhelm_c\n   : option \"-n --new-session\"\n      : description \"Begin a new, named session.\"\n      : convert(validate_session_name)\n      : args(1)\n\nhelm_c\n   : flag \"-l --listen\"\n   : description ( \"Open with a listener, which compiles files on save and \"\n                .. \"restarts the session.\" )\n\n\nlocal export_c = brParse\n                    : command \"export\"\n                    : description \"Export a project from the database.\"\n\nexport_c\n   : argument \"project\"\n     : description \"Project or projects to export\"\n     : args \"?\"\n\nexport_c\n  : option \"-o\" \"--outfile\"\n     : description (\"A file to export projects to.\"\n                 .. \"Defaults to ./<project>.bundle\")\n     : args(1)\n\nexport_c\n   : option \"-v\" \"--version\"\n      : description \"Version of the project to export\"\n      : convert(parse_version)\n      : args(1)\n\nexport_c\n   : flag \"-a\" \"--all\"\n      : description ( \"Export all projects.\"\n                   .. \"Latest bundles if no version is specified.\" )\n\n\nlocal import_c = brParse\n                    : command \"import\"\n                    : description \"Import a project from a bundle file.\"\n\nimport_c\n   : argument \"file\"\n   : description \"a bundled project file or files\"\n   : args \"+\"\n\nlocal session_c = brParse\n                    : command \"session s\"\n                    : description (\"Session runner. Provides unit tests\"\n                        .. \" derived from helm sessions. With no arguments,\"\n                        .. \" runs all accepted sessions for the project\"\n                        .. \" at pwd.\")\n                    : require_command(false)\n\nsession_c\n   : flag \"--all\"\n   : description(\"Run all accepted sessions in the database,\"\n                 .. \" for every project.\")\n\nsession_c\n   : flag \"--total\"\n   : description(\"Run every session in the database, no exceptions.\")\n\nsession_c\n   : flag \"-E\" \"--every\"\n   : description \"Run every session for a given project.\"\n\nsession_c\n   : option \"-s\" \"--some\"\n   : description \"Run only the indicated sessions, by name, number, or list.\"\n   : convert(parse_list)\n   : args(1)\n\nlocal session_list_c = session_c\n                          : command \"list l\"\n                          : description (\"List (accepted) sessions. \"\n                             .. \"Defaults to current project.\")\n\nsession_list_c\n    : option \"-l --latest\"\n    : description \"List the n most recent accepted sessions, default 5.\"\n    : args \"?\"\n    : argname \"<n>\"\n\nsession_list_c\n    : flag \"-a --all\"\n    : description \"List all sessions including deprecated sessions.\"\n    : action(function(args) args.list_all = true end)\n\nlocal function add_range_arg(cmd, arg_name)\n   cmd\n      : argument(arg_name)\n      : description (\"A session title, session number, or list of session \"\n         .. \"numbers/ranges e.g. [1,3,5..6,8..].\")\n      : convert(parse_list)\n      : args(1)\nend\n\nlocal session_update_c = session_c\n         : command \"update u\"\n         : description (\"Update session(s) premises to accept latest \"\n                        .. \"results.\")\nadd_range_arg(session_update_c, \"to_update\")\n\nlocal session_delete_c = session_c\n         : command \"delete d\"\n         : description (\"Delete listed sessions. \"\n                     .. \"Will only delete a deprecated session.\")\nadd_range_arg(session_delete_c, \"to_delete\")\n\nlocal session_force_delete_c = session_c\n                                  : command \"force-delete D\"\n                                  : description\n                                     (\"Delete listed sessions, including \"\n                                      .. \"accepted sessions.\")\nadd_range_arg(session_force_delete_c, \"to_delete\")\n\nlocal session_accept_c = session_c\n         : command \"accept a\"\n         : description \"Mark a session or list as accepted.\"\nadd_range_arg(session_accept_c, \"to_accept\")\n\nlocal session_deprecate_c = session_c\n         : command \"deprecate p\"\n         : description(\"dePrecate a session, or list of sessions, which will \"\n                     ..\"no longer be run with `br session`.\")\nadd_range_arg(session_deprecate_c, \"to_deprecate\")\n\nlocal session_rename_c = session_c\n         : command \"rename r\"\n         : description \"Give a session a new title.\"\n\nsession_rename_c\n  : argument \"old_name\"\n  : description \"The title or number of an existing session to rename.\"\n  : convert(parse_session_identifier)\n\nsession_rename_c\n  : argument \"new_name\"\n  : description \"The new title for the session.\"\n  : convert(validate_session_name)\n\nlocal session_export_c = session_c\n         : command \"export e\"\n         : description \"Export a session or list of sessions.\"\nadd_range_arg(session_export_c, \"to_export\")\n\nsession_export_c\n   : option \"-o\" \"--outfile\"\n   : description \"A file path. Defaults to stdout if not provided.\"\n   : args(1)\n\nlocal session_import_c = session_c\n         : command \"import i\"\n         : description (\"Import sessions from a bundle file, into the project \"\n                     .. \"named in the bundle.\")\n\nsession_import_c\n   : argument \"infile\"\n   : description \"A session bundle file. Defaults to stdin if not provided.\"\n   : args \"?\"\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\n\ncollectgarbage()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal verbs = { s = true, o = true, i = true}\n\nfunction verbs.orb(args)\n   if args.revert then\n      local revert = require \"bundle:revert\"\n      revert()\n   elseif args.old then\n      local orb = require \"orb\"\n      local uv = require \"luv\"\n      orb.run(uv.cwd())\n   else\n       local orb = require \"orb\"\n       local uv  = require \"luv\"\n       local lume = orb.lume(uv.cwd())\n       lume:run()\n       if args.serve then\n          lume:serve()\n       end\n   end\nend\n\nfunction verbs.session(args)\n   local session = assert(require \"valiant:session\" . session)\n   session(args)\nend\n\nfunction verbs.helm(args)\n   local helm = require \"helm:helm\"\n   helm()\nend\n\nfunction verbs.export(args)\n   if (not args.project) and (not args.all) then\n      error \"at least one project required without --all flag\"\n   end\n   local bundle\n   if not args.all then\n      bundle = require \"bundle:export\".export(args.project,\n                                                 args.version)\n   else\n      bundle = require \"bundle:export\".exportAll(args.version)\n   end\n   if args.outfile then\n      local file = io.open(args.outfile, \"w+\")\n      if not file then\n         error(\"unable to open \" .. args.outfile)\n      end\n      file:write(bundle)\n      file:close()\n   else\n      local bundle_name = args.project or \"all_modules\"\n      local outfilepath = \"./\" .. bundle_name .. \".bundle\"\n      local file = io.open(outfilepath, \"w+\")\n      if not file then\n         error(\"unable to open \" .. outfilepath)\n      end\n      file:write(bundle)\n      file:close()\n   end\nend\n\nfunction verbs.import(args)\n   local import = assert(_Bridge.import)\n   for _, file in ipairs(args.file) do\n      import(file)\n   end\nend\n\n\n\nif rawget(_G, \"arg\") ~= nil then\n   -- shim the arg array to emulate the \"lua <scriptname>\" calling\n   -- convention which argparse expects\n   table.insert(arg, 0, \"\")\n   -- check for custom command\n   if not(verbs[arg[1]] or string.sub(arg[1], 1, 1) == \"-\") then\n      local verb, args = table.remove(arg, 1), nil\n      local ok, argP = pcall(require, verb .. \":argparse\")\n      if ok then\n         args = argP:parse()\n      end\n      local ok, mod = pcall(require, verb .. \":\" .. verb)\n      if ok then\n         mod(args)\n      else\n         print(\"Can\'t find a project \" .. verb .. \".\")\n      end\n   else\n      _Bridge.args = _Bridge.brParse:parse()\n      local args = _Bridge.args\n      if args.show_arguments then\n         args.show_arguments = nil -- no reason to include this\n         local ts = require \"repr:repr\" . ts\n         print(ts(args))\n      end\n      if verbs[args.verb] then\n         verbs[args.verb](args)\n      elseif args.file then\n         if args.file:sub(-4, -1) == \".lua\" then\n            dofile(args.file)\n         end\n         -- #todo handle .orb files here\n      else\n         -- should be unreachable, but may as well print what we have:\n         local ts = require \"repr:repr\" . ts\n         print(ts(args))\n         error \"argparse should have thrown an error but didn\'t?\"\n      end\n   end\nend\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/repr.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/repr.git",
    home = "",
    website = "",
    name = "repr",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr",
hash = "fd3b2033eeae251575dbc406d5cf949969a8e8c9e584a7e1b0e6cf5437926b48",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal C = require \"singletons/color\"\nlocal Composer = require \"repr:repr/composer\"\nlocal tabulate = require \"repr:repr/tabulate\"\n\nlocal concat = assert(table.concat)\n\n\n\n\n\n\n\nlocal repr = {}\n\n\n\n\n\n\n\n\n\n\nfunction repr.lineGen(tab, disp_width, color)\n   color = color or C.color\n   local generator = Composer(tabulate)\n   return generator(tab, disp_width, color)\nend\n\nfunction repr.lineGenBW(tab, disp_width)\n   return repr.lineGen(tab, disp_width, C.no_color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction repr.ts(val, disp_width, color)\n   local phrase = {}\n   for line in repr.lineGen(val, disp_width, color or C.no_color) do\n      phrase[#phrase + 1] = line\n   end\n   return concat(phrase, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\nfunction repr.ts_color(val, disp_width, color)\n   return repr.ts(val, disp_width, color or C.color)\nend\n\n\n\nreturn repr\n\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/tabulate",
hash = "484e5de878cca726451e20a53fa58624ed43fa26a696e40463c8c01ddf222fdf",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\nlocal core_table, core_string = require \"core/table\", require \"core/string\"\nlocal Token = require \"repr:repr/token\"\nlocal names = require \"repr:repr/names\"\nlocal nameFor =  assert(names.nameFor)\nlocal C = require \"singletons/color\"\n\nlocal yield, wrap = assert(coroutine.yield), assert(coroutine.wrap)\n\n\n\n\n\n\nlocal SORT_LIMIT = 500  -- This won\'t be necessary #todo remove\n\nlocal function _keysort(a, b)\n   if (type(a) == \'string\' and type(b) == \'string\')\n      or (type(a) == \'number\' and type(b) == \'number\') then\n      return a < b\n   elseif type(a) == \'number\' and type(b) == \'string\' then\n      return false\n   elseif type(a) == \'string\' and type(b) == \'number\' then\n      return true\n   elseif type(a) == \'string\' or type(a) == \'number\' then\n      -- we want these tags at the bottom\n      return true\n   else\n      return false\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal hasmetamethod = assert(require \"core/meta\" . hasmetamethod)\nlocal lines = assert(core_string.lines)\nlocal assertfmt = assert(require \"core/fn\" . assertfmt)\n\nlocal function _yieldReprs(tab, window, c)\n   local _repr = hasmetamethod(\"repr\", tab)\n   assert(c, \"must have a value for c\")\n   assert(_repr, \"failed to retrieve repr metamethod\")\n   local repr = _repr(tab, window, c)\n   -- __repr may choose to use yield() directly rather than returning a value\n   if repr == nil then return end\n   if type(repr) == \"string\" then\n      repr = lines(repr)\n   end\n   assertfmt(type(repr) == \"function\",\n      \"Unexpected return type from __repr: \\\n      Expected string, iterator-of-string, or iterator-of-Token, got %s\",\n      type(repr))\n   for line_or_token, len in repr do\n      local token\n      if type(line_or_token) == \"string\" then\n         -- Note that len may be nil, in which case the Token will figure things out for itself\n         token = Token(line_or_token, { color = \"no_color\", event = \"repr_line\", total_disp = len })\n      else\n         token = line_or_token\n      end\n      yield(token)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function yield_name(...) yield(nameFor(...)) end\n\nlocal isarray, table_keys, sort = assert(core_table.isarray),\n                                  assert(core_table.keys),\n                                  assert(table.sort)\n\nlocal function _tabulate(tab, window, c, aG)\n   if type(tab) ~= \"table\"\n      or window.depth > C.depth\n      or window.cycle[tab] then\n      yield_name(tab, c, aG)\n      return nil\n   end\n   -- Check for an __repr metamethod. If present, it replaces the rest of the\n   -- tabulation process for this table\n   if hasmetamethod(\"repr\", tab) and (not rawget(tab, \"__repr\")) then\n      window.depth = window.depth + 1\n      _yieldReprs(tab, window, c)\n      window.depth = window.depth - 1\n      return nil\n   end\n   -- add non-__repr\'ed tables to cycle\n   window.cycle[tab] = true\n\n   -- Okay, we\'re repring the body of a table of some kind\n   -- Check to see if this is an array\n   local is_array = isarray(tab)\n   -- And print an open brace, noting increased depth\n   yield(Token(\"{ \", { color = \"base\", event = is_array and \"array\" or \"map\" }))\n   window.depth = window.depth + 1\n\n   -- if we have a metatable, get it first\n   local _M = getmetatable(tab)\n   if _M then\n      local mt_name_token = nameFor(_M, c, aG, \"metatable\")\n      mt_name_token.event = \"metatable\"\n      if window.cycle[_M] then\n         mt_name_token:insert(1, \"⟨\")\n         mt_name_token:insert(\"⟩\")\n         mt_name_token:insert(\" \")\n      end\n      yield(mt_name_token)\n      -- Skip printing the metatable altogether if it\'s going to end up\n      -- represented by its name, since we just printed that.\n      if window.depth < C.depth and not window.cycle[_M] then\n         yield(Token(\" → \", { color = \"base\", event = \"sep\" }))\n         yield(Token(\"⟨\", { color = \"metatable\", event = \"metatable\" }))\n         _tabulate(_M, window, c, aG)\n         yield(Token(\"⟩ \", { color = \"metatable\", event = \"sep\"}))\n      else\n         yield(Token(\" \", { color = \"no_color\", event = \"sep\" }))\n      end\n   end\n\n   if is_array then\n      for i, val in ipairs(tab) do\n         if i ~= 1 then yield(Token(\", \", { color = \"base\", event = \"sep\" })) end\n         _tabulate(val, window, c, aG)\n      end\n   else\n      local keys = table_keys(tab)\n      if #keys <= SORT_LIMIT then\n         sort(keys, _keysort)\n      end\n      for i, key in ipairs(keys) do\n         if i ~= 1 then yield(Token(\", \", { color = \"base\", event = \"sep\" })) end\n         local val = tab[key]\n         if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then\n            -- legal identifier, display it as a bareword\n            yield_name(key, c, aG, \"field\")\n         else\n            -- arbitrary string or other type, wrap with braces and repr it\n            yield(Token(\"[\", { color = \"base\" }))\n            -- We want names or hashes for any lvalue table\n            yield_name(key, c, aG)\n            yield(Token(\"]\", { color = \"base\" }))\n         end\n         yield(Token(\" = \", { color = \"base\" }))\n         _tabulate(val, window, c, aG)\n      end\n   end\n   yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   window.depth = window.depth - 1\n   return nil\nend\n\nlocal function tabulate(tab, window, c, aG)\n   aG = aG or assert(names.anti_G)\n   return wrap(function()\n      -- Don\'t overwrite these if they already exist, in case we\'re\n      -- re-entering from an __repr function\n      window.depth = window.depth or 0\n      window.cycle = window.cycle or {}\n      -- _tabulate returns nothing, so the return value here\n      -- can only be an error message\n      local success, err = xpcall(\n         function() return _tabulate(tab, window, c, aG) end,\n         debug.traceback)\n      if not success then\n         for line in lines(\"error in __repr: \" .. err) do\n            yield(Token(line, { color = \"alert\", event = \"repr_line\" }))\n         end\n      end\n   end)\nend\n\nreturn tabulate\n\n\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/names",
hash = "6c6cefec75df15c88c034a9a13cee1467ea52abe3655f7190043e9391ca53704",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal Token = require \"repr:repr/token\"\nlocal import = assert(require \"core/module\" . import)\n\n\n\n\n\nlocal names = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anti_G = setmetatable({ _G = \"_G\" }, {__mode = \"k\"})\nnames.all_symbols = { _G = true }\nnames.anti_G = anti_G\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function tie_break(old, new)\n   return #old > #new\nend\n\nlocal isidentifier = import(\"core/string\", \"isidentifier\")\n\nlocal addName, loadNames\n\naddName = function(value, name, aG)\n   local existing = aG[value]\n   if not existing or tie_break(existing, name) then\n      aG[value] = name\n      if type(value) == \"table\" then\n         loadNames(value, name, aG)\n      end\n   end\nend\n\nloadNames = function(tab, prefix, aG)\n   if prefix ~= \"\" then\n      prefix = prefix .. \".\"\n   end\n   aG = aG or anti_G\n   for k, v in pairs(tab) do\n      if type(k) == \"string\" then\n         -- Only add legal identifiers to all_symbols, since this is\n         -- used for autocomplete\n         if isidentifier(k) then\n            names.all_symbols[k] = true\n         end\n      else\n         -- #todo should we put <> around non-identifier strings? I guess\n         -- it seems fine not to, since this is just for display...\n         k = \"<\" .. tostring(k) .. \">\"\n      end\n      local name = prefix .. k\n      local typica = type(v)\n      if typica == \"table\"  or typica == \"function\"\n      or typica == \"thread\" or typica == \"userdata\" then\n         addName(v, name, aG)\n      end\n      local _M = getmetatable(v)\n      if typica == \"table\" and _M then\n         addName(_M, \"⟨\" .. name .. \"⟩\", aG)\n      end\n   end\nend\n\nfunction names.addName(value, name, aG)\n   aG = aG or anti_G\n   addName(value, name, aG)\nend\n\nfunction names.loadNames(tab, prefix, aG)\n   tab = tab or _G\n   prefix = prefix or \"\"\n   aG = aG or anti_G\n   loadNames(tab, prefix, aG)\nend\n\nfunction names.clearNames()\n   anti_G = {_G = \"_G\"}\n   names.all_symbols = {}\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _rawtostring(val)\n   local ts\n   if type(val) == \"table\" then\n      -- get metatable and check for __tostring\n      local M = getmetatable(val)\n      if M and M.__tostring then\n         -- cache the tostring method and put it back\n         local __tostring = M.__tostring\n         M.__tostring = nil\n         ts = tostring(val)\n         M.__tostring = __tostring\n      end\n   end\n   if not ts then\n      ts = tostring(val)\n   end\n   return ts\nend\n\nfunction names.nameFor(value, c, aG, hint)\n   local str\n   -- Hint provides a means to override the \"type\" of the value,\n   -- to account for cases more specific than mere type\n   local typica = hint or type(value)\n   -- Start with the color corresponding to the type--may be overridden below\n   local cfg = { color = typica }\n\n   -- Value types are generally represented by their tostring()\n   if typica == \"string\"\n      or typica == \"number\"\n      or typica == \"boolean\"\n      or typica == \"nil\" then\n      str = tostring(value)\n      if typica == \"string\" then\n         cfg.wrappable = true\n      elseif typica == \"boolean\" then\n         cfg.color = str -- i.e. \"true\" or \"false\"\n      end\n      return Token(str, cfg)\n   end\n\n   -- For other types, start by looking for a name in anti_G:\n   aG = aG or anti_G\n   if aG[value] then\n      str = aG[value]\n      if typica == \"thread\" then\n         -- Prepend coro: even to names from anti_G to more clearly\n         -- distinguish from functions\n         str = \"coro:\" .. str\n      end\n      return Token(str, cfg)\n   end\n\n   -- If not found, construct one starting with the tostring()\n   str = _rawtostring(value)\n   if typica == \"metatable\" then\n      str = \"⟨\" .. \"mt:\" .. str:sub(-6) .. \"⟩\"\n   elseif typica == \"table\" then\n      str = \"t:\" .. str:sub(-6)\n   elseif typica == \"function\" then\n      local f_label = str:sub(11)\n      str = f_label:sub(1,5) == \"built\"\n                and f_label\n                or \"f:\" .. str:sub(-6)\n   elseif typica == \"thread\" then\n      str = \"coro:\" .. str:sub(-6)\n   elseif typica == \"userdata\" then\n      local name_end = str:find(\":\")\n      if name_end then\n         str = str:sub(1, name_end - 1)\n      end\n   end\n\n   return Token(str, cfg)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function c_data(value, str, phrase)\n   --local meta = reflect.getmetatable(value)\n   yield(str, #str)\n   --[[\n   if meta then\n      yield(c.base \" = \", 3)\n      yield_name(meta)\n   end\n   --]]\nend\n\n\n\nreturn names\n\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/token",
hash = "4e3ca0371895f20aa8618772d08e06a2702e4fd639df19c9d4f710e5d1fb1c3a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Codepoints = require \"singletons/codepoints\"\nlocal utf8 = require \"lua-utf8\"\nlocal utf8_len, utf8_sub = utf8.len, utf8.sub\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\nlocal meta = require \"core/meta\" . meta\n\n\n\n\n\n\nlocal Token = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.toString(token, c)\n   local color = c[token.color]\n   if not token.wrappable then\n      return color(utf8_sub(token.str, token.start))\n   end\n   local output = {}\n   for i = token.start, #token.codepoints do\n      local frag = token.codepoints[i]\n      if token.escapes[frag] then\n         frag = c.stresc .. frag .. color\n      elseif token.err and token.err[i] then\n         frag = c.alert .. frag .. color\n      end\n      insert(output, frag)\n   end\n   return color(concat(output))\nend\n\n\n\n\n\n\n\n\n\nfunction Token.__tostring(token)\n   if token.wrappable then\n      return concat(token.codepoints, \"\", token.start)\n   else\n      return utf8_sub(token.str, token.start)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.split(token, max_disp)\n   local first\n   local cfg = { color = token.color,\n                 event = token.event,\n                 wrappable = token.wrappable,\n                 wrapped = token.wrapped }\n   if token.wrappable then\n      cfg.escapes = token.escapes\n      first = new(nil, cfg)\n      for i = token.start, #token.codepoints do\n         if first.total_disp + token.disps[i] > max_disp then\n            token.start = i\n            token.total_disp = token.total_disp - first.total_disp\n            break\n         end\n         first:insert(token.codepoints[i], token.disps[i], token.err and token.err[i])\n      end\n   else\n      first = new(utf8_sub(token.str, token.start, token.start + max_disp - 1), cfg)\n      token.start = token.start + max_disp\n      token.total_disp = token.total_disp - max_disp\n   end\n   return first\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.insert(token, pos, frag, disp, err)\n   assert(token.start == 1, \"Cannot insert into a token with a start offset\")\n   if type(pos) ~= \"number\" then\n      err = disp\n      disp = frag\n      frag = pos\n      -- If we have a codepoints array, our total_disp might exceed its length\n      -- because of escapes. If not, total_disp is assumed equal to the\n      -- number of codepoints in the string\n      pos = (token.codepoints and #token.codepoints or token.total_disp) + 1\n   end\n   -- Assume one cell if disp is not specified.\n   -- Cannot use #frag because of Unicode--might be two bytes but one cell.\n   disp = disp or 1\n   if token.wrappable then\n      insert(token.codepoints, pos, frag)\n      insert(token.disps, pos, disp)\n      -- Create the error array if needed, and/or shift it if it exists (even\n      -- if this fragment is not in error) to keep indices aligned\n      if token.err or err then\n         token.err = token.err or {}\n         insert(token.err, pos, err)\n      end\n   else\n      token.str = utf8_sub(token.str, 1, pos - 1) .. frag .. utf8_sub(token.str, pos)\n   end\n   token.total_disp = token.total_disp + disp\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Token.remove(token, pos)\n   assert(token.start == 1, \"Cannot remove from a token with a start offset\")\n   local removed, rem_disp, err\n   if token.wrappable then\n      removed = remove(token.codepoints, pos)\n      rem_disp = remove(token.disps, pos)\n      err = token.err and remove(token.err, pos)\n   else\n      pos = pos or token.total_disp\n      removed = utf8_sub(token.str, pos, pos)\n      rem_disp = 1\n      token.str = utf8_sub(token.str, 1, pos - 1) .. utf8_sub(token.str, pos + 1)\n   end\n   token.total_disp = token.total_disp - rem_disp\n   return removed, rem_disp, err\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal string_sub = assert(string.sub)\n\nfunction Token.removeTrailingSpaces(token)\n   assert(not token.wrappable, \"removeTrailingSpaces not implemented \\\n      for wrappable tokens\")\n   assert(token.start == 1, \"removeTrailingSpaces not implemented \\\n      for tokens with a start offset\")\n   -- Note that we can ignore Unicode here, as we only care about spaces\n   local last_non_space = -1\n   while string_sub(token.str, last_non_space, last_non_space) == \" \" do\n      last_non_space = last_non_space - 1\n   end\n   token.str = string_sub(token.str, 1, last_non_space)\n   token.total_disp = token.total_disp + last_non_space + 1\nend\n\n\n\n\n\n\nfunction Token.isForceBreak(token)\n   return token.event == \"break\" or token.event == \"repr_line\"\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal escape_char = assert(require \"core:string/escape\" . escape_char)\n\nnew = function(str, cfg)\n   local token = meta(Token)\n   token.str = str\n   token.start = 1\n   cfg = cfg or {}\n   if cfg.wrappable then\n      token.codepoints = Codepoints(str or \"\")\n      token.err = token.codepoints.err\n      token.disps = {}\n      token.escapes = {}\n      token.total_disp = 0\n      for i, frag in ipairs(token.codepoints) do\n         -- For now, start by assuming that all codepoints occupy one cell.\n         -- This is wrong, but *usually* does the right thing, and\n         -- handling Unicode properly is hard.\n         local disp = 1\n         local escaped = escape_char(frag)\n         if escaped ~= frag then\n            token.codepoints[i] = escaped\n            -- In the case of an escape, we know all of the characters involved\n            -- are one-byte, and each occupy one cell\n            disp = #escaped\n            token.escapes[escaped] = true\n         end\n         token.disps[i] = disp\n         token.total_disp = token.total_disp + disp\n      end\n      -- Note that we don\'t quote if str was nil, only if it was an actual\n      -- empty string. nil is used to create a blank token into which chars\n      -- will later be inserted (see :split()).\n      if str and str:find(\'^ *$\') then\n         -- Need to assign this over now so :insert() behaves properly\n         token.wrappable = true\n         token:insert(1, \'\"\')\n         token:insert(\'\"\')\n      end\n   else -- not cfg.wrappable\n      token.total_disp = utf8_len(str)\n   end\n   for k, v in pairs(cfg) do\n      token[k] = v\n   end\n   return token\nend\n\nToken.idEst = new\n\nreturn new\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/composer",
hash = "b22784722124d6caddfb22c19dfc37682763f9410cfc17a356c4d6a493a34265",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = require \"core/meta\" . meta\nlocal Token = require \"repr:repr/token\"\n\nlocal concat, insert, remove = assert(table.concat),\n                               assert(table.insert),\n                               assert(table.remove)\n\n\n\n\n\n\n\nlocal Composer = meta {}\nlocal new\n\n\n\n\n\n\n\n\n\n\nfunction Composer.indent(composer)\n   -- If the first token is the second half of a wrap--it is marked as wrapped\n   -- and has a start offset--we won\'t include any indentation\n   if composer.pos > 0 and\n      composer[1].wrapped and\n      composer[1].start > 1 then\n      return 0\n   end\n   return 2 * composer.level\nend\n\n\n\n\n\n\n\n\nfunction Composer.disp(composer)\n   local disp = composer:indent()\n   for i = 1, composer.pos do\n      disp = disp + composer[i].total_disp\n   end\n   return disp\nend\n\n\n\n\n\n\n\nfunction Composer.remains(composer)\n   return composer.width - composer:disp()\nend\n\n\n\n\n\n\n\n\nfunction Composer.peek(composer)\n   if composer.more and not composer[composer.pos + 1] then\n      composer[composer.pos + 1] = composer.token_source()\n   end\n   if not composer[composer.pos + 1] then\n      composer.more = false\n   end\n   return composer[composer.pos + 1]\nend\n\n\n\n\n\n\n\n\n\n\nfunction Composer.advance(composer)\n   local token = composer:peek()\n   if token then\n      composer.pos = composer.pos + 1\n   end\n   return token, composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\nlocal STAGED_EVENTS = {\n   array = true,\n   map = true\n}\n\nfunction Composer.checkPushStage(composer)\n   local token = composer[composer.pos]\n   if STAGED_EVENTS[token.event] then\n      insert(composer.stages, {\n         start_token = token,\n         event = token.event,\n         long = false })\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Composer.checkPopStage(composer)\n   local token = composer[composer.pos]\n   if token.event == \"end\" then\n      local next_token = composer:peek()\n      -- If the following token is a separator, don\'t end the stage here...\n      if not (next_token and next_token.event == \"sep\") then\n         remove(composer.stages)\n      end\n   elseif token.event == \"sep\" then\n      local prev = composer[composer.pos - 1]\n      -- ...because, if we encounter a separator and the *previous* token\n      -- is an =end=, *now* it\'s time to end the stage\n      if prev and prev.event == \"end\" then\n         remove(composer.stages)\n      end\n   end\n   return composer.stages[#composer.stages]\nend\n\n\n\n\n\n\n\n\nfunction Composer.enterLongMode(composer)\n   for i = 1, composer.level do\n      assert(composer.stages[i].long,\n         \"Cannot print a long stage inside a short one\")\n   end\n   local long_stage_index = composer.level\n   local stage\n   repeat\n      long_stage_index = long_stage_index + 1\n      stage = composer.stages[long_stage_index]\n      assert(stage, \"No new stage to put in long mode\")\n   until not stage.long\n   stage.long = true\n   for i = long_stage_index + 1, #composer.stages do\n      composer.stages[i] = nil\n   end\n   for i, token in ipairs(composer) do\n      if token == stage.start_token then\n         composer.pos = i\n         return token, composer.stages[#composer.stages]\n      end\n   end\n   error(\"Could not find start of stage\")\nend\n\n\n\n\n\n\n\n\nfunction Composer.emit(composer)\n   if composer.pos == 0 then\n      return nil\n   end\n   local output = { (\" \"):rep(composer:indent()) }\n   for i = 1, composer.pos do\n      insert(output, composer[i]:toString(composer.color))\n   end\n   -- Erase what we just copied to the output and shift\n   -- any remaining tokens back\n   for i = 1, #composer do\n      if i > composer.pos then\n         composer[i - composer.pos] = composer[i]\n      end\n      composer[i] = nil\n   end\n   composer.pos = 0\n   composer.level = #composer.stages\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\nlocal format = assert(string.format)\nlocal function errLine(...)\n   io.stderr:write(format(...))\n   io.stderr:write(\"\\n\")\n   io.stderr:flush()\nend\nfunction Composer.logDebugInfo(composer)\n   errLine((\"=\"):rep(40))\n   errLine(\"STAGES (level = %d):\", composer.level)\n   for i = 0, #composer.stages do\n      local stage = composer.stages[i]\n      errLine(\"%d: %s (%s)%s\",\n         i,\n         stage.event,\n         stage.long and \"long\" or \"short\",\n         i == composer.level and \" <- LEVEL\" or \"\")\n   end\n   errLine((\"-\"):rep(40))\n   errLine(\"TOKENS (width = %d, disp = %d, remains = %d):\",\n      composer.width, composer:disp(), composer:remains())\n   for i, token in ipairs(composer) do\n      errLine(\"%02d   %s%s\",\n         token.total_disp, tostring(token),\n         i == composer.pos and \" <- POS\" or \"\")\n   end\nend\n\n\n\n\n\n\n\n\n\n\nlocal MIN_SPLIT_WIDTH = 20\n\nfunction Composer.splitToken(composer, token)\n   local token = composer[composer.pos]\n   -- Step back one token to exclude the one we\'re about to split\n   composer.pos = composer.pos - 1\n   -- Reserve one space for the ~ indicating a wrapped line\n   local remaining = composer:remains() - 1\n   token.wrapped = true\n   -- Only split strings, and only if they\'re long enough to be worth it\n   -- In the extreme event that a non-string token is longer than the\n   -- entire available width, split it too to avoid an infinite loop\n   if token.wrappable and token.total_disp > MIN_SPLIT_WIDTH\n      or token.total_disp >= composer.width then\n      token = token:split(remaining)\n      -- Pad with spaces if we were forced to split a couple chars short\n      for i = 1, remaining - token.total_disp do\n         token:insert(\" \")\n      end\n   -- Short strings and other token types just get bumped to the next line\n   else\n      token = Token((\" \"):rep(remaining), { color = \"no_color\" })\n   end\n   -- Done splitting, step forward again\n   composer.pos = composer.pos + 1\n   insert(composer, composer.pos, token)\n   -- Leave the ~ ready to be consumed by the next advance()--we need to finish\n   -- processing the first half of the split first.\n   insert(composer, composer.pos + 1, Token(\"~\", { color = \"alert\", event = \"break\" }))\n   return token\nend\n\n\n\n\n\nfunction Composer.isReadyToEmit(composer)\n   local token, stage = composer[composer.pos], composer.stages[#composer.stages]\n   -- It\'s a forced break, obviously end of line\n   if token:isForceBreak() then return true end\n   -- We\'re in short mode, so no other break conditions are possible\n   if not stage.long then return false end\n   -- Break on separators, which includes after the arrow in a metatable\n   -- and after the metatable itself\n   if token.event == \"sep\" then return true end\n   -- At this point, the only possible place to break is after an opening brace\n   if token ~= stage.start_token then return false end\n   -- But not after the very outermost opening brace\n   if #composer.stages == 1 then return false end\n   -- Nor if the table has a metatable\n   local next_token = composer:peek()\n   if next_token and next_token.event == \"metatable\" then return false end\n   -- Nor after the opening brace *of* a metatable\n   local prev_token = composer[composer.pos - 1]\n   if prev_token and prev_token.event == \"metatable\" then return false end\n   -- Okay, we\'ve run the gauntlet, yes, this is a good place to stop\n   return true\nend\n\n\n\n\n\n\n\n\n\nfunction Composer.composeLine(composer)\n   repeat\n      local token = composer:advance()\n      if not token then break end\n\n      local stage = composer:checkPushStage()\n      if not stage then\n         error(\"No stage while processing: \" .. tostring(token))\n      end\n\n      if token:isForceBreak() and not stage.long then\n         token, stage = composer:enterLongMode()\n      end\n      -- If we know we are going to end the line after this token no matter\n      -- what, we can allow it to exactly fill the line--no need to reserve\n      -- space for a ~. We can also ignore any trailing spaces it may contain.\n      -- Note, we don\'t want to mess with repr lines here.\n      local reserved_space = 1\n      if composer:isReadyToEmit() and token.event ~= \"repr_line\" then\n         token:removeTrailingSpaces()\n         reserved_space = 0\n      end\n      if composer:remains() < reserved_space then\n         assert(token.event ~= \"break\", \"~ token overflowing line\")\n         if not stage.long then\n            token, stage = composer:enterLongMode()\n         -- Never wrap output from __repr--likely to do more harm than good\n         -- until/unless we can parse out color escape sequences\n         elseif token.event ~= \"repr_line\" then\n            token = composer:splitToken()\n         end\n      end\n      stage = composer:checkPopStage()\n   until composer:isReadyToEmit()\n   return composer:emit()\nend\n\nComposer.__call = Composer.composeLine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _field_windows(c, f, w) return c[f] end\nlocal function _fn_windows(c, f, w) return c[f](c) end\nlocal function _value_windows(c, f, w) return rawget(w, f) end\n\nlocal window_dispatch = { remains =  _fn_windows,\n                          case    =  _fn_windows,\n                          width   =  _field_windows,\n                          color   =  _field_windows,\n                          depth   =  _value_windows,\n                          cycle   =  _value_windows }\n\nlocal function make_window__index(composer, field)\n   return function(window, field)\n      if window_dispatch[field] then\n         return window_dispatch[field](composer, field, window)\n      end\n      error (\"window has no method \" .. field .. \"n\" .. debug.traceback())\n   end\nend\n\nlocal function _window__newindex(window, key, value)\n   if window_dispatch[key] == _value_windows then\n      rawset(window, key, value)\n   else\n      error(tostring(key) .. \" = \" .. tostring(value) ..\n         \": not a writable field on window\\n\" .. debug.traceback())\n   end\nend\n\nfunction Composer.window(composer)\n   local window = setmetatable({}, { __index = make_window__index(composer),\n      __newindex = _window__newindex})\n   return window\nend\n\n\n\n\n\n\nlocal function new(iter_gen, cfg)\n   cfg = cfg or {}\n   local function generator(val, disp_width, color)\n      assert(color, \"Must provide a color table to Composer\")\n      local width = disp_width or 80\n      local composer = setmetatable({\n         color = color,\n         width = width,\n         more = true,\n         pos = 0,\n         stages = {[0] = { long = true }},\n         level = 0,\n         long = false\n      }, Composer)\n      for k,v in pairs(cfg) do\n        composer[k] = v\n      end\n      composer.token_source = iter_gen(val, composer:window(), color)\n      return composer\n   end\n   return generator\nend\n\nComposer.idEst = new\n\nreturn new\n\n\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/repr",
hash = "fd3b2033eeae251575dbc406d5cf949969a8e8c9e584a7e1b0e6cf5437926b48",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal C = require \"singletons/color\"\nlocal Composer = require \"repr:repr/composer\"\nlocal tabulate = require \"repr:repr/tabulate\"\n\nlocal concat = assert(table.concat)\n\n\n\n\n\n\n\nlocal repr = {}\n\n\n\n\n\n\n\n\n\n\nfunction repr.lineGen(tab, disp_width, color)\n   color = color or C.color\n   local generator = Composer(tabulate)\n   return generator(tab, disp_width, color)\nend\n\nfunction repr.lineGenBW(tab, disp_width)\n   return repr.lineGen(tab, disp_width, C.no_color)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction repr.ts(val, disp_width, color)\n   local phrase = {}\n   for line in repr.lineGen(val, disp_width, color or C.no_color) do\n      phrase[#phrase + 1] = line\n   end\n   return concat(phrase, \"\\n\")\nend\n\n\n\n\n\n\n\n\n\nfunction repr.ts_color(val, disp_width, color)\n   return repr.ts(val, disp_width, color or C.color)\nend\n\n\n\nreturn repr\n\n",
},
  { 
vc_hash = "1b9d11bb2b570ef69c4a21ccf88cfeca87e08bfd",
name = "repr/persist-tabulate",
hash = "503b4d8a3bc15fd387213bf852fd4a76b57a3a41ebd9eda8836f691d6a0a264a",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\nlocal tabulate = require \"repr:repr/tabulate\"\nlocal names = require \"repr:repr/names\"\nlocal assertfmt = assert(require \"core:core/string\" . assertfmt)\n\n\n\nlocal persist_tabulate = {}\n\n\n\n\n\n\n\n\n\nlocal compression_map = {\n   event = {\n      array     = \"[\",\n      map       = \"{\",\n      metatable = \"<\",\n      [\"end\"]   = \"}\",\n      repr_line = \"#\",\n      [\"break\"] = \"~\",\n      sep       = \",\"\n   },\n   wrappable = { [true] = \"w\" },\n   color = {\n      -- Types and pseudo-types\n      [\"nil\"]      = \"z\",\n      [\"true\"]     = \"t\",\n      [\"false\"]    = \"f\",\n      number       = \"n\",\n      string       = \"s\",\n      table        = \"o\", -- For \"object\", t is taken\n      [\"function\"] = \"e\", -- For \"executable\", f is taken\n      userdata     = \"u\",\n      cdata        = \"c\",\n      thread       = \"r\", -- For \"routine\", c (for coro) and t are both taken\n      metatable    = \"m\",\n      -- Syntax elements\n      field        = \"p\", -- For \"property\", f is taken\n      operator     = \"i\", -- Okay, I pretty much give up, but, b*i*nary? eh?\n                          -- Also the only available letter in \"punctuation\"\n      keyword      = \"k\",\n      comment      = \"v\",\n      base         = \"b\",\n      -- Misc\n      alert        = \"a\",\n      search_hl    = \"h\",\n      [\"error\"]    = \"d\", -- Now I *really* give up\n      bold         = \"l\",\n      greyscale    = \"g\",\n      highlight    = \"j\",\n      no_color     = \"x\",\n   }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal decompression_map = {}\nfor prop, sub_map in pairs(compression_map) do\n   for val, char in pairs(sub_map) do\n      assertfmt(not decompression_map[char], \"Duplicate compression char %s\", char)\n      decompression_map[char] = { [prop] = val }\n   end\nend\n\n\n\n\n\nlocal function ninsert(tab, val)\n   tab.n = tab.n + 1\n   tab[tab.n] = val\nend\n\nlocal SOH, STX = \"\\x01\", \"\\x02\"\n\nlocal concat, insert, sort = assert(table.concat),\n                             assert(table.insert),\n                             assert(table.sort)\nlocal function dump_token(token, stream)\n   ninsert(stream, SOH)\n   local header_chars = {}\n   for prop, sub_map in pairs(compression_map) do\n      local val = token[prop]\n      if val then\n         local char = sub_map[val]\n         assertfmt(char, \"Missing compression char for property %s = %s\", prop, val)\n         insert(header_chars, char)\n      end\n   end\n   sort(header_chars)\n   ninsert(stream, concat(header_chars))\n   ninsert(stream, STX)\n   ninsert(stream, tostring(token))\n   return stream\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal no_color = assert(require \"singletons:color\" . no_color)\n\nlocal function tabulate_some(results, count, aG)\n   count = count or 100\n   aG = aG or assert(names.anti_G)\n   local results_tostring, results_tabs = {}, {}\n   for i = 1, results.n do\n      -- Make a dummy table to stand in for Composer:window(),\n      -- since we won\'t be making a Composer at all.\n      local dummy_window = { width = 80, remains = 80, color = no_color }\n      results_tabs[i] = tabulate(results[i], dummy_window, no_color, aG)\n      results_tostring[i] = { n = 0 }\n   end\n   local i = 1\n   return function()\n      if i > #results_tabs then\n         return true, results_tostring\n      end\n      local start_token_count = results_tostring[i].n\n      if start_token_count > 15000 then\n         -- bail early\n         results_tostring[i] = concat(results_tostring[i])\n         i  = i + 1\n         return false\n      end\n      while results_tostring[i].n - start_token_count <= count do\n         local success, token = pcall(results_tabs[i])\n         if success then\n            if token then\n               dump_token(token, results_tostring[i])\n            else\n               results_tostring[i] = concat(results_tostring[i])\n               i = i + 1\n               return false\n            end\n         else\n            error(token)\n         end\n      end\n      return false\n   end\nend\n\npersist_tabulate.tabulate_some = tabulate_some\n\n\n\n\n\n\n\n\nfunction persist_tabulate.tabulate(results, aG)\n   local persist_cb = tabulate_some(results, math.huge, aG)\n   local done, results_tostring\n   repeat\n      done, results_tostring = persist_cb()\n   until done\n   return results_tostring\nend\n\n\n\n\n\n\n\n\n\nlocal lines = assert(require \"core:string\" . lines)\nlocal addall = assert(require \"core:table\" . addall)\nlocal find, match, sub = assert(string.find),\n                         assert(string.match),\n                         assert(string.sub)\nlocal unescape = assert(require \"core:string/escape\" . unescape)\nlocal Token = require \"repr:repr/token\"\n\nlocal function _db_result__repr(result)\n   if sub(result[1], 1, 1) == SOH then\n      -- New format--tokens delimited by SOH/STX\n      local header_position = 1\n      local text_position = 0\n      return function()\n         text_position = find(result[1], STX, header_position + 1)\n         if not text_position then\n            return nil\n         end\n         local metadata = sub(result[1], header_position + 1, text_position - 1)\n         local cfg = {}\n         -- Handle old-format metadata, with space-separated\n         -- \"wrappable\" and \"event=\" tokens. `wrappable` and `event=end`\n         -- are both 9 characters, so that\'s a sensible cut-off\n         if #metadata >= 9 then\n            if find(metadata, \"wrappable\") then cfg.wrappable = true end\n            cfg.event = match(metadata, \"event=([%w_]+)\")\n         -- New compressed format, read one char at time using decompression map\n         else\n            for c in metadata:gmatch \".\" do\n               local extra_cfg = assertfmt(decompression_map[c], \"Unrecognized compressed character %s\", c)\n               addall(cfg, extra_cfg)\n            end\n         end\n         -- For now, force the color back to greyscale no matter what\n         cfg.color = \"greyscale\"\n         header_position = find(result[1], SOH, text_position + 1)\n         if not header_position then\n            header_position = #result[1] + 1\n         end\n         local text = sub(result[1], text_position + 1, header_position - 1)\n         if cfg.wrappable then\n            text = unescape(text)\n         end\n         return Token(text, cfg)\n      end\n   else\n      -- Old format--just a string, which we\'ll break up into lines\n      local line_iter = lines(result[1])\n      return function()\n         local line = line_iter()\n         if line then\n            -- Might as well return a Token in order to attach the color properly,\n            -- rather than just including the color escapes in the string\n            return Token(line, { color = \"greyscale\", event = \"repr_line\" })\n         else\n            return nil\n         end\n      end\n   end\nend\n\npersist_tabulate.db_result_M = { __repr = _db_result__repr }\n\n\n\n\n\n\nreturn persist_tabulate\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/scroll.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/scroll.git",
    home = "",
    website = "",
    name = "scroll",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "4fc6055ce946895717809840ad96641f9cbe8f5f",
name = "scroll",
hash = "ebf5a8f41c73e06ab8785c5f1b41b7b8fc57b5a4b58e7cee0b205db9955f30b8",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\"\nlocal string = require \"core:core/string\"\nlocal table = require \"core:core/table\"\nlocal Node = require \"espalier:node\"\nlocal Phrase = require \"singletons:singletons/phrase\"\n\n\n\n\n\n\nlocal Scroll = {}\nScroll.__index = Scroll\n\n\n\nlocal function new(seed)\n   local scroll = setmetatable({}, Scroll)\n   -- not using this, probably won\'t\n   scroll.source_map = {}\n   scroll.errors = {}\n   if seed then\n      scroll:add(seed)\n   end\n   return scroll\nend\nScroll.idEst = new\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert, concat = assert(table.insert),\n                       assert(table.concat)\n\nlocal lines = string.lines\n\nlocal function _insert(scroll, frag, index)\n   index = index or #scroll + 1\n   local sc_end = scroll[#scroll]\n   if sc_end and sc_end.partial then\n      insert(sc_end, frag)\n   else\n      scroll[index] = {frag}\n   end\nend\n\nlocal function _add(scroll, frag, index)\n   local idx_start = index or #scroll + 1\n   local str\n   if type(frag) == \'string\' then\n      str = frag\n   elseif type(frag) == \'table\' and frag.isNode then\n      str = frag:span()\n      -- we need to handle source mapping as well\n   elseif type(frag) == \'table\' then -- we\'ll pretend it\'s a Phrase\n      str = tostring(frag)\n   else\n      error(\"cannot add fragment to scroll of type \" .. type(frag))\n   end\n\n   local ln = lines(str)\n   local this_ln = ln()\n   while true do\n      -- todo: this won\'t always go on its own line\n      -- right now we\'re just recapitulating add, but handling newlines\n      -- for everything, not just Nodes.\n      local next_ln = ln()\n      if not next_ln then\n         -- don\'t insert a final newline as a blank line\n         if this_ln ~= \"\" then\n            _insert(scroll, this_ln, index)\n            scroll[#scroll].partial = true\n         else\n            -- close the line\n            scroll[#scroll].partial = nil\n         end\n         break\n      else\n         _insert(scroll, this_ln)\n         index = index + 1\n         scroll[#scroll].partial = nil\n         this_ln = next_ln\n      end\n   end\n   return index - idx_start\nend\n\nfunction Scroll.add(scroll, frag)\n   return _add(scroll, frag, #scroll + 1)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal replace = assert(table.replace)\n\nfunction Scroll.replace(scroll, frag, start, finish)\n   local sc_frag = new(frag)\n   sc_frag[#sc_frag].partial = nil\n   local span = finish - start + 1\n   replace(scroll, start, sc_frag, span)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- holds arrays of completed deferments, keyed by scroll\nlocal _defers = setmetatable({}, { __mode = \'k\' })\n\n-- holds deferments which are open but not closed,\n-- keyed by the close mark\nlocal _open_defers = setmetatable({}, { __mode = \'k\' })\n\nfunction Scroll.deferStart(scroll, deferment)\n   -- if we\'re on a partial, we start there. Otherwise, we need a new partial\n   -- line, with no contents.\n   local start_line;\n   if scroll[#scroll].partial then\n      start_line = scroll[#scroll]\n   else\n      start_line = { \"\", partial = true }\n      scroll[#scroll + 1] = start_line\n   end\n   -- make a new deferment table\n   local this_defer = { fn = deferment,\n                        start_index = #scroll,\n                        start_line  = scroll[#scroll] }\n   local close_mark = {}\n   _open_defers[close_mark] = this_defer\n   return close_mark, this_defer -- only returning the deferment for REPling.\nend\n\n\n\n\n\n\nfunction Scroll.deferFinish(scroll, close_mark, deferment)\n   local this_defer = _open_defers[close_mark]\n   if not this_defer then\n      error \"no deferment corresponding to the given close mark\"\n   end\n   -- remove from the collection\n   _open_defers[close_mark] = nil\n   if deferment then\n      this_defer.fn = deferment\n   end\n   -- always choose the last line for deferFinish\n   this_defer.finish_index = #scroll\n   this_defer.finish_line  = scroll[#scroll]\n   -- add to deferments, creating container if necessary.\n   local defers;\n   if _defers[scroll] then\n      defers = _defers[scroll]\n   else\n      defers = {}\n      _defers[scroll] = defers\n   end\n   defers[#defers + 1] = this_defer\n   -- return the deferment for REPLing\n   return this_defer\nend\n\n\n\n\n\n\nlocal function _findIndex(scroll, index, line)\n   -- for now we\'re just going to pretend that the\n   -- index is the line, as indeed it is,\n   -- if the scroll doesn\'t grow or shrink.\n   if scroll[index] == line then\n      return index\n   else\n      local offset =  1\n      while not (index - offset < 1 or index + offset > #scroll) do\n         if scroll[index + offset] == line then\n            return index + offset\n         end\n         if scroll[index - offset] == line then\n            return index - offset\n         end\n         offset = offset + 1\n      end\n      s:warn(\"failed to find the line at \" .. tostring(index))\n   end\nend\n\nfunction Scroll.deferResolve(scroll)\n   local resolved = true\n   local defers = _defers[scroll]\n   if not defers then\n      return resolved\n   end\n   for _, df in ipairs(defers) do\n      local start  = _findIndex(scroll, df.start_index, df.start_line)\n      local finish = _findIndex(scroll, df.finish_index, df.finish_line)\n      if not (start and finish) then\n         resolved = false\n      else\n         local section = scroll:section(start, finish)\n         local new_section = df.fn(section)\n         scroll:replace(new_section, start, finish)\n      end\n   end\n   -- remove the deferments\n   _defers[scroll] = nil\n\n   return resolved\nend\n\n\n\n\n\n\n\n\n\nlocal function section(scroll, start, finish)\n   assert(type(start) == \'number\', \"start must be a number\")\n   assert(type(finish) == \'number\', \"finish must be a number\")\n   local final = true\n   if scroll[finish].partial then\n      final = false\n   end\n   local collect = {}\n   for i = start, finish do\n      local line = scroll[i]\n      if type(line) == \'table\' and not line.has_closure then\n         collect[#collect + 1] = concat(line)\n      else\n         -- handle the case of a fragment or line closure\n         -- probably throw a warning and insert a placeholder?\n      end\n   end\n   if final then\n      collect[#collect + 1] = \"\"\n   end\n   return concat(collect, \"\\n\")\nend\n\nScroll.section = section\n\n\n\n\n\n\n\n\nfunction Scroll.__tostring(scroll)\n   return section(scroll, 1, #scroll)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Scroll.addError(scroll, errstring)\n   insert(scroll.errors, errstring)\nend\n\n\n\n\n\n\n\n\nfunction Scroll.repr(scroll)\n   return Phrase(tostring(scroll))\nend\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/set.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/set.git",
    home = "",
    website = "",
    name = "set",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "264f883d0955296ba671d553b7e24370c1def37f",
name = "set",
hash = "263ca3e9bf2bdd234715722126ca13d1344768e69272fddc6b217e9d701b57b8",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nlocal Set = {}\nSet.__index = Set\n\n\n\n\n\n\n\n\n\n\n\nlocal function new(items)\n   local set = {}\n   set.⊆ = {}\n   setmetatable(set, Set)\n   assert(type(items) == \"table\" or items == nil,\n          \"argument to set constructor must be a table\")\n   if items then\n      if items.idEst == new then\n         for k, _ in pairs(items.⊆) do\n            set.⊆[k] = true\n         end\n      else\n         for _,value in ipairs(items) do\n            set.⊆[value] = true\n         end\n      end\n   end\n   return set\nend\nSet.idEst = new\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.insert(set, ...)\n   local items = pack(...)\n   for i = 1, items.n do\n      if items[i] then\n         set.⊆[items[i]] = true\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.remove(set, ...)\n   local removed = true\n   local items = pack(...)\n   for i = 1, items.n do\n      removed = set.⊆[items[i]] and removed\n      set.⊆[items[i]] = nil\n   end\n   return removed and removed or nil\nend\n\n\n\n\n\n\n\n\nlocal clear = assert(table.clear)\n\nfunction Set.clear(set)\n   clear(set.⊆)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.∈(set, item)\n   return set.⊆[item] or false\nend\n\nSet.E = Set.∈\n\n\n\n\n\n\n\n\nfunction Set.__call(set, item)\n   return set.⊆[item] or false\nend\n\n\n\n\n\n\nlocal function hasSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\", \"bad argument #2 to hasSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = true\n   for k, _ in pairs(maybe_subset.⊆) do\n     is_subset = is_subset and set.⊆[k]\n   end\n\n   return is_subset == true\nend\n\nSet.hasSubset = hasSubset\n\nfunction Set.__lte(head, tail)\n   return hasSubset(tail, head)\nend\n\n\n\n\n\n\nlocal function hasProperSubset(set, maybe_subset)\n   assert(type(maybe_subset) == \"table\",\n          \"bad argument #2 to hasProperSubset\")\n   if maybe_subset.idEst ~= new then\n      maybe_subset = new(maybe_subset)\n   end\n\n   local is_subset = hasSubset(set, maybe_subset)\n   local is_superset = false\n   for k, _ in pairs(set.⊆) do\n      if not maybe_subset.⊆[k] then\n         is_superset = true\n      end\n   end\n   -- coerce a nil result to boolean for return value\n   return (is_subset and is_superset) == true\nend\n\nSet.hasProperSubset = hasProperSubset\n\nfunction Set.__lt(head, tail)\n   return hasProperSubset(tail, head)\nend\n\n\n\n\n\n\n\n\nfunction Set.__len(set)\n   local count = 0\n   for _, __ in pairs(set.⊆) do\n      count = count + 1\n   end\n   return count\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.__eq(left, right)\n   local same = true\n   for k, _ in pairs(left.⊆) do\n      same = same and right.⊆[k] ~= nil\n   end\n   for k, _ in pairs(right.⊆) do\n      same = same and left.⊆[k] ~= nil\n   end\n   return same == true\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function union(head, tail)\n   local union = new(head)\n   assert(type(tail) == \"table\", \"bad argument #2 to union: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k, _ in pairs(tail.⊆) do\n      union.⊆[k] = true\n   end\n   return union\nend\n\nSet.union = union\n\nfunction Set.__add(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot make union of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return union(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function difference(head, tail)\n   local diff = new(head)\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to difference: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k,_ in pairs(tail.⊆) do\n      diff.⊆[k] = nil\n   end\n   return diff\nend\n\nSet.difference = difference\n\nfunction Set.__sub(head, tail)\n   if type(head) ~= \"table\" then\n      error(\"cannot take difference of \" .. h_type .. \"and set\")\n   end\n   if type(tail) ~= \"table\" then\n      tail = {tail}\n   end\n   if not head.idEst == new then\n      head = new(head)\n   end\n   return difference(head, tail)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Set.intersection(head, tail)\n   local section = new()\n   assert(type(tail) == \"table\",\n          \"bad argument #2 to intersection: expected table\")\n   if not (tail.idEst == new) then\n      tail = new(tail)\n   end\n   for k,_ in pairs(tail.⊆) do\n      if head.⊆[k] then\n         section.⊆[k] = true\n      end\n   end\n   return section\nend\n\n\n\n\n\n\n\n\n\nfunction Set.__newindex(set, key, value)\n   assert(type(value) == \'boolean\' or value == nil,\n      \"Bad assignment to Set: must be boolean or nil\")\n   if value == false then\n      value = nil\n   end\n   rawset(set.⊆, key, value)\nend\n\n\n\n\n\n\n\n\nfunction Set.__pairs(set)\n   return pairs(set.⊆)\nend\n\n\n\n\n\n\n\n\n\nlocal wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)\nlocal tabulate, Token\n\nfunction Set.__repr(set, window, c)\n   tabulate = tabulate or require \"repr:tabulate\"\n   Token = Token or require \"repr:token\"\n   return wrap(function()\n      yield(Token(\"#{ \", { color = \"base\", event = \"array\"}))\n      local first = true\n      window.depth = window.depth + 1\n      for v, _ in pairs(set.⊆) do\n         if first then\n            first = false\n         else\n            yield(Token(\", \", { color = \"base\", event = \"sep\" }))\n         end\n         for t in tabulate(v, window, c) do\n            yield(t)\n         end\n      end\n      window.depth = window.depth - 1\n      yield(Token(\" }\", { color = \"base\", event = \"end\" }))\n   end)\nend\n\n\n\n\nreturn new\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/singletons.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/singletons.git",
    home = "",
    website = "",
    name = "singletons",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "ss",
hash = "\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"singletons\"\n\n",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\nreturn require \"singletons\"\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons/color",
hash = "4685515ac01a54659408bac53b23da48a4040c24c046ed003131f874e345a249",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal a = require \"anterm:anterm\"\n\nlocal Palette = require \"anterm:anterm/palette\"\n\nlocal WIDE_TABLE = 200 -- should be tty-specific\n\nlocal C = {}\n\nlocal thread_shade = a.fg24(240, 50, 100)\n\n-- #Todo make this into a proper color and use it again\n\nlocal function thread_color(str)\n   return a.italic .. thread_shade .. str .. a.clear\nend\n\nC.color = Palette {\n                    number = a.fg(42),\n                    string = a.fg(222),\n                    stresc = a.fg(225),\n                    table  = a.fg(64),\n                    func   = a.fg24(210,12,120),\n                    truth  = a.fg(231),\n                    falsehood  = a.fg(94),\n                    nilness    = a.fg(93),\n                    thread     = a.fg24(240, 50, 100),\n                    coro       = a.fg24(240, 50, 100),\n                    field      = a.fg(111),\n                    userdata   = a.fg24(230, 145, 23),\n                    cdata      = a.fg24(200, 115, 0),\n                    metatable  = a.fg24(242, 0, 234) }\n\nC.color[\"function\"] = C.color.func\nC.color[\"true\"]     = C.color.truth\nC.color[\"false\"]    = C.color.falsehood\nC.color[\"nil\"]      = C.color.nilness\n\nC.color.operator = a.fg24(220, 40, 150)\nC.color.keyword = a.fg24(100, 210, 100)\nC.color.comment = a.fg24(128,128,128)\n\n\nC.color.alert      = a.fg24(250, 0, 40)\nC.color.base       = a.fg24(200, 200, 200)\nC.color.search_hl = a.fg24(30, 230, 100)\nC.color.error = a.bg24(50,0,0)\nC.color.bold = a.bold\nC.color.greyscale = a.fg24(128,128,128)\n\nC.color.highlight = a.bg24(70, 70, 70)\n\nC.depth = 4 -- table print depth\n\n\n\n\n\n\n\n\n\nlocal no_color = {}\n-- if field accessed, pass through\nlocal function _no_c_index(nc, _)\n   return nc\nend\n\nlocal function _no_c_call(_, str)\n   return str or \"\"\nend\n\nlocal function _no_c_concat(head, tail)\n   head = head == no_color and \"\" or head\n   tail = tail == no_color and \"\" or tail\n   return head .. tail\nend\n\nsetmetatable(no_color, { __index  = _no_c_index,\n                                __call   = _no_c_call,\n                                __concat = _no_c_concat, })\n\nC.no_color = no_color\n\n-- Also attach a no_color option to the regular color table\nC.color.no_color = no_color\n\n\n\n\n\nreturn C\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons/codepoints",
hash = "9dada53e79a6b5e5b6aed46ce61edce16a5663212ff207fa12620d3b368030e5",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal meta = assert(require \"core:core/meta\" . meta)\nlocal utf8 = assert(require \"core:core/string\" . utf8)\n\n\n\n\n\nlocal Codepoints = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal sub = assert(string.sub)\n\nfunction Codepoints.__call(codepoints, str, start, finish)\n   start = start or 1\n   finish = (finish and finish <= #str) and finish or #str\n   -- propagate nil\n   if not str then return nil end\n   -- break on bad type\n   assert(type(str) == \"string\", \"codepoints must be given a string\")\n   local codes = setmetatable({}, Codepoints)\n   local index = start\n   while index <= finish do\n      local width, err = utf8(str, index)\n      if width then\n         local point = sub(str, index, index + width - 1)\n         insert(codes, point)\n         index = index + width\n      else\n         -- take off a byte and store it\n         local err_packet = { char = sub(str, index, index),\n                              err  = err }\n         codes.err = codes.err or {}\n         insert(codes, \"�\")\n         -- place the error at the same offset in the err table\n         codes.err[#codes] = err_packet\n         index = index + 1\n      end\n   end\n   return codes\nend\n\n\n\n\n\n\n\n\n\nlocal clone = assert(require \"core:core/table\" . clone)\n\nlocal function _adjustErrors(codepoints, pos, offset)\n   if pos and codepoints.err then\n      -- cache the error table so we can copy the\n      -- removed points without worrying about blasting them\n      -- before we reach them while iterating\n      local err_cache = clone(codepoints.err)\n      -- remove all errors above pos at once\n      for i, _ in pairs(codepoints.err) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i] = nil\n         end\n      end\n      -- now add them back, shifted by offset\n      for i, v in pairs(err_cache) do\n         if type(i) == \"number\" and i >= pos then\n            codepoints.err[i + offset] = v\n         end\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Codepoints.insert(codepoints, pos, value)\n   if value then\n      -- Insert the fragment\n      insert(codepoints, pos, value)\n      -- Only need to adjust errors if inserting other than at the end\n      _adjustErrors(codepoints, pos, 1)\n   else\n      -- Work around arguable bug in table.insert where calling\n      -- insert({}, \"a\", nil) throws an error--the third parameter\n      -- must be actually omitted rather than merely nil\n      insert(codepoints, pos)\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal remove = assert(table.remove)\n\nfunction Codepoints.remove(codepoints, pos)\n   local rem = remove(codepoints, pos)\n   -- Remove any corresponding error from the error table\n   if codepoints.err then\n      codepoints.err[pos or #codepoints + 1] = nil\n      -- And remove it altogether if it is now empty\n      if next(codepoints.err) then\n         _adjustErrors(codepoints, pos, -1)\n      else\n         codepoints.err = nil\n      end\n   end\n   return rem\nend\n\n\n\n\n\n\n\n\n\nlocal concat = assert(table.concat)\n\nfunction Codepoints.__tostring(codepoints)\n   local output = codepoints\n   if codepoints.err then\n      output = {}\n      for i, v in ipairs(codepoints) do\n         local err_here = codepoints.err[i]\n         output[i] = err_here and err_here.char or v\n      end\n   end\n   return concat(output)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal format, find, byte = assert(string.format),\n                           assert(string.find),\n                           assert(string.byte)\n\nlocal escapes_map = {\n   [\'\"\'] = \'\\\\\"\',\n   [\"\'\"] = \"\\\\\'\",\n   [\"\\\\\"] = \"\\\\\\\\\",\n   [\"\\a\"] = \"\\\\a\",\n   [\"\\b\"] = \"\\\\b\",\n   [\"\\f\"] = \"\\\\f\",\n   [\"\\n\"] = \"\\\\n\",\n   [\"\\r\"] = \"\\\\r\",\n   [\"\\t\"] = \"\\\\t\",\n   [\"\\v\"] = \"\\\\v\"\n}\n\nfunction Codepoints.toLuaString(codepoints, preface, afterward)\n   if type(codepoints) == \"string\" then\n      codepoints = Codepoints.__call(nil, codepoints)\n   end\n   local phrase = {}\n   if preface then\n      insert(phrase, preface)\n   end\n   insert(phrase, \'\"\')\n   local err = codepoints.err or {}\n   for i,frag in ipairs(codepoints) do\n      -- escape map non-printing chars\n      -- replace errors with an \\x?? token\n      -- otherwise, insert the frag\n      if escapes_map[frag] or find(frag, \"%c\") then\n         frag = escapes_map[frag] or format(\"\\\\x%02x\", byte(frag))\n      end\n      if err[i] then\n         frag = format(\"\\\\x%02x\", byte(err[i].char))\n      end\n      insert(phrase, frag)\n   end\n   insert(phrase, \'\"\')\n   if afterward then\n      insert(phrase, afterward)\n   end\n   return concat(phrase)\nend\n\n\n\nlocal CP_constructor = setmetatable({}, Codepoints)\nCodepoints.idEst = CP_constructor\n\n\n\nreturn CP_constructor\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons/check",
hash = "bfbaaaace8ccf657afa714c701e177c3aac4fe5bbf3658b84b06b0562eac41fe",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ts = tostring\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function ItIndex(itself, verb)\n   if verb == \"won\" or verb == \"did\" then\n      return nil\n   end\n   verb = verb and verb or \"\"\n   local it = itself.current\n   local result = {success = false}\n   result.why = \"`check` does not understand the verb \" .. ts(verb)\n               .. \" at least, not yet\" -- ¯\\_(ツ)_/¯\n   io.write(result.why .. \"\\n\")\n   it.did.also(result)\n   return function() return it end\nend\n\n\n\nlocal It = setmetatable({}, {__index = ItIndex})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(it)\n   if it.won == nil then\n      it = it:collate()\n   end\n   if it.won then\n      return it.subject, it\n   else\n      return nil, it\n   end\nend\n\n\n\n\n\n\n\n\n\nlocal function __repr(it)\n   return it.digest\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal must\n\nlocal function check(Object, name)\n   if Object.isIt and Object.isIt == It then\n      return Object\n   end\n\n   local itself = setmetatable({}, {__index = It,\n                                    __call = call,\n                                    __repr = __repr})\n   It.current  = setmetatable({} , {__index = itself,\n                                    __call = call,\n                                    __repr = __repr} )\n   itself.isIt = It\n   itself.name = name and name or \"it\"\n   itself.subject = Object\n   itself = must(itself)\n   itself.did = {}\n   itself.did.also = function(result)\n                        result.modal = itself.modal\n                        itself.did[#itself.did + 1] = result\n                        return itself\n                     end\n   itself.did.last = function() return itself.did[#itself.did] end\n\n   return itself\nend\n\nIt.it = check\n\n\n\n\n\n\n\n\n\n\nlocal ts = tostring -- stub, #todo replace with real deal\nlocal function verdict(it, subject, verb, object)\n   local subj = subject ~= \"\" and ts(subject) .. \" \" or \"\"\n   return it.name .. \": \" .. subj .. it.modal.inThatIt\n          .. \" \" .. verb .. \" \" .. ts(object)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Modal = {}\nModal.__index = Modal\n\n\n\n\n\n\n\n\nmust = function (it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local must = setmetatable({}, Modal)\n   must.beTrue = true\n   must.because = because\n   must.inThatIt = \"must\"\n   it.modal = must\n   return it\nend\n\nIt.must = must\n\nfunction It.mustnt(it, because)\n   assert(it.isIt == It, \"it isn\'t It\")\n   local mustnt = setmetatable({}, Modal)\n   mustnt.because = because or \"\"\n   mustnt.beTrue = false\n   mustnt.inThatIt = \"mustn\'t\"\n   it.modal = mustnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.should(it, because)\n   local should = setmetatable({}, Modal)\n   should.because = because or \"\"\n   should.beTrue = true\n   should.inThatIt = \"should\"\n   it.modal = should\n   return it\nend\n\nfunction It.shouldnt(it, because)\n   local shouldnt = setmetatable({}, Modal)\n   shouldnt.because = because or \"\"\n   shouldnt.beTrue = false\n   shouldnt.inThatIt = \"shouldn\'t\"\n   it.modal = shouldnt\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.can(it, because)\n   local can = setmetatable({}, Modal)\n   can.because = because or \"\"\n   can.beTrue = nil\n   can.inThatIt = \"could\"\n   it.modal = can\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.could(it, because)\n   local could = setmetatable({}, Modal)\n   could.because = because or \"\"\n   could.beTrue = nil\n   could.inThatIt = \"could\"\n   it.modal = could\n   return it\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.equal(it, rValue, because, becauseNot)\n   local result = {}\n   local success = it.subject == rValue and true or false\n   if not it.modal.beTrue then\n      success = not success\n   end\n   if success then\n      result.why =  verdict(it, it.subject, \"equal\", rValue)\n   else\n      result.why = verdict(it, it.subject, \"not equal\", rValue)\n   end\n   result.success = success\n\n   return it.did.also(result)\n\nend\n\n\n\n\n\n\n\n\n\nfunction It.has(it, field, because)\n   local result = {}\n   local success = false\n   local having = it.subject[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\nIt.have = It.has\n\n\n\n\n\n\n\nfunction It.whichHas(it, field, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having[field]\n   if having then\n      success = true\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   local clause = \" -> \" .. ts(having)\n   if success then\n      result.why =  because or it.modal.inThatIt .. \" have .\"\n                    .. ts(field, \"field\") .. clause\n   else\n      result.why =  because or it.modal.inThatIt .. \" not have .\"\n                       .. ts(field, \"field\") .. clause\n   end\n\n   result.having = having\n   result.field  = field\n   result.success = success\n   it.did.also(result)\n\n   return it\nend\n\n\n\n\n\n\n\n\n\n\nfunction It.equalTo(it, rValue, because)\n   local result = {}\n   local success = false\n   local last = it.did.last()\n   local having = last.having\n\n   if having == nil then\n      -- todo better message if \'has\' failed,\n      -- the more common case.\n      result.why = \"equalTo must follow have/has\"\n   else\n      success = having == rValue and true or false\n      local subj, obj\n      if not it.modal.beTrue then\n         success = not success\n         subj, obj = having, rValue\n      else\n         subj, obj = rValue, having\n      end\n      if success then\n         result.why = because or verdict(it, subj, \"==\", obj)\n       else\n         result.why = because or verdict(it, subj, \"~=\", obj)\n       end\n       result.having = having -- to chain field checks\n   end\n\n   result.success = success\n   return it.did.also(result)\nend\n\n\n\n\n\nfunction It.ofLen(it, len, because)\n   local result = {}\n   local success = false\n   local last = it.did[#it.did]\n   local having = last.having\n   if type(len) ~= \"number\" then\n      result.why = \"ofLen param must be a number\"\n   elseif not having then\n      result.why = \"ofLen must have a value on it.did\"\n   else\n      success = #having == len and true or false\n      if not it.modal.beTrue then\n         success = not success\n      end\n      if success then\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"==\", len)\n       else\n         result.why = because\n                      or verdict(it, \"#\" .. ts(having), \"~=\", len)\n       end\n   end\n\n   result.success = success\n   result.inThatIt = it.modal.inThatIt\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.nests(it, sample, because)\n   local result = { success = false,\n                    why  = \"nests is not yet implemented\"}\n    return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal function pack(...)\n   return {n = select(\'#\', ...), ...}\nend\n\nfunction It.calling(it, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   local method = last.having\n   if not method then\n      result.why = \"calling must be performed on a value\"\n   elseif not type(method) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name .. \" field must be function: \" .. last.field)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = method(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.field  = last.field\n      local callee = ts(last.field, \"field\") .. \"(\"\n      if result.arg and result.arg.n >= 1 then\n         for i = 1, result.arg.n do\n            callee = callee .. ts(result.arg[i]) .. \", \"\n         end\n         callee = string.sub(callee, 1, -3)\n      end\n      callee = callee .. \")\"\n      result.why    = verdict(it, \"\", \"be callable with\", callee)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction It.passedTo(it, fn, ...)\n   local success = false\n   local result = {}\n   local last = it.did[#it.did]\n   if not type(fn) == \'function\' then\n      -- #todo add a check for callable tables\n      result.why = verdict(it.name\n                   .. \" passedTo needs a function: \" .. fn)\n   else\n      success = true\n      result.arg = pack(...)\n      local b, c, d, e\n      result.answer, b, c, d, e = fn(it.subject, ...)\n      if b then\n         result.b, result.c, result.d, result.e = b, c, d, e\n      end\n      result.fn     = fn\n      result.why    = verdict(it, \"\", \"be passed to\", fn)\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n   result.success = success\n\n   return it.did.also(result)\nend\n\n\n\n\n\n\n\n\n\n\n\nfunction It.gives(it, rValue, b, c, d, e, f)\n   local success = false\n   local result = {}\n   local last = it.did.last()\n   local answer = last.answer\n   if answer == nil then\n      result.why = \"prior clause must provide an answer\"\n   else\n      -- build strings for verdict\n      local callee = \":anon:\"\n      if last.field then\n         callee = it.name .. ts(\":\" ..last.field, \"field\")\n      elseif last.fn then\n         callee = ts(last.fn)\n      end\n      local param = \"(\"\n      if last.fn then\n         param = param .. it.name\n      end\n      if last.arg and last.arg.n >= 1 then\n         if last.fn then param = param .. \", \" end\n         for i = 1, last.arg.n do\n            param = param .. ts(last.arg[i]) .. \", \"\n         end\n         param = string.sub(param, 1, -3)\n      end\n      param = param .. \")\"\n\n      local isSame = answer == rValue and true or false\n      if isSame then\n         if not last.b then\n            success = true\n            result.why = verdict(it, callee .. param, \"give\", ts(answer))\n         elseif b then\n            local gives = {ts(answer)}\n            local is_b_same  = last.b == b and true or false\n            gives[2] = ts(last.b)\n            success = true and is_b_same\n            result.why = vertict(it, callee .. param, \"give\", gives[1]\n                         .. \" \" .. gives[2])\n         end\n      else\n         result.why = it.name .. \":\" .. callee .. param .. \" \"\n                      .. it.modal.inThatIt .. \" give \" .. ts(rValue)\n                      .. \" not \" .. ts(answer)\n      end\n   end\n   if not it.modal.beTrue then\n      success = not success\n   end\n\n   result.success = success\n\n\n   return it.did.also(result)\nend\n\nIt.give = It.gives\nIt.giving = It.gives\n\n\n\n\n\n\n\n\n\nfunction It.calledWith(it, field, ...)\n   return it:has(field):calling(...)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function digestLine(did, mood)\n   local phrase = \"\"\n   local Yes, No\n   if mood == \"must\" or mood == \"mustn\'t\" then\n      Yes, No = \"✅   \",  \"❌   \"\n   elseif mood == \"should\" or mood == \"shouldn\'t\" then\n      Yes, No = \"🌟   \",  \"😡   \"\n   elseif mood == \"can\" or mood == \"could\" then\n      Yes, No = \"👍   \",  \"👎   \"\n   end\n   if did.success then\n      phrase = phrase .. \"   \" .. Yes .. did.why\n   else\n      phrase = phrase .. \"   \" .. No .. did.why\n   end\n   phrase = phrase .. \"\\n\"\n   did.digest = phrase\n   return phrase\nend\n\n\n\n\nfunction It.collate(it)\n   local winning = true\n   local wins = {must = 0, should = 0, can = 0, will = 0, shall = 0}\n   local musts, shoulds, cans, wills, shalls = 0, 0, 0, 0, 0\n   local phrase = it.name .. \":\\n\"\n   for _, did in ipairs(it.did) do\n      winning = winning and did.success\n      local mood = did.modal.inThatIt\n      local digest = digestLine(did, mood)\n      phrase = phrase .. digest\n\n      if mood == \"must\" or mood == \"mustn\'t\" then\n         musts = musts + 1\n         if did.success then\n            wins.must = wins.must + 1\n         end\n      elseif mood == \"should\" or mood == \"shouldn\'t\" then\n         shoulds = shoulds + 1\n         if did.success then\n            wins.should = wins.should + 1\n         end\n      end\n   -- etc\n   end\n   if musts > 0 then\n      phrase = phrase .. wins.must .. \"/\" .. musts .. \" musts\\n\"\n   end\n   if shoulds > 0 then\n      phrase = phrase .. wins.should .. \"/\" .. shoulds .. \" shoulds\\n\"\n   end\n   it.won = winning\n   if it.won then\n      phrase = \"All clear!\\n\" .. phrase\n   else\n      phrase = \"Needs work:\\n\" .. phrase\n   end\n   phrase = phrase .. \"\\n\"\n   it.digest = phrase\n\n   return it\nend\n\n\n\nfunction It.report(it)\n   it = it:collate()\n   io.write(it.digest)\n   return it\nend\n\n\n\n\n\n\n\n\nfunction It.fin(it)\n   It[#It + 1] = it\n   return it\nend\n\n\n\n\n\n\nfunction It.allReports(it)\n   local winning = true\n   if not rawget(_G, \"_Bridge\") then\n      for _, that in ipairs(It) do\n         that:report()\n         winning = winning and that.won\n      end\n      return it, winning\n   else\n      local digests = {}\n      for _, that in ipairs(It) do\n         that:collate()\n         table.insert(digests, that)\n      end\n      return digests\n   end\nend\n\nfunction It.allFailure(it)\n   for _, that in ipairs(It) do\n      that:check()\n      for _, did in ipairs(that.did) do\n         if not did.success then\n            io.write(did.digest)\n         end\n      end\n   end\n   return it\nend\n\n\n\nreturn check\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons/phrase",
hash = "c6f263a32fbe4c84b3837235bd7ca659a38f507ba4786455ad1487a11bf37e47",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal s = require \"status:status\" ()\ns.angry = false\n\n\n\n\n\n\nlocal Phrase = {}\nPhrase.__index = Phrase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal insert = assert(table.insert)\nlocal function spill(phrase)\n   local new_phrase = setmetatable({}, getmetatable(phrase))\n   for k, v in pairs(phrase) do\n      new_phrase[k] = v\n   end\n   new_phrase.interned = nil\n\n   return new_phrase\nend\n\n\nfunction Phrase.__concat(head_phrase, tail_phrase)\n   if type(head_phrase) == \'string\' then\n      -- bump the tail phrase accordingly\n      if tail_phrase.interned then\n         tail_phrase = spill(tail_phrase)\n      end\n\n      insert(tail_phrase, 1, head_phrase)\n      tail_phrase.len = tail_phrase.len + #head_phrase\n      return tail_phrase\n   end\n   local typica = type(tail_phrase)\n   if typica == \"string\" then\n      if head_phrase.interned then\n         head_phrase = spill(head_phrase)\n      end\n      insert(head_phrase, tail_phrase)\n      head_phrase.len = head_phrase.len + #tail_phrase\n      return head_phrase\n   elseif typica == \"table\" and tail_phrase.idEst == Phrase then\n      local new_phrase = setmetatable({}, getmetatable(head_phrase))\n      head_phrase.interned = true -- head_phrase is now in the middle of a string\n      tail_phrase.interned = true -- tail_phrase shouldn\'t be bump-catted\n      new_phrase[1] = head_phrase\n      new_phrase[2] = tail_phrase\n      new_phrase.len = head_phrase.len + tail_phrase.len\n      return new_phrase\n   end\n\n   return nil, \"tail phrase was unsuitable for concatenation\"\nend\n\n\n\n\n\n\n\n\nlocal function _gather_pieces(phrase, pieces)\n   pieces = pieces or {}\n   for _, v in ipairs(phrase) do\n      if type(v) == \"string\" then\n         insert(pieces, v)\n      else\n         _gather_pieces(v, pieces)\n      end\n   end\n   return pieces\nend\n\nfunction Phrase.__tostring(phrase)\n   return table.concat(_gather_pieces(phrase))\nend\n\n\n\n\n\n\n\nPhrase.toString = Phrase.__tostring\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__len(phrase)\n   return phrase.len\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.__eq(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head == tail\nend\n\n\n\nfunction Phrase.__lt(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head < tail\nend\n\n\n\nfunction Phrase.__lte(head, tail)\n   head = tostring(head)\n   tail = tostring(tail)\n   return head <= tail\nend\n\n\n\n\n\n\n\n\n\nfunction Phrase.__repr(phrase)\n   return tostring(phrase)\nend\n\n\n\n\n\nfunction Phrase.__call(phrase, phrase_seed)\n   phrase_seed = phrase_seed or \"\"\n   local _PhraseM = getmetatable(phrase)\n   local new_phrase = {}\n   if type(phrase_seed) == \"string\" then\n      new_phrase[1] = phrase_seed\n      new_phrase.len = #phrase_seed\n   else\n      error \"bad argument #2 to Phrase, expected string\"\n   end\n   return setmetatable(new_phrase, _PhraseM)\nend\n\n\n\n\n\n\n\n\n\n\nfunction Phrase.intern(phrase)\n   phrase.interned = true\n   return phrase\nend\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nfunction Phrase.inherit(phrase, cfg)\n   local Phrase_M = getmetatable(phrase)\n   local phrase_child = setmetatable({}, Phrase_M)\n   ---[[\n   for k,v in pairs(Phrase_M) do\n      if sub(k, 1, 2) == \"__\" then\n         phrase_child[k] = v\n      end\n   end\n   phrase_child.__index = phrase_child\n   if cfg then\n      -- this can override the above metamethod assignment\n      for k,v in pairs(cfg) do\n         phrase_child[k] = v\n      end\n   end\n   return setmetatable({}, phrase_child)\n   --]]\nend\n\n\n\n\n\nPhrase.idEst = Phrase\n\n\n\nreturn setmetatable({}, Phrase)\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons/stator",
hash = "0ffd0f68228d27dae4a962f367981b6fc07829a9b319af29472e42ce8c4b8e62",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal setmeta = assert(setmetatable)\n\n\n\nlocal Stator = meta {}\n\n\n\n\n\n\n\n\n-- local _weakstate = setmeta({}, {__mode = \'v\'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function call(stator, _weakstate)\n   local _weakstate = _weakstate or setmeta({}, {__mode = \'v\'})\n   local _M = setmeta({}, {__index = stator, __call = call })\n   _M._weakstate =  _weakstate\n   return _M\nend\n\n\n\n\n\n\n\n\n\nlocal function new(Stator, _weakstate)\n   local stator = call(Stator, _weakstate)\n   stator.g, stator.G, stator._G = stator, stator, stator\n   return stator\nend\n\n\n\n\nreturn setmetatable(Stator, {__call = new})\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "singletons",
hash = "fcf6ada640c11837daf53f562ae1ec0780c910bdad6b7c3b204c72b3e01b83f4",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function meta(MT, tab)\n   tab = tab or {}\n   if MT and MT.__index then\n      -- inherit\n      return setmetatable(tab, MT)\n   elseif MT then\n      -- decorate\n      MT.__index = MT\n      return MT\n   else\n      -- new metatable\n      local _M = tab\n      _M.__index = _M\n      return _M\n   end\nend\n\n\n\n\n\n\nlocal S = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.color = require \"singletons/color\"\n\n\n\n\n\n\n\n\nS.codepoints = require \"singletons/codepoints\"\nS.Codepoints = S.codepoints\n\n\n\n\n\nS.phrase = require \"singletons/phrase\"\nS.Phrase = S.phrase\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.check = require \"singletons/check\"\nS.It = S.check\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction S.new(tab)\n   new_singleton = tab or {}\n   return meta(new_singleton, S)\nend\n\n\n\n\n\n\nreturn S\n\n",
},
  { 
vc_hash = "4842e226a949d64851e5def0fea320a1b59fc093",
name = "init",
hash = "\n\n\n\n\n\nreturn require \"singletons\"\n\n",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\nreturn require \"singletons\"\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/status.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/status.git",
    home = "",
    website = "",
    name = "status",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "6c63424fdf1866f281a15ac3e06bba7ed23a3732",
name = "status",
hash = "7634d5da0200cbcc83338e1be049cc873117d189c664e0302013c9f93c3a1952",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_Bridge.status_on = true\n\n\n\n\n\n\n\n\nlocal Set = require \"set:set\"\nlocal format = assert(string.format)\n\n\n\n\n\n\n\n\nlocal Status = {}\nStatus.__index = Status\n\n\n\n\n\n\nStatus.idEst = Status\n\n\n\n\n\n\n\n\n\nStatus[1] = io.stdout\nStatus[2] = io.stderr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.Grumpy  = nil\nStatus.Angry   = nil\nStatus.Chatty  = nil\nStatus.Verbose = nil\nStatus.Boring  = nil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.grumpy  = true\nStatus.angry   = false\nStatus.chatty  = true\nStatus.verbose = false\nStatus.boring  = false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus.print = not _Bridge.helm\nStatus.log   = false\nStatus.helm = _Bridge.helm and true or false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _silent()\n   return\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function _log(statusQuo, message)\n   if statusQuo.print or rawget(statusQuo, 1) then\n      statusQuo[1]:write(message .. \"\\n\")\n   end\n   if statusQuo.log then\n      -- log to database\n   end\n   if statusQuo.tail then\n      -- append to file\n   end\n   if statusQuo.helm then\n      -- add to in-memory status \"file\"\n   end\nend\n\n\n\nlocal function _errlog(statusQuo, message, should_print)\n   if (statusQuo.print or rawget(statusQuo, 1)) and should_print then\n      statusQuo[2]:write(message .. \"\\n\")\n   end\n   if statusQuo.log then\n      -- log to database\n   end\n   if statusQuo.tail then\n      -- append to file\n   end\n   if statusQuo.helm then\n      -- add to in-memory status \"file\"\n   end\nend\n\n\n\n\n\n\n\n\n\n\nfunction Status.halt(statusQuo, message, ...)\n   local msg = select(\"#\", ...) == 0 and message or format(message, ...)\n   _errlog(statusQuo, msg, false)\n   error(msg, 2)\nend\n\n\n\n\n\n\nfunction Status.complain(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   local msg = select(\"#\", ...) == 0 and message or format(message, ...)\n   _errlog(statusQuo, msg, (not statusQuo.angry))\n   if statusQuo.angry then\n      error(msg, 2)\n   end\nend\n\n\n\n\n\n\nfunction Status.warn(statusQuo, message, ...)\n   if not statusQuo.grumpy then return end\n   local msg = select(\"#\", ...) == 0 and message or format(message, ...)\n   _errlog(statusQuo, msg, true)\nend\n\n\n\n\n\n\nfunction Status.chat(statusQuo, message, ...)\n   if not statusQuo.chatty then return end\n   local msg = select(\"#\", ...) == 0 and message or format(message, ...)\n   _log(statusQuo, msg)\nend\n\n\n\n\n\n\nfunction Status.verb(statusQuo, message, ...)\n   if not statusQuo.verbose then return end\n   local msg = select(\"#\", ...) == 0 and message or format(message, ...)\n   _log(statusQuo, msg)\nend\n\n\n\n\n\n\nfunction Status.bore(statusQuo, message, ...)\n   if not statusQuo.boring then return end\n   _log(format(message, ...))\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Moods = Set {\'Angry\', \'Grumpy\', \'Chatty\', \'Verbose\', \'Boring\'}\nlocal moods = Set {\'angry\', \'grumpy\', \'chatty\', \'verbose\', \'boring\'}\n\n\n\n\n\n\nlocal verbs = Set {\'halt\', \'complain\', \'chat\', \'verb\', \'bore\', \'warn\'}\n\n\n\n\n\n\n\n\nlocal upper, sub = assert(string.upper), assert(string.sub)\n\nlocal function status__newindex(statusQuo, key, value)\n   if Moods:∈(key) then\n      error(\"Cannot assign capital Mood \" .. key .. \" to instance of status\")\n   end\n   local Mood = upper(sub(key, 1, 1)) .. sub(key, 2)\n   if Status[Mood] ~= nil then return end\n   assert(type(value) == \'boolean\',\n          \"fields on status instance must be true or false\")\n   if moods:∈(key) then\n      rawset(statusQuo, key, value)\n      if key == \'boring\' and value == true then\n         rawset(statusQuo, \'verbose\', true)\n      end\n      return\n   end\n   error (key .. \" is an invalid field to assign to a status instance\")\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal status_M = { __index = Status,\n                   __newindex = status__newindex }\nlocal function Status__call(statusQuo, stdout, stderr)\n   return setmetatable({stdout, stderr}, status_M)\nend\n\n\n\n\n\n\n-- \'tail\' and \'silent\' are handled with custom code\nlocal modes = Set {\'print\', \'log\', \'helm\'}\n\n\n\nlocal lower = assert(string.lower)\n\nlocal function Status__newindex(statusQuo, key, value)\n   if key == \'silent\' then\n      -- stub out all functions\n      for key in pairs(verbs) do\n         Status[key] = _silent\n      end\n   elseif key == \'tail\' then\n      -- reassign [1] and [2]\n   elseif modes:∈(key) then\n      assert(type(value) == \'boolean\', \"Modes must be set true or false\")\n      rawset(Status, key, value)\n   elseif Moods:∈(key) then\n      assert(type(value) == \'boolean\', \"Moods must be set true or false\")\n      rawset(Status, key, value)\n      rawset(Status, lower(key), value)\n      if key == \'Boring\' and value == true then\n         rawset(Status, \'Verbose\', true)\n         rawset(Status, \'verbose\', true)\n      end\n   else\n      error(\"Cannot assign key \" .. key\n            .. \" to Status, with value \" .. tostring(value))\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Status.close(status)\n   return\nend\n\n\n\nreturn setmetatable(Status, { __newindex = Status__newindex,\n                              __call     = Status__call })\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/util.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/util.git",
    home = "",
    website = "",
    name = "util",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "d31dea4de2be9c05523e1400add66ca6ba91a3fd",
name = "sha",
hash = "7f3a580ba8d9251a1b62cc93a536f24b302f97584d9a52b7e4386cf167b85f44",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n--------------------------------------------------------------------------------------------------------------------------\n-- sha2.lua\n--------------------------------------------------------------------------------------------------------------------------\n-- VERSION: 8 (2019-09-03)\n-- AUTHOR:  Egor Skriptunoff\n-- LICENSE: MIT (the same license as Lua itself)\n--\n--\n-- DESCRIPTION:\n--    This module contains functions to calculate SHA digest:\n--       MD5, SHA-1,\n--       SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,\n--       SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,\n--       HMAC\n--    Written in pure Lua.\n--    Compatible with:\n--       Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).\n--    Main feature of this module: it was heavily optimized for speed.\n--    For every Lua version the module contains particular implementation branch to get benefits from version-specific features.\n--       - branch for Lua 5.1 (emulating bitwise operators using look-up table)\n--       - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"\n--       - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)\n--       - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT\n--       - branch for LuaJIT without FFI library (useful in a sandboxed environment)\n--       - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)\n--       - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)\n--       - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n--\n--\n-- USAGE:\n--    Input data should be provided as a binary string: either as a whole string or as a sequence of substrings (chunk-by-chunk loading, total length < 9*10^15 bytes).\n--    Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.\n--    Simplest usage example:\n--       local sha = require(\"sha2\")\n--       local your_hash = sha.sha256(\"your string\")\n--    See file \"sha2_test.lua\" for more examples.\n--\n--\n-- CHANGELOG:\n--  version     date      description\n--  -------  ----------   -----------\n--     8     2019-09-03   SHA3 functions added\n--     7     2019-03-17   Added functions to convert to/from base64\n--     6     2018-11-12   HMAC added\n--     5     2018-11-10   SHA-1 added\n--     4     2018-11-03   MD5 added\n--     3     2018-11-02   Bug fixed: incorrect hashing of long (2 GByte) data streams on Lua 5.3/5.4 built with \"int32\" integers\n--     2     2018-10-07   Decreased module loading time in Lua 5.1 implementation branch (thanks to Peter Melnichenko for giving a hint)\n--     1     2018-10-06   First release (only SHA-2 functions)\n-----------------------------------------------------------------------------\n\nlocal print_debug_messages = false  -- set to true to view some messages about your system\'s abilities and implementation branch chosen for your system\n\nlocal unpack, table_concat, byte, char, string_rep, sub, gsub, gmatch, string_format, floor, ceil, math_min, math_max, tonumber, type =\n   table.unpack or unpack, table.concat, string.byte, string.char, string.rep, string.sub, string.gsub, string.gmatch, string.format, math.floor, math.ceil, math.min, math.max, tonumber, type\n\n\n--------------------------------------------------------------------------------\n-- EXAMINING YOUR SYSTEM\n--------------------------------------------------------------------------------\n\nlocal function get_precision(one)\n   -- \"one\" must be either float 1.0 or integer 1\n   -- returns bits_precision, is_integer\n   -- This function works correctly with all floating point datatypes (including non-IEEE-754)\n   local k, n, m, prev_n = 0, one, one\n   while true do\n      k, prev_n, n, m = k + 1, n, n + n + 1, m + m + k % 2\n      if k > 256 or n - (n - 1) ~= 1 or m - (m - 1) ~= 1 or n == m then\n         return k, false   -- floating point datatype\n      elseif n == prev_n then\n         return k, true    -- integer datatype\n      end\n   end\nend\n\n-- Make sure Lua has \"double\" numbers\nlocal x = 2/3\nlocal Lua_has_double = x * 5 > 3 and x * 4 < 3 and get_precision(1.0) >= 53\nassert(Lua_has_double, \"at least 53-bit floating point numbers are required\")\n\n-- Q:\n--    SHA2 was designed for FPU-less machines.\n--    So, why floating point numbers are needed for this module?\n-- A:\n--    53-bit \"double\" numbers are useful to calculate \"magic numbers\" used in SHA.\n--    I prefer to write 50 LOC \"magic numbers calculator\" instead of storing more than 200 constants explicitly in this source file.\n\nlocal int_prec, Lua_has_integers = get_precision(1)\nlocal Lua_has_int64 = Lua_has_integers and int_prec == 64\nlocal Lua_has_int32 = Lua_has_integers and int_prec == 32\nassert(Lua_has_int64 or Lua_has_int32 or not Lua_has_integers, \"Lua integers must be either 32-bit or 64-bit\")\n\n-- Q:\n--    Does it mean that almost all non-standard configurations are not supported?\n-- A:\n--    Yes.  Sorry, too many problems to support all possible Lua numbers configurations.\n--       Lua 5.1/5.2    with \"int32\"               will not work.\n--       Lua 5.1/5.2    with \"int64\"               will not work.\n--       Lua 5.1/5.2    with \"int128\"              will not work.\n--       Lua 5.1/5.2    with \"float\"               will not work.\n--       Lua 5.1/5.2    with \"double\"              is OK.          (default config for Lua 5.1, Lua 5.2, LuaJIT)\n--       Lua 5.3/5.4    with \"int32\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int64\"  + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int128\" + \"float\"    will not work.\n--       Lua 5.3/5.4    with \"int32\"  + \"double\"   is OK.          (config used by Fengari)\n--       Lua 5.3/5.4    with \"int64\"  + \"double\"   is OK.          (default config for Lua 5.3, Lua 5.4)\n--       Lua 5.3/5.4    with \"int128\" + \"double\"   will not work.\n--   Using floating point numbers better than \"double\" instead of \"double\" is OK (non-IEEE-754 floating point implementation are allowed).\n--   Using \"int128\" instead of \"int64\" is not OK: \"int128\" would require different branch of implementation for optimized SHA512.\n\n-- Check for LuaJIT and 32-bit bitwise libraries\nlocal is_LuaJIT = ({false, [1] = true})[1] and (type(jit) ~= \"table\" or jit.version_num >= 20000)  -- LuaJIT 1.x.x is treated as vanilla Lua 5.1\nlocal is_LuaJIT_21  -- LuaJIT 2.1+\nlocal LuaJIT_arch\nlocal ffi           -- LuaJIT FFI library (as a table)\nlocal b             -- 32-bit bitwise library (as a table)\nlocal library_name\n\nif is_LuaJIT then\n   -- Assuming \"bit\" library is always available on LuaJIT\n   b = require\"bit\"\n   library_name = \"bit\"\n   -- \"ffi\" is intentionally disabled on some systems for safety reason\n   local LuaJIT_has_FFI, result = pcall(require, \"ffi\")\n   if LuaJIT_has_FFI then\n      ffi = result\n   end\n   is_LuaJIT_21 = not not loadstring\"b=0b0\"\n   LuaJIT_arch = type(jit) == \"table\" and jit.arch or ffi and ffi.arch or nil\nelse\n   -- For vanilla Lua, \"bit\"/\"bit32\" libraries are searched in global namespace only.  No attempt is made to load a library if it\'s not loaded yet.\n   for _, libname in ipairs(_VERSION == \"Lua 5.2\" and {\"bit32\", \"bit\"} or {\"bit\", \"bit32\"}) do\n      if type(_G[libname]) == \"table\" and _G[libname].bxor then\n         b = _G[libname]\n         library_name = libname\n         break\n      end\n   end\nend\n\n--------------------------------------------------------------------------------\n-- You can disable here some of your system\'s abilities (for testing purposes)\n--------------------------------------------------------------------------------\n-- is_LuaJIT = nil\n-- is_LuaJIT_21 = nil\n-- ffi = nil\n-- Lua_has_int32 = nil\n-- Lua_has_int64 = nil\n-- b, library_name = nil\n--------------------------------------------------------------------------------\n\nif print_debug_messages then\n   -- Printing list of abilities of your system\n   print(\"Abilities:\")\n   print(\"   Lua version:               \"..(is_LuaJIT and \"LuaJIT \"..(is_LuaJIT_21 and \"2.1 \" or \"2.0 \")..(LuaJIT_arch or \"\")..(ffi and \" with FFI\" or \" without FFI\") or _VERSION))\n   print(\"   Integer bitwise operators: \"..(Lua_has_int64 and \"int64\" or Lua_has_int32 and \"int32\" or \"no\"))\n   print(\"   32-bit bitwise library:    \"..(library_name or \"not found\"))\nend\n\n-- Selecting the most suitable implementation for given set of abilities\nlocal method, branch\nif is_LuaJIT and ffi then\n   method = \"Using \'ffi\' library of LuaJIT\"\n   branch = \"FFI\"\nelseif is_LuaJIT then\n   method = \"Using special code for FFI-less LuaJIT\"\n   branch = \"LJ\"\nelseif Lua_has_int64 then\n   method = \"Using native int64 bitwise operators\"\n   branch = \"INT64\"\nelseif Lua_has_int32 then\n   method = \"Using native int32 bitwise operators\"\n   branch = \"INT32\"\nelseif library_name then   -- when bitwise library is available (Lua 5.2 with native library \"bit32\" or Lua 5.1 with external library \"bit\")\n   method = \"Using \'\"..library_name..\"\' library\"\n   branch = \"LIB32\"\nelse\n   method = \"Emulating bitwise operators using look-up table\"\n   branch = \"EMUL\"\nend\n\nif print_debug_messages then\n   -- Printing the implementation selected to be used on your system\n   print(\"Implementation selected:\")\n   print(\"   \"..method)\nend\n\n\n--------------------------------------------------------------------------------\n-- BASIC 32-BIT BITWISE FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal AND, OR, XOR, SHL, SHR, ROL, ROR, NOT, NORM, HEX, XOR_BYTE\n-- Only low 32 bits of function arguments matter, high bits are ignored\n-- The result of all functions (except HEX) is an integer inside \"correct range\":\n--    for \"bit\" library:    (-2^31)..(2^31-1)\n--    for \"bit32\" library:        0..(2^32-1)\n\nif branch == \"FFI\" or branch == \"LJ\" or branch == \"LIB32\" then\n\n   -- Your system has 32-bit bitwise library (either \"bit\" or \"bit32\")\n\n   AND  = b.band                -- 2 arguments\n   OR   = b.bor                 -- 2 arguments\n   XOR  = b.bxor                -- 2..5 arguments\n   SHL  = b.lshift              -- second argument is integer 0..31\n   SHR  = b.rshift              -- second argument is integer 0..31\n   ROL  = b.rol or b.lrotate    -- second argument is integer 0..31\n   ROR  = b.ror or b.rrotate    -- second argument is integer 0..31\n   NOT  = b.bnot                -- only for LuaJIT\n   NORM = b.tobit               -- only for LuaJIT\n   HEX  = b.tohex               -- returns string of 8 lowercase hexadecimal digits\n   assert(AND and OR and XOR and SHL and SHR and ROL and ROR and NOT, \"Library \'\"..library_name..\"\' is incomplete\")\n   XOR_BYTE = XOR               -- XOR of two bytes (0..255)\n\nelseif branch == \"EMUL\" then\n\n   -- Emulating 32-bit bitwise operations using 53-bit floating point arithmetic\n\n   function SHL(x, n)\n      return (x * 2^n) % 2^32\n   end\n\n   function SHR(x, n)\n      -- return (x % 2^32 - x % 2^n) / 2^n\n      x = x % 2^32 / 2^n\n      return x - x % 1\n   end\n\n   function ROL(x, n)\n      x = x % 2^32 * 2^n\n      local r = x % 2^32\n      return r + (x - r) / 2^32\n   end\n\n   function ROR(x, n)\n      x = x % 2^32 / 2^n\n      local r = x % 1\n      return r * 2^32 + (x - r)\n   end\n\n   local AND_of_two_bytes = {[0] = 0}  -- look-up table (256*256 entries)\n   local idx = 0\n   for y = 0, 127 * 256, 256 do\n      for x = y, y + 127 do\n         x = AND_of_two_bytes[x] * 2\n         AND_of_two_bytes[idx] = x\n         AND_of_two_bytes[idx + 1] = x\n         AND_of_two_bytes[idx + 256] = x\n         AND_of_two_bytes[idx + 257] = x + 1\n         idx = idx + 2\n      end\n      idx = idx + 256\n   end\n\n   local function and_or_xor(x, y, operation)\n      -- operation: nil = AND, 1 = OR, 2 = XOR\n      local x0 = x % 2^32\n      local y0 = y % 2^32\n      local rx = x0 % 256\n      local ry = y0 % 256\n      local res = AND_of_two_bytes[rx + ry * 256]\n      x = x0 - rx\n      y = (y0 - ry) / 256\n      rx = x % 65536\n      ry = y % 256\n      res = res + AND_of_two_bytes[rx + ry] * 256\n      x = (x - rx) / 256\n      y = (y - ry) / 256\n      rx = x % 65536 + y % 256\n      res = res + AND_of_two_bytes[rx] * 65536\n      res = res + AND_of_two_bytes[(x + y - rx) / 256] * 16777216\n      if operation then\n         res = x0 + y0 - operation * res\n      end\n      return res\n   end\n\n   function AND(x, y)\n      return and_or_xor(x, y)\n   end\n\n   function OR(x, y)\n      return and_or_xor(x, y, 1)\n   end\n\n   function XOR(x, y, z, t, u)          -- 2..5 arguments\n      if z then\n         if t then\n            if u then\n               t = and_or_xor(t, u, 2)\n            end\n            z = and_or_xor(z, t, 2)\n         end\n         y = and_or_xor(y, z, 2)\n      end\n      return and_or_xor(x, y, 2)\n   end\n\n   function XOR_BYTE(x, y)\n      return x + y - 2 * AND_of_two_bytes[x + y * 256]\n   end\n\nend\n\nHEX = HEX or\n   function (x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x % 4294967296)\n   end\n\nlocal function XOR32A5(x)\n   return XOR(x, 0xA5A5A5A5) % 4294967296\nend\n\nlocal function create_array_of_lanes()\n   return {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\n\n--------------------------------------------------------------------------------\n-- CREATING OPTIMIZED INNER LOOP\n--------------------------------------------------------------------------------\n\n-- Inner loop functions\nlocal sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n\n-- Arrays of SHA2 \"magic numbers\" (in \"INT64\" and \"FFI\" branches \"*_lo\" arrays contain 64-bit values)\nlocal sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}\nlocal sha2_H_ext256 = {[224] = {}, [256] = sha2_H_hi}\nlocal sha2_H_ext512_lo, sha2_H_ext512_hi = {[384] = {}, [512] = sha2_H_lo}, {[384] = {}, [512] = sha2_H_hi}\nlocal md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}\nlocal md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}\nlocal HEX64, XOR64A5, lanes_index_base  -- defined only for branches that internally use 64-bit integers: \"INT64\" and \"FFI\"\nlocal common_W = {}    -- temporary table shared between all calculations (to avoid creating new temporary table every time)\nlocal K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0\n\nlocal function build_keccak_format(elem)\n   local keccak_format = {}\n   for _, size in ipairs{1, 9, 13, 17, 18, 21} do\n      keccak_format[size] = \"<\"..string_rep(elem, size)\n   end\n   return keccak_format\nend\n\n\nif branch == \"FFI\" then\n\n\n   -- SHA256 implementation for \"LuaJIT with FFI\" branch\n\n   local common_W_FFI_int32 = ffi.new\"int32_t[80]\"   -- 64 is enough for SHA256, but 80 is needed for SHA-1\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 63 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16] )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 0, 63, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j] + K[j+1] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+1] + K[j+2] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+2] + K[j+3] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+3] + K[j+4] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+4] + K[j+5] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+5] + K[j+6] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+6] + K[j+7] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(g, AND(e, XOR(f, g))) + XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + (W[j+7] + K[j+8] + h) )\n            h, g, f, e = g, f, e, NORM( d + z )\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local common_W_FFI_int64 = ffi.new\"int64_t[80]\"\n   local int64 = ffi.typeof\"int64_t\"\n   local int32 = ffi.typeof\"int32_t\"\n   local uint32 = ffi.typeof\"uint32_t\"\n\n   hi_factor = int64(2^32)\n\n   if is_LuaJIT_21 then   -- LuaJIT 2.1 supports bitwise 64-bit operations\n\n      local AND64, OR64, XOR64, NOT64, SHL64, SHR64, ROL64, ROR64  -- introducing synonyms for better code readability\n          = AND,   OR,   XOR,   NOT,   SHL,   SHR,   ROL,   ROR\n      HEX64 = HEX\n\n\n      -- SHA3 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local lanes_arr64 = ffi.typeof\"int64_t[30]\"  -- 25 + 5 for temporary usage\n      -- lanes array is indexed from 0\n      lanes_index_base = 0\n      hi_factor_keccak = int64(2^32)\n\n      function create_array_of_lanes()\n         return lanes_arr64()\n      end\n\n      function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = SHR(block_size_in_bytes, 3)\n         for pos = offs, offs + size - 1, block_size_in_bytes do\n            for j = 0, qwords_qty - 1 do\n               pos = pos + 8\n               local h, g, f, e, d, c, b, a = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               lanes[j] = XOR64(lanes[j], OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))))\n            end\n            for round_idx = 1, 24 do\n               for j = 0, 4 do\n                  lanes[25 + j] = XOR64(lanes[j], lanes[j+5], lanes[j+10], lanes[j+15], lanes[j+20])\n               end\n               local D = XOR64(lanes[25], ROL64(lanes[27], 1))\n               lanes[1], lanes[6], lanes[11], lanes[16] = ROL64(XOR64(D, lanes[6]), 44), ROL64(XOR64(D, lanes[16]), 45), ROL64(XOR64(D, lanes[1]), 1), ROL64(XOR64(D, lanes[11]), 10)\n               lanes[21] = ROL64(XOR64(D, lanes[21]), 2)\n               D = XOR64(lanes[26], ROL64(lanes[28], 1))\n               lanes[2], lanes[7], lanes[12], lanes[22] = ROL64(XOR64(D, lanes[12]), 43), ROL64(XOR64(D, lanes[22]), 61), ROL64(XOR64(D, lanes[7]), 6), ROL64(XOR64(D, lanes[2]), 62)\n               lanes[17] = ROL64(XOR64(D, lanes[17]), 15)\n               D = XOR64(lanes[27], ROL64(lanes[29], 1))\n               lanes[3], lanes[8], lanes[18], lanes[23] = ROL64(XOR64(D, lanes[18]), 21), ROL64(XOR64(D, lanes[3]), 28), ROL64(XOR64(D, lanes[23]), 56), ROL64(XOR64(D, lanes[8]), 55)\n               lanes[13] = ROL64(XOR64(D, lanes[13]), 25)\n               D = XOR64(lanes[28], ROL64(lanes[25], 1))\n               lanes[4], lanes[14], lanes[19], lanes[24] = ROL64(XOR64(D, lanes[24]), 14), ROL64(XOR64(D, lanes[19]), 8), ROL64(XOR64(D, lanes[4]), 27), ROL64(XOR64(D, lanes[14]), 39)\n               lanes[9] = ROL64(XOR64(D, lanes[9]), 20)\n               D = XOR64(lanes[29], ROL64(lanes[26], 1))\n               lanes[5], lanes[10], lanes[15], lanes[20] = ROL64(XOR64(D, lanes[10]), 3), ROL64(XOR64(D, lanes[20]), 18), ROL64(XOR64(D, lanes[5]), 36), ROL64(XOR64(D, lanes[15]), 41)\n               lanes[0] = XOR64(D, lanes[0])\n               lanes[0], lanes[1], lanes[2], lanes[3], lanes[4] = XOR64(lanes[0], AND64(NOT64(lanes[1]), lanes[2]), RC[round_idx]), XOR64(lanes[1], AND64(NOT64(lanes[2]), lanes[3])), XOR64(lanes[2], AND64(NOT64(lanes[3]), lanes[4])), XOR64(lanes[3], AND64(NOT64(lanes[4]), lanes[0])), XOR64(lanes[4], AND64(NOT64(lanes[0]), lanes[1]))\n               lanes[5], lanes[6], lanes[7], lanes[8], lanes[9] = XOR64(lanes[8], AND64(NOT64(lanes[9]), lanes[5])), XOR64(lanes[9], AND64(NOT64(lanes[5]), lanes[6])), XOR64(lanes[5], AND64(NOT64(lanes[6]), lanes[7])), XOR64(lanes[6], AND64(NOT64(lanes[7]), lanes[8])), XOR64(lanes[7], AND64(NOT64(lanes[8]), lanes[9]))\n               lanes[10], lanes[11], lanes[12], lanes[13], lanes[14] = XOR64(lanes[11], AND64(NOT64(lanes[12]), lanes[13])), XOR64(lanes[12], AND64(NOT64(lanes[13]), lanes[14])), XOR64(lanes[13], AND64(NOT64(lanes[14]), lanes[10])), XOR64(lanes[14], AND64(NOT64(lanes[10]), lanes[11])), XOR64(lanes[10], AND64(NOT64(lanes[11]), lanes[12]))\n               lanes[15], lanes[16], lanes[17], lanes[18], lanes[19] = XOR64(lanes[19], AND64(NOT64(lanes[15]), lanes[16])), XOR64(lanes[15], AND64(NOT64(lanes[16]), lanes[17])), XOR64(lanes[16], AND64(NOT64(lanes[17]), lanes[18])), XOR64(lanes[17], AND64(NOT64(lanes[18]), lanes[19])), XOR64(lanes[18], AND64(NOT64(lanes[19]), lanes[15]))\n               lanes[20], lanes[21], lanes[22], lanes[23], lanes[24] = XOR64(lanes[22], AND64(NOT64(lanes[23]), lanes[24])), XOR64(lanes[23], AND64(NOT64(lanes[24]), lanes[20])), XOR64(lanes[24], AND64(NOT64(lanes[20]), lanes[21])), XOR64(lanes[20], AND64(NOT64(lanes[21]), lanes[22])), XOR64(lanes[21], AND64(NOT64(lanes[22]), lanes[23]))\n            end\n         end\n      end\n\n\n      -- SHA512 implementation for \"LuaJIT 2.1 + FFI\" branch\n\n      local A5_long = 0xA5A5A5A5 * int64(2^32 + 1)  -- It\'s impossible to use constant 0xA5A5A5A5A5A5A5A5LL because it will raise syntax error on other Lua versions\n\n      function XOR64A5(long)\n         return XOR64(long, A5_long)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR64(OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32), uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h))))\n            end\n            for j = 16, 79 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7)) + XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6)) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n               z = XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23)) + XOR64(g, AND64(e, XOR64(f, g))) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XOR64(AND64(XOR64(a, b), c), AND64(a, b)) + XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30)) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   else  -- LuaJIT 2.0 doesn\'t support 64-bit bitwise operations\n\n\n      -- SHA512 implementation for \"LuaJIT 2.0 + FFI\" branch\n\n      local union64 = ffi.typeof\"union{int64_t i64; struct{int32_t lo, hi;} i32;}\"\n      do  -- make sure the struct is endianness-compatible\n         local u = union64(1)\n         if u.i32.lo < u.i32.hi then\n            union64 = ffi.typeof\"union{int64_t i64; struct{int32_t hi, lo;} i32;}\"\n         end\n      end\n      local unions64 = ffi.typeof(\"$[?]\", union64)\n      local U = unions64(3)   -- this array of unions is used for fast splitting int64 into int32_high and int32_low\n\n      -- \"xorrific\" 64-bit functions :-)\n      -- int64 input is splitted into two int32 parts, some bitwise 32-bit operations are performed, finally the result is converted to int64\n      -- these functions are needed because bit.* functions in LuaJIT 2.0 don\'t work with int64_t\n\n      local function XORROR64_1(a)\n         -- return XOR64(ROR64(a, 1), ROR64(a, 8), SHR64(a, 7))\n         U[0].i64 = a\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n         local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n         return t_hi * int64(2^32) + uint32(int32(t_lo))\n      end\n\n      local function XORROR64_2(b)\n         -- return XOR64(ROR64(b, 19), ROL64(b, 3), SHR64(b, 6))\n         U[0].i64 = b\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n         local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_3(e)\n         -- return XOR64(ROR64(e, 14), ROR64(e, 18), ROL64(e, 23))\n         U[0].i64 = e\n         local e_lo, e_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n         local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_6(a)\n         -- return XOR64(ROR64(a, 28), ROL64(a, 25), ROL64(a, 30))\n         U[0].i64 = a\n         local b_lo, b_hi = U[0].i32.lo, U[0].i32.hi\n         local u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n         local u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n         return u_hi * int64(2^32) + uint32(int32(u_lo))\n      end\n\n      local function XORROR64_4(e, f, g)\n         -- return XOR64(g, AND64(e, XOR64(f, g)))\n         U[0].i64 = f\n         U[1].i64 = g\n         U[2].i64 = e\n         local f_lo, f_hi = U[0].i32.lo, U[0].i32.hi\n         local g_lo, g_hi = U[1].i32.lo, U[1].i32.hi\n         local e_lo, e_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n         local result_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      local function XORROR64_5(a, b, c)\n         -- return XOR64(AND64(XOR64(a, b), c), AND64(a, b))\n         U[0].i64 = a\n         U[1].i64 = b\n         U[2].i64 = c\n         local a_lo, a_hi = U[0].i32.lo, U[0].i32.hi\n         local b_lo, b_hi = U[1].i32.lo, U[1].i32.hi\n         local c_lo, c_hi = U[2].i32.lo, U[2].i32.hi\n         local result_lo = XOR(AND(XOR(a_lo, b_lo), c_lo), AND(a_lo, b_lo))\n         local result_hi = XOR(AND(XOR(a_hi, b_hi), c_hi), AND(a_hi, b_hi))\n         return result_hi * int64(2^32) + uint32(int32(result_lo))\n      end\n\n      function XOR64A5(long)\n         -- return XOR64(long, 0xA5A5A5A5A5A5A5A5)\n         U[0].i64 = long\n         local lo32, hi32 = U[0].i32.lo, U[0].i32.hi\n         lo32 = XOR(lo32, 0xA5A5A5A5)\n         hi32 = XOR(hi32, 0xA5A5A5A5)\n         return hi32 * int64(2^32) + uint32(int32(lo32))\n      end\n\n      function HEX64(long)\n         U[0].i64 = long\n         return HEX(U[0].i32.hi)..HEX(U[0].i32.lo)\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W_FFI_int64, sha2_K_lo\n         for pos = offs, offs + size - 1, 128 do\n            for j = 0, 15 do\n               pos = pos + 8\n               local a, b, c, d, e, f, g, h = byte(str, pos - 7, pos)   -- slow, but doesn\'t depend on endianness\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d) * int64(2^32) + uint32(int32(OR(SHL(e, 24), SHL(f, 16), SHL(g, 8), h)))\n            end\n            for j = 16, 79 do\n               W[j] = XORROR64_1(W[j-15]) + XORROR64_2(W[j-2]) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n            for j = 0, 79, 8 do\n               local z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+1] + W[j]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+2] + W[j+1]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+3] + W[j+2]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+4] + W[j+3]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+5] + W[j+4]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+6] + W[j+5]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+7] + W[j+6]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n               z = XORROR64_3(e) + XORROR64_4(e, f, g) + h + K[j+8] + W[j+7]\n               h, g, f, e = g, f, e, z + d\n               d, c, b, a = c, b, a, XORROR64_5(a, b, c) + XORROR64_6(a) + z\n            end\n            H[1] = a + H[1]\n            H[2] = b + H[2]\n            H[3] = c + H[3]\n            H[4] = d + H[4]\n            H[5] = e + H[5]\n            H[6] = f + H[6]\n            H[7] = g + H[7]\n            H[8] = h + H[8]\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT with FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W_FFI_int32, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 0, 15, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+4] + W[j+3] + a), 22) + b)\n         end\n         for j = 16, 31, 4 do\n            local g = 5*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g + 1, 15)] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 6, 15)] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g - 5, 15)] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+4] + W[AND(g    , 15)] + a), 20) + b)\n         end\n         for j = 32, 47, 4 do\n            local g = 3*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 5, 15)] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 8, 15)] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 5, 15)] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+4] + W[AND(g - 2, 15)] + a), 23) + b)\n         end\n         for j = 48, 63, 4 do\n            local g = 7*j\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15)] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15)] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15)] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+4] + W[AND(g + 5, 15)] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT with FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W_FFI_int32\n      for pos = offs, offs + size - 1, 64 do\n         for j = 0, 15 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)   -- slow, but doesn\'t depend on endianness\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 16, 79 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 0, 19, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 20, 39, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 40, 59, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 60, 79, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\n-- SHA3 implementation for \"LuaJIT 2.0 + FFI\" and \"LuaJIT without FFI\" branches\n\nif branch == \"FFI\" and not is_LuaJIT_21 or branch == \"LJ\" then\n\n   if branch == \"FFI\" then\n      local lanes_arr32 = ffi.typeof\"int32_t[31]\"  -- 25 + 5 + 1 (due to 1-based indexing)\n\n      function create_array_of_lanes()\n         return lanes_arr32()\n      end\n\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = SHR(block_size_in_bytes, 3)\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a))\n         end\n         for round_idx = 1, 24 do\n            for j = 1, 5 do\n               lanes_lo[25 + j] = XOR(lanes_lo[j], lanes_lo[j + 5], lanes_lo[j + 10], lanes_lo[j + 15], lanes_lo[j + 20])\n            end\n            for j = 1, 5 do\n               lanes_hi[25 + j] = XOR(lanes_hi[j], lanes_hi[j + 5], lanes_hi[j + 10], lanes_hi[j + 15], lanes_hi[j + 20])\n            end\n            local D_lo = XOR(lanes_lo[26], SHL(lanes_lo[28], 1), SHR(lanes_hi[28], 31))\n            local D_hi = XOR(lanes_hi[26], SHL(lanes_hi[28], 1), SHR(lanes_lo[28], 31))\n            lanes_lo[2], lanes_hi[2], lanes_lo[7], lanes_hi[7], lanes_lo[12], lanes_hi[12], lanes_lo[17], lanes_hi[17] = XOR(SHR(XOR(D_lo, lanes_lo[7]), 20), SHL(XOR(D_hi, lanes_hi[7]), 12)), XOR(SHR(XOR(D_hi, lanes_hi[7]), 20), SHL(XOR(D_lo, lanes_lo[7]), 12)), XOR(SHR(XOR(D_lo, lanes_lo[17]), 19), SHL(XOR(D_hi, lanes_hi[17]), 13)), XOR(SHR(XOR(D_hi, lanes_hi[17]), 19), SHL(XOR(D_lo, lanes_lo[17]), 13)), XOR(SHL(XOR(D_lo, lanes_lo[2]), 1), SHR(XOR(D_hi, lanes_hi[2]), 31)), XOR(SHL(XOR(D_hi, lanes_hi[2]), 1), SHR(XOR(D_lo, lanes_lo[2]), 31)), XOR(SHL(XOR(D_lo, lanes_lo[12]), 10), SHR(XOR(D_hi, lanes_hi[12]), 22)), XOR(SHL(XOR(D_hi, lanes_hi[12]), 10), SHR(XOR(D_lo, lanes_lo[12]), 22))\n            local L, H = XOR(D_lo, lanes_lo[22]), XOR(D_hi, lanes_hi[22])\n            lanes_lo[22], lanes_hi[22] = XOR(SHL(L, 2), SHR(H, 30)), XOR(SHL(H, 2), SHR(L, 30))\n            D_lo = XOR(lanes_lo[27], SHL(lanes_lo[29], 1), SHR(lanes_hi[29], 31))\n            D_hi = XOR(lanes_hi[27], SHL(lanes_hi[29], 1), SHR(lanes_lo[29], 31))\n            lanes_lo[3], lanes_hi[3], lanes_lo[8], lanes_hi[8], lanes_lo[13], lanes_hi[13], lanes_lo[23], lanes_hi[23] = XOR(SHR(XOR(D_lo, lanes_lo[13]), 21), SHL(XOR(D_hi, lanes_hi[13]), 11)), XOR(SHR(XOR(D_hi, lanes_hi[13]), 21), SHL(XOR(D_lo, lanes_lo[13]), 11)), XOR(SHR(XOR(D_lo, lanes_lo[23]), 3), SHL(XOR(D_hi, lanes_hi[23]), 29)), XOR(SHR(XOR(D_hi, lanes_hi[23]), 3), SHL(XOR(D_lo, lanes_lo[23]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[8]), 6), SHR(XOR(D_hi, lanes_hi[8]), 26)), XOR(SHL(XOR(D_hi, lanes_hi[8]), 6), SHR(XOR(D_lo, lanes_lo[8]), 26)), XOR(SHR(XOR(D_lo, lanes_lo[3]), 2), SHL(XOR(D_hi, lanes_hi[3]), 30)), XOR(SHR(XOR(D_hi, lanes_hi[3]), 2), SHL(XOR(D_lo, lanes_lo[3]), 30))\n            L, H = XOR(D_lo, lanes_lo[18]), XOR(D_hi, lanes_hi[18])\n            lanes_lo[18], lanes_hi[18] = XOR(SHL(L, 15), SHR(H, 17)), XOR(SHL(H, 15), SHR(L, 17))\n            D_lo = XOR(lanes_lo[28], SHL(lanes_lo[30], 1), SHR(lanes_hi[30], 31))\n            D_hi = XOR(lanes_hi[28], SHL(lanes_hi[30], 1), SHR(lanes_lo[30], 31))\n            lanes_lo[4], lanes_hi[4], lanes_lo[9], lanes_hi[9], lanes_lo[19], lanes_hi[19], lanes_lo[24], lanes_hi[24] = XOR(SHL(XOR(D_lo, lanes_lo[19]), 21), SHR(XOR(D_hi, lanes_hi[19]), 11)), XOR(SHL(XOR(D_hi, lanes_hi[19]), 21), SHR(XOR(D_lo, lanes_lo[19]), 11)), XOR(SHL(XOR(D_lo, lanes_lo[4]), 28), SHR(XOR(D_hi, lanes_hi[4]), 4)), XOR(SHL(XOR(D_hi, lanes_hi[4]), 28), SHR(XOR(D_lo, lanes_lo[4]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[24]), 8), SHL(XOR(D_hi, lanes_hi[24]), 24)), XOR(SHR(XOR(D_hi, lanes_hi[24]), 8), SHL(XOR(D_lo, lanes_lo[24]), 24)), XOR(SHR(XOR(D_lo, lanes_lo[9]), 9), SHL(XOR(D_hi, lanes_hi[9]), 23)), XOR(SHR(XOR(D_hi, lanes_hi[9]), 9), SHL(XOR(D_lo, lanes_lo[9]), 23))\n            L, H = XOR(D_lo, lanes_lo[14]), XOR(D_hi, lanes_hi[14])\n            lanes_lo[14], lanes_hi[14] = XOR(SHL(L, 25), SHR(H, 7)), XOR(SHL(H, 25), SHR(L, 7))\n            D_lo = XOR(lanes_lo[29], SHL(lanes_lo[26], 1), SHR(lanes_hi[26], 31))\n            D_hi = XOR(lanes_hi[29], SHL(lanes_hi[26], 1), SHR(lanes_lo[26], 31))\n            lanes_lo[5], lanes_hi[5], lanes_lo[15], lanes_hi[15], lanes_lo[20], lanes_hi[20], lanes_lo[25], lanes_hi[25] = XOR(SHL(XOR(D_lo, lanes_lo[25]), 14), SHR(XOR(D_hi, lanes_hi[25]), 18)), XOR(SHL(XOR(D_hi, lanes_hi[25]), 14), SHR(XOR(D_lo, lanes_lo[25]), 18)), XOR(SHL(XOR(D_lo, lanes_lo[20]), 8), SHR(XOR(D_hi, lanes_hi[20]), 24)), XOR(SHL(XOR(D_hi, lanes_hi[20]), 8), SHR(XOR(D_lo, lanes_lo[20]), 24)), XOR(SHL(XOR(D_lo, lanes_lo[5]), 27), SHR(XOR(D_hi, lanes_hi[5]), 5)), XOR(SHL(XOR(D_hi, lanes_hi[5]), 27), SHR(XOR(D_lo, lanes_lo[5]), 5)), XOR(SHR(XOR(D_lo, lanes_lo[15]), 25), SHL(XOR(D_hi, lanes_hi[15]), 7)), XOR(SHR(XOR(D_hi, lanes_hi[15]), 25), SHL(XOR(D_lo, lanes_lo[15]), 7))\n            L, H = XOR(D_lo, lanes_lo[10]), XOR(D_hi, lanes_hi[10])\n            lanes_lo[10], lanes_hi[10] = XOR(SHL(L, 20), SHR(H, 12)), XOR(SHL(H, 20), SHR(L, 12))\n            D_lo = XOR(lanes_lo[30], SHL(lanes_lo[27], 1), SHR(lanes_hi[27], 31))\n            D_hi = XOR(lanes_hi[30], SHL(lanes_hi[27], 1), SHR(lanes_lo[27], 31))\n            lanes_lo[6], lanes_hi[6], lanes_lo[11], lanes_hi[11], lanes_lo[16], lanes_hi[16], lanes_lo[21], lanes_hi[21] = XOR(SHL(XOR(D_lo, lanes_lo[11]), 3), SHR(XOR(D_hi, lanes_hi[11]), 29)), XOR(SHL(XOR(D_hi, lanes_hi[11]), 3), SHR(XOR(D_lo, lanes_lo[11]), 29)), XOR(SHL(XOR(D_lo, lanes_lo[21]), 18), SHR(XOR(D_hi, lanes_hi[21]), 14)), XOR(SHL(XOR(D_hi, lanes_hi[21]), 18), SHR(XOR(D_lo, lanes_lo[21]), 14)), XOR(SHR(XOR(D_lo, lanes_lo[6]), 28), SHL(XOR(D_hi, lanes_hi[6]), 4)), XOR(SHR(XOR(D_hi, lanes_hi[6]), 28), SHL(XOR(D_lo, lanes_lo[6]), 4)), XOR(SHR(XOR(D_lo, lanes_lo[16]), 23), SHL(XOR(D_hi, lanes_hi[16]), 9)), XOR(SHR(XOR(D_hi, lanes_hi[16]), 23), SHL(XOR(D_lo, lanes_lo[16]), 9))\n            lanes_lo[1], lanes_hi[1] = XOR(D_lo, lanes_lo[1]), XOR(D_hi, lanes_hi[1])\n            lanes_lo[1], lanes_lo[2], lanes_lo[3], lanes_lo[4], lanes_lo[5] = XOR(lanes_lo[1], AND(NOT(lanes_lo[2]), lanes_lo[3]), RC_lo[round_idx]), XOR(lanes_lo[2], AND(NOT(lanes_lo[3]), lanes_lo[4])), XOR(lanes_lo[3], AND(NOT(lanes_lo[4]), lanes_lo[5])), XOR(lanes_lo[4], AND(NOT(lanes_lo[5]), lanes_lo[1])), XOR(lanes_lo[5], AND(NOT(lanes_lo[1]), lanes_lo[2]))\n            lanes_lo[6], lanes_lo[7], lanes_lo[8], lanes_lo[9], lanes_lo[10] = XOR(lanes_lo[9], AND(NOT(lanes_lo[10]), lanes_lo[6])), XOR(lanes_lo[10], AND(NOT(lanes_lo[6]), lanes_lo[7])), XOR(lanes_lo[6], AND(NOT(lanes_lo[7]), lanes_lo[8])), XOR(lanes_lo[7], AND(NOT(lanes_lo[8]), lanes_lo[9])), XOR(lanes_lo[8], AND(NOT(lanes_lo[9]), lanes_lo[10]))\n            lanes_lo[11], lanes_lo[12], lanes_lo[13], lanes_lo[14], lanes_lo[15] = XOR(lanes_lo[12], AND(NOT(lanes_lo[13]), lanes_lo[14])), XOR(lanes_lo[13], AND(NOT(lanes_lo[14]), lanes_lo[15])), XOR(lanes_lo[14], AND(NOT(lanes_lo[15]), lanes_lo[11])), XOR(lanes_lo[15], AND(NOT(lanes_lo[11]), lanes_lo[12])), XOR(lanes_lo[11], AND(NOT(lanes_lo[12]), lanes_lo[13]))\n            lanes_lo[16], lanes_lo[17], lanes_lo[18], lanes_lo[19], lanes_lo[20] = XOR(lanes_lo[20], AND(NOT(lanes_lo[16]), lanes_lo[17])), XOR(lanes_lo[16], AND(NOT(lanes_lo[17]), lanes_lo[18])), XOR(lanes_lo[17], AND(NOT(lanes_lo[18]), lanes_lo[19])), XOR(lanes_lo[18], AND(NOT(lanes_lo[19]), lanes_lo[20])), XOR(lanes_lo[19], AND(NOT(lanes_lo[20]), lanes_lo[16]))\n            lanes_lo[21], lanes_lo[22], lanes_lo[23], lanes_lo[24], lanes_lo[25] = XOR(lanes_lo[23], AND(NOT(lanes_lo[24]), lanes_lo[25])), XOR(lanes_lo[24], AND(NOT(lanes_lo[25]), lanes_lo[21])), XOR(lanes_lo[25], AND(NOT(lanes_lo[21]), lanes_lo[22])), XOR(lanes_lo[21], AND(NOT(lanes_lo[22]), lanes_lo[23])), XOR(lanes_lo[22], AND(NOT(lanes_lo[23]), lanes_lo[24]))\n            lanes_hi[1], lanes_hi[2], lanes_hi[3], lanes_hi[4], lanes_hi[5] = XOR(lanes_hi[1], AND(NOT(lanes_hi[2]), lanes_hi[3]), RC_hi[round_idx]), XOR(lanes_hi[2], AND(NOT(lanes_hi[3]), lanes_hi[4])), XOR(lanes_hi[3], AND(NOT(lanes_hi[4]), lanes_hi[5])), XOR(lanes_hi[4], AND(NOT(lanes_hi[5]), lanes_hi[1])), XOR(lanes_hi[5], AND(NOT(lanes_hi[1]), lanes_hi[2]))\n            lanes_hi[6], lanes_hi[7], lanes_hi[8], lanes_hi[9], lanes_hi[10] = XOR(lanes_hi[9], AND(NOT(lanes_hi[10]), lanes_hi[6])), XOR(lanes_hi[10], AND(NOT(lanes_hi[6]), lanes_hi[7])), XOR(lanes_hi[6], AND(NOT(lanes_hi[7]), lanes_hi[8])), XOR(lanes_hi[7], AND(NOT(lanes_hi[8]), lanes_hi[9])), XOR(lanes_hi[8], AND(NOT(lanes_hi[9]), lanes_hi[10]))\n            lanes_hi[11], lanes_hi[12], lanes_hi[13], lanes_hi[14], lanes_hi[15] = XOR(lanes_hi[12], AND(NOT(lanes_hi[13]), lanes_hi[14])), XOR(lanes_hi[13], AND(NOT(lanes_hi[14]), lanes_hi[15])), XOR(lanes_hi[14], AND(NOT(lanes_hi[15]), lanes_hi[11])), XOR(lanes_hi[15], AND(NOT(lanes_hi[11]), lanes_hi[12])), XOR(lanes_hi[11], AND(NOT(lanes_hi[12]), lanes_hi[13]))\n            lanes_hi[16], lanes_hi[17], lanes_hi[18], lanes_hi[19], lanes_hi[20] = XOR(lanes_hi[20], AND(NOT(lanes_hi[16]), lanes_hi[17])), XOR(lanes_hi[16], AND(NOT(lanes_hi[17]), lanes_hi[18])), XOR(lanes_hi[17], AND(NOT(lanes_hi[18]), lanes_hi[19])), XOR(lanes_hi[18], AND(NOT(lanes_hi[19]), lanes_hi[20])), XOR(lanes_hi[19], AND(NOT(lanes_hi[20]), lanes_hi[16]))\n            lanes_hi[21], lanes_hi[22], lanes_hi[23], lanes_hi[24], lanes_hi[25] = XOR(lanes_hi[23], AND(NOT(lanes_hi[24]), lanes_hi[25])), XOR(lanes_hi[24], AND(NOT(lanes_hi[25]), lanes_hi[21])), XOR(lanes_hi[25], AND(NOT(lanes_hi[21]), lanes_hi[22])), XOR(lanes_hi[21], AND(NOT(lanes_hi[22]), lanes_hi[23])), XOR(lanes_hi[22], AND(NOT(lanes_hi[23]), lanes_hi[24]))\n         end\n      end\n   end\n\nend\n\n\nif branch == \"LJ\" then\n\n\n   -- SHA256 implementation for \"LuaJIT without FFI\" branch\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = NORM( NORM( XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) ) + NORM( W[j-7] + W[j-16] ) )\n         end\n         local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for j = 1, 64, 8 do  -- Thanks to Peter Cawley for this workaround (unroll the loop to avoid \"PHI shuffling too complex\" due to PHIs overlap)\n            local z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j] + W[j] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+1] + W[j+1] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+2] + W[j+2] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+3] + W[j+3] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+4] + W[j+4] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+5] + W[j+5] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+6] + W[j+6] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n            z = NORM( XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + XOR(g, AND(e, XOR(f, g))) + (K[j+7] + W[j+7] + h) )\n            h, g, f, e = g, f, e, NORM(d + z)\n            d, c, b, a = c, b, a, NORM( XOR(AND(a, XOR(b, c)), AND(b, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10)) + z )\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n         H[5], H[6], H[7], H[8] = NORM(e + H[5]), NORM(f + H[6]), NORM(g + H[7]), NORM(h + H[8])\n      end\n   end\n\n   local function ADD64_4(a_lo, a_hi, b_lo, b_hi, c_lo, c_hi, d_lo, d_hi)\n      local sum_lo = a_lo % 2^32 + b_lo % 2^32 + c_lo % 2^32 + d_lo % 2^32\n      local sum_hi = a_hi + b_hi + c_hi + d_hi\n      local result_lo = NORM( sum_lo )\n      local result_hi = NORM( sum_hi + floor(sum_lo / 2^32) )\n      return result_lo, result_hi\n   end\n\n   if LuaJIT_arch == \"x86\" then  -- Special trick is required to avoid \"PHI shuffling too complex\" on x86 platform\n\n\n      -- SHA512 implementation for \"LuaJIT x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            local zero = 0\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               zero = zero + zero  -- this thick is needed to avoid \"PHI shuffling too complex\" due to PHIs overlap\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = OR(zero, g_lo), OR(zero, g_hi), OR(zero, f_lo), OR(zero, f_hi), OR(zero, e_lo), OR(zero, e_hi)\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = OR(zero, c_lo), OR(zero, c_hi), OR(zero, b_lo), OR(zero, b_hi), OR(zero, a_lo), OR(zero, a_hi)\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + t_lo % 2^32 + u_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + t_hi + u_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   else  -- all platforms except x86\n\n\n      -- SHA512 implementation for \"LuaJIT non-x86 without FFI\" branch\n\n      function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n         for pos = offs, offs + size - 1, 128 do\n            for j = 1, 16*2 do\n               pos = pos + 4\n               local a, b, c, d = byte(str, pos - 3, pos)\n               W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n            end\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi = W[jj-30], W[jj-31]\n               local t_lo = XOR(OR(SHR(a_lo, 1), SHL(a_hi, 31)), OR(SHR(a_lo, 8), SHL(a_hi, 24)), OR(SHR(a_lo, 7), SHL(a_hi, 25)))\n               local t_hi = XOR(OR(SHR(a_hi, 1), SHL(a_lo, 31)), OR(SHR(a_hi, 8), SHL(a_lo, 24)), SHR(a_hi, 7))\n               local b_lo, b_hi = W[jj-4], W[jj-5]\n               local u_lo = XOR(OR(SHR(b_lo, 19), SHL(b_hi, 13)), OR(SHL(b_lo, 3), SHR(b_hi, 29)), OR(SHR(b_lo, 6), SHL(b_hi, 26)))\n               local u_hi = XOR(OR(SHR(b_hi, 19), SHL(b_lo, 13)), OR(SHL(b_hi, 3), SHR(b_lo, 29)), SHR(b_hi, 6))\n               W[jj], W[jj-1] = ADD64_4(t_lo, t_hi, u_lo, u_hi, W[jj-14], W[jj-15], W[jj-32], W[jj-33])\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n            for j = 1, 80 do\n               local t_lo = XOR(g_lo, AND(e_lo, XOR(f_lo, g_lo)))\n               local t_hi = XOR(g_hi, AND(e_hi, XOR(f_hi, g_hi)))\n               local u_lo = XOR(OR(SHR(e_lo, 14), SHL(e_hi, 18)), OR(SHR(e_lo, 18), SHL(e_hi, 14)), OR(SHL(e_lo, 23), SHR(e_hi, 9)))\n               local u_hi = XOR(OR(SHR(e_hi, 14), SHL(e_lo, 18)), OR(SHR(e_hi, 18), SHL(e_lo, 14)), OR(SHL(e_hi, 23), SHR(e_lo, 9)))\n               local sum_lo = u_lo % 2^32 + t_lo % 2^32 + h_lo % 2^32 + K_lo[j] + W[2*j] % 2^32\n               local z_lo, z_hi = NORM( sum_lo ), NORM( u_hi + t_hi + h_hi + K_hi[j] + W[2*j-1] + floor(sum_lo / 2^32) )\n               h_lo, h_hi, g_lo, g_hi, f_lo, f_hi = g_lo, g_hi, f_lo, f_hi, e_lo, e_hi\n               local sum_lo = z_lo % 2^32 + d_lo % 2^32\n               e_lo, e_hi = NORM( sum_lo ), NORM( z_hi + d_hi + floor(sum_lo / 2^32) )\n               d_lo, d_hi, c_lo, c_hi, b_lo, b_hi = c_lo, c_hi, b_lo, b_hi, a_lo, a_hi\n               u_lo = XOR(OR(SHR(b_lo, 28), SHL(b_hi, 4)), OR(SHL(b_lo, 30), SHR(b_hi, 2)), OR(SHL(b_lo, 25), SHR(b_hi, 7)))\n               u_hi = XOR(OR(SHR(b_hi, 28), SHL(b_lo, 4)), OR(SHL(b_hi, 30), SHR(b_lo, 2)), OR(SHL(b_hi, 25), SHR(b_lo, 7)))\n               t_lo = OR(AND(d_lo, c_lo), AND(b_lo, XOR(d_lo, c_lo)))\n               t_hi = OR(AND(d_hi, c_hi), AND(b_hi, XOR(d_hi, c_hi)))\n               local sum_lo = z_lo % 2^32 + u_lo % 2^32 + t_lo % 2^32\n               a_lo, a_hi = NORM( sum_lo ), NORM( z_hi + u_hi + t_hi + floor(sum_lo / 2^32) )\n            end\n            H_lo[1], H_hi[1] = ADD64_4(H_lo[1], H_hi[1], a_lo, a_hi, 0, 0, 0, 0)\n            H_lo[2], H_hi[2] = ADD64_4(H_lo[2], H_hi[2], b_lo, b_hi, 0, 0, 0, 0)\n            H_lo[3], H_hi[3] = ADD64_4(H_lo[3], H_hi[3], c_lo, c_hi, 0, 0, 0, 0)\n            H_lo[4], H_hi[4] = ADD64_4(H_lo[4], H_hi[4], d_lo, d_hi, 0, 0, 0, 0)\n            H_lo[5], H_hi[5] = ADD64_4(H_lo[5], H_hi[5], e_lo, e_hi, 0, 0, 0, 0)\n            H_lo[6], H_hi[6] = ADD64_4(H_lo[6], H_hi[6], f_lo, f_hi, 0, 0, 0, 0)\n            H_lo[7], H_hi[7] = ADD64_4(H_lo[7], H_hi[7], g_lo, g_hi, 0, 0, 0, 0)\n            H_lo[8], H_hi[8] = ADD64_4(H_lo[8], H_hi[8], h_lo, h_hi, 0, 0, 0, 0)\n         end\n      end\n\n   end\n\n\n   -- MD5 implementation for \"LuaJIT without FFI\" branch\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, md5_K\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(d, 24), SHL(c, 16), SHL(b, 8), a)\n         end\n         local a, b, c, d = H[1], H[2], H[3], H[4]\n         for j = 1, 16, 4 do\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j  ] + W[j  ] + a),  7) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+1] + W[j+1] + a), 12) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+2] + W[j+2] + a), 17) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(d, AND(b, XOR(c, d))) + (K[j+3] + W[j+3] + a), 22) + b)\n         end\n         for j = 17, 32, 4 do\n            local g = 5*j-4\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j  ] + W[AND(g     , 15) + 1] + a),  5) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+1] + W[AND(g +  5, 15) + 1] + a),  9) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+2] + W[AND(g + 10, 15) + 1] + a), 14) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, AND(d, XOR(b, c))) + (K[j+3] + W[AND(g -  1, 15) + 1] + a), 20) + b)\n         end\n         for j = 33, 48, 4 do\n            local g = 3*j+2\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j  ] + W[AND(g    , 15) + 1] + a),  4) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+1] + W[AND(g + 3, 15) + 1] + a), 11) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+2] + W[AND(g + 6, 15) + 1] + a), 16) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(b, c, d) + (K[j+3] + W[AND(g - 7, 15) + 1] + a), 23) + b)\n         end\n         for j = 49, 64, 4 do\n            local g = j*7\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j  ] + W[AND(g - 7, 15) + 1] + a),  6) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+1] + W[AND(g    , 15) + 1] + a), 10) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+2] + W[AND(g + 7, 15) + 1] + a), 15) + b)\n            a, d, c, b = d, c, b, NORM(ROL(XOR(c, OR(b, NOT(d))) + (K[j+3] + W[AND(g - 2, 15) + 1] + a), 21) + b)\n         end\n         H[1], H[2], H[3], H[4] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4])\n      end\n   end\n\n\n   -- SHA-1 implementation for \"LuaJIT without FFI\" branch\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = OR(SHL(a, 24), SHL(b, 16), SHL(c, 8), d)\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = H[1], H[2], H[3], H[4], H[5]\n         for j = 1, 20, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j]   + 0x5A827999 + e))          -- constant = floor(2^30 * sqrt(2))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+1] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+2] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+3] + 0x5A827999 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(d, AND(b, XOR(d, c))) + (W[j+4] + 0x5A827999 + e))\n         end\n         for j = 21, 40, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0x6ED9EBA1 + e))                       -- 2^30 * sqrt(3)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0x6ED9EBA1 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0x6ED9EBA1 + e))\n         end\n         for j = 41, 60, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j]   + 0x8F1BBCDC + e))  -- 2^30 * sqrt(5)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+1] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+2] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+3] + 0x8F1BBCDC + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(AND(d, XOR(b, c)), AND(b, c)) + (W[j+4] + 0x8F1BBCDC + e))\n         end\n         for j = 61, 80, 5 do\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j]   + 0xCA62C1D6 + e))                       -- 2^30 * sqrt(10)\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+1] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+2] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+3] + 0xCA62C1D6 + e))\n            e, d, c, b, a = d, c, ROR(b, 2), a, NORM(ROL(a, 5) + XOR(b, c, d) + (W[j+4] + 0xCA62C1D6 + e))\n         end\n         H[1], H[2], H[3], H[4], H[5] = NORM(a + H[1]), NORM(b + H[2]), NORM(c + H[3]), NORM(d + H[4]), NORM(e + H[5])\n      end\n   end\n\nend\n\n\nif branch == \"INT64\" then\n\n\n   -- implementation for Lua 5.3/5.4\n\n   hi_factor = 4294967296\n   hi_factor_keccak = 4294967296\n   lanes_index_base = 1\n\n   HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo = ...\n      local string_format, string_unpack = string.format, string.unpack\n\n      local function HEX64(x)\n         return string_format(\"%016x\", x)\n      end\n\n      local function XOR64A5(x)\n         return x ~ 0xa5a5a5a5a5a5a5a5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 64 do\n               local a = W[j-15]\n               a = a<<32 | a\n               local b = W[j-2]\n               b = b<<32 | b\n               W[j] = (a>>7 ~ a>>18 ~ a>>35) + (b>>17 ~ b>>19 ~ b>>42) + W[j-7] + W[j-16] & (1<<32)-1\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               e = e<<32 | e & (1<<32)-1\n               local z = (e>>6 ~ e>>11 ~ e>>25) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = a<<32 | a & (1<<32)-1\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a>>13 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W, sha2_K_lo\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-15]\n               local b = W[j-2]\n               W[j] = (a >> 1 ~ a >> 7 ~ a >> 8 ~ a << 56 ~ a << 63) + (b >> 6 ~ b >> 19 ~ b >> 61 ~ b << 3 ~ b << 45) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 80 do\n               local z = (e >> 14 ~ e >> 18 ~ e >> 41 ~ e << 23 ~ e << 46 ~ e << 50) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a >> 28 ~ a >> 34 ~ a >> 39 ~ a << 25 ~ a << 30 ~ a << 36)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = (a<<32 | a) << 1 >> 32\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i8 = build_keccak_format(\"i8\")\n\n      local function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i8[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local qwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes[j] = lanes[j] ~ qwords_from_message[j]\n            end\n            local L01, L02, L03, L04, L05, L06, L07, L08, L09, L10, L11, L12, L13, L14, L15, L16, L17, L18, L19, L20, L21, L22, L23, L24, L25 =\n               lanes[1], lanes[2], lanes[3], lanes[4], lanes[5], lanes[6], lanes[7], lanes[8], lanes[9], lanes[10], lanes[11], lanes[12], lanes[13],\n               lanes[14], lanes[15], lanes[16], lanes[17], lanes[18], lanes[19], lanes[20], lanes[21], lanes[22], lanes[23], lanes[24], lanes[25]\n            for round_idx = 1, 24 do\n               local C1 = L01 ~ L06 ~ L11 ~ L16 ~ L21\n               local C2 = L02 ~ L07 ~ L12 ~ L17 ~ L22\n               local C3 = L03 ~ L08 ~ L13 ~ L18 ~ L23\n               local C4 = L04 ~ L09 ~ L14 ~ L19 ~ L24\n               local C5 = L05 ~ L10 ~ L15 ~ L20 ~ L25\n               local D = C1 ~ C3<<1 ~ C3>>63\n               local T0 = D ~ L02\n               local T1 = D ~ L07\n               local T2 = D ~ L12\n               local T3 = D ~ L17\n               local T4 = D ~ L22\n               L02 = T1<<44 ~ T1>>20\n               L07 = T3<<45 ~ T3>>19\n               L12 = T0<<1 ~ T0>>63\n               L17 = T2<<10 ~ T2>>54\n               L22 = T4<<2 ~ T4>>62\n               D = C2 ~ C4<<1 ~ C4>>63\n               T0 = D ~ L03\n               T1 = D ~ L08\n               T2 = D ~ L13\n               T3 = D ~ L18\n               T4 = D ~ L23\n               L03 = T2<<43 ~ T2>>21\n               L08 = T4<<61 ~ T4>>3\n               L13 = T1<<6 ~ T1>>58\n               L18 = T3<<15 ~ T3>>49\n               L23 = T0<<62 ~ T0>>2\n               D = C3 ~ C5<<1 ~ C5>>63\n               T0 = D ~ L04\n               T1 = D ~ L09\n               T2 = D ~ L14\n               T3 = D ~ L19\n               T4 = D ~ L24\n               L04 = T3<<21 ~ T3>>43\n               L09 = T0<<28 ~ T0>>36\n               L14 = T2<<25 ~ T2>>39\n               L19 = T4<<56 ~ T4>>8\n               L24 = T1<<55 ~ T1>>9\n               D = C4 ~ C1<<1 ~ C1>>63\n               T0 = D ~ L05\n               T1 = D ~ L10\n               T2 = D ~ L15\n               T3 = D ~ L20\n               T4 = D ~ L25\n               L05 = T4<<14 ~ T4>>50\n               L10 = T1<<20 ~ T1>>44\n               L15 = T3<<8 ~ T3>>56\n               L20 = T0<<27 ~ T0>>37\n               L25 = T2<<39 ~ T2>>25\n               D = C5 ~ C2<<1 ~ C2>>63\n               T1 = D ~ L06\n               T2 = D ~ L11\n               T3 = D ~ L16\n               T4 = D ~ L21\n               L06 = T2<<3 ~ T2>>61\n               L11 = T4<<18 ~ T4>>46\n               L16 = T1<<36 ~ T1>>28\n               L21 = T3<<41 ~ T3>>23\n               L01 = D ~ L01\n               L01, L02, L03, L04, L05 = L01 ~ ~L02 & L03, L02 ~ ~L03 & L04, L03 ~ ~L04 & L05, L04 ~ ~L05 & L01, L05 ~ ~L01 & L02\n               L06, L07, L08, L09, L10 = L09 ~ ~L10 & L06, L10 ~ ~L06 & L07, L06 ~ ~L07 & L08, L07 ~ ~L08 & L09, L08 ~ ~L09 & L10\n               L11, L12, L13, L14, L15 = L12 ~ ~L13 & L14, L13 ~ ~L14 & L15, L14 ~ ~L15 & L11, L15 ~ ~L11 & L12, L11 ~ ~L12 & L13\n               L16, L17, L18, L19, L20 = L20 ~ ~L16 & L17, L16 ~ ~L17 & L18, L17 ~ ~L18 & L19, L18 ~ ~L19 & L20, L19 ~ ~L20 & L16\n               L21, L22, L23, L24, L25 = L23 ~ ~L24 & L25, L24 ~ ~L25 & L21, L25 ~ ~L21 & L22, L21 ~ ~L22 & L23, L22 ~ ~L23 & L24\n               L01 = L01 ~ RC[round_idx]\n            end\n            lanes[1]  = L01\n            lanes[2]  = L02\n            lanes[3]  = L03\n            lanes[4]  = L04\n            lanes[5]  = L05\n            lanes[6]  = L06\n            lanes[7]  = L07\n            lanes[8]  = L08\n            lanes[9]  = L09\n            lanes[10] = L10\n            lanes[11] = L11\n            lanes[12] = L12\n            lanes[13] = L13\n            lanes[14] = L14\n            lanes[15] = L15\n            lanes[16] = L16\n            lanes[17] = L17\n            lanes[18] = L18\n            lanes[19] = L19\n            lanes[20] = L20\n            lanes[21] = L21\n            lanes[22] = L22\n            lanes[23] = L23\n            lanes[24] = L24\n            lanes[25] = L25\n         end\n      end\n\n      return HEX64, XOR64A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo)\n\nend\n\n\nif branch == \"INT32\" then\n\n\n   -- implementation for Lua 5.3/5.4 having non-standard numbers config \"int32\"+\"double\" (built with LUA_INT_TYPE=LUA_INT_INT)\n\n   K_lo_modulo = 2^32\n\n   function HEX(x) -- returns string of 8 lowercase hexadecimal digits\n      return string_format(\"%08x\", x)\n   end\n\n   XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed = load[[\n      local md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi = ...\n      local string_unpack, floor = string.unpack, math.floor\n\n      local function XOR32A5(x)\n         return x ~ 0xA5A5A5A5\n      end\n\n      local function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      local function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 64 do\n               local a, b = W[j-15], W[j-2]\n               W[j] = (a>>7 ~ a<<25 ~ a<<14 ~ a>>18 ~ a>>3) + (b<<15 ~ b>>17 ~ b<<13 ~ b>>19 ~ b>>10) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               local z = (e>>6 ~ e<<26 ~ e>>11 ~ e<<21 ~ e>>25 ~ e<<7) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a<<30 ~ a>>13 ~ a<<19 ~ a<<10 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      local function sha512_feed_128(H_lo, H_hi, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n         local floor, W, K_lo, K_hi = floor, common_W, sha2_K_lo, sha2_K_hi\n         local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n         local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16],\n               W[17], W[18], W[19], W[20], W[21], W[22], W[23], W[24], W[25], W[26], W[27], W[28], W[29], W[30], W[31], W[32] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for jj = 17*2, 80*2, 2 do\n               local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n               local tmp =\n                  (a_lo>>1 ~ a_hi<<31 ~ a_lo>>8 ~ a_hi<<24 ~ a_lo>>7 ~ a_hi<<25) % 2^32\n                  + (b_lo>>19 ~ b_hi<<13 ~ b_lo<<3 ~ b_hi>>29 ~ b_lo>>6 ~ b_hi<<26) % 2^32\n                  + W[jj-14] % 2^32 + W[jj-32] % 2^32\n               W[jj-1] =\n                  (a_hi>>1 ~ a_lo<<31 ~ a_hi>>8 ~ a_lo<<24 ~ a_hi>>7)\n                  + (b_hi>>19 ~ b_lo<<13 ~ b_hi<<3 ~ b_lo>>29 ~ b_hi>>6)\n                  + W[jj-15] + W[jj-33] + floor(tmp / 2^32)\n               W[jj] = 0|((tmp + 2^31) % 2^32 - 2^31)\n            end\n            local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n            local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n            for j = 1, 80 do\n               local jj = 2*j\n               local z_lo = (e_lo>>14 ~ e_hi<<18 ~ e_lo>>18 ~ e_hi<<14 ~ e_lo<<23 ~ e_hi>>9) % 2^32 + (g_lo ~ e_lo & (f_lo ~ g_lo)) % 2^32 + h_lo % 2^32 + K_lo[j] + W[jj] % 2^32\n               local z_hi = (e_hi>>14 ~ e_lo<<18 ~ e_hi>>18 ~ e_lo<<14 ~ e_hi<<23 ~ e_lo>>9) + (g_hi ~ e_hi & (f_hi ~ g_hi)) + h_hi + K_hi[j] + W[jj-1] + floor(z_lo / 2^32)\n               z_lo = z_lo % 2^32\n               h_lo = g_lo\n               h_hi = g_hi\n               g_lo = f_lo\n               g_hi = f_hi\n               f_lo = e_lo\n               f_hi = e_hi\n               e_lo = z_lo + d_lo % 2^32\n               e_hi = z_hi + d_hi + floor(e_lo / 2^32)\n               e_lo = 0|((e_lo + 2^31) % 2^32 - 2^31)\n               d_lo = c_lo\n               d_hi = c_hi\n               c_lo = b_lo\n               c_hi = b_hi\n               b_lo = a_lo\n               b_hi = a_hi\n               z_lo = z_lo + (d_lo & c_lo ~ b_lo & (d_lo ~ c_lo)) % 2^32 + (b_lo>>28 ~ b_hi<<4 ~ b_lo<<30 ~ b_hi>>2 ~ b_lo<<25 ~ b_hi>>7) % 2^32\n               a_hi = z_hi + (d_hi & c_hi ~ b_hi & (d_hi ~ c_hi)) + (b_hi>>28 ~ b_lo<<4 ~ b_hi<<30 ~ b_lo>>2 ~ b_hi<<25 ~ b_lo>>7) + floor(z_lo / 2^32)\n               a_lo = 0|((z_lo + 2^31) % 2^32 - 2^31)\n            end\n            a_lo = h1_lo % 2^32 + a_lo % 2^32\n            h1_hi = h1_hi + a_hi + floor(a_lo / 2^32)\n            h1_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h2_lo % 2^32 + b_lo % 2^32\n            h2_hi = h2_hi + b_hi + floor(a_lo / 2^32)\n            h2_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h3_lo % 2^32 + c_lo % 2^32\n            h3_hi = h3_hi + c_hi + floor(a_lo / 2^32)\n            h3_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h4_lo % 2^32 + d_lo % 2^32\n            h4_hi = h4_hi + d_hi + floor(a_lo / 2^32)\n            h4_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h5_lo % 2^32 + e_lo % 2^32\n            h5_hi = h5_hi + e_hi + floor(a_lo / 2^32)\n            h5_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h6_lo % 2^32 + f_lo % 2^32\n            h6_hi = h6_hi + f_hi + floor(a_lo / 2^32)\n            h6_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h7_lo % 2^32 + g_lo % 2^32\n            h7_hi = h7_hi + g_hi + floor(a_lo / 2^32)\n            h7_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n            a_lo = h8_lo % 2^32 + h_lo % 2^32\n            h8_hi = h8_hi + h_hi + floor(a_lo / 2^32)\n            h8_lo = 0|((a_lo + 2^31) % 2^32 - 2^31)\n         end\n         H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n      end\n\n      local function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = (F << 32-s | F>>s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      local function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4i4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = a << 1 ~ a >> 31\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = (a << 5 ~ a >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = (a << 5 ~ a >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = (a << 5 ~ a >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = b << 30 ~ b >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i4i4 = build_keccak_format(\"i4i4\")\n\n      local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n         local qwords_qty = block_size_in_bytes / 8\n         local keccak_format = keccak_format_i4i4[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local dwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes_lo[j] = lanes_lo[j] ~ dwords_from_message[2*j-1]\n               lanes_hi[j] = lanes_hi[j] ~ dwords_from_message[2*j]\n            end\n            local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n               L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n               L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n               lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n               lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n               lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n               lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n               lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n            for round_idx = 1, 24 do\n               local C1_lo = L01_lo ~ L06_lo ~ L11_lo ~ L16_lo ~ L21_lo\n               local C1_hi = L01_hi ~ L06_hi ~ L11_hi ~ L16_hi ~ L21_hi\n               local C2_lo = L02_lo ~ L07_lo ~ L12_lo ~ L17_lo ~ L22_lo\n               local C2_hi = L02_hi ~ L07_hi ~ L12_hi ~ L17_hi ~ L22_hi\n               local C3_lo = L03_lo ~ L08_lo ~ L13_lo ~ L18_lo ~ L23_lo\n               local C3_hi = L03_hi ~ L08_hi ~ L13_hi ~ L18_hi ~ L23_hi\n               local C4_lo = L04_lo ~ L09_lo ~ L14_lo ~ L19_lo ~ L24_lo\n               local C4_hi = L04_hi ~ L09_hi ~ L14_hi ~ L19_hi ~ L24_hi\n               local C5_lo = L05_lo ~ L10_lo ~ L15_lo ~ L20_lo ~ L25_lo\n               local C5_hi = L05_hi ~ L10_hi ~ L15_hi ~ L20_hi ~ L25_hi\n               local D_lo = C1_lo ~ C3_lo<<1 ~ C3_hi>>31\n               local D_hi = C1_hi ~ C3_hi<<1 ~ C3_lo>>31\n               local T0_lo = D_lo ~ L02_lo\n               local T0_hi = D_hi ~ L02_hi\n               local T1_lo = D_lo ~ L07_lo\n               local T1_hi = D_hi ~ L07_hi\n               local T2_lo = D_lo ~ L12_lo\n               local T2_hi = D_hi ~ L12_hi\n               local T3_lo = D_lo ~ L17_lo\n               local T3_hi = D_hi ~ L17_hi\n               local T4_lo = D_lo ~ L22_lo\n               local T4_hi = D_hi ~ L22_hi\n               L02_lo = T1_lo>>20 ~ T1_hi<<12\n               L02_hi = T1_hi>>20 ~ T1_lo<<12\n               L07_lo = T3_lo>>19 ~ T3_hi<<13\n               L07_hi = T3_hi>>19 ~ T3_lo<<13\n               L12_lo = T0_lo<<1 ~ T0_hi>>31\n               L12_hi = T0_hi<<1 ~ T0_lo>>31\n               L17_lo = T2_lo<<10 ~ T2_hi>>22\n               L17_hi = T2_hi<<10 ~ T2_lo>>22\n               L22_lo = T4_lo<<2 ~ T4_hi>>30\n               L22_hi = T4_hi<<2 ~ T4_lo>>30\n               D_lo = C2_lo ~ C4_lo<<1 ~ C4_hi>>31\n               D_hi = C2_hi ~ C4_hi<<1 ~ C4_lo>>31\n               T0_lo = D_lo ~ L03_lo\n               T0_hi = D_hi ~ L03_hi\n               T1_lo = D_lo ~ L08_lo\n               T1_hi = D_hi ~ L08_hi\n               T2_lo = D_lo ~ L13_lo\n               T2_hi = D_hi ~ L13_hi\n               T3_lo = D_lo ~ L18_lo\n               T3_hi = D_hi ~ L18_hi\n               T4_lo = D_lo ~ L23_lo\n               T4_hi = D_hi ~ L23_hi\n               L03_lo = T2_lo>>21 ~ T2_hi<<11\n               L03_hi = T2_hi>>21 ~ T2_lo<<11\n               L08_lo = T4_lo>>3 ~ T4_hi<<29\n               L08_hi = T4_hi>>3 ~ T4_lo<<29\n               L13_lo = T1_lo<<6 ~ T1_hi>>26\n               L13_hi = T1_hi<<6 ~ T1_lo>>26\n               L18_lo = T3_lo<<15 ~ T3_hi>>17\n               L18_hi = T3_hi<<15 ~ T3_lo>>17\n               L23_lo = T0_lo>>2 ~ T0_hi<<30\n               L23_hi = T0_hi>>2 ~ T0_lo<<30\n               D_lo = C3_lo ~ C5_lo<<1 ~ C5_hi>>31\n               D_hi = C3_hi ~ C5_hi<<1 ~ C5_lo>>31\n               T0_lo = D_lo ~ L04_lo\n               T0_hi = D_hi ~ L04_hi\n               T1_lo = D_lo ~ L09_lo\n               T1_hi = D_hi ~ L09_hi\n               T2_lo = D_lo ~ L14_lo\n               T2_hi = D_hi ~ L14_hi\n               T3_lo = D_lo ~ L19_lo\n               T3_hi = D_hi ~ L19_hi\n               T4_lo = D_lo ~ L24_lo\n               T4_hi = D_hi ~ L24_hi\n               L04_lo = T3_lo<<21 ~ T3_hi>>11\n               L04_hi = T3_hi<<21 ~ T3_lo>>11\n               L09_lo = T0_lo<<28 ~ T0_hi>>4\n               L09_hi = T0_hi<<28 ~ T0_lo>>4\n               L14_lo = T2_lo<<25 ~ T2_hi>>7\n               L14_hi = T2_hi<<25 ~ T2_lo>>7\n               L19_lo = T4_lo>>8 ~ T4_hi<<24\n               L19_hi = T4_hi>>8 ~ T4_lo<<24\n               L24_lo = T1_lo>>9 ~ T1_hi<<23\n               L24_hi = T1_hi>>9 ~ T1_lo<<23\n               D_lo = C4_lo ~ C1_lo<<1 ~ C1_hi>>31\n               D_hi = C4_hi ~ C1_hi<<1 ~ C1_lo>>31\n               T0_lo = D_lo ~ L05_lo\n               T0_hi = D_hi ~ L05_hi\n               T1_lo = D_lo ~ L10_lo\n               T1_hi = D_hi ~ L10_hi\n               T2_lo = D_lo ~ L15_lo\n               T2_hi = D_hi ~ L15_hi\n               T3_lo = D_lo ~ L20_lo\n               T3_hi = D_hi ~ L20_hi\n               T4_lo = D_lo ~ L25_lo\n               T4_hi = D_hi ~ L25_hi\n               L05_lo = T4_lo<<14 ~ T4_hi>>18\n               L05_hi = T4_hi<<14 ~ T4_lo>>18\n               L10_lo = T1_lo<<20 ~ T1_hi>>12\n               L10_hi = T1_hi<<20 ~ T1_lo>>12\n               L15_lo = T3_lo<<8 ~ T3_hi>>24\n               L15_hi = T3_hi<<8 ~ T3_lo>>24\n               L20_lo = T0_lo<<27 ~ T0_hi>>5\n               L20_hi = T0_hi<<27 ~ T0_lo>>5\n               L25_lo = T2_lo>>25 ~ T2_hi<<7\n               L25_hi = T2_hi>>25 ~ T2_lo<<7\n               D_lo = C5_lo ~ C2_lo<<1 ~ C2_hi>>31\n               D_hi = C5_hi ~ C2_hi<<1 ~ C2_lo>>31\n               T1_lo = D_lo ~ L06_lo\n               T1_hi = D_hi ~ L06_hi\n               T2_lo = D_lo ~ L11_lo\n               T2_hi = D_hi ~ L11_hi\n               T3_lo = D_lo ~ L16_lo\n               T3_hi = D_hi ~ L16_hi\n               T4_lo = D_lo ~ L21_lo\n               T4_hi = D_hi ~ L21_hi\n               L06_lo = T2_lo<<3 ~ T2_hi>>29\n               L06_hi = T2_hi<<3 ~ T2_lo>>29\n               L11_lo = T4_lo<<18 ~ T4_hi>>14\n               L11_hi = T4_hi<<18 ~ T4_lo>>14\n               L16_lo = T1_lo>>28 ~ T1_hi<<4\n               L16_hi = T1_hi>>28 ~ T1_lo<<4\n               L21_lo = T3_lo>>23 ~ T3_hi<<9\n               L21_hi = T3_hi>>23 ~ T3_lo<<9\n               L01_lo = D_lo ~ L01_lo\n               L01_hi = D_hi ~ L01_hi\n               L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = L01_lo ~ ~L02_lo & L03_lo, L02_lo ~ ~L03_lo & L04_lo, L03_lo ~ ~L04_lo & L05_lo, L04_lo ~ ~L05_lo & L01_lo, L05_lo ~ ~L01_lo & L02_lo\n               L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = L01_hi ~ ~L02_hi & L03_hi, L02_hi ~ ~L03_hi & L04_hi, L03_hi ~ ~L04_hi & L05_hi, L04_hi ~ ~L05_hi & L01_hi, L05_hi ~ ~L01_hi & L02_hi\n               L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = L09_lo ~ ~L10_lo & L06_lo, L10_lo ~ ~L06_lo & L07_lo, L06_lo ~ ~L07_lo & L08_lo, L07_lo ~ ~L08_lo & L09_lo, L08_lo ~ ~L09_lo & L10_lo\n               L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = L09_hi ~ ~L10_hi & L06_hi, L10_hi ~ ~L06_hi & L07_hi, L06_hi ~ ~L07_hi & L08_hi, L07_hi ~ ~L08_hi & L09_hi, L08_hi ~ ~L09_hi & L10_hi\n               L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = L12_lo ~ ~L13_lo & L14_lo, L13_lo ~ ~L14_lo & L15_lo, L14_lo ~ ~L15_lo & L11_lo, L15_lo ~ ~L11_lo & L12_lo, L11_lo ~ ~L12_lo & L13_lo\n               L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = L12_hi ~ ~L13_hi & L14_hi, L13_hi ~ ~L14_hi & L15_hi, L14_hi ~ ~L15_hi & L11_hi, L15_hi ~ ~L11_hi & L12_hi, L11_hi ~ ~L12_hi & L13_hi\n               L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = L20_lo ~ ~L16_lo & L17_lo, L16_lo ~ ~L17_lo & L18_lo, L17_lo ~ ~L18_lo & L19_lo, L18_lo ~ ~L19_lo & L20_lo, L19_lo ~ ~L20_lo & L16_lo\n               L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = L20_hi ~ ~L16_hi & L17_hi, L16_hi ~ ~L17_hi & L18_hi, L17_hi ~ ~L18_hi & L19_hi, L18_hi ~ ~L19_hi & L20_hi, L19_hi ~ ~L20_hi & L16_hi\n               L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = L23_lo ~ ~L24_lo & L25_lo, L24_lo ~ ~L25_lo & L21_lo, L25_lo ~ ~L21_lo & L22_lo, L21_lo ~ ~L22_lo & L23_lo, L22_lo ~ ~L23_lo & L24_lo\n               L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = L23_hi ~ ~L24_hi & L25_hi, L24_hi ~ ~L25_hi & L21_hi, L25_hi ~ ~L21_hi & L22_hi, L21_hi ~ ~L22_hi & L23_hi, L22_hi ~ ~L23_hi & L24_hi\n               L01_lo = L01_lo ~ RC_lo[round_idx]\n               L01_hi = L01_hi ~ RC_hi[round_idx]\n            end\n            lanes_lo[1]  = L01_lo\n            lanes_hi[1]  = L01_hi\n            lanes_lo[2]  = L02_lo\n            lanes_hi[2]  = L02_hi\n            lanes_lo[3]  = L03_lo\n            lanes_hi[3]  = L03_hi\n            lanes_lo[4]  = L04_lo\n            lanes_hi[4]  = L04_hi\n            lanes_lo[5]  = L05_lo\n            lanes_hi[5]  = L05_hi\n            lanes_lo[6]  = L06_lo\n            lanes_hi[6]  = L06_hi\n            lanes_lo[7]  = L07_lo\n            lanes_hi[7]  = L07_hi\n            lanes_lo[8]  = L08_lo\n            lanes_hi[8]  = L08_hi\n            lanes_lo[9]  = L09_lo\n            lanes_hi[9]  = L09_hi\n            lanes_lo[10] = L10_lo\n            lanes_hi[10] = L10_hi\n            lanes_lo[11] = L11_lo\n            lanes_hi[11] = L11_hi\n            lanes_lo[12] = L12_lo\n            lanes_hi[12] = L12_hi\n            lanes_lo[13] = L13_lo\n            lanes_hi[13] = L13_hi\n            lanes_lo[14] = L14_lo\n            lanes_hi[14] = L14_hi\n            lanes_lo[15] = L15_lo\n            lanes_hi[15] = L15_hi\n            lanes_lo[16] = L16_lo\n            lanes_hi[16] = L16_hi\n            lanes_lo[17] = L17_lo\n            lanes_hi[17] = L17_hi\n            lanes_lo[18] = L18_lo\n            lanes_hi[18] = L18_hi\n            lanes_lo[19] = L19_lo\n            lanes_hi[19] = L19_hi\n            lanes_lo[20] = L20_lo\n            lanes_hi[20] = L20_hi\n            lanes_lo[21] = L21_lo\n            lanes_hi[21] = L21_hi\n            lanes_lo[22] = L22_lo\n            lanes_hi[22] = L22_hi\n            lanes_lo[23] = L23_lo\n            lanes_hi[23] = L23_hi\n            lanes_lo[24] = L24_lo\n            lanes_hi[24] = L24_hi\n            lanes_lo[25] = L25_lo\n            lanes_hi[25] = L25_hi\n         end\n      end\n\n      return XOR32A5, XOR_BYTE, sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n   ]](md5_next_shift, md5_K, sha2_K_lo, sha2_K_hi, build_keccak_format, sha3_RC_lo, sha3_RC_hi)\n\nend\n\n\nif branch == \"LIB32\" or branch == \"EMUL\" then\n\n\n   -- implementation for Lua 5.1/5.2 (with or without bitwise library available)\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16]\n         end\n         local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n         for j = 1, 64 do\n            local z = XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + AND(e, f) + AND(-1-e, g) + h + K[j] + W[j]\n            h = g\n            g = f\n            f = e\n            e = z + d\n            d = c\n            c = b\n            b = a\n            a = z + AND(d, c) + AND(a, XOR(d, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10))\n         end\n         h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296\n         h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n   end\n\n   function sha512_feed_128(H_lo, H_hi, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 128\n      -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n      local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n      local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n      local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n      for pos = offs, offs + size - 1, 128 do\n         for j = 1, 16*2 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for jj = 17*2, 80*2, 2 do\n            local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n            local tmp1 = XOR(SHR(a_lo, 1) + SHL(a_hi, 31), SHR(a_lo, 8) + SHL(a_hi, 24), SHR(a_lo, 7) + SHL(a_hi, 25)) % 4294967296 + XOR(SHR(b_lo, 19) + SHL(b_hi, 13), SHL(b_lo, 3) + SHR(b_hi, 29), SHR(b_lo, 6) + SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]\n            local tmp2 = tmp1 % 4294967296\n            W[jj-1] = XOR(SHR(a_hi, 1) + SHL(a_lo, 31), SHR(a_hi, 8) + SHL(a_lo, 24), SHR(a_hi, 7)) + XOR(SHR(b_hi, 19) + SHL(b_lo, 13), SHL(b_hi, 3) + SHR(b_lo, 29), SHR(b_hi, 6)) + W[jj-15] + W[jj-33] + (tmp1 - tmp2) / 4294967296\n            W[jj] = tmp2\n         end\n         local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n         for j = 1, 80 do\n            local jj = 2*j\n            local tmp1 = XOR(SHR(e_lo, 14) + SHL(e_hi, 18), SHR(e_lo, 18) + SHL(e_hi, 14), SHL(e_lo, 23) + SHR(e_hi, 9)) % 4294967296 + (AND(e_lo, f_lo) + AND(-1-e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]\n            local z_lo = tmp1 % 4294967296\n            local z_hi = XOR(SHR(e_hi, 14) + SHL(e_lo, 18), SHR(e_hi, 18) + SHL(e_lo, 14), SHL(e_hi, 23) + SHR(e_lo, 9)) + AND(e_hi, f_hi) + AND(-1-e_hi, g_hi) + h_hi + K_hi[j] + W[jj-1] + (tmp1 - z_lo) / 4294967296\n            h_lo = g_lo\n            h_hi = g_hi\n            g_lo = f_lo\n            g_hi = f_hi\n            f_lo = e_lo\n            f_hi = e_hi\n            tmp1 = z_lo + d_lo\n            e_lo = tmp1 % 4294967296\n            e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296\n            d_lo = c_lo\n            d_hi = c_hi\n            c_lo = b_lo\n            c_hi = b_hi\n            b_lo = a_lo\n            b_hi = a_hi\n            tmp1 = z_lo + (AND(d_lo, c_lo) + AND(b_lo, XOR(d_lo, c_lo))) % 4294967296 + XOR(SHR(b_lo, 28) + SHL(b_hi, 4), SHL(b_lo, 30) + SHR(b_hi, 2), SHL(b_lo, 25) + SHR(b_hi, 7)) % 4294967296\n            a_lo = tmp1 % 4294967296\n            a_hi = z_hi + (AND(d_hi, c_hi) + AND(b_hi, XOR(d_hi, c_hi))) + XOR(SHR(b_hi, 28) + SHL(b_lo, 4), SHL(b_hi, 30) + SHR(b_lo, 2), SHL(b_hi, 25) + SHR(b_lo, 7)) + (tmp1 - a_lo) / 4294967296\n         end\n         a_lo = h1_lo + a_lo\n         h1_lo = a_lo % 4294967296\n         h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296\n         a_lo = h2_lo + b_lo\n         h2_lo = a_lo % 4294967296\n         h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296\n         a_lo = h3_lo + c_lo\n         h3_lo = a_lo % 4294967296\n         h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296\n         a_lo = h4_lo + d_lo\n         h4_lo = a_lo % 4294967296\n         h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296\n         a_lo = h5_lo + e_lo\n         h5_lo = a_lo % 4294967296\n         h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296\n         a_lo = h6_lo + f_lo\n         h6_lo = a_lo % 4294967296\n         h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296\n         a_lo = h7_lo + g_lo\n         h7_lo = a_lo % 4294967296\n         h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296\n         a_lo = h8_lo + h_lo\n         h8_lo = a_lo % 4294967296\n         h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296\n      end\n      H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n      H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n   end\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n      local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((d * 256 + c) * 256 + b) * 256 + a\n         end\n         local a, b, c, d = h1, h2, h3, h4\n         local s = 32-7\n         for j = 1, 16 do\n            local F = ROR(AND(b, c) + AND(-1-b, d) + a + K[j] + W[j], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-5\n         for j = 17, 32 do\n            local F = ROR(AND(d, b) + AND(-1-d, c) + a + K[j] + W[(5*j-4) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-4\n         for j = 33, 48 do\n            local F = ROR(XOR(XOR(b, c), d) + a + K[j] + W[(3*j+2) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-6\n         for j = 49, 64 do\n            local F = ROR(XOR(c, OR(b, -1-d)) + a + K[j] + W[(j*7-7) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n      end\n      H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n   end\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = h1, h2, h3, h4, h5\n         for j = 1, 20 do\n            local z = ROL(a, 5) + AND(b, c) + AND(-1-b, d) + 0x5A827999 + W[j] + e        -- constant = floor(2^30 * sqrt(2))\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 21, 40 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0x6ED9EBA1 + W[j] + e                    -- 2^30 * sqrt(3)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 41, 60 do\n            local z = ROL(a, 5) + AND(d, c) + AND(b, XOR(d, c)) + 0x8F1BBCDC + W[j] + e   -- 2^30 * sqrt(5)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 61, 80 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0xCA62C1D6 + W[j] + e                    -- 2^30 * sqrt(10)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n         h5 = (e + h5) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- This is an example of a Lua function having 79 local variables :-)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = block_size_in_bytes / 8\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)\n         end\n         local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n            L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n            L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n            lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n            lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n            lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n            lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n            lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n         for round_idx = 1, 24 do\n            local C1_lo = XOR(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)\n            local C1_hi = XOR(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)\n            local C2_lo = XOR(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)\n            local C2_hi = XOR(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)\n            local C3_lo = XOR(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)\n            local C3_hi = XOR(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)\n            local C4_lo = XOR(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)\n            local C4_hi = XOR(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)\n            local C5_lo = XOR(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)\n            local C5_hi = XOR(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)\n            local D_lo = XOR(C1_lo, C3_lo * 2 + (C3_hi % 2^32 - C3_hi % 2^31) / 2^31)\n            local D_hi = XOR(C1_hi, C3_hi * 2 + (C3_lo % 2^32 - C3_lo % 2^31) / 2^31)\n            local T0_lo = XOR(D_lo, L02_lo)\n            local T0_hi = XOR(D_hi, L02_hi)\n            local T1_lo = XOR(D_lo, L07_lo)\n            local T1_hi = XOR(D_hi, L07_hi)\n            local T2_lo = XOR(D_lo, L12_lo)\n            local T2_hi = XOR(D_hi, L12_hi)\n            local T3_lo = XOR(D_lo, L17_lo)\n            local T3_hi = XOR(D_hi, L17_hi)\n            local T4_lo = XOR(D_lo, L22_lo)\n            local T4_hi = XOR(D_hi, L22_hi)\n            L02_lo = (T1_lo % 2^32 - T1_lo % 2^20) / 2^20 + T1_hi * 2^12\n            L02_hi = (T1_hi % 2^32 - T1_hi % 2^20) / 2^20 + T1_lo * 2^12\n            L07_lo = (T3_lo % 2^32 - T3_lo % 2^19) / 2^19 + T3_hi * 2^13\n            L07_hi = (T3_hi % 2^32 - T3_hi % 2^19) / 2^19 + T3_lo * 2^13\n            L12_lo = T0_lo * 2 + (T0_hi % 2^32 - T0_hi % 2^31) / 2^31\n            L12_hi = T0_hi * 2 + (T0_lo % 2^32 - T0_lo % 2^31) / 2^31\n            L17_lo = T2_lo * 2^10 + (T2_hi % 2^32 - T2_hi % 2^22) / 2^22\n            L17_hi = T2_hi * 2^10 + (T2_lo % 2^32 - T2_lo % 2^22) / 2^22\n            L22_lo = T4_lo * 2^2 + (T4_hi % 2^32 - T4_hi % 2^30) / 2^30\n            L22_hi = T4_hi * 2^2 + (T4_lo % 2^32 - T4_lo % 2^30) / 2^30\n            D_lo = XOR(C2_lo, C4_lo * 2 + (C4_hi % 2^32 - C4_hi % 2^31) / 2^31)\n            D_hi = XOR(C2_hi, C4_hi * 2 + (C4_lo % 2^32 - C4_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L03_lo)\n            T0_hi = XOR(D_hi, L03_hi)\n            T1_lo = XOR(D_lo, L08_lo)\n            T1_hi = XOR(D_hi, L08_hi)\n            T2_lo = XOR(D_lo, L13_lo)\n            T2_hi = XOR(D_hi, L13_hi)\n            T3_lo = XOR(D_lo, L18_lo)\n            T3_hi = XOR(D_hi, L18_hi)\n            T4_lo = XOR(D_lo, L23_lo)\n            T4_hi = XOR(D_hi, L23_hi)\n            L03_lo = (T2_lo % 2^32 - T2_lo % 2^21) / 2^21 + T2_hi * 2^11\n            L03_hi = (T2_hi % 2^32 - T2_hi % 2^21) / 2^21 + T2_lo * 2^11\n            L08_lo = (T4_lo % 2^32 - T4_lo % 2^3) / 2^3 + T4_hi * 2^29 % 2^32\n            L08_hi = (T4_hi % 2^32 - T4_hi % 2^3) / 2^3 + T4_lo * 2^29 % 2^32\n            L13_lo = T1_lo * 2^6 + (T1_hi % 2^32 - T1_hi % 2^26) / 2^26\n            L13_hi = T1_hi * 2^6 + (T1_lo % 2^32 - T1_lo % 2^26) / 2^26\n            L18_lo = T3_lo * 2^15 + (T3_hi % 2^32 - T3_hi % 2^17) / 2^17\n            L18_hi = T3_hi * 2^15 + (T3_lo % 2^32 - T3_lo % 2^17) / 2^17\n            L23_lo = (T0_lo % 2^32 - T0_lo % 2^2) / 2^2 + T0_hi * 2^30 % 2^32\n            L23_hi = (T0_hi % 2^32 - T0_hi % 2^2) / 2^2 + T0_lo * 2^30 % 2^32\n            D_lo = XOR(C3_lo, C5_lo * 2 + (C5_hi % 2^32 - C5_hi % 2^31) / 2^31)\n            D_hi = XOR(C3_hi, C5_hi * 2 + (C5_lo % 2^32 - C5_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L04_lo)\n            T0_hi = XOR(D_hi, L04_hi)\n            T1_lo = XOR(D_lo, L09_lo)\n            T1_hi = XOR(D_hi, L09_hi)\n            T2_lo = XOR(D_lo, L14_lo)\n            T2_hi = XOR(D_hi, L14_hi)\n            T3_lo = XOR(D_lo, L19_lo)\n            T3_hi = XOR(D_hi, L19_hi)\n            T4_lo = XOR(D_lo, L24_lo)\n            T4_hi = XOR(D_hi, L24_hi)\n            L04_lo = T3_lo * 2^21 % 2^32 + (T3_hi % 2^32 - T3_hi % 2^11) / 2^11\n            L04_hi = T3_hi * 2^21 % 2^32 + (T3_lo % 2^32 - T3_lo % 2^11) / 2^11\n            L09_lo = T0_lo * 2^28 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^4) / 2^4\n            L09_hi = T0_hi * 2^28 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^4) / 2^4\n            L14_lo = T2_lo * 2^25 % 2^32 + (T2_hi % 2^32 - T2_hi % 2^7) / 2^7\n            L14_hi = T2_hi * 2^25 % 2^32 + (T2_lo % 2^32 - T2_lo % 2^7) / 2^7\n            L19_lo = (T4_lo % 2^32 - T4_lo % 2^8) / 2^8 + T4_hi * 2^24 % 2^32\n            L19_hi = (T4_hi % 2^32 - T4_hi % 2^8) / 2^8 + T4_lo * 2^24 % 2^32\n            L24_lo = (T1_lo % 2^32 - T1_lo % 2^9) / 2^9 + T1_hi * 2^23 % 2^32\n            L24_hi = (T1_hi % 2^32 - T1_hi % 2^9) / 2^9 + T1_lo * 2^23 % 2^32\n            D_lo = XOR(C4_lo, C1_lo * 2 + (C1_hi % 2^32 - C1_hi % 2^31) / 2^31)\n            D_hi = XOR(C4_hi, C1_hi * 2 + (C1_lo % 2^32 - C1_lo % 2^31) / 2^31)\n            T0_lo = XOR(D_lo, L05_lo)\n            T0_hi = XOR(D_hi, L05_hi)\n            T1_lo = XOR(D_lo, L10_lo)\n            T1_hi = XOR(D_hi, L10_hi)\n            T2_lo = XOR(D_lo, L15_lo)\n            T2_hi = XOR(D_hi, L15_hi)\n            T3_lo = XOR(D_lo, L20_lo)\n            T3_hi = XOR(D_hi, L20_hi)\n            T4_lo = XOR(D_lo, L25_lo)\n            T4_hi = XOR(D_hi, L25_hi)\n            L05_lo = T4_lo * 2^14 + (T4_hi % 2^32 - T4_hi % 2^18) / 2^18\n            L05_hi = T4_hi * 2^14 + (T4_lo % 2^32 - T4_lo % 2^18) / 2^18\n            L10_lo = T1_lo * 2^20 % 2^32 + (T1_hi % 2^32 - T1_hi % 2^12) / 2^12\n            L10_hi = T1_hi * 2^20 % 2^32 + (T1_lo % 2^32 - T1_lo % 2^12) / 2^12\n            L15_lo = T3_lo * 2^8 + (T3_hi % 2^32 - T3_hi % 2^24) / 2^24\n            L15_hi = T3_hi * 2^8 + (T3_lo % 2^32 - T3_lo % 2^24) / 2^24\n            L20_lo = T0_lo * 2^27 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^5) / 2^5\n            L20_hi = T0_hi * 2^27 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^5) / 2^5\n            L25_lo = (T2_lo % 2^32 - T2_lo % 2^25) / 2^25 + T2_hi * 2^7\n            L25_hi = (T2_hi % 2^32 - T2_hi % 2^25) / 2^25 + T2_lo * 2^7\n            D_lo = XOR(C5_lo, C2_lo * 2 + (C2_hi % 2^32 - C2_hi % 2^31) / 2^31)\n            D_hi = XOR(C5_hi, C2_hi * 2 + (C2_lo % 2^32 - C2_lo % 2^31) / 2^31)\n            T1_lo = XOR(D_lo, L06_lo)\n            T1_hi = XOR(D_hi, L06_hi)\n            T2_lo = XOR(D_lo, L11_lo)\n            T2_hi = XOR(D_hi, L11_hi)\n            T3_lo = XOR(D_lo, L16_lo)\n            T3_hi = XOR(D_hi, L16_hi)\n            T4_lo = XOR(D_lo, L21_lo)\n            T4_hi = XOR(D_hi, L21_hi)\n            L06_lo = T2_lo * 2^3 + (T2_hi % 2^32 - T2_hi % 2^29) / 2^29\n            L06_hi = T2_hi * 2^3 + (T2_lo % 2^32 - T2_lo % 2^29) / 2^29\n            L11_lo = T4_lo * 2^18 + (T4_hi % 2^32 - T4_hi % 2^14) / 2^14\n            L11_hi = T4_hi * 2^18 + (T4_lo % 2^32 - T4_lo % 2^14) / 2^14\n            L16_lo = (T1_lo % 2^32 - T1_lo % 2^28) / 2^28 + T1_hi * 2^4\n            L16_hi = (T1_hi % 2^32 - T1_hi % 2^28) / 2^28 + T1_lo * 2^4\n            L21_lo = (T3_lo % 2^32 - T3_lo % 2^23) / 2^23 + T3_hi * 2^9\n            L21_hi = (T3_hi % 2^32 - T3_hi % 2^23) / 2^23 + T3_lo * 2^9\n            L01_lo = XOR(D_lo, L01_lo)\n            L01_hi = XOR(D_hi, L01_hi)\n            L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = XOR(L01_lo, AND(-1-L02_lo, L03_lo)), XOR(L02_lo, AND(-1-L03_lo, L04_lo)), XOR(L03_lo, AND(-1-L04_lo, L05_lo)), XOR(L04_lo, AND(-1-L05_lo, L01_lo)), XOR(L05_lo, AND(-1-L01_lo, L02_lo))\n            L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = XOR(L01_hi, AND(-1-L02_hi, L03_hi)), XOR(L02_hi, AND(-1-L03_hi, L04_hi)), XOR(L03_hi, AND(-1-L04_hi, L05_hi)), XOR(L04_hi, AND(-1-L05_hi, L01_hi)), XOR(L05_hi, AND(-1-L01_hi, L02_hi))\n            L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = XOR(L09_lo, AND(-1-L10_lo, L06_lo)), XOR(L10_lo, AND(-1-L06_lo, L07_lo)), XOR(L06_lo, AND(-1-L07_lo, L08_lo)), XOR(L07_lo, AND(-1-L08_lo, L09_lo)), XOR(L08_lo, AND(-1-L09_lo, L10_lo))\n            L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = XOR(L09_hi, AND(-1-L10_hi, L06_hi)), XOR(L10_hi, AND(-1-L06_hi, L07_hi)), XOR(L06_hi, AND(-1-L07_hi, L08_hi)), XOR(L07_hi, AND(-1-L08_hi, L09_hi)), XOR(L08_hi, AND(-1-L09_hi, L10_hi))\n            L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = XOR(L12_lo, AND(-1-L13_lo, L14_lo)), XOR(L13_lo, AND(-1-L14_lo, L15_lo)), XOR(L14_lo, AND(-1-L15_lo, L11_lo)), XOR(L15_lo, AND(-1-L11_lo, L12_lo)), XOR(L11_lo, AND(-1-L12_lo, L13_lo))\n            L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = XOR(L12_hi, AND(-1-L13_hi, L14_hi)), XOR(L13_hi, AND(-1-L14_hi, L15_hi)), XOR(L14_hi, AND(-1-L15_hi, L11_hi)), XOR(L15_hi, AND(-1-L11_hi, L12_hi)), XOR(L11_hi, AND(-1-L12_hi, L13_hi))\n            L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = XOR(L20_lo, AND(-1-L16_lo, L17_lo)), XOR(L16_lo, AND(-1-L17_lo, L18_lo)), XOR(L17_lo, AND(-1-L18_lo, L19_lo)), XOR(L18_lo, AND(-1-L19_lo, L20_lo)), XOR(L19_lo, AND(-1-L20_lo, L16_lo))\n            L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = XOR(L20_hi, AND(-1-L16_hi, L17_hi)), XOR(L16_hi, AND(-1-L17_hi, L18_hi)), XOR(L17_hi, AND(-1-L18_hi, L19_hi)), XOR(L18_hi, AND(-1-L19_hi, L20_hi)), XOR(L19_hi, AND(-1-L20_hi, L16_hi))\n            L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = XOR(L23_lo, AND(-1-L24_lo, L25_lo)), XOR(L24_lo, AND(-1-L25_lo, L21_lo)), XOR(L25_lo, AND(-1-L21_lo, L22_lo)), XOR(L21_lo, AND(-1-L22_lo, L23_lo)), XOR(L22_lo, AND(-1-L23_lo, L24_lo))\n            L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = XOR(L23_hi, AND(-1-L24_hi, L25_hi)), XOR(L24_hi, AND(-1-L25_hi, L21_hi)), XOR(L25_hi, AND(-1-L21_hi, L22_hi)), XOR(L21_hi, AND(-1-L22_hi, L23_hi)), XOR(L22_hi, AND(-1-L23_hi, L24_hi))\n            L01_lo = XOR(L01_lo, RC_lo[round_idx])\n            L01_hi = L01_hi + RC_hi[round_idx]      -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR\n         end\n         lanes_lo[1]  = L01_lo\n         lanes_hi[1]  = L01_hi\n         lanes_lo[2]  = L02_lo\n         lanes_hi[2]  = L02_hi\n         lanes_lo[3]  = L03_lo\n         lanes_hi[3]  = L03_hi\n         lanes_lo[4]  = L04_lo\n         lanes_hi[4]  = L04_hi\n         lanes_lo[5]  = L05_lo\n         lanes_hi[5]  = L05_hi\n         lanes_lo[6]  = L06_lo\n         lanes_hi[6]  = L06_hi\n         lanes_lo[7]  = L07_lo\n         lanes_hi[7]  = L07_hi\n         lanes_lo[8]  = L08_lo\n         lanes_hi[8]  = L08_hi\n         lanes_lo[9]  = L09_lo\n         lanes_hi[9]  = L09_hi\n         lanes_lo[10] = L10_lo\n         lanes_hi[10] = L10_hi\n         lanes_lo[11] = L11_lo\n         lanes_hi[11] = L11_hi\n         lanes_lo[12] = L12_lo\n         lanes_hi[12] = L12_hi\n         lanes_lo[13] = L13_lo\n         lanes_hi[13] = L13_hi\n         lanes_lo[14] = L14_lo\n         lanes_hi[14] = L14_hi\n         lanes_lo[15] = L15_lo\n         lanes_hi[15] = L15_hi\n         lanes_lo[16] = L16_lo\n         lanes_hi[16] = L16_hi\n         lanes_lo[17] = L17_lo\n         lanes_hi[17] = L17_hi\n         lanes_lo[18] = L18_lo\n         lanes_hi[18] = L18_hi\n         lanes_lo[19] = L19_lo\n         lanes_hi[19] = L19_hi\n         lanes_lo[20] = L20_lo\n         lanes_hi[20] = L20_hi\n         lanes_lo[21] = L21_lo\n         lanes_hi[21] = L21_hi\n         lanes_lo[22] = L22_lo\n         lanes_hi[22] = L22_hi\n         lanes_lo[23] = L23_lo\n         lanes_hi[23] = L23_hi\n         lanes_lo[24] = L24_lo\n         lanes_hi[24] = L24_hi\n         lanes_lo[25] = L25_lo\n         lanes_hi[25] = L25_hi\n      end\n   end\n\nend\n\n\n--------------------------------------------------------------------------------\n-- MAGIC NUMBERS CALCULATOR\n--------------------------------------------------------------------------------\n-- Q:\n--    Is 53-bit \"double\" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?\n-- A:\n--    Yes, 53-bit \"double\" arithmetic is enough.\n--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton\'s method.\n\ndo\n   local function mul(src1, src2, factor, result_length)\n      -- src1, src2 - long integers (arrays of digits in base 2^24)\n      -- factor - small integer\n      -- returns long integer result (src1 * src2 * factor) and its floating point approximation\n      local result, carry, value, weight = {}, 0.0, 0.0, 1.0\n      for j = 1, result_length do\n         for k = math_max(1, j + 1 - #src2), math_min(j, #src1) do\n            carry = carry + factor * src1[k] * src2[j + 1 - k]  -- \"int32\" is not enough for multiplication result, that\'s why \"factor\" must be of type \"double\"\n         end\n         local digit = carry % 2^24\n         result[j] = floor(digit)\n         carry = (carry - digit) / 2^24\n         value = value + digit * weight\n         weight = weight * 2^24\n      end\n      return result, value\n   end\n\n   local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo\n   repeat\n      p = p + step[p % 6]\n      local d = 1\n      repeat\n         d = d + step[d % 6]\n         if d*d > p then -- next prime number is found\n            local root = p^(1/3)\n            local R = root * 2^40\n            R = mul({R - R % 1}, one, 1.0, 2)\n            local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)\n            local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n            local lo = R[1] % 256 * 16777216 + floor(delta * (2^-56 / 3) * root / p)\n            if idx < 16 then\n               root = p^(1/2)\n               R = root * 2^40\n               R = mul({R - R % 1}, one, 1.0, 2)\n               _, delta = mul(R, R, -1.0, 2)\n               local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)\n               local lo = R[1] % 256 * 16777216 + floor(delta * 2^-17 / root)\n               local idx = idx % 8 + 1\n               sha2_H_ext256[224][idx] = lo\n               sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor\n               if idx > 7 then\n                  sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]\n               end\n            end\n            idx = idx + 1\n            sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor\n            break\n         end\n      until p % d == 0\n   until idx > 79\nend\n\n-- Calculating IVs for SHA512/224 and SHA512/256\nfor width = 224, 256, 32 do\n   local H_lo, H_hi = {}\n   if XOR64A5 then\n      for j = 1, 8 do\n         H_lo[j] = XOR64A5(sha2_H_lo[j])\n      end\n   else\n      H_hi = {}\n      for j = 1, 8 do\n         H_lo[j] = XOR32A5(sha2_H_lo[j])\n         H_hi[j] = XOR32A5(sha2_H_hi[j])\n      end\n   end\n   sha512_feed_128(H_lo, H_hi, \"SHA-512/\"..tostring(width)..\"\\128\"..string_rep(\"\\0\", 115)..\"\\88\", 0, 128)\n   sha2_H_ext512_lo[width] = H_lo\n   sha2_H_ext512_hi[width] = H_hi\nend\n\n-- Constants for MD5\ndo\n   local sin, abs, modf = math.sin, math.abs, math.modf\n   for idx = 1, 64 do\n      -- we can\'t use formula floor(abs(sin(idx))*2^32) because its result may be beyond integer range on Lua built with 32-bit integers\n      local hi, lo = modf(abs(sin(idx)) * 2^16)\n      md5_K[idx] = hi * 65536 + floor(lo * 2^16)\n   end\nend\n\n-- Constants for SHA3\ndo\n   local sh_reg = 29\n   local function next_bit()\n      local r = sh_reg % 2\n      sh_reg = XOR_BYTE((sh_reg - r) / 2, 142 * r)\n      return r\n   end\n   for idx = 1, 24 do\n      local lo, m = 0\n      for _ = 1, 6 do\n         m = m and m * m * 2 or 1\n         lo = lo + next_bit() * m\n      end\n      local hi = next_bit() * m\n      sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak\n   end\nend\n\n\n--------------------------------------------------------------------------------\n-- MAIN FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal function sha256ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(sha2_H_ext256[width])}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha256_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha256_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process 2^53 bytes of data by using this Lua script :-)\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha256_feed_64(H, final_blocks, 0, #final_blocks)\n            local max_reg = width / 32\n            for j = 1, max_reg do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H, \"\", 1, max_reg)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA256 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha512ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local length, tail, H_lo, H_hi = 0.0, \"\", {unpack(sha2_H_ext512_lo[width])}, not HEX64 and {unpack(sha2_H_ext512_hi[width])}\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 128 then\n               offs = 128 - #tail\n               sha512_feed_128(H_lo, H_hi, tail..sub(message_part, 1, offs), 0, 128)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 128\n            sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-17-length) % 128 + 9)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-17 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move floating point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)\n            local max_reg = ceil(width / 64)\n            if HEX64 then\n               for j = 1, max_reg do\n                  H_lo[j] = HEX64(H_lo[j])\n               end\n            else\n               for j = 1, max_reg do\n                  H_lo[j] = HEX(H_hi[j])..HEX(H_lo[j])\n               end\n               H_hi = nil\n            end\n            H_lo = sub(table_concat(H_lo, \"\", 1, max_reg), 1, width / 4)\n         end\n         return H_lo\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA512 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function md5(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H, 1, 4)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               md5_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            md5_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64)}\n            tail = nil\n            length = length * 8  -- convert \"byte-counter\" to \"bit-counter\"\n            for j = 4, 11 do\n               local low_byte = length % 256\n               final_blocks[j] = char(low_byte)\n               length = (length - low_byte) / 256\n            end\n            final_blocks = table_concat(final_blocks)\n            md5_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 4 do\n               H[j] = HEX(H[j])\n            end\n            H = gsub(table_concat(H), \"(..)(..)(..)(..)\", \"%4%3%2%1\")\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the MD5 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function sha1(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha1_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha1_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 / 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha1_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 5 do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA-1 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)\n   -- \"block_size_in_bytes\" is multiple of 8\n   if type(digest_size_in_bytes) ~= \"number\" then\n      -- arguments in SHAKE are swapped:\n      --    NIST FIPS 202 defines SHAKE(message,num_bits)\n      --    this module   defines SHAKE(num_bytes,message)\n      -- it\'s easy to forget about this swap, hence the check\n      error(\"Argument \'digest_size_in_bytes\' must be a number\", 2)\n   end\n\n   -- Create an instance (private objects for current calculation)\n   local tail, lanes_lo, lanes_hi = \"\", create_array_of_lanes(), hi_factor_keccak == 0 and create_array_of_lanes()\n   local result\n\n--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),\n--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)\n--~     initialize the state S to a string of b 0 bits.\n--~     absorb the input into the state: For each block Pi,\n--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,\n--~         XOR that with S and\n--~         apply the block permutation f to the result, yielding a new state S\n--~     initialize Z to be the empty string\n--~     while the length of Z is less than d:\n--~         append the first r bits of S to Z\n--~         if Z is still less than d bits long, apply f to S, yielding a new state S.\n--~     truncate Z to d bits\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= block_size_in_bytes then\n               offs = block_size_in_bytes - #tail\n               keccak_feed(lanes_lo, lanes_hi, tail..sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % block_size_in_bytes\n            keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            -- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1\n            local gap_start = is_SHAKE and 31 or 6\n            tail = tail..(#tail + 1 == block_size_in_bytes and char(gap_start + 128) or char(gap_start)..string_rep(\"\\0\", (-2 - #tail) % block_size_in_bytes)..\"\\128\")\n            keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)\n            tail = nil\n\n            local lanes_used = 0\n            local total_lanes = floor(block_size_in_bytes / 8)\n            local qwords = {}\n\n            local function get_next_qwords_of_digest(qwords_qty)\n               -- returns not more than \'qwords_qty\' qwords (\'qwords_qty\' might be non-integer)\n               -- doesn\'t go across keccak-buffer boundary\n               -- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords\n               if lanes_used >= total_lanes then\n                  keccak_feed(lanes_lo, lanes_hi, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 0, 8, 8)\n                  lanes_used = 0\n               end\n               qwords_qty = floor(math_min(qwords_qty, total_lanes - lanes_used))\n               if hi_factor_keccak ~= 0 then\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])\n                  end\n               else\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX(lanes_hi[lanes_used + j])..HEX(lanes_lo[lanes_used + j])\n                  end\n               end\n               lanes_used = lanes_used + qwords_qty\n               return\n                  gsub(table_concat(qwords, \"\", 1, qwords_qty), \"(..)(..)(..)(..)(..)(..)(..)(..)\", \"%8%7%6%5%4%3%2%1\"),\n                  qwords_qty * 8\n            end\n\n            local parts = {}      -- digest parts\n            local last_part, last_part_size = \"\", 0\n\n            local function get_next_part_of_digest(bytes_needed)\n               -- returns \'bytes_needed\' bytes, for arbitrary integer \'bytes_needed\'\n               bytes_needed = bytes_needed or 1\n               if bytes_needed <= last_part_size then\n                  last_part_size = last_part_size - bytes_needed\n                  local part_size_in_nibbles = bytes_needed * 2\n                  local result = sub(last_part, 1, part_size_in_nibbles)\n                  last_part = sub(last_part, part_size_in_nibbles + 1)\n                  return result\n               end\n               local parts_qty = 0\n               if last_part_size > 0 then\n                  parts_qty = 1\n                  parts[parts_qty] = last_part\n                  bytes_needed = bytes_needed - last_part_size\n               end\n               -- repeats until the length is enough\n               while bytes_needed >= 8 do\n                  local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = next_part\n                  bytes_needed = bytes_needed - next_part_size\n               end\n               if bytes_needed > 0 then\n                  last_part, last_part_size = get_next_qwords_of_digest(1)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = get_next_part_of_digest(bytes_needed)\n               else\n                  last_part, last_part_size = \"\", 0\n               end\n               return table_concat(parts, \"\", 1, parts_qty)\n            end\n\n            if digest_size_in_bytes < 0 then\n               result = get_next_part_of_digest\n            else\n               result = get_next_part_of_digest(digest_size_in_bytes)\n            end\n\n         end\n         return result\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA3 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal hex2bin, bin2base64, base642bin\ndo\n\n   function hex2bin(hex_string)\n      return (gsub(hex_string, \"%x%x\",\n         function (hh)\n            return char(tonumber(hh, 16))\n         end\n      ))\n   end\n\n   local base64_symbols = {\n      [\'+\'] = 62, [\'-\'] = 62,  [62] = \'+\',\n      [\'/\'] = 63, [\'_\'] = 63,  [63] = \'/\',\n      [\'=\'] = -1, [\'.\'] = -1,  [-1] = \'=\'\n   }\n   local symbol_index = 0\n   for j, pair in ipairs{\'AZ\', \'az\', \'09\'} do\n      for ascii = byte(pair), byte(pair, 2) do\n         local ch = char(ascii)\n         base64_symbols[ch] = symbol_index\n         base64_symbols[symbol_index] = ch\n         symbol_index = symbol_index + 1\n      end\n   end\n\n   function bin2base64(binary_string)\n      local result = {}\n      for pos = 1, #binary_string, 3 do\n         local c1, c2, c3, c4 = byte(sub(binary_string, pos, pos + 2)..\'\\0\', 1, -1)\n         result[#result + 1] =\n            base64_symbols[floor(c1 / 4)]\n            ..base64_symbols[c1 % 4 * 16 + floor(c2 / 16)]\n            ..base64_symbols[c3 and c2 % 16 * 4 + floor(c3 / 64) or -1]\n            ..base64_symbols[c4 and c3 % 64 or -1]\n      end\n      return table_concat(result)\n   end\n\n   function base642bin(base64_string)\n      local result, chars_qty = {}, 3\n      for pos, ch in gmatch(gsub(base64_string, \'%s+\', \'\'), \'()(.)\') do\n         local code = base64_symbols[ch]\n         if code < 0 then\n            chars_qty = chars_qty - 1\n            code = 0\n         end\n         local idx = pos % 4\n         if idx > 0 then\n            result[-idx] = code\n         else\n            local c1 = result[-1] * 4 + floor(result[-2] / 16)\n            local c2 = (result[-2] % 16) * 16 + floor(result[-3] / 4)\n            local c3 = (result[-3] % 4) * 64 + code\n            result[#result + 1] = sub(char(c1, c2, c3), 1, chars_qty)\n         end\n      end\n      return table_concat(result)\n   end\n\nend\n\n\nlocal block_size_for_HMAC  -- this table will be initialized at the end of the module\n\nlocal function pad_and_xor(str, result_length, byte_for_xor)\n   return gsub(str, \".\",\n      function(c)\n         return char(XOR_BYTE(byte(c), byte_for_xor))\n      end\n   )..string_rep(char(byte_for_xor), result_length - #str)\nend\n\nlocal function hmac(hash_func, key, message)\n\n   -- Create an instance (private objects for current calculation)\n   local block_size = block_size_for_HMAC[hash_func]\n   if not block_size then\n      error(\"Unknown hash function\", 2)\n   end\n   if #key > block_size then\n      key = hex2bin(hash_func(key))\n   end\n   local append = hash_func()(pad_and_xor(key, block_size, 0x36))\n   local result\n\n   local function partial(message_part)\n      if not message_part then\n         result = result or hash_func(pad_and_xor(key, block_size, 0x5C)..hex2bin(append()))\n         return result\n      elseif result then\n         error(\"Adding more chunks is not allowed after receiving the result\", 2)\n      else\n         append(message_part)\n         return partial\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the HMAC of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading of a message\n      -- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nlocal sha = {\n   md5        = md5,                                                                                                                   -- MD5\n   sha1       = sha1,                                                                                                                  -- SHA-1\n   -- SHA2 hash functions:\n   sha224     = function (message)                       return sha256ext(224, message)                                           end, -- SHA-224\n   sha256     = function (message)                       return sha256ext(256, message)                                           end, -- SHA-256\n   sha512_224 = function (message)                       return sha512ext(224, message)                                           end, -- SHA-512/224\n   sha512_256 = function (message)                       return sha512ext(256, message)                                           end, -- SHA-512/256\n   sha384     = function (message)                       return sha512ext(384, message)                                           end, -- SHA-384\n   sha512     = function (message)                       return sha512ext(512, message)                                           end, -- SHA-512\n   -- SHA3 hash functions:\n   sha3_224   = function (message)                       return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)             end, -- SHA3-224\n   sha3_256   = function (message)                       return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)             end, -- SHA3-256\n   sha3_384   = function (message)                       return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)             end, -- SHA3-384\n   sha3_512   = function (message)                       return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)             end, -- SHA3-512\n   shake128   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message) end, -- SHAKE128\n   shake256   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message) end, -- SHAKE256\n   -- misc utilities:\n   hmac       = hmac,       -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*\n   hex2bin    = hex2bin,    -- converts hexadecimal representation to binary string\n   base642bin = base642bin, -- converts base64 representation to binary string\n   bin2base64 = bin2base64, -- converts binary string to base64 representation\n}\n\n\nblock_size_for_HMAC = {\n   [sha.md5]        = 64,\n   [sha.sha1]       = 64,\n   [sha.sha224]     = 64,\n   [sha.sha256]     = 64,\n   [sha.sha512_224] = 128,\n   [sha.sha512_256] = 128,\n   [sha.sha384]     = 128,\n   [sha.sha512]     = 128,\n   [sha.sha3_224]   = (1600 - 2 * 224) / 8,\n   [sha.sha3_256]   = (1600 - 2 * 256) / 8,\n   [sha.sha3_384]   = (1600 - 2 * 384) / 8,\n   [sha.sha3_512]   = (1600 - 2 * 512) / 8,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\nlocal function shorthash(str)\n   if #str < 64 then return str end\n   return sub(sha512ext(512, str),1,64)\nend\n\nsha.shorthash = shorthash\n\n\n\n\nreturn sha\n\n",
},
  { 
vc_hash = "d31dea4de2be9c05523e1400add66ca6ba91a3fd",
name = "serpent",
hash = "bce8a2084abbd67bb6a1c1f76dd58e4dc32b614301f049430f252f0da0004282",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\nlocal n, v = \"serpent\", \"0.302\" -- (C) 2012-18 Paul Kulchenko; MIT License\nlocal c, d = \"Paul Kulchenko\", \"Lua serializer and pretty printer\"\nlocal snum = {[tostring(1/0)]=\'1/0 --[[math.huge]]\',[tostring(-1/0)]=\'-1/0 --[[-math.huge]]\',[tostring(0/0)]=\'0/0\'}\nlocal badtype = {thread = true, userdata = true, cdata = true}\nlocal getmetatable = debug and debug.getmetatable or getmetatable\nlocal pairs = function(t) return next, t end -- avoid using __pairs in Lua 5.2+\nlocal keyword, globals, G = {}, {}, (_G or _ENV)\nfor _,k in ipairs({\'and\', \'break\', \'do\', \'else\', \'elseif\', \'end\', \'false\',\n  \'for\', \'function\', \'goto\', \'if\', \'in\', \'local\', \'nil\', \'not\', \'or\', \'repeat\',\n  \'return\', \'then\', \'true\', \'until\', \'while\'}) do keyword[k] = true end\nfor k,v in pairs(G) do globals[v] = k end -- build func to name mapping\nfor _,g in ipairs({\'coroutine\', \'debug\', \'io\', \'math\', \'string\', \'table\', \'os\'}) do\n  for k,v in pairs(type(G[g]) == \'table\' and G[g] or {}) do globals[v] = g..\'.\'..k end end\n\nlocal function s(t, opts)\n  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum\n  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge\n  local space, maxl = (opts.compact and \'\' or \' \'), (opts.maxlevel or math.huge)\n  local maxlen, metatostring = tonumber(opts.maxlength), opts.metatostring\n  local iname, comm = \'_\'..(name or \'\'), opts.comment and (tonumber(opts.comment) or math.huge)\n  local numformat = opts.numformat or \"%.17g\"\n  local seen, sref, syms, symn = {}, {\'local \'..iname..\'={}\'}, {}, 0\n  local function gensym(val) return \'_\'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\n    -- tostring(val) is needed because __tostring may return a non-string value\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end\n  local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end\n  local function comment(s,l) return comm and (l or 0) < comm and \' --[[\'..select(2, pcall(tostring, s))..\']]\' or \'\' end\n  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can\'t serialize \"..tostring(s)) end\n  local function safename(path, name) -- generates foo.bar, foo[3], or foo[\'b a r\']\n    local n = name == nil and \'\' or name\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\n    local safe = plain and n or \'[\'..safestr(n)..\']\'\n    return (path or \'\')..(plain and path and \'.\' or \'\')..safe, safe end\n  local alphanumsort = type(opts.sortkeys) == \'function\' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\n    local maxn, to = tonumber(n) or 12, {number = \'a\', string = \'b\'}\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\n    table.sort(k, function(a,b)\n      -- sort numeric keys first: k[key] is not nil for numerical keys\n      return (k[a] ~= nil and 0 or to[type(a)] or \'z\')..(tostring(a):gsub(\"%d+\",padnum))\n           < (k[b] ~= nil and 0 or to[type(b)] or \'z\')..(tostring(b):gsub(\"%d+\",padnum)) end) end\n  local function val2str(t, name, indent, insref, path, plainindex, level)\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\n    local spath, sname = safename(path, name)\n    local tag = plainindex and\n      ((type(name) == \"number\") and \'\' or name..space..\'=\'..space) or\n      (name ~= nil and sname..space..\'=\'..space or \'\')\n    if seen[t] then -- already seen this element\n      sref[#sref+1] = spath..space..\'=\'..space..seen[t]\n      return tag..\'nil\'..comment(\'ref\', level) end\n    -- protect from those cases where __tostring may fail\n    if type(mt) == \'table\' and metatostring ~= false then\n      local to, tr = pcall(function() return mt.__tostring(t) end)\n      local so, sr = pcall(function() return mt.__serialize(t) end)\n      if (to or so) then -- knows how to serialize itself\n        seen[t] = insref or spath\n        t = so and sr or tr\n        ttype = type(t)\n      end -- new value falls through to be serialized\n    end\n    if ttype == \"table\" then\n      if level >= maxl then return tag..\'{}\'..comment(\'maxlvl\', level) end\n      seen[t] = insref or spath\n      if next(t) == nil then return tag..\'{}\'..comment(t, level) end -- table empty\n      if maxlen and maxlen < 0 then return tag..\'{}\'..comment(\'maxlen\', level) end\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\n      for key = 1, maxn do o[key] = key end\n      if not maxnum or #o < maxnum then\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\n      for n, key in ipairs(o) do\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\n        or opts.keyallow and not opts.keyallow[key]\n        or opts.keyignore and opts.keyignore[key]\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\n        or sparse and value == nil then -- skipping nils; do nothing\n        elseif ktype == \'table\' or ktype == \'function\' or badtype[ktype] then\n          if not seen[key] and not globals[key] then\n            sref[#sref+1] = \'placeholder\'\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\n          sref[#sref+1] = \'placeholder\'\n          local path = seen[t]..\'[\'..tostring(seen[key] or globals[key] or gensym(key))..\']\'\n          sref[#sref] = path..space..\'=\'..space..tostring(seen[value] or val2str(value,nil,indent,path))\n        else\n          out[#out+1] = val2str(value,key,indent,nil,seen[t],plainindex,level+1)\n          if maxlen then\n            maxlen = maxlen - #out[#out]\n            if maxlen < 0 then break end\n          end\n        end\n      end\n      local prefix = string.rep(indent or \'\', level)\n      local head = indent and \'{\\n\'..prefix..indent or \'{\'\n      local body = table.concat(out, \',\'..(indent and \'\\n\'..prefix..indent or space))\n      local tail = indent and \"\\n\"..prefix..\'}\' or \'}\'\n      return (custom and custom(tag,head,body,tail,level) or tag..head..body..tail)..comment(t, level)\n    elseif badtype[ttype] then\n      seen[t] = insref or spath\n      return tag..globerr(t, level)\n    elseif ttype == \'function\' then\n      seen[t] = insref or spath\n      if opts.nocode then return tag..\"function() --[[..skipped..]] end\"..comment(t, level) end\n      local ok, res = pcall(string.dump, t)\n      local func = ok and \"((loadstring or load)(\"..safestr(res)..\",\'@serialized\'))\"..comment(t, level)\n      return tag..(func or globerr(t, level))\n    else return tag..safestr(t) end -- handle all other types\n  end\n  local sepr = indent and \"\\n\" or \";\"..space\n  local body = val2str(t, name, indent) -- this call also populates sref\n  local tail = #sref>1 and table.concat(sref, sepr)..sepr or \'\'\n  local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or \'\'\n  return not name and body..warn or \"do local \"..body..sepr..tail..\"return \"..name..sepr..\"end\"\nend\n\nlocal function deserialize(data, opts)\n  opts = opts or {}\n  local env = (opts and opts.safe == false) and G\n    or setmetatable({}, {\n        __index = function(t,k) return t end,\n        __call = function(t,...) error(\"cannot call functions\") end\n      })\n  local ret = opts.noreturn and \'\' or \'return \'\n  local f, res = (loadstring or load)(ret..data, nil, nil, env)\n  if not f then f, res = (loadstring or load)(data, nil, nil, env) end\n  if not f then return f, res end\n  if setfenv then setfenv(f, env) end\n  local ok, res = pcall(f)\n  if ok then return res end\n  return nil, res\nend\n\nlocal function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end\nreturn { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,\n  load = deserialize,\n  import = function(bundle)\n              return deserialize(bundle, {noreturn = true})\n           end,\n  bundle = function(a, opts)\n              return \"return \" .. s(a, merge({ indent = \'  \',\n                                               sortkeys = true,\n                                               metatostring = false,\n                                               comment = false, }, opts))\n           end,\n  dump = function(a, opts) return s(a, merge({name = \'_\', compact = true, sparse = true}, opts)) end,\n  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,\n  block = function(a, opts) return s(a, merge({indent = \'  \', sortkeys = true, comment = true}, opts)) end }\n\n",
},
} },
{
  project = {
    repo = "git@gitlab.com:special-circumstance/valiant.git",
    repo_alternates = "https://gitlab.special-circumstanc.es/bridge-tools/valiant",
    home = "",
    website = "",
    name = "valiant",
    repo_type = "git",
},
  version = {    patch = 0,
    minor = 0,
    stage = "SNAPSHOT",
    major = 0,
    special = "no",
    edition = "",
},
  modules = {   { 
vc_hash = "762770881f9082bd98babed73d8504d88045e3a6",
name = "session",
hash = "56f295b43052808d099763a2c4941e745ad8ae8a7facafa5e42478b5140fa258",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njit.off()\nlocal uv = require \"luv\"\nlocal fn = require \"core:fn\"\nlocal Valiant = require \"valiant:valiant\"\nlocal kit = require \"valiant:replkit\"\nlocal persist_tabulate = require \"repr:repr/persist-tabulate\"\nlocal names = require \"repr:repr/names\"\nlocal tabulate = persist_tabulate.tabulate\nlocal result_M = persist_tabulate.db_result_M\nlocal ts = require \"repr:repr\" . ts_color\nlocal helm_db = require \"helm:helm/helm-db\"\nlocal Path = require \"fs:fs/path\"\nlocal Set = require \"set:set\"\nlocal sha = require \"util:sha\" . shorthash\n\nlocal a = require \"anterm:anterm\"\nlocal s = require \"status:status\"()\ns.chatty = true\ns.verbose = false\n\n\n\n\nlocal session = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal core = require \"core:core\"\nlocal names = require \"repr:repr/names\"\nnames.loadNames(package.loaded)\nnames.loadNames(_G)\nnames.loadNames({ core = core })\n\n\n\n\n\n\n\n\n\n\n\n\nlocal anti_G_M = {__index = assert(names.anti_G)}\n\n\n\nlocal insert = assert(table.insert)\n\nlocal function evalSessionById(stmts, session_id, run_deprecated)\n   -- #todo valiant should create a throwaway anti_G internally as well\n   local aG  = setmetatable({}, anti_G_M)\n   local eval_G = { core = core,\n                    kit  = kit }\n   local eval = Valiant(_G, eval_G, aG)\n   -- retrieve session\n   local sesh = stmts.get_session_by_id\n                        :bind(session_id) :resultset()\n   if not sesh then return nil end\n   -- run session again\n   local _session = { prem_count = 0, pass_count = 0 }\n   _session.session_title = sesh.session_title and sesh.session_title[1]\n   _session.session_id = sesh.session_id and sesh.session_id[1]\n   _session.project = sesh.project and sesh.project[1]\n   _session.accepted = sesh.session_accepted and sesh.session_accepted[1] ~= 0\n   -- bail on deprecated sessions\n   if (not _session.accepted) and (not run_deprecated) then return nil end\n\n   for i, line in ipairs(sesh.line) do\n      -- set up a container\n      _session[i] = {}\n      local premise = _session[i]\n      premise.ordinal = i\n      premise.status = sesh.status[i]\n      premise.title  = sesh.title[i]\n      premise.time = sesh.time[i]\n      premise.line = line\n      premise.same = false\n      -- re-evaluate line\n      local ok, result = eval(line)\n      -- handle error-type results here:\n\n      -- avoid empty results\n      if result.n > 0 then\n         if not result.error then\n            premise.new_result = tabulate(result, aG)\n         else\n            -- propagate error directly\n            premise.new_result = result\n         end\n      end\n      local old_repr = stmts.get_results :bind(sesh.line_id[i]) :resultset()\n      old_repr = old_repr and old_repr.repr\n      -- we do need to handle the absence of results, but for now:\n      if old_repr then\n         premise.old_result = old_repr or {}\n      end\n      -- might need to handle all four cases instead of just two...\n      if premise.new_result and premise.old_result then\n         local same = true\n         for j, res in ipairs(premise.new_result) do\n            same = same and premise.new_result[j] == premise.old_result[j]\n         end\n         premise.same = same\n      end\n\n      -- handle zero-result lines correctly:\n      if (not premise.old_result) and (not premise.new_result) then\n         premise.same = true\n      end\n      if premise.status == \'accept\' and premise.same then\n         premise.passed = true\n      end\n      if premise.status ~= \'ignore\' then\n         _session.prem_count = _session.prem_count + 1\n      end\n      if premise.passed then\n         _session.pass_count = _session.pass_count + 1\n      end\n   end\n   return _session, sesh\nend\n\nsession.evalSessionById = evalSessionById\n\n\n\n\n\n\n\n\nlocal function evalProjectById(stmts, project_id, run_all)\n   local session_ids = stmts.get_sessions_by_project\n                          :bind(project_id) :resultset()\n   if not session_ids then return end\n\n   local sessions = {}\n   for _, sesh in ipairs(session_ids.session_id) do\n      local result = evalSessionById(stmts, sesh, run_all) or {}\n      insert(sessions, result)\n   end\n   return sessions\nend\n\nsession.evalProjectById = evalProjectById\n\n\n\n\n\n\n\n\n\nlocal function evalProjectByDir(stmts, dir, run_all)\n   local project_id = stmts.get_project_by_dir :bind(dir) :value()\n   if not project_id then return end\n   return evalProjectById(stmts, project_id, run_all)\nend\n\nsession.evalProjectByDir = evalProjectByDir\n\n\n\n\n\n\n\n\nlocal function getSessionsByDir(stmts, dir)\n   dir = dir or uv.cwd()\n   local project_id = stmts.get_project_by_dir :bind(dir) :value()\n   if not project_id then return nil end\n   local iter = stmts.get_sessions_for_project :bind(project_id)\n   local sessions = {}\n   for sesh in iter:rows() do\n      sesh.accepted = sesh.accepted ~= 0\n      sessions[#sessions + 1] = sesh\n   end\n   return sessions\nend\n\nsession.getSessionsByDir = getSessionsByDir\n\n\n\n\n\n\n\n\n\n\nlocal function refineSessions(select_list, sessions)\n   local selected = {}\n   if type(select_list) == \'string\' then\n      for _, sesh in ipairs(sessions) do\n         s:verb(sesh.session_title)\n         if sesh.session_title == select_list then\n            insert(selected, sesh)\n         end\n      end\n   elseif type(select_list) == \'number\' then\n       insert(selected, sessions[select_list])\n   else\n      -- we have an array of either session indices (number),\n      -- or ranges (table).\n      -- we only want to update a session once, so we cache indices, in case\n      -- ranges overlap.\n      local idx_cache = Set()\n      for _, range in ipairs(select_list) do\n         if type(range) == \'number\' then\n            if not idx_cache(range) then\n               insert(selected, sessions[range])\n               idx_cache[range] = true\n            end\n         elseif type(range) == \'table\' then\n            local start, finish = range[1], range[2]\n            finish = type(finish) == \'number\' and finish or #sessions\n            for i = start, finish do\n               if not idx_cache(i) then\n                  insert(selected, sessions[i])\n                  idx_cache[i] = true\n               end\n            end\n         end\n      end\n   end\n   if #selected == 0 then\n      if type(select_list) == \'table\' then\n         s:warn(\"Didn\'t find sessions in that list\")\n      else\n         s:warn(\"Didn\'t find a session %s\", tostring(select_list))\n      end\n      return nil\n   end\n   return selected\nend\n\nsession.refineSessions = refineSessions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function updateSession(stmts, sesh)\n   local insert_line = stmts.insert_line\n   local insert_result_hash = stmts.insert_result_hash\n   local insert_repr = stmts.insert_repr\n   local update_premise = stmts.update_premise_line\n   for _, premise in ipairs(sesh) do\n      if (not premise.same) and premise.status == \'accept\' then\n         -- add line and new results to DB\n         insert_line :bind(sesh.project, premise.line, premise.time)\n                     :value()\n         local line_id = stmts.lastRowId()\n         for _, result in ipairs(premise.new_result) do\n            local hash = sha(result)\n            insert_repr :bind(hash, result) :value()\n            insert_result_hash :bind(line_id, hash) :value()\n         end\n         -- update premise to point at new line\n         update_premise :bind(line_id, sesh.session_id, premise.ordinal)\n                        :value()\n      end\n   end\nend\n\n\n\n\nlocal function updateSessions(stmts, args)\n   local will_update = refineSessions(args.to_update,\n                                      evalProjectByDir(stmts, uv.cwd()))\n   if not will_update then return end\n   -- begin transaction\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_update) do\n      updateSession(stmts, sesh)\n   end\n   -- commit transaction\n   stmts.commit()\nend\n\nsession.updateSessions = updateSessions\nsession.updateSession  = updateSession\n\n\n\n\n\n\nfunction deleteDeprecatedSessions(stmts, args)\n   local will_delete = refineSessions(args.to_delete, getSessionsByDir(stmts))\n   if not will_delete then return end\n   -- set up prepared statements\n   local delete_sesh = stmts.delete_session_by_id\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_delete) do\n      if sesh.accepted then\n         s:chat(\"Not deleting \\\"%s\\\" (accepted)\", sesh.session_title)\n      else\n         s:chat(\"Deleting \\\"%s\\\" (deprecated)\", sesh.session_title)\n         delete_sesh :bind(sesh.session_id) :value()\n      end\n   end\n   stmts.commit()\nend\n\n\n\n\nfunction deleteSessions(stmts, args)\n   local will_delete = refineSessions(args.to_delete, getSessionsByDir(stmts))\n   if not will_delete then return end\n   io.write \"Deleting sessions cannot be undone. Continue (y/n)? \"\n   if io.read():sub(1,1):lower() ~= \"y\" then\n      print \"Ok, bailing out.\"\n      return\n   end\n   -- set up prepared statements\n   local delete_sesh = stmts.delete_session_by_id\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_delete) do\n      s:chat(\"Deleting \\\"%s\\\"\", sesh.session_title)\n      delete_sesh :bind(sesh.session_id) :value()\n   end\n   stmts.commit()\nend\n\n\n\n\n\n\n\n\n\nfunction _alterAcceptance(accept, stmts, args)\n   local list = accept and args.to_accept or args.to_deprecate\n   local will_alter = refineSessions(list, getSessionsByDir(stmts))\n   if not will_alter then return end\n   local accept_sesh = stmts.update_accepted_session\n   stmts.beginTransaction()\n   for _, sesh in ipairs(will_alter) do\n      local state = accept and \"accepted\" or \"deprecated\"\n      s:chat(\"\\\"%s\\\" now %s\", sesh.session_title, state)\n      accept_sesh :bind(accept, sesh.session_id) :value()\n   end\n   stmts.commit()\nend\n\n\n\nlocal curry = assert(fn.curry)\n\nlocal acceptSessions = curry(_alterAcceptance, true)\nlocal deprecateSessions = curry(_alterAcceptance, false)\n\nsession.acceptSessions = acceptSessions\nsession.deprecateSessions = deprecateSessions\n\n\n\n\n\n\n\n\nfunction renameSession(stmts, args)\n   local sesh = refineSessions(args.old_name, getSessionsByDir(stmts))\n   if not sesh then\n      return\n   end\n   sesh = sesh[1]\n   stmts.update_title_session :bind(args.new_name, sesh.session_id) :step()\n   s:chat(\"%s is now \\\"%s\\\"\", args.old_name, args.new_name)\nend\n\nsession.renameSession = renameSession\n\n\n\n\n\n\n\n\n\nlocal Bundle, serpent;\n\nlocal function bundleSessions(stmts, args, dir)\n   Bundle = Bundle or require \"valiant:bundle\"\n   serpent = serpent or require \"util:serpent\"\n   dir = dir or uv.cwd()\n   local project = Path(dir):basename()\n   local list = args.to_export\n   local bundle = Bundle.create(stmts, project)\n   local sessions = refineSessions(list, getSessionsByDir(stmts, dir))\n   if not sessions then\n      return serpent.bundle(bundle)\n   end\n   for _, sesh in ipairs(sessions) do\n      Bundle.addSession(stmts, bundle, sesh)\n   end\n   return serpent.bundle(bundle)\nend\n\nsession.bundleSessions = bundleSessions\n\n\n\n\nlocal File;\n\nlocal function exportSessions(stmts, args, dir)\n   local bundle = bundleSessions(stmts, args, dir)\n   if args.outfile then\n      File = File or require \"fs:file\"\n      local out = File(args.outfile)\n      out:write(bundle)\n   else\n      io.stdout:write(bundle)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function loadBundle(args)\n   local bundle_str;\n   if not args.infile then\n      bundle_str = io.stdin:read \"*a\"\n   else\n      File = File or require \"fs:file\"\n      bundle_str = File(args.infile):read()\n   end\n   if not bundle_str then return nil end\n   serpent = serpent or require \"util:serpent\"\n   local bundle = serpent.load(bundle_str)\n   -- do something with it, to wit:\n   return bundle\nend\n\nsession.loadBundle = loadBundle\n\n\n\nlocal function importSession(stmts, sesh, project_id)\n   sesh.project_id = project_id\n   local existing_id = stmts.get_session_by_project_and_title\n                           :bind(project_id, sesh.session_title)\n                           :value()\n   if existing_id then\n      io.write((\'A session named \"%s\" already exists. \' ..\n                       \"Do you want to replace it (y/n)? \")\n                       :format(sesh.session_title))\n      if io.read():sub(1,1):lower() == \"y\" then\n         sesh.session_id = existing_id\n         stmts.update_session:bindkv(sesh):value()\n         -- Get rid of any extra premises in the old session. Existing ones\n         -- up to the length of the new session will be overwritten\n         stmts.truncate_session:bind(existing_id, #sesh):value()\n      else\n         -- Or bail out if the user said no\n         return nil\n      end\n   else\n      s:chat(\"Adding session: %s\", sesh.session_title)\n      stmts.insert_session:bindkv(sesh):value()\n      sesh.session_id = stmts.lastRowId()\n   end\n   for ordinal, premise in ipairs(sesh) do\n      stmts.insert_line :bind(project_id, premise.line, premise.time) :value()\n      local line_id = stmts.lastRowId()\n      -- add the results if any\n      local results = premise.results\n      for i = 1, results.n do\n         local hash = sha(results.repr[i])\n         stmts.insert_repr :bind(hash, results.repr[i]) :value()\n         stmts.insert_result_hash :bind(line_id, hash) :value()\n      end\n      -- add the premise\n      stmts.insert_premise\n         :bind(sesh.session_id, ordinal, line_id, premise.title, premise.status)\n         :value()\n   end\nend\n\n\n\nlocal fromkeys = assert(require \"core:table\" . fromkeys)\nlocal function importSessions(stmts, args)\n   local bundle = loadBundle(args)\n   if not bundle then\n      s:chat(\"Unable to read bundle\")\n      return nil\n   end\n   -- check version and bundle type\n   if not bundle.bundle_type == \'session\' then\n      s:halt(\"Don\'t know what to do with a bundle of type %s\",\n             bundle.bundle_type)\n   end\n   if not bundle.version == 1 then\n      s:halt(\"Can only import bundles with version 1\")\n   end\n   -- get all project directories\n   local project_info, n = stmts.get_project_info()\n   -- iterate until we find the project_id matching the basename\n   local project_id;\n   for i = 1, n do\n      local basename = Path(project_info.directory[i]):basename()\n      if basename == bundle.project then\n         project_id = project_info.project_id[i]\n         break\n      end\n   end\n   if not project_id then\n      s:chat(\"Unable to find project named %s\", bundle.project)\n      s:chat(\"Run `br helm` in %s\'s root directory to add it to the database\",\n             bundle.project)\n      return nil\n   end\n   stmts.beginTransaction()\n   -- prepare the statements we\'ll need, :value() will reset them\n   local prepared_stmts = fromkeys(stmts, \"get_session_by_project_and_title\",\n                                    \"update_session\", \"truncate_session\",\n                                    \"insert_session\", \"insert_line\",\n                                    \"insert_result_hash\", \"insert_repr\",\n                                    \"insert_premise\", \"lastRowId\")\n   for _, sesh in ipairs(bundle) do\n      importSession(prepared_stmts, sesh, project_id)\n   end\n   -- commit\n   stmts.commit()\n   return true\nend\n\nsession.importSessions = importSessions\nsession.importSession  = importSession\n\n\n\n\n\n\n\nlocal function printPremise(premise)\n   local no_title = premise.title ~= \"\"\n   local indent = \"   \"\n   local title = no_title and premise.title or \"«\" .. premise.line .. \"»\"\n   local passed = premise.same and \"✅ \" or \"❌ \"\n   if premise.status == \'reject\' then\n      passed = \"🚫 \"\n   end\n   if not (premise.status == \'ignore\') then\n      s:chat(indent .. passed .. title)\n      if (not premise.same) and premise.status ~= \'reject\' then\n         if not no_title then\n            s:chat(\"for `\" .. premise.line .. \"`:\")\n         end\n         s:chat(\"\\n\" .. indent .. \"expected:\")\n         s:chat(ts(setmetatable(premise.old_result, result_M)))\n         local new_result_ts = premise.new_result.error\n                               and premise.new_result[1]\n                               or ts(setmetatable(premise.new_result, result_M))\n         local nr_message = premise.new_result.error\n                            and \"received error:\"\n                            or  \"received:\"\n         s:chat(\"\\n\" .. indent .. nr_message)\n         s:chat(new_result_ts)\n      end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function listSessionsByProject(stmts, dir, print_accepted)\n   local sesh = stmts.get_session_list_by_dir :bind(dir)\n   local count_premises = stmts.count_premises\n   if not sesh then return nil end\n   for i, title, accepted, session_id in sesh:cols() do\n      -- cast accepted to a true boolean\n      accepted = accepted ~= 0 and true or false\n      local num_prems = count_premises :bind(session_id) :value()\n      if print_accepted then\n         local accept = accepted and \"▶️\" or \"⏸\"\n         s:chat(\"%s %3d: %s (%d)\", accept, i, title, num_prems or 0)\n      elseif accepted then\n         s:chat(\"%3d: %s (%d)\", i, title, num_prems or 0)\n      end\n   end\nend\n\n\n\n\n\n\n\nfunction printSession(sesh)\n   local prem_count, pass_count = sesh.prem_count, sesh.pass_count\n   -- skip empty sessions\n   if not prem_count then return end\n   local hl, gr = pass_count == prem_count and a.green or a.red, a.green\n   local prem_head = \"[\" .. hl(pass_count) .. \"/\" .. gr(prem_count) .. \"] \"\n   s:chat(a.bold(prem_head .. sesh.session_title))\n   for _, premise in ipairs(sesh) do\n      printPremise(premise)\n   end\nend\n\n\n\n\n\n\n\n\nfunction runSessionById(stmts, session_id)\n   local session = evalSessionById(stmts, session_id)\n   if not session then return nil end\n   printSession(session)\n   return session\nend\nsession.runSessionById = runSessionById\n\n\n\n\n\n\n\n\nfunction session.runProjectByDir(stmts, dir, run_all, to_refine)\n   local sessions;\n   if not to_refine then\n      sessions = evalProjectByDir(stmts, dir, run_all)\n   else\n      -- really we shouldn\'t run the other sessions at all\n      -- #Todo rewrite this so only selected sessions run\n      sessions = refineSessions(to_refine,\n                                evalProjectByDir(stmts, dir, run_all))\n   end\n   if not sessions then return end\n   local all_pass, all_prem = 0, 0\n   for _, sesh in ipairs(sessions) do\n      if sesh.pass_count then\n         all_pass = all_pass + sesh.pass_count\n         all_prem = all_prem + sesh.prem_count\n         printSession(sesh)\n      end\n   end\n   local hl, gr = all_pass == all_prem and a.green or a.red, a.green\n   local passphrase = a.bold(\"\\ntotal passed: [\"..hl\"%d\"..\"/\"..gr\"%d\"..\"]\")\n   s:chat(passphrase, all_pass, all_prem)\nend\n\n\n\n\n\n\n\n\n\n\nlocal function _runAllSessions(stmts, run_all)\n   -- obtain project list\n   local project_info = stmts.get_project_info()\n   if not project_info then return end\n   local project_ids, dirs = project_info.project_id, project_info.directory\n   local all_prem, all_pass = 0, 0\n   for i, proj_id in ipairs(project_ids) do\n      local session_ids = stmts.get_sessions_from_project\n                               :bind(proj_id)\n                               :resultset()\n      if session_ids then\n         local project = Path(dirs[i]):basename()\n         s:chat(\"\\n\" .. a.bold(project) .. \":\\n\")\n         local proj_prem, proj_pass = 0, 0\n         for j, session_id in ipairs(session_ids.session_id) do\n            if run_all or session_ids.accepted[j] == 1 then\n               local sesh = runSessionById(stmts, session_id)\n               if sesh then\n                  proj_prem = proj_prem + sesh.prem_count\n                  proj_pass = proj_pass + sesh.pass_count\n               end\n            end\n         end\n         local hl, gr = proj_pass == proj_prem and a.green or a.red, a.green\n         s:chat(a.bold(\"\\n\" .. hl(project)\n                .. \": [\" .. hl(proj_pass) .. \"/\" .. gr(proj_prem) .. \"]\\n\"))\n         all_prem = all_prem + proj_prem\n         all_pass = all_pass + proj_pass\n      end\n   end\n   local hl, gr = all_pass == all_prem and a.green or a.red, a.green\n   s:chat(a.bold(\"total passed: [\"\n                 .. hl(all_pass) .. \"/\" .. gr(all_prem) .. \"]\"))\nend\n\nfunction session.runAllSessions(stmts)\n   return _runAllSessions(stmts, true)\nend\n\n\n\n\n\n\n\n\n\n\nfunction session.runAllAcceptedSessions(stmts)\n   return _runAllSessions(stmts, false)\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction session.session(args, conn_handle)\n   local stmts = helm_db.session(conn_handle)\n   if args.all then\n      _runAllSessions(stmts, false)\n   -- other options go here, as we add them.\n   elseif args.accepted then\n      error \"NYI\"\n   elseif args.list then\n      if args.list_all then\n         listSessionsByProject(stmts, uv.cwd(), true)\n      else\n         listSessionsByProject(stmts, uv.cwd())\n      end\n   elseif args.to_update then\n      updateSessions(stmts, args)\n   elseif args.delete then\n      deleteDeprecatedSessions(stmts, args)\n   elseif args[\"force-delete\"] then\n      deleteSessions(stmts, args)\n   elseif args.accept then\n      acceptSessions(stmts, args)\n   elseif args.deprecate then\n      deprecateSessions(stmts, args)\n   elseif args.rename then\n      renameSession(stmts, args)\n   elseif args.export then\n      exportSessions(stmts, args)\n   elseif args.import then\n      importSessions(stmts, args)\n   else\n      session.runProjectByDir(stmts, uv.cwd(), args.every, args.some)\n   end\n   helm_db.close()\nend\n\n\n\njit.on()\nreturn session\n\n",
},
  { 
vc_hash = "762770881f9082bd98babed73d8504d88045e3a6",
name = "bundle",
hash = "968eecafb2e5518f6fccdd274923cb90f88a5ab1a69737afaaf0b71190973732",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Bundle = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Bundle.create(stmts, project)\n   return { version = 1,\n            bundle_type = \'session\',\n            project = project }\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Bundle.addSession(stmts, bundle, session)\n   local premise_stmt = stmts.get_premises_for_export :bindkv(session)\n   for premise in premise_stmt:rows() do\n       -- get results here\n       local results, n = stmts.get_results\n                             :bind(premise.line_id)\n                             :resultset()\n       if not results then\n          results = {n = 0}\n       else\n         results.n = n\n       end\n       premise.results = results\n       -- don\'t need the line_id any longer\n       premise.line_id = nil\n       session[#session + 1] = premise\n   end\n   -- remove parameters we don\'t want to export\n   session.session_id = nil\n   session.project = nil\n   bundle[#bundle + 1] = session\n   return bundle\nend\n\n\n\nreturn Bundle\n\n",
},
  { 
vc_hash = "762770881f9082bd98babed73d8504d88045e3a6",
name = "valiant",
hash = "d30f44e4755877fd7207236cf3f4310e4f0ffb1991a95c154740f7a0bd5a00ac",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\nlocal lua_parser = require \"helm/lua-parser\"\nlocal names = require \"repr:repr/names\"\n\nlocal meta = require \"core:core/meta\" . meta\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Valiant = meta {}\n\n\n\n\n\n\n\n\n\n\n\n\nlocal req = assert(require)\n\nlocal function _require(valiant, module)\n   if not valiant.restarting then\n      valiant.mods[module] = true\n      return req(module)\n   else\n      if valiant.cleared[module] then\n         return req(module)\n      end\n      local hash = _Bridge.load_hashes[module]\n      if not hash then\n         return req(module)\n      else\n         -- invalidate our various caches\n         package.loaded[module] = nil\n         _Bridge.loaded[hash] = nil\n         _Bridge.load_hashes[module] = nil\n         -- mark as cleared so we don\'t re-invalidate it\n         valiant.cleared[module] = true\n         return req(module)\n      end\n   end\nend\n\nlocal clear = assert(table.clear)\n\nfunction Valiant.restart(valiant)\n   clear(valiant.eval_env)\n   valiant.eval_env.require = valiant.require\n   valiant.restarting = true\nend\n\nfunction Valiant.reset(valiant)\n   valiant.cleared = {}\n   valiant.restarting = nil\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal pget = assert(require \"core:table\" . pget)\nlocal function make__index(env, env_2)\n   return function (eval_ENV, key)\n      local val = pget(env, key)\n      if not val and env_2 then\n         val = pget(env_2, key)\n      end\n      return val\n   end\nend\n\n\n\nlocal loadNames = assert(names.loadNames)\n\nlocal function make__newindex(anti_G)\n   return function (eval_ENV, key, value)\n      rawset(eval_ENV, key, value)\n      -- Use loadNames() to get the key added to all_symbols\n      loadNames({ [key] = value }, nil, anti_G)\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal sub = assert(string.sub)\n\nlocal function gatherResults(success, ...)\n  return success, pack(...)\nend\n\n\nfunction Valiant.__call(valiant, chunk)\n   -- check for leading =, old-school style\n   local head = sub(chunk, 1, 1)\n   if head == \"=\" then -- take pity on old-school Lua hackers\n       chunk = \"return \" .. sub(chunk,2)\n   end\n   -- add \"return\" and see if it parses\n   local return_chunk = \"return \" .. chunk\n   local parsed_chunk = lua_parser(return_chunk)\n   if not parsed_chunk:select \"Error\" () then\n      chunk = return_chunk\n   else\n      -- re-parse the chunk\n      parsed_chunk = lua_parser(chunk)\n   end\n   -- #Todo tinker with the chunk, finding $1-type vars\n   if parsed_chunk:select \"Error\" () then\n      -- our parser isn\'t perfect, let\'s see what lua thinks\n      local is_expr = loadstring(return_chunk)\n      if is_expr then\n         -- we have an expression which needs a return, and didn\'t\n         -- detect it:\n         chunk = return_chunk\n         -- otherwise, we\'ll try our luck with the chunk, as-is\n      end\n   end\n   local success, results\n   local f, err = loadstring(chunk, \'REPL\')\n   if f then\n      setfenv(f, valiant.eval_env)\n      -- patch our custom require for the duration of the call\n      local global_env = getfenv(0)\n      local req = global_env.require\n      rawset(global_env, \"require\", valiant.require)\n      success, results = gatherResults(xpcall(f, debug.traceback))\n      rawset(global_env, \"require\", req)\n      if not success then\n         -- error\n         results.error = true\n         return false, results\n      end\n   else\n      if err:match \"\'<eof>\'$\" then\n         -- Lua expects some more input\n         return false, \'advance\'\n      else\n         -- make the error into the result\n         results = { err,\n                     n = 1,\n                     error = true }\n         return false, results\n      end\n   end\n\n   return true, results\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal curry = assert(require \"core:fn\" . curry)\n\nlocal function new(env, env_2, anti_G)\n   assert(env, \"must provide at least one environment\")\n   local valiant = meta(Valiant)\n   valiant.mods = {}\n   valiant.cleared = {}\n   anti_G = anti_G or assert(names.anti_G)\n   local eval_M = { __index = make__index(env, env_2),\n                    __newindex = make__newindex(anti_G)}\n   valiant.require = curry(_require, valiant)\n   valiant.eval_env = { require = valiant.require }\n   setmetatable(valiant.eval_env, eval_M)\n   return valiant\nend\n\n\n\nreturn new\n\n",
},
  { 
vc_hash = "762770881f9082bd98babed73d8504d88045e3a6",
name = "replkit",
hash = "0af42214dde85b2d5bd41d6722a1ed4d6760b46ac85ea73cc8129fdc6d97db69",
branch = "2021-04-27_RELEASE_BRANCH",
binary = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal stmts = assert(require \"helm:helm/helm-db\" . session())\nlocal Path = require \"fs:path\"\n\n\n\n\nlocal replkit = {}\n\n\n\n\n\n\n\n\n\nfunction replkit.project_path(project)\n   -- get all project directories\n   local project_info, n = stmts.get_project_info()\n   -- iterate until we find the directory matching the basename\n   for i = 1, n do\n       local project_path = Path(project_info.directory[i])\n       if project_path:basename() == project then\n          return project_path\n       end\n   end\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal ITER_MAX = 50000\n\nfunction replkit.num_iters(iter, state, start)\n   local count, done, drain = 0, false, start\n   while (not done) and count < ITER_MAX do\n      drain = iter(state, drain)\n      if drain ~= nil then\n         count = count + 1\n      else\n         done = true\n      end\n   end\n   if count >= ITER_MAX then\n      error (\"num_iters cannot count past 50k!\"\n             .. \" very long iterator or infinite loop\")\n   end\n   return count\nend\n\n\n\n\nreturn replkit\n\n",
},
} },
}